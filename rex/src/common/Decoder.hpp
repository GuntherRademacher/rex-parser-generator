#ifndef DECODER_HPP_
#define DECODER_HPP_

#include "../common/Platforms.hpp"

#include <stdlib.h>
#include <string.h>
#include <new>
#include <cwctype>

#include <stdio.h>

class Decoder
{
public:

#ifdef __GNUG__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds" // suppress flawed array bounds warning of g++
#endif

  static int decode_utf8_char(const char *string, size_t *encodedSize = 0)
  {
    const unsigned char *encoded = (const unsigned char *) string;
    int codepoint = encoded[0];
    size_t bytes;

    if ((codepoint & 0x80) == 0)
    {
      bytes = 1;
    }
    else if (   (codepoint  & 0x60) == 0x40
             && (encoded[1] & 0xc0) == 0x80)
    {
      codepoint = ((codepoint  & 0x1f) << 6)
                |  (encoded[1] & 0x3f);
      bytes = codepoint < 0x80 ? 0 : 2;

  // printf("2 codepoint %d code %x\n", codepoint, decoded[used - 1]);

    }
    else if (   (codepoint  & 0x70) == 0x60
             && (encoded[1] & 0xc0) == 0x80
             && (encoded[2] & 0xc0) == 0x80)
    {
      codepoint = ((codepoint  &  0xf) << 12)
                | ((encoded[1] & 0x3f) <<  6)
                |  (encoded[2] & 0x3f);
      bytes = codepoint < 0x800 ? 0 : 3;

  // printf("3 codepoint %d code %x from %x %x %x\n", codepoint, decoded[used - 1], encoded[-3], encoded[-2], encoded[-1]);

    }
    else if (   (codepoint  & 0x78) == 0x70
             && (encoded[1] & 0xc0) == 0x80
             && (encoded[2] & 0xc0) == 0x80
             && (encoded[3] & 0xc0) == 0x80)
    {
      codepoint  = ((codepoint  &  0x7) << 18)
                 | ((encoded[1] & 0x3f) << 12)
                 | ((encoded[2] & 0x3f) <<  6)
                 | ( encoded[3] & 0x3f       );
      bytes = codepoint < 0x10000 || codepoint > 0x10ffff ? 0 : 4;

  // printf("4 codepoint %d code %x %x\n", codepoint + 0x10000, decoded[used - 2], decoded[used - 1]);

    }
    else
    {
      bytes = 0;
    }
    if (encodedSize)
    {
      *encodedSize = bytes;
    }
    return codepoint;
  }

  static wchar_t *decode(const char *encoded, const wchar_t *encoding = 0, size_t encodingLength = 0)
  {
    return decode(encoded, strlen(encoded), encoding, encodingLength);
  }

  static wchar_t *decode(const char *encoded, size_t length, const wchar_t *encoding = 0, size_t encodingLength = 0)
  {
    if (encoding == 0)
    {
      if (((const unsigned char *) encoded)[0] == 0xef
       && ((const unsigned char *) encoded)[1] == 0xbb
       && ((const unsigned char *) encoded)[2] == 0xbf)
      {
        encoded += 3;
      }
      encoding = L"UTF-8";
    }

    if (encodingLength == 0)
    {
      encodingLength = wcslen(encoding);
    }

    if (wcsncasecmp(encoding, L"UTF-8", encodingLength) == 0 && encodingLength == 5)
    {
      return decode_utf8(encoded, length);
    }

    const wchar_t *table = getDecodingTable(encoding, encodingLength);
    if (table != 0)
    {
      return decode_table(encoded, length, table);
    }

    return 0;
  }

#ifdef __GNUG__
#pragma GCC diagnostic pop
#endif

private:
  static wchar_t *decode_table(const char *string, size_t length, const wchar_t *table)
  {
    const unsigned char *encoded = (const unsigned char *) string;
    wchar_t *decoded = ALLOCATE_ARRAY(wchar_t, length + 1);

    size_t i = 0;
    for (; i < length; i++)
    {
      int c = encoded[i];
      if (c == 0)
      {
        break;
      }
      decoded[i] = table[c];
    }
    decoded[i] = 0;
    return decoded;
  }

  static wchar_t *decode_utf8(const char *string, size_t length)
  {
    wchar_t *decoded = ALLOCATE_ARRAY(wchar_t, length + 1);

    size_t consumed = 0;
    size_t used = 0;
    size_t bytes;

    while (consumed < length)
    {
      int codepoint = decode_utf8_char(string + consumed, &bytes);

      if (bytes == 0)
      {
        free(decoded);
        return 0;
      }

      consumed += bytes;

      if (codepoint < 0x10000)
      {
        decoded[used++] = codepoint;
        if (codepoint == 0)
        {
          return decoded;
        }
      }
      else
      {
        codepoint -= 0x10000;
        decoded[used++] = 0x0d800 | (codepoint >> 10);
        decoded[used++] = 0x0dc00 | (codepoint & 0x3ff);
      }
    }
    decoded[used++] = 0;
    return decoded;
  }

  static const wchar_t *getDecodingTable(const wchar_t *encoding, size_t encodingLength = 0)
  {
    static const wchar_t *decoders[] = {
      L"iso-8859-1", L"windows-1252",  0  };

    static const wchar_t data[] = {
      // iso-8859-1
      0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
      0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
      0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
      0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
      0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
      0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
      0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
      0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
      0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
      0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
      0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
      0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
      0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
      0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
      0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
      0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,
      // windows-1252
      0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
      0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
      0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
      0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
      0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
      0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
      0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
      0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
      0x20ac, 0xfffd, 0x201a, 0x0192, 0x201e, 0x2026, 0x2020, 0x2021, 0x02c6, 0x2030, 0x0160, 0x2039, 0x0152, 0xfffd, 0x017d, 0xfffd,
      0xfffd, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x02dc, 0x2122, 0x0161, 0x203a, 0x0153, 0xfffd, 0x017e, 0x0178,
      0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
      0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
      0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
      0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
      0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
      0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff};

    if (encodingLength == 0)
    {
      encodingLength = wcslen(encoding);
    }

    for (const wchar_t **d = decoders; *d; d++)
    {
      if (wcsncasecmp(encoding, *d, encodingLength) == 0 && (*d)[encodingLength] == 0)
      {
        return data + 256 * (d - decoders);
      }
    }

    return 0;
  }
};

#endif
