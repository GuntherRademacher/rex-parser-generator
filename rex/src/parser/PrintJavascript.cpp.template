~                                                           #include "../common/Memory.hpp"

                                                            #include "PrintJavascript.hpp"
                                                            #include "ItemSet.hpp"

                                                            void PrintJavascript::openClass()
                                                            {
                                                              if (! hasProlog)
                                                              {
~
function ~                                                      print(className.c_str());
         ~(string~                                              if (noLexer)
                                                                {
                 ~, lexer~                                      }
                                                                if (tree)
                                                                {
                 ~, parsingEventHandler~                        }
                 ~)
{
  init(string~                                                  if (noLexer)
                                                                {
             ~, lexer~                                          }
                                                                if (tree)
                                                                {
             ~, parsingEventHandler~
                                                                }
             ~);
~                                                             }
~
  var thisParser = this;

  this.ParseException = function(b, e, s, o, x)
  {
    var begin = b;
    var end = e;
    var state = s;
    var offending = o;
    var expected = x;~                                        if (useGlr)
                                                              {
~
    var ambiguousInput = false;~                                if (tree)
                                                                {
~
    var ambiguityDescriptor;~                                   }
                                                              }
~

    this.getBegin = function() {return begin;};
    this.getEnd = function() {return end;};
    this.getState = function() {return state;};
    this.getExpected = function() {return expected;};
    this.getOffending = function() {return offending;};
    this.isAmbiguousInput = function() {return ~              if (useGlr)
                                                              {
                                               ~ambiguousInput~
                                                              }
                                                              else
                                                              {
                                               ~false~        }
                                               ~;};
~                                                             if (useGlr)
                                                              {
~
    this.setAmbiguousInput = function(a)
    {
      ambiguousInput = true;
      ambiguityDescriptor = a;
    };
~                                                             }
~
    this.getMessage = function()
    {
      return ~                                                if (useGlr)
                                                              {
             ~ambiguousInput
           ? "ambiguous input"
           : ~                                                }
             ~offending < 0
           ? "lexical analysis failed"
           : "syntax error";
    };~                                                       if (useGlr)
                                                              {
~

    this.serialize = function(eventHandler)
    {
      ambiguityDescriptor.serialize(eventHandler);
    };~                                                       }
~
  };
~                                                           }

                                                            void PrintJavascript::printFlush(int i, bool withinThread)
                                                            {
                                                              increaseIndent(i);
                                                              if (trace)
                                                              {
~
flushTrace();~                                                }
                                                              decreaseIndent(i);
                                                            }

                                                            void PrintJavascript::openStackNode()
                                                            {
~
~                                                             print(className.c_str());
~.StackNode = function(state, ~                               if (grammar->states->hasLookback)
                                                              {
                              ~code, ~                        }
                              ~pos, link)
{
  this.state = state;~                                        if (grammar->states->hasLookback)
                                                              {
~
  this.code = code;~                                          }
~
  this.pos = pos;
  this.link = link;

  this.equals = function(obj)
  {
    var lhs = this;
    var rhs = obj;
    while (lhs != null && rhs != null)
    {
      if (lhs == rhs) return true;
      if (lhs.state != rhs.state) return false;~              if (grammar->states->hasLookback)
                                                              {
~
      if (lhs.code != rhs.code) return false;~                }
~
      if (lhs.pos != rhs.pos) return false;
      lhs = lhs.link;
      rhs = rhs.link;
    }
    return lhs == rhs;
  };
~                                                             increaseIndent();
                                                            }

                                                            void PrintJavascript::closeStackNode()
                                                            {
                                                              decreaseIndent();
~
};
~                                                             if (hasCustomCode)
                                                              {
                                                                print(className.c_str());
~.DeferredCode = function(link, codeId, b0, e0)
{
  this.link = link;
  this.codeId = codeId;
  this.b0 = b0;
  this.e0 = e0;
};
~                                                             }
                                                              if (tree)
                                                              {
~
~                                                               print(className.c_str());
~.DeferredEvent = function(link, name, begin, end, count)
{
  this.link = link;

  this.execute = function(eventHandler)
  {
    if (count == null)
    {
      eventHandler.terminal(name, begin, end);
    }
    else
    {
      eventHandler.nonterminal(name, begin, end, count);
    }
  };

  this.release = function(eventHandler)
  {
    var current = this;
    var predecessor = current.link;
    current.link = null;
    while (predecessor != null)
    {
      var next = predecessor.link;
      predecessor.link = current;
      current = predecessor;
      predecessor = next;
    }
    do
    {
      current.execute(eventHandler);
      current = current.link;
    }
    while (current != null);
  };

  this.show = function(eventHandler)
  {
    var stack = [];
    for (var current = this; current != null; current = current.link)
    {
      stack.push(current);
    }
    while (stack.length > 0)
    {
      stack.pop().execute(eventHandler);
    }
  };

  this.toString = function()
  {
    if (count == null)
      return "terminal(" + name + ", " + begin + ", " + end + ")";
    else
      return "nonterminal(" + name + ", " + begin + ", " + end + ", " + count + ")";
  };
};
~                                                             }
~
~                                                             print(className.c_str());
~.Heap = function()
{
  var array = [];
  var size = 0;

  this.offer = function(value)
  {
    var index = size++;
    while (index != 0)
    {
      var parentIndex = (index - 1) >> 1;
      if (array[parentIndex].compareTo(value) <= 0)
        break;
      array[index] = array[parentIndex];
      index = parentIndex;
    }
    array[index] = value;
  };

  this.poll = function()
  {
    if (size == 0)
      return null;
    var min = array[0];
    if (--size > 0)
    {
      var value = array[size];
      var index = 0;
      for (var child;;)
      {
        child = (index << 1) + 2;
        if (child < size)
        {
          var otherChild = child - 1;
          if (otherChild < size && array[child].compareTo(array[otherChild]) > 0)
            child = otherChild;
        }
        else if (--child >= size)
        {
          break;
        }
        if (value.compareTo(array[child]) <= 0)
        {
          break;
        }
        array[index] = array[child];
        index = child;
      }
      array[index] = value;
    }
    return min;
  };

  this.peek = function()
  {
    return size == 0 ? null : array[0];
  };

  this.isEmpty = function()
  {
    return size == 0;
  };
};
~                                                           }

                                                            void PrintJavascript::printXmlSerializer()
                                                            {
                                                              if (tree)
                                                              {
~
~                                                               print(className.c_str());
~.XmlSerializer = function(log, indent)
{
  var input = null;
  var delayedTag = null;
  var hasChildElement = false;
  var depth = 0;

  this.reset = function(string)
  {
    log("<?xml version=\"1.0\" encoding=\"UTF-8\"?" + ">");
    input = string;
    delayedTag = null;
    hasChildElement = false;
    depth = 0;
  };

  this.startNonterminal = function(tag, begin)
  {
    if (delayedTag != null)
    {
      log("<");
      log(delayedTag);
      log(">");
    }
    delayedTag = tag;
    if (indent)
    {
      log("\n");
      for (var i = 0; i < depth; ++i)
      {
        log("  ");
      }
    }
    hasChildElement = false;
    ++depth;
  };

  this.endNonterminal = function(tag, end)
  {
    --depth;
    if (delayedTag != null)
    {
      delayedTag = null;
      log("<");
      log(tag);
      log("/>");
    }
    else
    {
      if (indent)
      {
        if (hasChildElement)
        {
          log("\n");
          for (var i = 0; i < depth; ++i)
          {
            log("  ");
          }
        }
      }
      log("</");
      log(tag);
      log(">");
    }
    hasChildElement = true;
  };

  this.terminal = function(tag, begin, end)
  {
    if (tag.charAt(0) == '\'') tag = "TOKEN";
    this.startNonterminal(tag, begin);
    characters(begin, end);
    this.endNonterminal(tag, end);
  };

  this.whitespace = function(begin, end)
  {
    characters(begin, end);
  };

  function characters(begin, end)
  {
    if (begin < end)
    {
      if (delayedTag != null)
      {
        log("<");
        log(delayedTag);
        log(">");
        delayedTag = null;
      }
      log(input.substring(begin, end)
               .replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;"));
    }
  }
};
~                                                             }
                                                            }

                                                            void PrintJavascript::openThread()
                                                            {
~
var PARSING = 0;
var ACCEPTED = 1;
var ERROR = 2;

function parse(target, initialState, ~                        if (tree)
                                                              {
                                     ~eventHandler, ~
                                                              }
                                     ~thread)
{
  var threads = thread.open(initialState~                     if (tree)
                                                              {
                                        ~, eventHandler~      }
                                        ~, target);
  for (;;)
  {
    thread = threads.poll();
    if (thread.getAccepted())
    {
      var other = null;
      while (! threads.isEmpty())
      {
        other = threads.poll();
        if (thread.getE0() < other.getE0())
        {
          thread = other;
          other = null;
        }
      }
      if (other != null)
      {
        rejectAmbiguity(thread.getStack().pos, thread.getE0()~
                                                              if (tree)
                                                              {
                       ~, thread.getDeferredEvent(), other.getDeferredEvent()~
                                                              }
                       ~);
      }~
                                                              if (tree)
                                                              {
~
      thread.release();~                                      }
                                                              if (hasCustomCode)
                                                              {
~
      thread.executeDeferredCode();~                          }
~
      return thread;
    }

    if (! threads.isEmpty())
    {
      if (threads.peek().equals(thread))
      {
        rejectAmbiguity(thread.getStack().pos, thread.getE0()~
                                                              if (tree)
                                                              {
                       ~, thread.getDeferredEvent(), threads.peek().getDeferredEvent()~
                                                              }
                       ~);
      }
    }~                                                        if (tree || hasCustomCode)
                                                              {
~
    else
    {~                                                          if (tree)
                                                                {
~
      thread.release();~                                        }
                                                                if (hasCustomCode)
                                                                {
~
      thread.executeDeferredCode();~                            }
~
    }~                                                        }
~

    var status;
    for (;;)
    {
      if ((status = thread.parse()) != PARSING) break;
      if (! threads.isEmpty()) break;
    }

    if (status != ERROR)
    {
      threads.offer(thread);
    }
    else if (threads.isEmpty())
    {
      throw new thisParser.ParseException(thread.getB1(),
                                          thread.getE1(),
                                          ~                   print(staticPrefix());
                                          ~TOKENSET[thread.getState()] + 1,
                                          thread.getL1(),
                                          -1
                                         );
    }
  }
}

function rejectAmbiguity(begin, end~                        if (tree)
                                                              {
                                   ~, first, second~          }
                                   ~)
{~                                                            if (tree)
                                                              {
~
  var treeBuilder = new ~                                       print(className.c_str());
                        ~.ParseTreeBuilder();
  treeBuilder.reset(input);
  second.show(treeBuilder);
  treeBuilder.nonterminal("ALTERNATIVE", treeBuilder.getStack()[0].begin, treeBuilder.getStack()[treeBuilder.getTop()].end, treeBuilder.getTop() + 1);
  var secondTree = treeBuilder.pop(1)[0];
  first.show(treeBuilder);
  treeBuilder.nonterminal("ALTERNATIVE", treeBuilder.getStack()[0].begin, treeBuilder.getStack()[treeBuilder.getTop()].end, treeBuilder.getTop() + 1);
  treeBuilder.push(secondTree);
  treeBuilder.nonterminal("AMBIGUOUS", treeBuilder.getStack()[0].begin, treeBuilder.getStack()[treeBuilder.getTop()].end, 2);~
                                                              }
~
  var exception = new thisParser.ParseException(begin, end, -1, -1, -1);
  exception.setAmbiguousInput(~                               if (tree)
                                                              {
                              ~treeBuilder~                   }
                                          ~);
  throw exception;
}

var thread;~                                                  if (tree)
                                                              {
~
var eventHandler;~                                            }
~
var input;
var size;
var maxId = 0;

function ParsingThread()
{
  var thisThread = this;
  var threads;
  var accepted;
  var stack;
  var state;
  var action;~                                                if (tree || useGlr)
                                                              {
~
  var target;~                                                }                                                if (tree)
                                                              {
~
  var deferredEvent;~                                           if (useGlr)
                                                                {
~
  var es;~                                                      }
                                                              }
                                                              if (useGlr)
                                                              {
~
  var bw, bs;~                                                }
                                                              if (hasCustomCode)
                                                              {
~
  var deferredCode;~                                          }
~
  var id;

  this.getId = function() {return id;};
  this.getAction = function() {return action;};
  this.getAccepted = function() {return accepted;};
  this.getThreads = function() {return threads};
  this.getState = function() {return state};
  this.getStack = function() {return stack};
  this.getEnd = function() {return end;};
  this.getB0 = function() {return b0;};
  this.getE0 = function() {return e0;};~                      for (size_t i = 1; i <= grammar->k; ++i)
                                                              {
                                                                const wchar_t *iString = format.toString<wchar_t>(i);
~
  this.getB~                                                    print(iString);
           ~ = function() {return b~                            print(iString);
                                   ~;};
  this.getE~                                                    print(iString);
           ~ = function() {return e~                            print(iString);
                                   ~;};
  this.getL~                                                    print(iString);
           ~ = function() {return l~                            print(iString);
                                   ~;};~                      }
                                                              if (complexWhitespace)
                                                              {
~
  this.setB1 = function(b) {b1 = b;};
  this.setE1 = function(e) {e1 = e;};
  this.setL1 = function(l) {l1 = l;};~                        }
~
  this.getBs = function() {return bs;};
  this.getBw = function() {return bw;};
  this.getTarget = function() {return target;};~              if (tree)
                                                              {
~
  this.getEs = function() {return es;};
  this.getEventHandler = function() {return eventHandler;};
  this.getDeferredEvent = function() {return deferredEvent;};~
                                                              }
                                                              if (hasCustomCode)
                                                              {
~
  this.getDeferredCode = function() {return deferredCode};~   }
~

  this.open = function(initialState~                          if (tree)
                                                              {
                                   ~, eh~                     }
                                   ~, t)
  {
    accepted = false;
    target = t;~                                              if (tree)
                                                              {
~
    if (eh != null)
    {
      eh.reset(input);
    }
    eventHandler = eh;
    deferredEvent = null;~                                    }
                                                              if (hasCustomCode && useGlr)
                                                              {
~
    deferredCode = null;~                                     }
~
    stack = new ~                                             print(className.c_str());
                ~.StackNode(-1, ~                             if (grammar->states->hasLookback)
                                                              {
                                ~0, ~                         }
                                    ~e0, null);
    state = initialState;
    action = predict(initialState);
    bw = e0;
    bs = e0;~                                                 if (tree)
                                                              {
~
    es = e0;~                                                 }
~
    threads = new ~                                           print(className.c_str());
                  ~.Heap();
    threads.offer(this);
    return threads;
  };

  this.copy = function(other, a)
  {
    action = a;
    accepted = other.getAccepted();
    threads = other.getThreads();
    state = other.getState();
    stack = other.getStack();
    end = other.getEnd();
    target = other.getTarget();
    bs = other.getBs();
    bw = other.getBw();~                                      if (tree)
                                                              {
~
    es = other.getEs();
    eventHandler = other.getEventHandler();
    deferredEvent = other.getDeferredEvent();~                }
                                                              if (hasCustomCode)
                                                              {
~
    deferredCode = other.getDeferredCode();~                  }
~
    id = ++maxId;
    b0 = other.getB0();
    e0 = other.getE0();
    l1 = other.getL1();
    b1 = other.getB1();
    e1 = other.getE1();
    return this;
  };

  this.compareTo = function(other)
  {
    if (accepted != other.getAccepted())
      return accepted ? 1 : -1;
    var comp = e0 - other.getE0();
    return comp == 0 ? id - other.getId() : comp;
  };

  this.equals = function(other)
  {
    if (accepted != other.getAccepted()) return false;
    if (b1 != other.getB1()) return false;
    if (e1 != other.getE1()) return false;
    if (l1 != other.getL1()) return false;
    if (state != other.getState()) return false;
    if (action != other.getAction()) return false;
    if (! stack.equals(other.getStack())) return false;
    return true;
  };
~                                                             if (tree)
                                                              {
~
  this.release = function()
  {
    if (deferredEvent != null)
    {
      deferredEvent.release(eventHandler);
      deferredEvent = null;
    }
  };
~                                                             }
~
  this.parse = function()
  {~                                                          increaseIndent();
                                                            }

                                                            void PrintJavascript::openMethod(const wchar_t *type,
                                                                                             const wchar_t *prefix,
                                                                                             const wchar_t *name,
                                                                                             const wchar_t *args,
                                                                                             bool constant,
                                                                                             const wchar_t *clazz)
                                                            {
                                                              if (isPublic)
                                                              {
~
this.~                                                          print(name);
     ~ = function~                                            }
                                                              else
                                                              {
~
function ~                                                      print(name);
                                                              }
         ~(~                                                  printArgNamesOnly(args);
           ~)~                                              }

                                                            void PrintJavascript::privateVars()
                                                            {
                                                              if (trace)
                                                              {
~
  function lookaheadString()
  {
    var result = "";
    if (l1 > 0)
    {
      result += ~                                               print(staticPrefix());
                ~TOKEN[l1];~                                    for (size_t i = 2; i <= grammar->k; ++i)
                                                                {
~
      if (l~                                                      print(format.toString<wchar_t>(i));
           ~ > 0)
      {
        result += " " + ~                                         print(staticPrefix());
                        ~TOKEN[l~                                 print(format.toString<wchar_t>(i));
                                ~];~                              increaseIndent();
                                                                }
                                                                for (size_t i = 2; i <= grammar->k; ++i)
                                                                {
                                                                  decreaseIndent();
~
      }~                                                        }
~
    }
    return result;
  }
~                                                             }
~
  var ~                                                       if (! isLrParser && (grammar->k > 1 ||
                                                                                   memoization ||
                                                                                   ! grammar->decisionPoints.empty()))
                                                              {
      ~lk,~                                                   }
                                                              else
                                                              {
      ~   ~                                                   }
          ~ b0, e0;~                                          for (size_t k = 1; k <= grammar->k; ++k)
                                                              {
                                                                Format format;
                                                                wchar_t *asString = format.toString<wchar_t>(k);
~
  var l~                                                        print(asString);
       ~, b~                                                    print(asString);
           ~, e~                                                print(asString);
               ~;~                                            }
                                                              if (hasBacktracking)
                                                              {
~
  var bx, ex, sx, lx, tx;~                                    }
                                                              if (isLrParser && ! useGlr)
                                                              {
~
  var iStack = [];
  var top = -1;~                                              }
                                                              if (tree)
                                                              {
~
  var eventHandler;~                                          }
                                                              if (memoization)
                                                              {
                                                                int bits = Math::bits(grammar->conflictCount);
~
  var memo;~                                                    if (grammar->noThrow)
                                                                {
~
  var viable;~                                                  }
~

  function memoize(i, e, v)
  {
    memo[(e << ~                                                print(format.toString<wchar_t>(bits));
               ~) + i] = v;
  }

  function memoized(i, e)
  {
    var v = memo[(e << ~                                        print(format.toString<wchar_t>(bits));
                       ~) + i];
    return typeof v != "undefined" ? v : 0;
  }~                                                          }
                                                              if (useGlr)
                                                              {
                                                                decreaseIndent();
                                                              }
                                                            }

                                                            void PrintJavascript::printPlatformSpecific()
                                                            {
~
  if (typeof process !== "undefined")   // assume node.js
  {
    var command = "node";
    var arguments = process.argv.slice(2);
    var log = function(string) {process.stdout.write(string);};
    var fs = require("fs");
    var readTextFile = fs.readFileSync;~                      if (performanceTest)
                                                              {
~
    var readDir = fs.readdirSync;
    var isDirectory = function(filename) {return fs.statSync(filename).isDirectory();};~
                                                              }
~
  }
  else                                  // assume rhino or jrunscript
  {
    var arguments = function()
                    {
                      var strings = [];
                      for (var i = 0; i < args.length; ++i)
                      {
                        strings[i] = String(args[i]);
                      }
                      return strings;
                    }();~                                     if (performanceTest)
                                                              {
~
    var readDir = function(dirName)
                  {
                    var files = new java.io.File(dirName).listFiles();
                    var names = [];
                    for (var i = 0; i < files.length; ++i)
                    {
                      names[names.length] = files[i].getName();
                    }
                    return names;
                  };
    var isDirectory = function(filename) {return new java.io.File(filename).isDirectory();};~
                                                              }
~

    if (typeof println == "undefined")  // assume rhino
    {
      var command = "java -jar js.jar";
      var log = function(string) {java.lang.System.out.write(java.lang.String(string).getBytes("utf-8"));};
      var readTextFile = readFile;
    }
    else                                // assume jrunscript
    {
      var command = "jrunscript";
      var log = function(string) {java.lang.System.out.print(string);};
      var readTextFile = function(filename, encoding)
                         {
                           var file = new java.io.File(filename);
                           var buffer = javaByteArray(file.length());
                           new java.io.FileInputStream(file).read(buffer);
                           return String(new java.lang.String(buffer, encoding));
                         };
    }
  }
~                                                           }

                                                            void PrintJavascript::printFileProcessor()
                                                            {
~
// performance test main program for use with node.js, rhino, or jrunscript

function main(args)
{~                                                            printPlatformSpecific();
~
  var quiet = false;
  var parsed = 0;
  var errorCount = 0;
  var parsers = [];

  function ParseJob(s, i)
  {
    this.name = s;
    this.input = i;~                                          if (tree)
                                                              {
~
    this.contentCounter = new ContentCounter();~                if (isLrParser)
                                                                {
~
    this.parseTreeBuilder = new ~                                 print(className.c_str());
                                ~.ParseTreeBuilder();~          }
                                                              }
~
    this.parser = new ~                                       print(className.c_str());
                      ~(i~                                    if (noLexer)
                                                              {
                         ~, null~                             }
                                                              if (tree)
                                                              {
                                                                if (isLrParser)
                                                                {
                         ~, this.parseTreeBuilder~              }
                                                                else
                                                                {
                         ~, this.contentCounter~                }
                                                              }
                         ~);
  }
~                                                             if (tree)
                                                              {
~
  function ContentCounter()
  {
    var length = 0;
    this.getLength = function() {return length;};
    this.reset = function(string) {length = 0;};
    this.startNonterminal = function(name, begin) {};
    this.endNonterminal = function(name, end) {};
    this.terminal = function(name, begin, end) {length += end - begin;};
    this.whitespace = function(begin, end) {length += end - begin;};
  }
~                                                             }
                                                              printReadMethod();
~
  function findFiles(f, filter)
  {
    if (isDirectory(f))
    {
      var files = readDir(f);
      for (var i = 0; i < files.length; ++i)
      {
        findFiles(f + "/" + files[i], filter);
      }
    }
    else if (f.substring(f.length - filter.length).toLowerCase() == filter.toLowerCase())
    {
      collectInput(f, read(f));
    }
  }

  function collectInput(name, content)
  {
    if (! quiet) log("loading " + name + "\n");
    parsers[parsers.length] = new ParseJob(name, content);
  }

  if (arguments.length == 0)
  {
    log("Usage: " + command + " ~                                   print(className.c_str());
                                ~.js [-q] [-r N] [-t N] ENDING...\n");
    log("\n");
    log("  parse all files that have names ending with ENDING, in current dir and below,\n");
    log("  and display performance summary.\n");
    log("\n");
    log("  -q     do not show file names\n");
    log("  -r N   repeat N times\n");
    log("  -t N   repeat until N seconds have elapsed\n");
  }
  else
  {
    var repeat = 1;
    var timeout = 0;
    var i;
    for (i = 0; i < arguments.length; ++i)
    {
      if (arguments[i] == "-q")
      {
        quiet = true;
      }
      else if (arguments[i] == "-r")
      {
        repeat = parseInt(arguments[++i]);
        timeout = 0;
      }
      else if (arguments[i] == "-t")
      {
        repeat = 0;
        timeout = 1000 * parseInt(arguments[++i]);
      }
      else if (arguments[i].substring(0, 1) !== "-")
      {
        break;
      }
      else
      {
        throw "invalid option: " + arguments[i];
      }
    }

    var start = Date.now();

    for (; i < arguments.length; ++i)
    {
      findFiles(".", arguments[i]);
    }

    if (parsers.length != 0)
    {
      var msec = Date.now() - start;

      if (! quiet) log("\n");
      log("loaded " + parsers.length + " file" +
          (parsers.length == 1 ? "" : "s") + " in " +
          msec + " msec\n");
      if (! quiet) log("\n");

      start = Date.now();
      for (i = 0; ; ++i)
      {
        if (repeat != 0 && i >= repeat) break;
        if (timeout != 0 && Date.now() - start >= timeout) break;

        for (var j = 0; j < parsers.length; ++j)
        {
          var job = parsers[j];
          if (job.parser != null)
          {
            try
            {
              if (! quiet) log("parsing " + job.name);
              job.parser.reset(0, 0, 0);
              job.parser.~                                    print(methodPrefixParse);
                                                              print(Format::acceptableName<WString>(grammar->startSymbol()->name).c_str());
                         ~();
              if (! quiet) log("\n");~                        if (tree)
                                                              {
                                                                if (isLrParser)
                                                                {
~
              job.parseTreeBuilder.serialize(job.contentCounter);~
                                                                }
~
              if (job.contentCounter.getLength() != job.input.length)
              {
                throw "content counter saw " + job.contentCounter.getLength() +
                      ", but input length is " + job.input.length;
              }~                                              }
~
              parsed += job.input.length;
            }
            catch (pe)
            {
              if (pe instanceof job.parser.ParseException)
              {
                ++errorCount;
                log((quiet ? ("parsing " + job.name) : "") +
                    ": error: " + job.parser.getErrorMessage(pe) + "\n");
                job.parser = null;
              }
              else
              {
                throw pe;
              }
            }
          }
        }
      }

      msec = Date.now() - start;
      var sec = msec / 1000e0;
      var perSec = msec == 0
                   ? ""
                   : parsed / sec > 1024 * 1024
                   ? (" ("  + (parsed / 1024 / 1024 /sec).toFixed(2) + " MB/sec)")
                   : (" ("  + (parsed / 1024        /sec).toFixed(2) + " KB/sec)");

      if (! quiet) log("\n");
      log("parsed " + parsed + " byte" + (parsed == 1 ? "" : "s") +
          " in " + msec + " msec" + perSec + "\n");
      log(errorCount + " error" + (errorCount == 1 ? "" : "s") + "\n");
    }
  }
}

main(arguments);
~                                                           }

                                                            void PrintJavascript::printReadMethod()
                                                            {
~
  function read(input)
  {
    if (/^^{.*}$/.test(input))
    {
      return input.substring(1, input.length - 1);
    }
    else
    {
      var content = readTextFile(input, "utf-8");
      return content.length > 0 && content.charCodeAt(0) == 0xFEFF
           ? content.substring(1)
           : content;
    }
  }
~                                                           }

                                                            void PrintJavascript::close(Grammar *node)
                                                            {
                                                              if (lexerInstanceCode == 0 || lexerStaticCode == 0)
                                                              {
                                                                internalerr();
                                                              }

                                                              print(L"\n");
                                                              print(lexerInstanceCode);
~
}
~                                                             if (useGlr)
                                                              {
                                                                openStackNode();
                                                                printCountMethod();
                                                                closeStackNode();
                                                              }
                                                              printXmlSerializer();
                                                              print(lexerStaticCode);
                                                              visitEpilog();

                                                              if (main)
                                                              {
~
// main program for use with node.js, rhino, or jrunscript

function main(args)
{~                                                              printPlatformSpecific();
                                                                printReadMethod();

~
  if (arguments.length == 0)
  {
    log("Usage: " + command + " ~                               print(className.c_str());
                                ~.js ~                          if (tree)
                                                                {
                                     ~[-i] ~                    }
                                     ~INPUT...\n");
    log("\n");
    log("  parse INPUT, which is either a filename or literal text enclosed in curly braces\n");~
                                                                if (tree)
                                                                {
~
    log("\n");
    log("  Option:\n");
    log("    -i     indented parse tree\n");~                   }
~
  }
  else
  {
    var indent = false;
    for (var i = 0; i < arguments.length; ++i)
    {~                                                          if (tree)
                                                                {
~
      if (arguments[i] === "-i")
      {
        indent = true;
        continue;
      }~                                                        }
~
      var input = read(String(arguments[i]));~                  if (tree)
                                                                {
~
      var s = new ~                                               print(staticPrefix());
                  ~XmlSerializer(log, indent);~                   if (isLrParser)
                                                                  {
~
      var b = new ~                                                 print(staticPrefix());
                  ~ParseTreeBuilder();~                           }
                                                                }
~
      var parser = new ~                                        print(className.c_str());
                       ~(input~                                 if (tree)
                                                                {
                                                                  if (isLrParser)
                                                                  {
                              ~, b~                               }
                                                                  else
                                                                  {
                              ~, s~                               }
                                                                }
                              ~);
      try
      {~                                                        if (trace)
                                                                {
~
        parser.writeTrace("<?xml version=\"1.0\" encoding=\"UTF-8\"?" + ">\n<trace>\n");~
                                                                }
~
        parser.~                                                print(methodPrefixParse);
                                                                print(Format::acceptableName<WString>(grammar->startSymbol()->name).c_str());
               ~();~                                            if (trace)
                                                                {
~
        parser.writeTrace("</trace>\n");
        parser.flushTrace();~                                   }
                                                                if (tree && isLrParser)
                                                                {
~
        b.serialize(s);~                                        }
~
      }
      catch (pe)
      {
        if (! (pe instanceof parser.ParseException))
        {
          throw pe;
        }
        else
        {~                                                      if (useGlr && tree)
                                                                {
~
          if (pe.isAmbiguousInput())
          {
            pe.serialize(s);
            log("\n");
          }~                                                    }
~
          throw parser.getErrorMessage(pe);
        }
      }
    }
  }
}

main(arguments);
~
                                                              }
                                                              if (performanceTest)
                                                              {
                                                                printFileProcessor();
                                                              }
                                                            }
