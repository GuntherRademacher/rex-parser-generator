xquery version "1.0" encoding "UTF-8";

(: This file was generated on Thu Dec 26, 2024 07:00 (UTC+01) by REx v6.1-SNAPSHOT which is Copyright (c) 1979-2024 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q XQueryV11-20081203.ebnf -a xquery -xquery :)

                                                                      (: line 57 "XQueryV11-20081203.ebnf" :)
                                                                      declare namespace p="XQueryV11";
                                                                      (: line 9 "XQueryV11-20081203.xquery" :)
(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  63, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 32, 30, 30, 30, 30, 30, 30, 33, 6, 34, 6, 30, 6, 35, 36,
  37, 38, 39, 40, 41, 42, 43, 30, 30, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1010, 1028, 1045, 1064,
  1072, 1080, 1088, 1282, 1282, 1282, 1282, 1282, 1282, 1431, 1282, 1274, 1274, 1275, 1274, 1274, 1274, 1275, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1276, 1282, 1282, 1282, 1282, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1274, 1274, 1274, 1274, 1274, 1274, 1362, 1275, 1273, 1272, 1274, 1274, 1274, 1274,
  1274, 1275, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1278, 1053, 1274, 1274, 1274, 1274, 1203, 1056, 1274,
  1274, 1274, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
  1274, 1281, 1282, 1055, 1280, 1282, 1408, 1282, 1282, 1282, 1282, 1282, 1273, 1274, 1274, 1279, 1140, 1328, 1407,
  1282, 1402, 1408, 1140, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1364, 1274, 1275, 1151, 1402, 1317, 1216,
  1402, 1408, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1404, 1282, 1282, 1282, 1408, 1282, 1282, 1282, 1387,
  1251, 1274, 1274, 1271, 1274, 1274, 1274, 1274, 1275, 1275, 1418, 1272, 1274, 1278, 1282, 1273, 1109, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1273, 1109, 1274, 1274, 1274, 1274, 1118, 1282, 1274, 1274, 1274, 1274, 1274,
  1274, 1131, 1017, 1274, 1274, 1274, 1132, 1276, 1280, 1444, 1274, 1274, 1274, 1274, 1274, 1274, 1169, 1402, 1404,
  1217, 1274, 1187, 1402, 1282, 1282, 1444, 1131, 1363, 1274, 1274, 1272, 1201, 1212, 1178, 1190, 1431, 1227, 1187,
  1402, 1280, 1282, 1238, 1261, 1363, 1274, 1274, 1272, 1101, 1212, 1193, 1190, 1282, 1249, 1432, 1402, 1259, 1282,
  1444, 1250, 1271, 1274, 1274, 1272, 1269, 1169, 1292, 1123, 1282, 1282, 994, 1402, 1282, 1282, 1444, 1131, 1363, 1274,
  1274, 1272, 1360, 1169, 1218, 1190, 1432, 1227, 1020, 1402, 1282, 1282, 1002, 1033, 1305, 1301, 1204, 1033, 1142,
  1020, 1219, 1216, 1431, 1282, 1431, 1402, 1282, 1282, 1444, 1109, 1272, 1274, 1274, 1272, 1110, 1020, 1293, 1216,
  1433, 1282, 1020, 1402, 1282, 1282, 1002, 1109, 1272, 1274, 1274, 1272, 1110, 1020, 1293, 1216, 1433, 1284, 1020,
  1402, 1282, 1282, 1002, 1109, 1272, 1274, 1274, 1272, 1274, 1020, 1179, 1216, 1431, 1282, 1020, 1402, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1274,
  1274, 1274, 1274, 1276, 1282, 1274, 1274, 1274, 1274, 1275, 1282, 1273, 1274, 1274, 1274, 1274, 1275, 1313, 1407,
  1325, 1403, 1402, 1408, 1282, 1282, 1282, 1282, 1230, 1337, 1054, 1273, 1347, 1357, 1313, 1161, 1372, 1404, 1402,
  1408, 1282, 1282, 1282, 1282, 1284, 1037, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1279, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1269, 1100, 1279, 1282, 1282,
  1282, 1282, 1416, 1281, 1416, 1203, 1051, 1349, 1202, 1229, 1282, 1282, 1282, 1282, 1284, 1282, 1339, 1283, 1303,
  1279, 1282, 1282, 1282, 1282, 1427, 1281, 1429, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1278, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
  1274, 1280, 1274, 1274, 1276, 1276, 1274, 1274, 1274, 1274, 1276, 1276, 1274, 1419, 1274, 1274, 1274, 1276, 1274,
  1274, 1274, 1274, 1274, 1274, 1109, 1143, 1241, 1277, 1132, 1278, 1274, 1277, 1241, 1277, 1094, 1282, 1282, 1282,
  1273, 1329, 1177, 1282, 1273, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1277, 999, 1273, 1274, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1441, 1053, 1274, 1274, 1274, 1274, 1277, 1282, 1282, 1282, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1402, 1405, 1385, 1282, 1282, 1282, 1274, 1274, 1274, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1278, 1282, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1408, 1402, 1408, 1395, 1377, 1274, 1273, 1274, 1274, 1274, 1280,
  1401, 1402, 1293, 1406, 1292, 1401, 1402, 1404, 1401, 1385, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1273,
  1274, 1274, 1274, 1275, 1429, 1273, 1274, 1274, 1274, 1275, 1282, 1401, 1402, 1175, 1402, 1402, 1157, 1382, 1282,
  1274, 1274, 1274, 1279, 1279, 1282, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 6, 6,
  6, 6, 6, 62, 62, 6, 6, 62, 62, 6, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 6, 6, 30, 30, 6, 6, 6, 6, 62, 62, 30,
  30, 30, 30, 32, 30, 30, 30, 6, 6, 6, 30, 30, 6, 6, 30, 6, 30, 30, 30, 33, 6, 34, 6, 30, 6, 6, 6, 6, 6, 30, 30, 30, 30,
  30, 30, 6, 35, 36, 37, 38, 39, 40, 41, 42, 43, 30, 30, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 6, 6, 6, 6, 6, 62, 6, 30, 6, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 62, 62, 62,
  62, 6, 62, 62, 62, 6, 6, 30, 30, 30, 30, 30, 6, 6, 30, 30, 62, 30, 30, 30, 30, 30, 30, 30, 6, 30, 6, 30, 30, 30, 30,
  6, 30, 62, 62, 6, 62, 62, 62, 6, 62, 62, 30, 6, 6, 30, 30, 6, 6, 62, 30, 62, 62, 6, 62, 62, 62, 62, 62, 6, 6, 62, 62,
  30, 30, 62, 62, 6, 6, 62, 62, 62, 6, 6, 6, 6, 62, 30, 6, 30, 6, 6, 6, 30, 30, 6, 6, 6, 30, 30, 6, 6, 62, 6, 62, 62,
  62, 62, 6, 6, 6, 62, 62, 6, 6, 6, 6, 30, 30, 6, 30, 6, 6, 30, 6, 6, 62, 6, 6, 30, 30, 30, 6, 30, 30, 6, 30, 30, 30,
  30, 6, 30, 6, 30, 30, 62, 62, 30, 30, 30, 6, 6, 6, 6, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 6, 6, 6,
  6, 6, 6, 6, 6, 30, 6, 62, 62, 62, 62, 62, 62, 6, 62, 62, 6, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 6, 30, 62, 30, 30,
  62, 62, 62, 62, 62, 30, 30, 62, 30, 30, 30, 30, 30, 30, 62, 62, 62, 62, 62, 62, 30, 6, 30, 6, 6, 30, 6, 6, 30, 30, 6,
  30, 30, 30, 6, 30, 6, 30, 6, 30, 6, 6, 30, 30, 6, 30, 30, 6, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 62, 6,
  6, 6, 6, 62, 62, 6, 62, 6, 6, 6, 6, 6, 6, 30, 62, 6, 6, 6, 6, 6, 62, 6, 62, 62, 62, 62, 62, 62, 62, 62, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 30, 6, 30, 6, 30, 6, 30, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6, 6, 62, 62, 6, 30, 30, 30, 6, 62, 62, 62, 6, 30,
  30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 10242, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 4111, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
  31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
  89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 4222, 127, 128, 129, 130, 131, 132, 133, 134, 135, 4232, 4233,
  4234, 4235, 4236, 4237, 4238, 4239, 4240, 145, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 154, 155, 156, 157,
  158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 4267, 4268, 4269
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10983, 8192, 8194, 8210, 8194, 8194, 8194, 8237, 8194,
  8244, 8221, 13869, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283,
  8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064,
  8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787,
  8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 8979, 9031, 9096, 9125, 9144, 9213, 9128, 9354, 8963, 9244,
  9263, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591,
  9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064, 9955, 10013, 10029,
  16693, 10187, 10064, 13380, 10064, 10064, 10063, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 14046, 8260, 8283,
  8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064,
  8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787,
  8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244,
  10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591,
  9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10538, 10221, 10064, 13432, 10064, 10277, 10064, 10238, 13159, 10064,
  10261, 21024, 10064, 13380, 10064, 13344, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 8916, 8260, 8283, 8308,
  10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064, 8517,
  8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803,
  8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178,
  17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591, 9607,
  9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10293, 10064, 10064, 14429, 10064, 10064, 10064, 10319, 10064, 10064,
  13163, 10187, 10064, 17073, 10064, 8267, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 10342, 8283, 8308,
  10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064, 8517,
  8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803,
  8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178,
  17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591, 9607,
  9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10414, 10064, 12934, 10064, 25802, 10402, 10365, 10064, 10388,
  10433, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283, 8308,
  10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064, 8517,
  8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803,
  8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178,
  17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591, 9607,
  9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064, 10319, 10064, 10064,
  8586, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283, 8308,
  10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064, 8517,
  8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803,
  8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178,
  17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591, 9607,
  9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064, 10462, 10064, 10064,
  8586, 11296, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283, 8308,
  10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064, 8517,
  8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803,
  8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178,
  17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591, 9607,
  9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10661, 10485, 10064, 20830, 10064, 10417, 10064, 10502, 14926, 10064,
  10525, 11305, 10064, 13380, 10064, 25999, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 10554, 8283,
  8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064,
  8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787,
  8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244,
  10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591,
  9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10446, 10577, 10581, 10603, 10597, 10581, 10579, 10619, 10677, 10634,
  10648, 10187, 10064, 13021, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283,
  10693, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064,
  8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787,
  8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244,
  10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591,
  9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10744, 10064, 11813, 10715, 10064, 10715, 10735, 10765, 10781,
  10806, 10822, 10064, 18677, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283,
  10847, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064,
  8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787,
  8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244,
  10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591,
  9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064, 10869, 10906, 10922,
  10970, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283, 8308,
  10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9228, 8448, 8487, 8841, 11752, 10064, 10064, 8517,
  8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803,
  8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178,
  17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591, 9607,
  9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064, 10999, 11055, 11071,
  11096, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283, 8308,
  10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 9635, 11752, 10064, 10064, 8517,
  8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803,
  8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178,
  17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591, 9607,
  9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 16961, 10064, 14429, 11137, 10064, 16964, 11158, 11171, 11187,
  26373, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283, 8308,
  10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064, 8517,
  8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803,
  8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178,
  17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 9591, 9607,
  9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 11212, 10064, 10064, 14429, 10064, 10064, 10064, 11234, 11271, 11287,
  11330, 11346, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 23091, 10064, 10064,
  11371, 10064, 11423, 10064, 13667, 14554, 21954, 25931, 14829, 14829, 13735, 20114, 19456, 19456, 15248, 10064, 10064,
  10064, 26262, 17801, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 17023, 15859, 10064, 10064, 10064,
  16205, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 15255, 10064, 10064, 26075, 13670, 17820, 14829, 14868,
  25400, 11655, 19457, 10064, 10064, 11461, 15034, 9994, 14829, 11479, 17199, 20799, 10064, 11498, 20295, 14829, 25405,
  20420, 10064, 13375, 11532, 20526, 19360, 21733, 13669, 21341, 19562, 15489, 22735, 11556, 21743, 11619, 10942, 20501,
  11642, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274,
  10064, 10064, 14429, 10064, 10064, 10064, 10319, 10064, 10064, 11676, 11723, 10064, 13380, 10064, 10064, 10064, 10064,
  15036, 21959, 15176, 14829, 16477, 14787, 24550, 10064, 10064, 11748, 10064, 10064, 10064, 13667, 14554, 21954, 25931,
  14829, 14829, 13735, 20114, 19456, 19456, 23095, 10064, 10064, 10064, 10064, 10064, 13669, 14554, 18486, 14829, 14829,
  20031, 11442, 19456, 19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456,
  19456, 15255, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994,
  14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669,
  14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 11867, 10064, 14429, 10064, 10064, 10064, 11768, 11829,
  11855, 11839, 10187, 10064, 13380, 10064, 10064, 11885, 26216, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260,
  8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064,
  10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465,
  8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432,
  8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917,
  9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064, 10319,
  10064, 10064, 11902, 11723, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 18427,
  10064, 10064, 11748, 18908, 10064, 10064, 13667, 14554, 21954, 25931, 14829, 14829, 13735, 20114, 19456, 19456, 15772,
  10064, 10064, 10064, 11935, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 18817, 11956, 10064,
  10064, 13816, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 17068, 10064, 10064, 10064, 13670, 17820,
  14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295,
  14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164,
  10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10274, 14009, 10064, 23584, 24216, 10064, 18672, 10319, 10065, 11975, 10749, 25333, 10064, 16931, 10064, 10064,
  10064, 10064, 14303, 14312, 10719, 12528, 12302, 9072, 12221, 8260, 8283, 11998, 10064, 10064, 21058, 8330, 8614,
  8358, 12020, 12047, 12077, 12104, 12443, 12341, 12131, 12732, 11752, 10064, 10064, 8517, 8583, 8602, 9045, 9059,
  12031, 12523, 12185, 12061, 12355, 12213, 12237, 24609, 14350, 10108, 10064, 13465, 8740, 12271, 12287, 12412, 12197,
  12326, 12145, 12558, 12246, 8932, 8955, 10081, 9031, 12371, 12400, 12428, 12384, 12653, 12568, 8963, 9244, 10178,
  17777, 12459, 12510, 12883, 12544, 12584, 9404, 13878, 12611, 12088, 12640, 12669, 9467, 9497, 12704, 12115, 12720,
  12765, 9607, 12626, 12843, 12781, 12829, 12859, 12899, 12473, 12871, 9080, 12169, 12158, 12914, 12310, 12950, 13001,
  13015, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10090, 10064, 14429, 13999, 10064, 10064,
  13037, 26287, 13073, 11707, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766,
  9575, 8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752,
  10064, 10064, 13106, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 13147, 13179, 14350, 10108, 12805,
  13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8462, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128,
  8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551,
  9917, 9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904,
  9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064,
  9764, 13205, 13221, 13246, 10187, 10064, 13380, 10064, 10064, 10064, 10099, 14303, 14312, 14930, 8671, 8881, 8766,
  9789, 8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752,
  10064, 10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064,
  13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128,
  8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551,
  9917, 9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904,
  9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11689, 14516, 10064, 14429, 10064, 10064, 10064,
  13262, 13311, 13327, 9388, 21033, 10064, 13380, 10064, 10064, 10064, 17595, 14303, 14312, 14930, 8671, 8881, 8766,
  13490, 8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752,
  10064, 10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064,
  13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128,
  8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551,
  9917, 9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904,
  9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11109, 11119, 10064, 14429, 10064, 10064, 10064,
  13360, 13396, 13412, 24247, 13448, 10064, 13380, 10064, 10064, 10064, 12688, 14303, 14312, 14930, 8671, 8881, 8766,
  9736, 8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752,
  10064, 10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064,
  13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128,
  8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551,
  9917, 9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 13481, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904,
  9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 13506, 10064, 10064, 14429, 13546, 10064, 10064,
  10319, 17971, 14077, 9247, 10187, 10064, 13380, 10064, 10064, 13566, 10064, 14303, 14312, 14930, 8671, 8881, 8766,
  8891, 8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752,
  10064, 10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064,
  13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128,
  8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551,
  9917, 9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904,
  9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064,
  10319, 10064, 10064, 13583, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766,
  9575, 8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752,
  10064, 10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064,
  13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128,
  8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551,
  9917, 9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904,
  9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064, 10064,
  13599, 13624, 19832, 25136, 11723, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787,
  23091, 10064, 10064, 11748, 10064, 10064, 10064, 13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456, 19456,
  23095, 10064, 10064, 10064, 13819, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 19756, 13664,
  10064, 10064, 13816, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 17068, 10064, 10064, 13686, 13670,
  17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 13704,
  20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296,
  17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064, 10064, 13599, 13624, 19832, 25136, 11723, 10064, 13380, 10064,
  10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 23091, 10064, 10064, 11748, 10064, 10064, 10064, 13667,
  14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 10064, 13819, 10064, 13669, 14554,
  18486, 14829, 14829, 20031, 11442, 19456, 19456, 19756, 13664, 10064, 10064, 13816, 10064, 15037, 11255, 14829, 14829,
  20033, 19456, 19456, 19456, 17068, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064,
  10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731,
  19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485,
  19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064,
  10064, 13599, 13624, 19832, 25136, 11723, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477,
  14787, 23091, 10064, 10064, 11748, 10064, 10064, 10064, 13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456,
  19456, 23095, 10064, 10064, 10064, 9860, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 19756,
  13664, 10064, 10064, 13816, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 17068, 10064, 10064, 10064,
  13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064,
  10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497,
  18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064, 10064, 13599, 13624, 19832, 25136, 11723, 10064, 13380,
  10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 23091, 10064, 10064, 11748, 10064, 10064, 10064,
  13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 10064, 13819, 10064, 13669,
  14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 19756, 13664, 10064, 10064, 13952, 10064, 15037, 11255, 14829,
  14829, 20033, 19456, 19456, 19456, 17068, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064,
  10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297,
  15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485,
  16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064,
  10064, 10064, 13599, 13624, 19832, 25136, 11723, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829,
  16477, 14787, 20606, 10064, 10064, 11748, 10064, 10064, 10064, 13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645,
  19456, 19456, 17467, 10064, 10064, 10064, 13819, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456,
  19756, 13664, 10064, 10064, 13816, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 17068, 10064, 10064,
  10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081,
  10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079,
  20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064, 10064, 13599, 13624, 19832, 25136, 11723, 10064,
  13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 23091, 10064, 10064, 11748, 10064, 10064,
  10064, 13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 10064, 10064, 10064,
  13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037, 11255,
  14829, 14829, 20033, 19456, 19456, 19456, 15255, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457,
  10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064,
  20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086,
  16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429,
  10064, 10064, 10064, 13722, 13624, 19832, 25136, 11723, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176,
  14829, 16477, 14787, 23091, 10064, 10064, 11748, 10064, 22115, 10064, 13667, 14554, 21954, 13921, 14829, 14829, 13735,
  13645, 19456, 19456, 23095, 10064, 10064, 10064, 10064, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456,
  19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 15255, 10064,
  10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456,
  20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489,
  18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064, 10064, 13599, 13624, 19832, 25136, 11723,
  10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 23091, 10064, 10064, 11748, 10064,
  10064, 10064, 13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 10064, 10064,
  10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037,
  11255, 14829, 14829, 20033, 19456, 19456, 19456, 15255, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456,
  19457, 10064, 10064, 25022, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064,
  10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064,
  23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064,
  14429, 10064, 10064, 10064, 13756, 13795, 13807, 25479, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312,
  14930, 8671, 8881, 8766, 9575, 8260, 8283, 8308, 10064, 13835, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159,
  8448, 8487, 8841, 11752, 10064, 10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609,
  14350, 10108, 10064, 13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125,
  10136, 9213, 9128, 8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433,
  9467, 13854, 9551, 9917, 9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805,
  8378, 9845, 9904, 9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429,
  10064, 10064, 10064, 13894, 26312, 13943, 14463, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930,
  8671, 8881, 8766, 9575, 8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448,
  8487, 8841, 11752, 10064, 10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350,
  10108, 10064, 13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136,
  9213, 9128, 8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467,
  9497, 9551, 9917, 9567, 13968, 9607, 9623, 9660, 13984, 9727, 9752, 14037, 8771, 26392, 8638, 10162, 10151, 9805,
  8378, 9845, 9904, 9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 20984, 10064, 14429,
  13189, 10064, 14062, 14100, 14116, 14132, 14146, 14162, 14198, 14236, 10064, 11732, 12813, 14291, 14211, 14335, 14366,
  21350, 18116, 14382, 14445, 14479, 10064, 14497, 10064, 8988, 10509, 13667, 14554, 24204, 13921, 14829, 11603, 14532,
  13645, 19456, 11660, 23095, 10561, 21460, 10064, 13819, 10064, 12749, 14553, 14570, 24522, 19074, 20031, 14606, 19456,
  15275, 19756, 14696, 13706, 10064, 14730, 14481, 14749, 14774, 14807, 14828, 20033, 25057, 21995, 19456, 20450, 25352,
  21420, 18511, 13670, 17820, 14829, 23314, 20491, 19456, 16587, 14634, 14846, 10064, 15034, 9994, 14866, 25404, 19433,
  20081, 10064, 10064, 11407, 14829, 14884, 20073, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489,
  18079, 14911, 16074, 22571, 13771, 15420, 14946, 11626, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 11915, 11142, 10064, 14429, 16967, 10064, 10064, 14966, 14991, 19832, 25136, 11723,
  10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 23091, 10064, 10064, 11748, 10064,
  10064, 10064, 13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 11982, 13819,
  15014, 15031, 14554, 15053, 14829, 20771, 20031, 11442, 19456, 21223, 19756, 13664, 10064, 10064, 13816, 10064, 15037,
  11255, 14829, 14829, 20033, 19456, 19456, 19456, 17068, 18206, 10064, 10064, 11783, 19119, 14829, 15906, 13779, 19456,
  19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064,
  10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 19100, 18147, 10946, 23064,
  23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 15257, 15091,
  14429, 10064, 10064, 11314, 15111, 15127, 15143, 15157, 11723, 10064, 24386, 10064, 15173, 10064, 10064, 15036, 21959,
  15176, 14829, 16477, 15192, 19820, 18722, 10064, 15212, 16925, 17219, 9512, 13838, 16323, 22804, 23858, 23900, 14829,
  9527, 15236, 15273, 19456, 23095, 9691, 10064, 10064, 13819, 9888, 13669, 15291, 18486, 24168, 24847, 22783, 15309,
  19456, 19261, 19756, 13664, 10064, 10064, 17548, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 17068,
  10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 18967, 17909, 14829, 25404,
  15357, 14620, 10064, 10064, 15376, 25639, 25405, 15418, 10064, 10064, 20297, 13740, 20117, 11566, 13669, 14829, 25405,
  15489, 18079, 20497, 18296, 23467, 15436, 15485, 10946, 23064, 16558, 16485, 16485, 14275, 17965, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 20978, 14429, 11463, 11426, 10790, 15505, 15521, 15537, 15551,
  11723, 10064, 13380, 10064, 10064, 10064, 15015, 17883, 21959, 12255, 23309, 23299, 14660, 23091, 10064, 15567, 11748,
  15595, 10064, 22332, 8471, 15612, 15634, 15650, 15673, 15728, 15747, 15788, 11445, 15830, 23095, 10064, 24360, 22932,
  13819, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 19756, 15850, 10064, 15875, 13816, 10064,
  15037, 11255, 15904, 14829, 15922, 20414, 19456, 15834, 17068, 10064, 10064, 25456, 15943, 25371, 14829, 20023, 23044,
  19456, 15970, 10064, 8314, 10064, 16006, 23723, 16045, 15448, 23526, 20081, 10064, 10064, 20295, 14829, 25405, 20499,
  10853, 10064, 20297, 22675, 19456, 16064, 13669, 14829, 25405, 15489, 18079, 20497, 21705, 16099, 10942, 20501, 10946,
  23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064,
  16275, 14429, 9644, 16115, 16266, 16134, 16150, 16166, 16180, 11723, 22924, 26340, 16196, 16230, 24730, 16251, 16308,
  16347, 16363, 16390, 17143, 16430, 16465, 15596, 8532, 16501, 10469, 15220, 10064, 8567, 14554, 11795, 13921, 16517,
  15712, 16536, 16574, 16603, 14895, 16631, 16654, 16674, 16709, 14733, 24944, 9970, 16759, 24756, 16083, 16775, 15075,
  16805, 16829, 16864, 16899, 16947, 16983, 17112, 11014, 11029, 22612, 24460, 11596, 15394, 17001, 24679, 18271, 17039,
  17068, 17089, 17105, 14176, 13670, 9984, 23623, 17128, 17159, 17180, 25785, 10064, 9299, 17215, 22460, 17235, 14829,
  22418, 17195, 21670, 20857, 22994, 17251, 17285, 17316, 25980, 17332, 10196, 20297, 17351, 23160, 23020, 17367, 14829,
  17389, 17407, 17442, 17490, 17514, 17537, 21897, 17572, 17621, 23064, 23086, 17665, 16485, 19393, 17965, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 16213, 14429, 10222, 10064, 16214, 17701, 17717, 17733,
  17747, 11723, 10064, 17763, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 20569, 15760, 23091, 11869, 10064,
  17793, 10064, 20191, 9444, 13667, 17817, 15618, 22489, 14829, 14829, 13735, 17836, 19456, 19456, 23095, 10064, 10064,
  10064, 13819, 10064, 13669, 14554, 18486, 14829, 18889, 20031, 11442, 19456, 20261, 19756, 13664, 10064, 10064, 13816,
  10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 17068, 10064, 10064, 10064, 17879, 17899, 14829, 22775,
  10950, 19456, 17054, 10064, 10064, 9880, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405,
  19439, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501,
  10946, 23064, 23086, 17925, 16485, 17951, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915,
  10064, 10064, 14429, 10064, 11512, 11506, 17987, 18003, 18019, 18033, 11723, 10064, 13380, 10064, 8939, 10064, 10064,
  15036, 21959, 15176, 14829, 16477, 14787, 23091, 18049, 10064, 11748, 10064, 20136, 10064, 13667, 14554, 21954, 13921,
  14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 10064, 10064, 10064, 13669, 14554, 18486, 14829, 14829,
  20031, 11442, 19456, 19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456,
  19456, 15255, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 22951, 10064, 15034, 9994,
  14829, 25404, 19456, 21609, 18067, 13277, 20295, 14829, 25405, 20499, 10064, 22903, 18101, 18132, 19331, 11566, 10205,
  22860, 23653, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 18171, 19393, 17965, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064, 10064, 13599, 13624,
  19832, 25136, 11723, 10064, 11355, 10064, 10064, 12741, 10064, 15036, 18199, 16118, 14830, 15688, 21182, 25067, 10064,
  18741, 18222, 13082, 10064, 10064, 13667, 14554, 21954, 13921, 14829, 14829, 26045, 13645, 19456, 17863, 23095, 10064,
  10064, 10064, 10064, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 17023, 14998, 10064, 10064,
  10064, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 15255, 10064, 18250, 10064, 13670, 17820, 14829,
  14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829,
  25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 18269, 18287, 18079, 20497, 18296, 17164, 10942,
  20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  11915, 10064, 14714, 14429, 14182, 21874, 14708, 18319, 18335, 18351, 18365, 11723, 10064, 14319, 10064, 10064, 10326,
  15095, 18476, 14220, 25924, 24338, 24326, 20598, 23091, 10064, 10064, 11748, 25167, 10064, 10064, 18381, 18403, 18779,
  23613, 11540, 21499, 13735, 18419, 22428, 19456, 18443, 17556, 18466, 18502, 18535, 18554, 13669, 14554, 18570, 14829,
  24173, 24840, 11442, 19456, 21189, 25011, 10064, 10064, 18608, 13051, 10064, 15037, 11255, 14829, 14829, 17263, 18639,
  19456, 19456, 15255, 18658, 18693, 25244, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 18719, 10064, 18738, 18757,
  18795, 22640, 18833, 18857, 18905, 10064, 15814, 18924, 24654, 19170, 16877, 10047, 23422, 20297, 15731, 19456, 20387,
  13669, 14829, 25405, 15489, 18079, 20497, 18940, 18956, 10942, 20501, 10946, 24285, 18983, 16485, 16485, 22360, 17965,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 16739, 26224, 19010,
  19026, 19042, 19056, 11723, 8706, 13380, 20083, 8939, 10064, 21416, 13608, 21959, 10935, 19072, 23453, 17014, 23091,
  19090, 10064, 11748, 10064, 10349, 8997, 13667, 19116, 19135, 22764, 22513, 19156, 19203, 19226, 21220, 19251, 19285,
  14423, 10064, 24571, 10064, 10064, 16235, 14554, 13131, 19308, 14829, 20031, 19347, 17855, 19456, 17023, 10064, 12928,
  23829, 22235, 10064, 15037, 19381, 14829, 19409, 20033, 19456, 22435, 25539, 17474, 10064, 10064, 10064, 23487, 17820,
  22179, 14868, 10950, 19455, 19457, 13288, 19473, 16292, 13121, 19491, 14829, 23153, 19456, 20081, 19515, 10038, 20295,
  14829, 25405, 20499, 24923, 10064, 20297, 22518, 18642, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164,
  10942, 20501, 19532, 19548, 21636, 16485, 19592, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 11915, 10064, 13550, 14429, 10064, 11807, 10064, 19618, 19634, 19650, 19664, 11723, 14017, 13380, 10064, 19680,
  10064, 17422, 14975, 21959, 14021, 19698, 23345, 17455, 23091, 10064, 25344, 11748, 8547, 10064, 10064, 13667, 14554,
  21954, 13921, 24339, 9535, 19722, 19747, 23670, 19187, 21645, 23252, 10064, 10064, 10064, 10064, 13669, 14554, 18486,
  14829, 14829, 24871, 19772, 19805, 19456, 17023, 21914, 16743, 10064, 19848, 13426, 15037, 11255, 15385, 14829, 16414,
  15196, 19456, 16445, 15255, 10064, 22590, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064,
  15034, 9994, 14829, 25404, 19456, 25236, 10064, 10064, 20295, 14829, 25405, 20499, 25589, 10064, 20297, 15731, 19456,
  11566, 13669, 14829, 25405, 16883, 18234, 19864, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393,
  17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 11959, 21785, 10064, 20964, 8850,
  19880, 19896, 19912, 19926, 11723, 17685, 13380, 19942, 10064, 14850, 18623, 15888, 19971, 19995, 20049, 20099, 21547,
  16615, 10372, 20133, 20152, 18155, 20172, 20190, 13667, 14554, 14758, 13921, 14829, 14829, 13735, 13645, 19456, 19456,
  23095, 20207, 9015, 10064, 24700, 10064, 13629, 14554, 18486, 20226, 14829, 20031, 20244, 19456, 19456, 17023, 10064,
  10064, 16284, 10064, 20277, 11249, 24636, 14829, 23733, 20033, 20313, 15360, 25513, 16638, 13908, 9290, 18051, 20331,
  20347, 18592, 21129, 20373, 20403, 20436, 19475, 12965, 21443, 15034, 20357, 24526, 10954, 19456, 23968, 19682, 10699,
  20480, 20517, 20542, 17636, 10064, 11218, 20585, 22186, 20622, 11566, 20656, 14537, 21272, 17498, 18079, 20678, 15469,
  24278, 20730, 14672, 10946, 23064, 23086, 20787, 16485, 19393, 20824, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 11915, 10064, 10486, 20846, 10064, 8292, 10831, 20873, 20889, 20905, 20919, 20935, 21000, 13380, 20808,
  9417, 21049, 21056, 21074, 21090, 21153, 21169, 17300, 21205, 20557, 10064, 10064, 11748, 21239, 19955, 10064, 13667,
  18768, 21954, 13921, 21753, 24493, 21258, 13645, 20256, 19181, 21297, 10064, 21242, 11516, 9871, 14084, 25029, 14554,
  21330, 14829, 21366, 21383, 11442, 19365, 19456, 21401, 21436, 9281, 21459, 10064, 10064, 15037, 11255, 24904, 14829,
  20033, 19456, 21476, 19456, 15255, 16985, 24773, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 19979, 10064,
  10064, 15034, 21495, 14829, 25508, 19456, 16843, 10064, 21515, 21534, 14829, 24803, 20499, 10064, 10064, 20297, 15731,
  19456, 19576, 13669, 21563, 21580, 15460, 24156, 21599, 21625, 21661, 10942, 20501, 10946, 23064, 22683, 21686, 21721,
  19393, 21779, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 11196,
  10890, 21801, 13624, 21830, 21844, 11723, 10064, 21860, 10064, 10064, 10064, 10064, 15036, 19140, 21890, 14829, 16477,
  14787, 23091, 16658, 21913, 11748, 12595, 21930, 10064, 13667, 21949, 16331, 17649, 15657, 14829, 21975, 22018, 18841,
  26016, 14590, 10064, 10064, 9706, 10120, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 19235,
  22053, 10064, 21933, 25610, 22073, 17373, 11255, 25644, 14829, 20033, 19456, 22089, 19456, 15255, 22110, 10064, 10064,
  13670, 17820, 14829, 22131, 10950, 21583, 19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064,
  10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 23562, 22155, 20497,
  11576, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064, 10064, 13599, 13624, 19832, 25136, 11723, 10064, 13380,
  10064, 10245, 10064, 18253, 25686, 23414, 13519, 22214, 22202, 18808, 21281, 22232, 10064, 11748, 10064, 10064, 10064,
  13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 10064, 10064, 10064, 13669,
  14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037, 11255, 14829,
  14829, 20033, 19456, 19456, 19456, 15255, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064,
  10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297,
  19706, 15335, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485,
  16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 16724, 10064,
  11886, 10064, 22251, 22267, 22283, 22297, 11723, 10064, 20950, 24144, 26366, 21105, 22327, 24438, 22313, 22348, 24986,
  23360, 22376, 22392, 10064, 19516, 22451, 22476, 8562, 22534, 13667, 18394, 21954, 13921, 15700, 24489, 22554, 13645,
  23809, 20634, 23095, 10064, 10064, 13336, 10064, 22587, 22606, 14554, 22628, 13927, 23778, 22663, 22699, 19783, 21479,
  15803, 10064, 13090, 22723, 22751, 10064, 22799, 22820, 20228, 22848, 25096, 19456, 23697, 22876, 22892, 10064, 11386,
  17426, 13670, 17820, 18885, 14868, 14950, 19456, 19457, 22948, 20156, 10064, 15034, 9994, 19499, 25404, 20315, 20081,
  20464, 10064, 9829, 14829, 22967, 20499, 14680, 22991, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 21696, 24052,
  23010, 18296, 17164, 23036, 23060, 23080, 23064, 23086, 16374, 23111, 19393, 17965, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 11915, 10064, 10064, 20692, 10064, 15579, 23127, 23176, 23192, 23208, 23222, 23238, 10064,
  13380, 10064, 23247, 10064, 23268, 18703, 21959, 23284, 22501, 23330, 24999, 23091, 26254, 10064, 11748, 10064, 10064,
  16912, 23384, 23400, 21954, 23438, 25937, 14829, 23503, 23549, 22002, 19456, 23095, 11700, 11121, 23578, 10064, 10064,
  13669, 14554, 16029, 14829, 14829, 20031, 11442, 19456, 19456, 17023, 10064, 14508, 10064, 10117, 23600, 15037, 23639,
  14829, 24973, 21385, 23669, 19789, 23686, 15984, 10064, 10064, 10064, 20286, 23713, 9997, 14868, 22566, 22094, 23749,
  10064, 22914, 22057, 15034, 9994, 22216, 23794, 25546, 20081, 10064, 23828, 20295, 14829, 25405, 20499, 10064, 23845,
  23874, 16550, 16449, 23920, 23936, 14829, 25405, 15489, 21117, 23958, 18296, 17164, 23984, 20501, 23368, 24000, 14581,
  16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 17584,
  10064, 11919, 24040, 24068, 24084, 24100, 24114, 11723, 17335, 13380, 24130, 21015, 9381, 12486, 24189, 24240, 12494,
  23887, 24263, 24301, 20745, 8715, 18519, 24355, 8724, 12680, 24376, 24402, 25758, 24423, 24476, 18085, 15064, 24509,
  24542, 23533, 17846, 19602, 13230, 10064, 24566, 10064, 9272, 24587, 24625, 15954, 15402, 24652, 21137, 24670, 14397,
  13648, 17023, 25171, 24695, 10884, 9451, 24716, 24746, 14263, 24900, 16048, 20033, 24811, 19456, 24024, 19292, 10064,
  22037, 24772, 14250, 24789, 24827, 24863, 19731, 25572, 19457, 12796, 21306, 9939, 24407, 24887, 19210, 25109, 19456,
  24920, 24939, 10064, 20295, 24960, 25045, 25439, 10064, 25661, 25083, 25125, 22975, 18183, 11397, 16789, 24015, 25152,
  18079, 20497, 18296, 17164, 10942, 16813, 18303, 18872, 25187, 25224, 16485, 22832, 17965, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 15990, 10064, 25260, 25276, 25292, 25306, 11723,
  16848, 13380, 13567, 10064, 9480, 9481, 15036, 21959, 24224, 14829, 20010, 14787, 19269, 16687, 10064, 11748, 10064,
  25322, 10064, 13667, 25368, 21954, 23140, 14829, 21367, 25387, 25421, 19456, 19456, 14410, 25455, 25472, 10064, 21518,
  25200, 13669, 24451, 25495, 21763, 22167, 22139, 11442, 25529, 25562, 17023, 10064, 25588, 10064, 10064, 10064, 23942,
  11255, 18581, 14829, 20033, 20640, 19456, 19456, 14456, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456,
  19457, 25605, 10064, 12980, 15034, 9994, 15927, 23516, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064,
  10064, 20297, 15731, 19456, 11566, 13669, 23904, 20063, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 17521, 25626,
  23086, 16485, 13530, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064,
  17605, 10064, 25660, 10064, 25677, 25702, 25725, 25739, 11723, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959,
  15176, 20769, 20757, 19321, 23091, 10064, 10064, 11748, 10064, 10064, 20210, 13667, 25755, 21954, 22405, 14829, 14829,
  13735, 25774, 19456, 19456, 23095, 10064, 10064, 10064, 25801, 10064, 9819, 16019, 18486, 21564, 14829, 20031, 11442,
  15341, 19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 15255,
  10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 13295, 10064, 15034, 9994, 14829, 25404,
  19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 18994, 13669, 14829, 25405,
  15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 11080, 10064, 13458, 13057, 25818, 25834, 25850, 25864,
  11723, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 23091, 10064, 10064, 11748,
  10064, 10064, 10064, 13667, 14554, 21954, 13921, 14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 10064,
  10064, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 17023, 10064, 10064, 10064, 10064, 10064,
  15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 15255, 12985, 10064, 10064, 13670, 17820, 17269, 14868, 21985,
  25430, 22707, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499,
  10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946,
  23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064,
  10064, 14429, 10064, 10064, 10064, 13599, 13624, 25880, 25894, 11723, 10064, 11940, 10064, 10064, 10064, 18538, 11039,
  24601, 14647, 23776, 23764, 19422, 23091, 10064, 10064, 25910, 9711, 10064, 10064, 13667, 14554, 21954, 13921, 14829,
  14829, 21814, 13645, 19456, 14791, 17935, 10064, 10064, 10064, 10064, 10064, 13669, 14554, 18486, 14829, 14829, 20031,
  11442, 19456, 19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456,
  18450, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994, 14829,
  25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829,
  25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915, 10064, 10064, 14429, 10064, 10064, 10064, 13599, 13624, 19832,
  25136, 25953, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 25969, 24314, 10064, 10064,
  11748, 10064, 10064, 10064, 13667, 14554, 21954, 13921, 14829, 14812, 13735, 13645, 19456, 11482, 23095, 9006, 10064,
  10064, 10064, 13688, 13669, 15293, 18486, 14829, 11586, 20031, 11442, 19456, 15324, 17023, 10064, 25996, 10064, 10064,
  10064, 20662, 11255, 22647, 14829, 16402, 17391, 26015, 19456, 15255, 10064, 10064, 10064, 13670, 17820, 14829, 16520,
  10950, 19456, 23812, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 22032, 10064, 23481, 20295, 14829, 25405,
  20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501,
  10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 11915,
  10064, 10064, 14429, 10064, 10064, 10064, 26032, 13624, 19832, 25136, 11723, 10064, 13380, 10064, 10064, 10064, 10064,
  15036, 21959, 15176, 14829, 16477, 14787, 23091, 10064, 10064, 11748, 10064, 10064, 10064, 13667, 14554, 21954, 13921,
  14829, 14829, 13735, 13645, 19456, 19456, 23095, 10064, 10064, 10064, 10064, 10064, 13669, 14554, 18486, 14829, 14829,
  20031, 11442, 19456, 19456, 17023, 10064, 10064, 10064, 10064, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456,
  19456, 15255, 10064, 10064, 10064, 13670, 17820, 14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994,
  14829, 25404, 19456, 20081, 10064, 10064, 20295, 14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669,
  14829, 25405, 15489, 18079, 20497, 18296, 17164, 10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 21314, 26061, 26112, 26102, 26091, 26070,
  26128, 26143, 10187, 10064, 13380, 10064, 12004, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260,
  8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064,
  10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465,
  8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432,
  8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917,
  9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 26172, 26159,
  26191, 26207, 25709, 10187, 10064, 13380, 10064, 10064, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575,
  8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064,
  10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465,
  8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432,
  8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917,
  9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064, 26240,
  10303, 26278, 25208, 10187, 10064, 13380, 10064, 22538, 10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575,
  8260, 8283, 8308, 10064, 10064, 21058, 8330, 8614, 8358, 8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064,
  10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630, 9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465,
  8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932, 8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432,
  8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404, 13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917,
  9567, 9591, 9607, 9623, 9660, 9676, 9727, 9752, 9780, 8771, 26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933,
  10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10274, 10064, 10064, 14429, 10064, 10064, 10064, 10319,
  10064, 10064, 8586, 11723, 10064, 13380, 10064, 10064, 10064, 10064, 15036, 21959, 15176, 14829, 16477, 14787, 23091,
  10064, 10064, 11748, 10064, 10064, 10064, 13667, 14554, 21954, 25931, 14829, 14829, 13735, 20114, 19456, 19456, 23095,
  10064, 10064, 10064, 10064, 10064, 13669, 14554, 18486, 14829, 14829, 20031, 11442, 19456, 19456, 17023, 10064, 10064,
  10064, 10064, 10064, 15037, 11255, 14829, 14829, 20033, 19456, 19456, 19456, 15255, 10064, 10064, 10064, 13670, 17820,
  14829, 14868, 10950, 19456, 19457, 10064, 10064, 10064, 15034, 9994, 14829, 25404, 19456, 20081, 10064, 10064, 20295,
  14829, 25405, 20499, 10064, 10064, 20297, 15731, 19456, 11566, 13669, 14829, 25405, 15489, 18079, 20497, 18296, 17164,
  10942, 20501, 10946, 23064, 23086, 16485, 16485, 19393, 17965, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 10064, 10064, 10064, 10064, 20174, 10064, 26175, 20714, 26303, 20703, 10064, 10064, 10064, 10064, 10064,
  10064, 10064, 14303, 14312, 14930, 8671, 8881, 8766, 9575, 8260, 8283, 17679, 10064, 10064, 21058, 8330, 8614, 8358,
  8374, 9173, 8394, 8421, 9159, 8448, 8487, 8841, 11752, 10064, 10064, 8517, 8583, 8602, 9045, 8753, 9197, 8666, 8630,
  9187, 8654, 8670, 8688, 24609, 14350, 10108, 10064, 13465, 8740, 8787, 8803, 8829, 8501, 8866, 8813, 8907, 8697, 8932,
  8955, 10081, 9031, 9096, 9125, 10136, 9213, 9128, 8432, 8963, 9244, 10178, 17777, 9315, 9343, 8672, 9327, 9370, 9404,
  13878, 8342, 9109, 8405, 9433, 9467, 9497, 9551, 9917, 9567, 26328, 9607, 9623, 9660, 26356, 9727, 9752, 26389, 8771,
  26392, 8638, 10162, 10151, 9805, 8378, 9845, 9904, 9933, 10064, 10064, 10064, 10064, 10064, 10064, 10064, 10064,
  10064, 45237, 45237, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286,
  47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 220, 47286, 47286, 47286, 47286,
  47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 1, 10242, 3, 32768, 34816, 47286, 47286, 47286, 47286,
  30720, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 47286, 0, 45237, 47286, 47286, 45237, 47286, 47286, 0,
  0, 0, 669696, 0, 0, 681984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 462, 0, 0, 0, 0, 0, 0, 0, 0, 776192, 0, 0, 0, 0, 823296, 0,
  0, 0, 0, 0, 0, 0, 0, 210, 212, 236, 0, 0, 0, 0, 0, 0, 0, 220, 220, 0, 673792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1449,
  0, 0, 0, 0, 759808, 768000, 0, 0, 786432, 792576, 798720, 0, 811008, 829440, 884736, 0, 0, 567296, 567296, 567296,
  712704, 567296, 567296, 567296, 567296, 565248, 565248, 565248, 565248, 710656, 712704, 565248, 798720, 567296,
  811008, 567296, 829440, 567296, 567296, 567296, 884736, 567296, 567296, 567296, 0, 0, 0, 829440, 0, 792576, 829440, 0,
  0, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 821248, 0,
  811008, 565248, 829440, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 884736, 565248, 565248, 565248,
  565248, 565248, 565248, 565248, 696320, 710656, 712704, 565248, 565248, 731136, 565248, 565248, 565248, 0, 776192,
  567296, 669696, 0, 565248, 565248, 565248, 565248, 565248, 772096, 565248, 565248, 565248, 565248, 565248, 565248,
  874496, 886784, 565248, 894976, 565248, 565248, 907264, 565248, 565248, 565248, 565248, 565248, 565248, 759808,
  565248, 768000, 565248, 772096, 565248, 565248, 786432, 565248, 792576, 798720, 565248, 565248, 184, 0, 185, 0, 0, 0,
  690176, 0, 0, 0, 0, 0, 0, 0, 761, 0, 0, 0, 0, 0, 764, 295, 295, 811008, 565248, 565248, 829440, 565248, 565248,
  565248, 565248, 565248, 565248, 565248, 565248, 565248, 884736, 565248, 565248, 565248, 565248, 567296, 565248,
  565248, 565248, 565248, 565248, 788480, 819200, 565248, 565248, 880640, 565248, 0, 790528, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 755712, 0, 796672, 0, 0, 0, 0, 688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 697, 0, 0, 0, 0, 715, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  726, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 762, 0, 295, 295, 295, 0, 0, 657408, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 10242, 3, 0, 667648, 0, 724992, 0, 0, 0, 0, 802816, 0, 0, 667648, 567296, 567296, 567296, 567296,
  567296, 567296, 743424, 567296, 567296, 759808, 567296, 768000, 567296, 567296, 786432, 792576, 888832, 565248,
  565248, 565248, 565248, 565248, 567296, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 0, 0,
  0, 0, 0, 720896, 0, 0, 565248, 565248, 565248, 565248, 741376, 565248, 565248, 565248, 755712, 565248, 565248, 565248,
  565248, 565248, 565248, 796672, 802816, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 565248, 565248, 565248, 565248, 565248, 565248, 747520, 888832, 565248, 565248, 565248, 565248, 565248,
  565248, 0, 544768, 565248, 565248, 0, 0, 0, 0, 0, 0, 690176, 0, 0, 0, 0, 0, 0, 0, 0, 416, 0, 0, 0, 0, 0, 0, 0, 0, 677,
  0, 0, 0, 0, 0, 0, 0, 0, 719, 0, 0, 0, 0, 0, 0, 728, 770048, 0, 0, 0, 0, 567296, 684032, 686080, 567296, 567296,
  567296, 567296, 733184, 567296, 567296, 567296, 567296, 567296, 567296, 802816, 0, 0, 0, 565248, 565248, 667648,
  565248, 565248, 565248, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 0, 698368, 0, 0, 0, 770048, 567296, 567296, 825344, 567296, 567296, 567296, 567296, 567296, 567296, 567296,
  567296, 0, 565248, 565248, 684032, 686080, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 733184, 565248,
  565248, 565248, 565248, 565248, 770048, 565248, 565248, 565248, 788480, 565248, 565248, 819200, 825344, 565248,
  565248, 565248, 565248, 565248, 565248, 565248, 825344, 565248, 565248, 565248, 565248, 565248, 866304, 870400,
  565248, 565248, 565248, 565248, 542720, 0, 0, 565248, 565248, 0, 0, 0, 0, 0, 0, 0, 0, 246, 0, 233, 0, 0, 233, 233, 0,
  565248, 565248, 565248, 684032, 686080, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  733184, 565248, 0, 0, 0, 567296, 0, 0, 0, 0, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 0,
  540672, 116736, 565248, 565248, 116736, 0, 0, 565248, 565248, 565248, 565248, 866304, 870400, 565248, 565248, 880640,
  565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 0, 540672, 0, 565248, 565248, 0, 0, 184, 735232, 0, 0,
  0, 0, 0, 831488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 464, 0, 0, 0, 0, 0, 794624, 0, 0, 0, 0, 0, 0, 878592, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 804864, 0, 0, 827392, 0, 856064, 0, 0, 704512, 763904, 1336, 0, 907264, 0, 722944, 0, 0, 0, 0, 0, 0, 0, 0,
  737, 0, 0, 0, 0, 0, 0, 0, 0, 751, 0, 0, 0, 0, 0, 0, 0, 0, 927, 0, 0, 0, 0, 0, 0, 0, 0, 942, 0, 944, 0, 0, 0, 0, 0, 0,
  0, 0, 874496, 0, 0, 0, 0, 886784, 894976, 567296, 567296, 567296, 704512, 567296, 567296, 724992, 567296, 567296,
  741376, 567296, 755712, 567296, 567296, 567296, 567296, 796672, 802816, 567296, 567296, 567296, 567296, 567296,
  567296, 802816, 0, 0, 0, 565248, 565798, 668198, 565798, 565798, 565798, 610, 565859, 565859, 565859, 565859, 565859,
  565859, 565859, 565859, 565859, 565859, 565859, 565859, 0, 0, 0, 0, 0, 720896, 0, 0, 735232, 567296, 763904, 567296,
  567296, 831488, 567296, 567296, 567296, 874496, 886784, 894976, 907264, 565248, 565248, 565248, 565248, 565248,
  833536, 565248, 565248, 565248, 565248, 565248, 696320, 565248, 731136, 565248, 565248, 692224, 565248, 704512,
  565248, 565248, 565248, 565248, 735232, 745472, 565248, 565248, 763904, 565248, 565248, 565248, 565248, 565248,
  831488, 565248, 565248, 831488, 565248, 565248, 565248, 565248, 565248, 874496, 886784, 894976, 565248, 565248,
  907264, 565248, 568632, 565248, 0, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 565248, 743424, 565248, 565248, 565248, 759808, 565248, 768000, 565248, 565248, 565248, 786432, 792576,
  798720, 565248, 565248, 0, 565248, 667648, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 724992, 565248, 565248, 565248, 741376, 565248, 565248, 565248, 755712, 565248, 565248, 565248, 565248,
  565248, 735232, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 692224, 565248, 565248, 704512, 565248, 0,
  8192, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 743424, 860160,
  0, 909312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 10242, 536752, 774144, 0, 0, 0, 0, 876544, 0, 1336, 872448, 0, 0,
  0, 0, 0, 0, 0, 0, 981, 0, 0, 0, 0, 0, 0, 0, 0, 1142, 0, 0, 0, 0, 0, 0, 0, 0, 1326, 0, 0, 0, 0, 0, 0, 0, 0, 1446, 0, 0,
  0, 0, 0, 0, 1453, 856064, 567296, 872448, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 747520,
  565248, 774144, 565248, 565248, 804864, 565248, 565248, 837632, 565248, 565248, 856064, 565248, 565248, 872448,
  565248, 565248, 804864, 565248, 565248, 837632, 565248, 856064, 565248, 872448, 565248, 565248, 911360, 565248,
  565248, 565248, 565248, 565248, 565248, 874496, 886784, 565248, 894976, 565248, 565248, 907264, 565248, 566584,
  566584, 565248, 911360, 0, 0, 0, 0, 700416, 0, 0, 712704, 731136, 0, 0, 0, 0, 0, 0, 473, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  118784, 118784, 118784, 1, 10242, 3, 0, 0, 903168, 0, 780288, 0, 0, 0, 833536, 0, 868352, 0, 710656, 0, 0, 0, 0, 0,
  458, 0, 0, 0, 0, 0, 0, 0, 0, 406, 466, 565248, 565248, 833536, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  677888, 0, 0, 0, 0, 0, 0, 683, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1171, 0, 0, 0, 0, 0, 757760, 0, 0, 835584, 901120,
  749568, 739328, 761856, 0, 0, 849920, 0, 890880, 0, 0, 0, 0, 0, 472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 851968, 0, 0, 0,
  0, 778240, 0, 0, 0, 0, 0, 0, 0, 688128, 782336, 0, 0, 0, 0, 748, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 757, 0, 295, 748, 0,
  334, 334, 842, 334, 334, 334, 334, 334, 334, 334, 334, 830, 334, 334, 334, 334, 334, 334, 334, 567296, 688128, 567296,
  567296, 782336, 567296, 567296, 663552, 565248, 688128, 565248, 565248, 565248, 727040, 565248, 782336, 688128,
  565248, 565248, 565248, 727040, 565248, 565248, 782336, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 0, 540672, 0, 565248, 565248, 0, 0, 0, 565248, 899072, 0, 694272, 0, 0, 0, 806912, 0, 0, 0, 897024, 0, 0, 0,
  1632, 577536, 0, 0, 0, 0, 841728, 0, 671744, 0, 858112, 784384, 671744, 694272, 567296, 784384, 858112, 565248,
  671744, 694272, 565248, 565248, 751616, 784384, 806912, 845824, 858112, 897024, 675840, 565248, 565248, 565248,
  565248, 542720, 904, 0, 565248, 565248, 0, 0, 0, 0, 0, 0, 0, 224, 0, 226, 0, 0, 0, 0, 0, 201, 565248, 565248, 565248,
  671744, 675840, 694272, 565248, 565248, 565248, 565248, 751616, 784384, 806912, 845824, 565248, 858112, 565248,
  565248, 565248, 897024, 0, 0, 0, 0, 0, 815104, 0, 0, 0, 0, 1632, 0, 0, 0, 0, 923, 0, 0, 0, 0, 0, 0, 0, 0, 0, 932, 0,
  0, 0, 0, 954, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 722, 0, 725, 0, 0, 0, 800768, 0, 913408, 718848, 718848, 565248,
  714752, 718848, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 0, 540672, 0, 565248, 565248, 0,
  86016, 0, 892928, 565248, 714752, 718848, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 892928, 0, 0, 0, 0,
  0, 0, 106753, 0, 0, 0, 0, 0, 0, 0, 106777, 0, 0, 817152, 0, 0, 0, 1632, 0, 0, 0, 565248, 565248, 565248, 565248,
  565248, 565248, 565248, 565248, 0, 540672, 0, 565248, 565248, 112640, 0, 0, 565248, 737280, 565248, 565248, 864256,
  565248, 565248, 737280, 565248, 565248, 565248, 565248, 864256, 702464, 0, 0, 0, 0, 0, 993, 0, 0, 0, 0, 0, 295, 295,
  295, 295, 295, 295, 295, 295, 1576, 334, 334, 334, 334, 334, 334, 0, 0, 665600, 565248, 565248, 565248, 565248,
  862208, 665600, 565248, 565248, 565248, 565248, 862208, 708608, 0, 0, 0, 0, 968, 0, 0, 0, 0, 0, 970, 0, 0, 0, 0, 0, 0,
  969, 0, 464, 0, 0, 0, 0, 0, 0, 0, 1459, 0, 0, 0, 0, 0, 0, 0, 0, 0, 983, 0, 0, 986, 0, 0, 0, 839680, 565248, 753664,
  847872, 565248, 565248, 753664, 847872, 565248, 765952, 716800, 565248, 716800, 565248, 565248, 565248, 565248,
  565248, 899072, 565248, 727040, 565248, 565248, 565248, 565248, 565248, 663552, 565248, 565248, 565248, 565248,
  565248, 565248, 854016, 854016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1462, 0, 0, 0, 1466, 32768, 34816, 0, 0, 0, 0, 30720,
  0, 0, 0, 0, 0, 0, 0, 279, 0, 0, 0, 0, 992, 0, 0, 995, 0, 0, 0, 295, 998, 999, 295, 295, 295, 295, 295, 295, 295, 295,
  1363, 295, 295, 295, 295, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1376, 334, 279, 279,
  0, 0, 0, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 0, 279, 279, 279, 279, 279, 279, 279, 279, 0, 0, 0, 0,
  0, 0, 0, 0, 1561, 0, 0, 0, 0, 0, 0, 0, 0, 1626, 0, 0, 0, 0, 0, 1630, 0, 467, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 187, 0, 0, 704512, 763904, 0, 0, 907264, 0, 722944, 0, 0, 0, 0, 0, 0, 0, 0, 104448, 0, 0, 0, 0, 0, 0, 0, 0,
  112640, 0, 0, 0, 0, 0, 0, 0, 0, 813056, 0, 0, 0, 0, 0, 0, 0, 0, 728, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565248, 831488,
  565248, 565248, 565248, 565248, 565248, 874496, 886784, 894976, 565248, 565248, 907264, 565248, 567296, 565248,
  565248, 565248, 565248, 679936, 0, 706560, 808960, 864256, 0, 0, 0, 0, 565248, 565248, 565248, 565248, 729088, 565248,
  565248, 565248, 565248, 565248, 565248, 729088, 565248, 565248, 774144, 0, 0, 0, 0, 876544, 0, 0, 872448, 0, 0, 0, 0,
  0, 0, 0, 184, 185, 0, 0, 0, 0, 0, 0, 0, 0, 1638, 0, 0, 0, 0, 0, 0, 0, 0, 1701, 0, 0, 295, 295, 1702, 295, 295, 57344,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 57594, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 465,
  0, 0, 0, 0, 0, 0, 0, 184, 184, 184, 184, 184, 184, 184, 184, 0, 0, 184, 1, 10242, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 184, 0, 0, 530606, 10242, 3, 0, 178, 0, 0, 0, 0, 178, 0, 0, 0, 0, 0, 0, 0, 397312, 397312, 397312, 397312,
  397312, 397312, 397312, 397312, 397312, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 478, 0, 0, 481,
  0, 0, 666, 670, 0, 669696, 0, 0, 681984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 32768, 34816, 61440, 0, 0,
  0, 30720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 679, 680, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 61440,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 185, 0, 0, 61440, 0, 61440,
  61440, 61440, 61440, 61440, 61440, 61440, 61440, 0, 0, 61440, 1, 10242, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 183,
  251, 251, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 721, 0, 0, 0, 0, 0, 63488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 210, 32768, 63742, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 753, 0, 0, 0, 0, 0, 0, 0, 185, 185,
  185, 185, 185, 185, 185, 185, 0, 0, 185, 1, 10242, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 57344, 0, 184, 0, 0, 185, 669696,
  0, 0, 681984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 929, 0, 0, 0, 0, 0, 0, 0, 183, 65719, 183, 183, 183, 183, 183, 183, 183,
  183, 183, 183, 183, 183, 183, 183, 183, 183, 65719, 223, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183,
  183, 183, 221, 183, 183, 183, 183, 183, 32768, 34816, 183, 183, 183, 183, 30720, 183, 183, 183, 183, 183, 183, 183,
  65719, 183, 65719, 65719, 65719, 183, 65719, 65719, 65719, 65719, 0, 0, 183, 183, 0, 183, 183, 65719, 65759, 65759,
  65759, 65759, 65759, 65759, 65759, 65719, 65719, 65719, 1, 10242, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 63488, 0, 185,
  65719, 65719, 183, 183, 65719, 65719, 65719, 183, 183, 183, 183, 183, 183, 183, 65719, 183, 0, 0, 573875, 573875, 0,
  673792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1563, 0, 0, 0, 0, 0, 0, 71680, 71680, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  565798, 565798, 565798, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 71680, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  187, 0, 1, 10242, 3, 0, 0, 0, 71680, 0, 0, 0, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 0, 71680,
  71680, 71680, 71680, 71680, 71680, 71680, 71680, 0, 0, 0, 0, 0, 0, 0, 199, 245, 0, 0, 0, 0, 0, 0, 199, 0, 71680, 0, 0,
  0, 0, 0, 71680, 0, 0, 71680, 71680, 71680, 0, 10242, 3, 0, 59392, 0, 0, 0, 0, 0, 184, 185, 0, 0, 0, 0, 0, 0, 0, 212,
  0, 0, 0, 0, 0, 0, 0, 212, 0, 0, 220, 0, 0, 673792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1628, 0, 0, 0, 0, 32768, 34816, 0,
  0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 73728, 0, 0, 0, 0, 1152, 1153, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 0, 0, 247, 247,
  0, 73728, 73728, 0, 0, 0, 73728, 73728, 73728, 73728, 73728, 73728, 73728, 73728, 73728, 73728, 73728, 0, 73728,
  73728, 73728, 75776, 73728, 75776, 73728, 73728, 0, 0, 0, 8564, 0, 0, 0, 0, 0, 488, 0, 0, 0, 0, 0, 0, 0, 334, 334,
  334, 334, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1516, 373, 373, 373, 0, 73728, 8564,
  8564, 8564, 8564, 8564, 8564, 8564, 8564, 73728, 73728, 8564, 1, 10242, 3, 0, 0, 0, 0, 0, 0, 45237, 45237, 45237,
  45237, 0, 47286, 47286, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 77824, 0, 0, 0, 0, 1167, 0, 0, 968, 0,
  0, 0, 0, 0, 0, 1175, 0, 0, 0, 0, 1181, 0, 1183, 0, 0, 1186, 0, 0, 0, 0, 0, 0, 295, 295, 295, 295, 520, 295, 295, 295,
  295, 295, 77824, 77824, 0, 0, 0, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 0,
  77824, 77824, 77824, 79872, 77824, 79872, 77824, 77824, 0, 0, 0, 0, 0, 0, 0, 218, 219, 0, 220, 0, 0, 0, 0, 0, 0, 0, 0,
  77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 1, 10242, 3, 0, 0, 0, 0, 120832, 0, 0, 0,
  120832, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 948, 0, 0, 0, 81920, 0, 81920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 190,
  191, 192, 0, 0, 32768, 34816, 0, 0, 0, 0, 30720, 0, 81920, 81920, 0, 81920, 81920, 81920, 81920, 0, 0, 0, 81920,
  81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 81920, 81920, 81920, 81920, 81920, 81920,
  81920, 81920, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 235, 0, 0, 0, 0, 1, 175, 3, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1641, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 83968, 0, 0, 0, 0, 1194, 1195, 295, 295,
  295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 0, 334, 334, 334, 83968, 83968, 0, 0, 0, 83968, 83968, 83968, 83968,
  83968, 83968, 83968, 83968, 83968, 83968, 83968, 0, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 0, 0, 0,
  0, 0, 0, 0, 401, 402, 0, 0, 0, 0, 0, 0, 0, 184, 22931, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0,
  83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 1, 0, 3, 37041, 0, 399, 0, 0, 0, 0, 184, 185, 0,
  0, 0, 0, 0, 0, 0, 431, 0, 433, 0, 220, 220, 220, 0, 0, 0, 0, 220, 220, 0, 0, 0, 0, 0, 0, 0, 0, 707, 0, 709, 0, 0, 0,
  0, 1323, 0, 0, 0, 0, 0, 1328, 0, 0, 0, 0, 0, 0, 1700, 0, 0, 0, 0, 295, 295, 295, 295, 295, 295, 295, 295, 334, 334,
  334, 334, 334, 334, 1580, 0, 0, 730, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 241, 0, 334, 334, 9043, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 881, 373, 0, 1454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 227, 0, 334, 1505, 334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 897, 373, 0, 0, 0,
  1556, 0, 0, 0, 1560, 0, 0, 0, 0, 0, 0, 0, 0, 0, 229, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 962, 0, 0, 0, 295, 295, 295,
  295, 295, 295, 295, 1649, 334, 334, 334, 334, 334, 334, 334, 334, 816, 334, 334, 334, 334, 334, 334, 334, 334, 373,
  1748, 373, 373, 373, 373, 373, 1753, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1632, 0, 1765, 0, 334, 334,
  334, 334, 334, 334, 334, 1045, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1222, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 831, 334, 334, 334, 334, 334, 334, 334, 334, 1776, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0,
  0, 1841, 0, 334, 334, 334, 0, 0, 334, 1823, 334, 334, 334, 334, 334, 334, 334, 373, 1831, 373, 373, 373, 373, 1407,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 894, 373, 373, 373, 373, 0, 0, 88457, 88457, 88457, 88457,
  88457, 88457, 88457, 88457, 0, 0, 88457, 1, 10242, 3, 0, 0, 0, 118784, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 925, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 104448, 104448, 104448, 1, 10242, 3, 37041, 0, 0, 0, 0, 0, 0, 184, 185, 0, 0, 0, 0, 0, 0, 0,
  460, 0, 0, 463, 0, 0, 0, 405, 0, 0, 0, 220, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 741376, 0, 0, 32768, 34816, 0,
  0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 92440, 0, 0, 0, 0, 1349, 0, 0, 0, 0, 0, 295, 1354, 295, 295, 295, 295, 295, 295,
  295, 295, 295, 788, 295, 790, 0, 0, 0, 0, 0, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 71680, 0, 0, 92440, 92440,
  0, 0, 0, 92440, 92440, 0, 0, 0, 0, 0, 0, 92440, 92440, 92440, 92440, 92440, 92440, 92440, 92440, 92440, 0, 1, 10242,
  3, 0, 92440, 92440, 92440, 0, 92440, 0, 92440, 92440, 0, 0, 0, 0, 186, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 683,
  0, 110592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 0, 0, 394, 394, 394, 394, 394, 394, 394, 394, 0, 0, 394,
  1, 10242, 3, 37041, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 724, 968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 220, 220, 220, 0, 437, 0, 914, 1125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 208, 209, 0, 0, 0, 187, 0, 188, 0, 188,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 960, 0, 0, 0, 0, 0, 0, 0, 0, 573876, 0, 673792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 393216,
  0, 0, 0, 0, 0, 792576, 829440, 0, 0, 0, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565798,
  565798, 725542, 565798, 565798, 565798, 741926, 565798, 565798, 565798, 756262, 565798, 565798, 565798, 743974,
  565798, 565798, 565798, 760358, 565798, 768550, 565798, 565798, 565798, 786982, 793126, 799270, 565798, 565798, 0,
  565859, 668259, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 725603, 811558,
  565798, 829990, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 885286, 565798, 565798, 565798, 565798,
  565798, 834086, 565798, 565798, 565798, 565798, 565798, 696870, 565798, 731686, 565798, 565798, 0, 776192, 567296,
  669696, 0, 565798, 565798, 565798, 565798, 565798, 772646, 565798, 565798, 565798, 565798, 565798, 899622, 565798,
  727590, 565798, 565798, 565798, 565798, 565798, 664163, 565859, 565859, 811619, 565859, 565859, 830051, 565859,
  565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 885347, 565859, 565859, 565859, 565859, 770659,
  565859, 565859, 565859, 789091, 565859, 565859, 819811, 825955, 565859, 565859, 565859, 565859, 679936, 0, 706560,
  808960, 864256, 0, 0, 0, 0, 565798, 565798, 565798, 565798, 729638, 565798, 565798, 565798, 565798, 565859, 565859,
  729699, 565859, 565859, 889382, 565798, 565798, 565798, 565798, 565798, 567296, 565798, 565798, 565798, 565798,
  565798, 565798, 565798, 565798, 565798, 567296, 565798, 565798, 565798, 565798, 565798, 789030, 819750, 565798,
  565798, 881190, 565798, 803427, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859,
  565859, 565859, 565859, 565859, 565859, 0, 540672, 0, 565859, 565798, 0, 0, 0, 889443, 565859, 565859, 565859, 565859,
  565859, 565859, 0, 544768, 565859, 565798, 0, 0, 0, 0, 0, 0, 690176, 0, 0, 0, 0, 0, 0, 0, 499, 0, 0, 0, 0, 0, 334,
  334, 334, 770048, 567296, 567296, 825344, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 0, 565798,
  565798, 684582, 686630, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 733734, 565798, 565798, 565798,
  565798, 565798, 770598, 565798, 0, 0, 0, 567296, 0, 0, 0, 0, 0, 565798, 565798, 565798, 565798, 565798, 565798,
  565859, 565859, 565859, 565859, 565859, 565859, 821248, 0, 565859, 565859, 565859, 684643, 686691, 565859, 565859,
  565859, 565859, 565859, 565859, 565859, 565859, 565859, 733795, 565859, 565859, 565859, 760419, 565859, 768611,
  565859, 772707, 565859, 565859, 787043, 565859, 793187, 799331, 565859, 565859, 565859, 565859, 741987, 565859,
  565859, 565859, 756323, 565859, 565859, 565859, 565859, 565859, 565859, 797283, 735232, 567296, 763904, 567296,
  567296, 831488, 567296, 567296, 567296, 874496, 886784, 894976, 907264, 565798, 565798, 565798, 735782, 565798,
  565798, 565798, 565859, 565859, 565859, 565859, 692835, 565859, 565859, 705123, 565859, 692774, 565798, 705062,
  565798, 565798, 565798, 565798, 735782, 746022, 565798, 565798, 764454, 565798, 565798, 565798, 565798, 825894,
  565798, 565798, 565798, 565798, 565798, 866854, 870950, 565798, 565798, 565798, 565798, 565798, 832038, 565798,
  565798, 565798, 565798, 565798, 875046, 887334, 895526, 565798, 565798, 907814, 565798, 567296, 565798, 0, 0, 565859,
  565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 744035, 856064, 567296,
  872448, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 748070, 565798, 774694, 565798, 565798,
  565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 0, 698368, 0, 0, 0, 0, 0, 491, 0, 0, 0, 0, 0,
  0, 0, 0, 498, 0, 503, 0, 0, 0, 0, 334, 334, 334, 805414, 565798, 565798, 838182, 565798, 856614, 565798, 872998,
  565798, 565798, 911910, 565798, 565798, 565798, 565798, 565798, 797222, 803366, 565798, 565798, 565798, 565798,
  565798, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565859, 774755,
  565859, 565859, 805475, 565859, 565859, 838243, 565859, 565859, 856675, 565859, 565859, 873059, 565859, 565859,
  565859, 565859, 866915, 871011, 565859, 565859, 881251, 565859, 565859, 565859, 565859, 565859, 565859, 565859,
  875107, 887395, 565859, 895587, 565859, 565859, 907875, 565859, 565859, 565798, 565859, 911971, 0, 0, 0, 0, 700416, 0,
  0, 712704, 731136, 0, 0, 0, 0, 0, 0, 717, 0, 0, 0, 0, 0, 0, 0, 727, 0, 0, 567296, 567296, 567296, 712704, 567296,
  567296, 567296, 567296, 565798, 565798, 565798, 565798, 711206, 713254, 565798, 672294, 694822, 565798, 565798,
  752166, 784934, 807462, 846374, 858662, 897574, 676390, 565798, 565798, 565798, 565798, 565859, 565859, 565859,
  565859, 565859, 696931, 711267, 713315, 565859, 565859, 731747, 565859, 565859, 565859, 565859, 735843, 746083,
  565859, 565859, 764515, 565859, 565859, 565859, 565859, 565859, 832099, 565859, 565859, 565859, 834147, 565859,
  565859, 565859, 565859, 565859, 565859, 565859, 677888, 0, 0, 0, 0, 0, 0, 735, 736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124928,
  0, 0, 0, 0, 0, 0, 567296, 688128, 567296, 567296, 782336, 567296, 567296, 664102, 565798, 688678, 565798, 565798,
  565798, 727590, 565798, 782886, 688739, 565859, 565859, 565859, 727651, 565859, 565859, 782947, 565859, 565859,
  565859, 565859, 565859, 565859, 565859, 565859, 542720, 0, 0, 565859, 565798, 0, 0, 0, 0, 0, 0, 0, 474, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 996, 0, 295, 295, 295, 295, 295, 565859, 899683, 0, 694272, 0, 0, 0, 806912, 0, 0, 0, 897024, 0, 0, 0,
  1632, 565859, 565859, 565859, 897635, 0, 0, 0, 0, 0, 815104, 0, 0, 0, 0, 1632, 0, 0, 0, 0, 1431, 0, 0, 1434, 1435, 0,
  0, 0, 0, 0, 0, 0, 38912, 0, 0, 0, 0, 0, 0, 0, 0, 0, 476, 0, 0, 0, 0, 482, 0, 0, 800768, 0, 913408, 718848, 718848,
  565798, 715302, 719398, 565798, 565798, 565798, 565798, 565798, 565798, 565798, 565859, 672355, 676451, 694883,
  565859, 565859, 565859, 565859, 752227, 784995, 807523, 846435, 565859, 858723, 893478, 565859, 715363, 719459,
  565859, 565859, 565859, 565859, 565859, 565859, 565859, 893539, 0, 0, 0, 0, 0, 0, 565798, 565798, 565798, 565798,
  565798, 565798, 565798, 565798, 565798, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859, 565859,
  565859, 565859, 565859, 748131, 0, 817152, 0, 0, 0, 1632, 0, 0, 0, 565798, 565798, 565798, 565798, 565798, 565798,
  565798, 737830, 565798, 565798, 864806, 565859, 565859, 737891, 565859, 565859, 565859, 565859, 864867, 702464, 0, 0,
  0, 0, 0, 1139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 61440, 61440, 61440, 0, 0, 666150, 565798, 565798, 565798,
  565798, 862758, 666211, 565859, 565859, 565859, 565859, 862819, 708608, 0, 0, 0, 0, 1442, 1443, 0, 0, 0, 0, 0, 0, 0,
  0, 1452, 0, 0, 0, 0, 1457, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1315, 0, 0, 0, 0, 839680, 565798, 754214, 848422, 565798,
  565859, 754275, 848483, 565859, 765952, 717350, 565798, 717411, 565859, 565798, 565859, 565798, 565859, 854566,
  854627, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 573875, 573875, 573875, 0, 0, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0,
  104448, 0, 0, 104448, 0, 0, 0, 0, 0, 1168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 0, 0, 218, 218, 0, 0, 104448, 104448,
  104448, 104448, 104448, 104448, 104448, 104448, 0, 0, 0, 0, 0, 0, 0, 718, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1143, 1144, 1145,
  0, 0, 0, 0, 0, 790528, 0, 38912, 0, 0, 0, 24576, 0, 0, 0, 0, 755712, 0, 796672, 0, 0, 0, 0, 1471, 0, 0, 0, 295, 1475,
  295, 295, 295, 295, 295, 295, 0, 0, 0, 0, 795, 334, 334, 334, 334, 1026, 888832, 565248, 565248, 565248, 565248,
  565248, 565248, 0, 544768, 565248, 565248, 184, 0, 0, 0, 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 530606, 10242, 3,
  0, 185, 0, 0, 0, 185, 0, 0, 0, 684032, 0, 0, 0, 0, 0, 0, 189, 0, 225, 0, 189, 189, 225, 0, 0, 0, 106777, 106777, 0, 0,
  0, 106777, 106777, 106777, 106777, 106777, 106777, 106777, 106777, 106777, 106777, 106777, 0, 106777, 106777, 106777,
  106777, 106777, 106777, 106777, 106777, 0, 0, 0, 0, 0, 0, 0, 926, 0, 0, 0, 0, 931, 0, 0, 0, 0, 0, 106891, 106891,
  106891, 106891, 106891, 106891, 106891, 106891, 106777, 106777, 106894, 1, 10242, 3, 32768, 34816, 0, 0, 0, 0, 30720,
  0, 0, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 0, 1557, 0, 0, 0, 0, 0, 1562, 0, 0, 0, 0, 0, 0, 1433, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1448, 0, 0, 0, 0, 0, 118784, 118784, 0, 0, 0, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784,
  118784, 118784, 118784, 0, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 0, 0, 0, 0, 0, 0, 0, 957,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 0, 0, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 121114, 0,
  0, 0, 0, 1635, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 0, 0, 121114, 121114, 0, 0, 0, 121114, 121114, 121114,
  121114, 121114, 121114, 121114, 121114, 121114, 121114, 121114, 0, 121114, 121114, 121114, 121114, 121114, 121114,
  121114, 121114, 0, 0, 0, 0, 120832, 0, 0, 0, 0, 0, 1182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 184, 184, 0, 0, 0, 0, 0,
  0, 129024, 0, 0, 0, 184, 185, 96256, 0, 0, 0, 0, 0, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 733184, 825344, 0, 0,
  686080, 0, 0, 817152, 0, 0, 0, 14336, 0, 0, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 0,
  540672, 0, 565248, 565248, 114688, 0, 0, 1, 10242, 536752, 0, 0, 0, 0, 0, 180, 0, 0, 0, 180, 0, 0, 0, 0, 0, 495, 0, 0,
  0, 0, 0, 0, 0, 334, 334, 334, 334, 1877, 334, 373, 373, 373, 373, 1881, 373, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 453, 0, 0, 131072, 131072,
  131072, 131072, 131072, 131072, 131072, 131072, 0, 0, 131072, 1, 10242, 3, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0,
  0, 0, 0, 0, 0, 295, 295, 295, 295, 516, 295, 295, 295, 295, 295, 0, 0, 295, 295, 295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  295, 295, 295, 295, 1002, 334, 9043, 795, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1113,
  373, 0, 0, 1125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295, 295, 295, 295, 295, 295, 0, 1335, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 988, 0, 0, 1554, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1147, 0, 32768, 34816, 0, 0, 0, 0, 30720,
  0, 0, 0, 266, 0, 0, 0, 0, 295, 0, 0, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1666, 373, 373, 373,
  32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 1793, 0, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 373, 373, 1398, 1399, 373, 373, 373, 373, 373, 135168, 135168, 0, 0, 0, 135168, 135168, 0, 0, 0, 0, 0, 0,
  135168, 135168, 135168, 0, 135168, 0, 135168, 135168, 0, 0, 0, 0, 0, 0, 0, 968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  731, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295, 765, 295, 851968, 1632, 0, 0, 0, 778240, 0, 0, 0, 0, 0, 0, 0, 688128,
  782336, 0, 0, 0, 0, 45237, 47286, 0, 184, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 843776, 0, 0, 0, 0, 0, 0, 32768, 34816, 0,
  0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 137216, 0, 0, 0, 0, 0, 1310, 0, 0, 1312, 0, 0, 0, 1316, 0, 0, 0, 0, 0, 795, 334,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 1035, 334, 334, 334, 334, 334, 0, 137216, 137216, 137216, 137216, 137216,
  137216, 137216, 137216, 0, 0, 0, 0, 0, 0, 0, 968, 0, 1170, 0, 0, 0, 0, 0, 0, 565248, 899072, 0, 694272, 0, 0, 0,
  806912, 0, 0, 0, 897024, 0, 0, 0, 1695, 565248, 565248, 565248, 897024, 0, 0, 0, 0, 0, 815104, 0, 0, 0, 0, 1734, 0, 0,
  0, 0, 104448, 104448, 0, 0, 104448, 104448, 0, 0, 0, 0, 0, 0, 187, 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 417, 0, 0, 0, 0, 0,
  0, 0, 334, 334, 334, 0, 817152, 0, 0, 0, 1734, 0, 0, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 0, 540672, 663, 565248, 565248, 663, 0, 0, 0, 0, 189, 0, 189, 244, 189, 0, 0, 0, 0, 0, 189, 225, 225, 0, 0, 0,
  0, 126976, 0, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 984, 0, 0, 0, 0, 0, 32768, 34816, 225, 0, 0, 0, 30720, 0, 0, 0, 0,
  0, 0, 273, 283, 296, 283, 283, 296, 296, 296, 283, 283, 323, 323, 323, 323, 323, 323, 323, 323, 323, 335, 323, 323,
  323, 354, 296, 354, 323, 360, 363, 363, 363, 374, 363, 363, 363, 374, 374, 374, 374, 374, 374, 374, 374, 363, 363,
  374, 1, 10242, 3, 37041, 0, 0, 0, 0, 0, 0, 184, 185, 0, 0, 0, 0, 405, 0, 0, 0, 0, 0, 1337, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 205, 0, 205, 0, 0, 0, 408, 409, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 423, 0, 0, 0, 295, 295, 512, 295, 295, 295,
  295, 295, 295, 295, 0, 0, 0, 0, 494, 0, 0, 0, 494, 424, 0, 0, 0, 0, 0, 0, 0, 432, 0, 0, 220, 220, 220, 0, 0, 0, 0, 0,
  1350, 0, 0, 0, 0, 295, 295, 1355, 295, 295, 295, 295, 295, 295, 295, 295, 1210, 1211, 295, 295, 0, 334, 334, 334,
  1884, 373, 373, 373, 1886, 0, 334, 334, 373, 373, 334, 373, 0, 486, 0, 0, 0, 490, 0, 0, 0, 0, 0, 493, 0, 0, 0, 0, 0,
  0, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 434,
  220, 220, 220, 0, 0, 295, 295, 295, 535, 295, 295, 295, 0, 0, 0, 493, 0, 0, 0, 493, 0, 0, 0, 0, 788480, 0, 0, 0, 0, 0,
  0, 0, 0, 882688, 0, 905216, 423, 0, 0, 408, 0, 0, 0, 0, 0, 0, 0, 548, 549, 334, 334, 553, 580, 583, 334, 0, 373, 373,
  615, 373, 373, 373, 373, 373, 373, 373, 640, 373, 373, 373, 1088, 373, 373, 373, 373, 373, 373, 373, 373, 1095, 373,
  373, 373, 903, 0, 0, 0, 373, 334, 0, 0, 0, 913, 0, 0, 0, 0, 0, 924, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0,
  645, 373, 648, 373, 373, 658, 373, 373, 0, 0, 0, 373, 334, 0, 0, 0, 0, 1297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 137216,
  137216, 137216, 1, 10242, 3, 667, 671, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1189, 0, 0, 0, 220, 220, 0, 0, 0, 0,
  0, 0, 705, 0, 0, 0, 0, 0, 0, 1140, 1141, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 295, 0, 753, 334,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1708, 334, 334, 334, 1003, 295, 295, 295, 295, 295, 295, 295,
  295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 1018, 295, 295, 0, 0, 0, 0, 795, 334, 334, 334, 334, 334,
  373, 1850, 373, 373, 373, 373, 373, 373, 0, 0, 0, 373, 334, 0, 911, 0, 0, 0, 917, 0, 334, 334, 9043, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 1083, 373, 373, 0, 0, 0, 1534, 0, 0, 0, 0, 0, 0, 1538, 1539, 0, 0, 0, 0, 0, 1432,
  0, 0, 0, 0, 0, 1437, 1438, 0, 0, 0, 0, 0, 496, 0, 0, 0, 0, 0, 0, 0, 334, 334, 334, 0, 373, 373, 373, 373, 373, 373,
  373, 631, 373, 373, 373, 373, 373, 1810, 373, 1812, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1627, 0, 0, 0, 0, 0, 0, 0, 0, 1125, 0,
  0, 0, 0, 0, 0, 0, 0, 1130, 0, 0, 0, 0, 0, 205, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 205, 206, 0, 0, 0, 0, 1163, 0, 0, 0, 0,
  0, 0, 968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 973, 0, 1191, 0, 0, 0, 295, 295, 1196, 1197, 295, 295, 295, 295, 295, 295,
  295, 295, 295, 295, 295, 295, 0, 792, 0, 0, 295, 1204, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 1189, 334,
  334, 334, 0, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 895, 373, 373, 373, 1216, 334, 1218, 334,
  1220, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 833, 334, 334, 334, 334, 1230, 334, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 591, 0, 0, 0, 1441, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480, 0,
  0, 0, 334, 1493, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 295, 334, 1595, 334, 373, 373,
  373, 373, 373, 373, 373, 373, 1603, 373, 373, 373, 373, 373, 887, 373, 373, 373, 373, 373, 373, 373, 373, 896, 373,
  334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1756, 0, 1758, 0, 0, 0, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 565248, 565248, 565248, 0, 1821, 334, 334, 334, 334, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373,
  373, 373, 1402, 32768, 34816, 0, 0, 255, 255, 30720, 0, 0, 0, 0, 0, 0, 0, 0, 295, 295, 295, 295, 517, 295, 295, 295,
  295, 295, 0, 0, 295, 295, 295, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1129, 0, 0, 0, 0, 0, 974, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 499, 974, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295,
  295, 295, 1016, 295, 295, 295, 0, 0, 0, 0, 795, 334, 334, 334, 334, 334, 827, 828, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 1060, 1061, 334, 334, 334, 334, 334, 334, 1068, 334, 1070, 195, 196, 197, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 494, 0, 0, 0, 32768, 34816, 0, 197, 256, 256, 30720, 258, 258, 265, 0, 265, 265, 274, 284, 297, 284, 284, 297,
  297, 297, 315, 319, 324, 324, 324, 332, 332, 333, 333, 333, 333, 336, 333, 333, 333, 324, 297, 324, 333, 333, 364,
  364, 364, 375, 364, 364, 364, 375, 375, 375, 375, 375, 375, 375, 375, 364, 364, 375, 1, 10242, 3, 0, 0, 456, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 334, 334, 334, 607, 334, 0, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 1267, 373, 373, 373, 0, 0, 220, 220, 0, 0, 702, 682, 0, 0, 0, 0, 0, 0, 0, 0, 0, 738, 0, 0, 0, 0, 0, 0, 334, 9043,
  795, 852, 854, 373, 373, 373, 373, 861, 373, 865, 373, 373, 373, 373, 0, 904, 730, 373, 334, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 193, 194, 373, 871, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1114,
  295, 1004, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 1012, 295, 334, 334, 9043, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 1084, 373, 373, 373, 1101, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 1674, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1093, 373, 373, 373, 373, 373, 373, 373, 1520,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1280, 373, 1568, 295, 295, 295, 295, 295, 295,
  1574, 295, 334, 334, 334, 334, 334, 334, 334, 1223, 334, 334, 334, 334, 334, 334, 334, 334, 1236, 334, 334, 334, 334,
  334, 334, 334, 334, 1034, 334, 334, 334, 334, 334, 334, 334, 1609, 1610, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0,
  0, 0, 0, 0, 0, 1819, 0, 1790, 0, 0, 0, 0, 334, 334, 334, 334, 334, 1800, 334, 334, 334, 373, 373, 373, 373, 373, 373,
  373, 373, 1515, 373, 373, 373, 373, 0, 1726, 0, 0, 0, 0, 0, 0, 0, 0, 1632, 0, 0, 0, 334, 334, 334, 334, 334, 1772,
  334, 373, 373, 1807, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1632, 0, 32768, 34816, 0, 245, 227, 227,
  30720, 0, 0, 0, 267, 0, 0, 275, 285, 298, 285, 285, 298, 298, 298, 316, 320, 325, 325, 325, 325, 325, 325, 325, 325,
  325, 337, 325, 325, 325, 325, 298, 325, 325, 325, 365, 365, 365, 376, 365, 365, 365, 376, 376, 376, 376, 376, 376,
  376, 376, 365, 365, 376, 1, 10242, 3, 0, 686, 0, 0, 0, 689, 0, 0, 0, 0, 693, 694, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0,
  238, 239, 0, 0, 0, 711, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 684, 295, 295, 295, 295, 295, 774, 295, 295, 295,
  295, 295, 295, 295, 295, 295, 295, 295, 295, 0, 0, 683, 0, 295, 782, 295, 295, 784, 295, 295, 295, 295, 295, 295, 295,
  791, 0, 0, 694, 0, 0, 693, 0, 0, 795, 797, 334, 334, 334, 334, 334, 334, 334, 334, 334, 817, 334, 334, 334, 334, 334,
  334, 810, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 821, 334, 0, 0, 0, 295, 0, 0, 0, 0, 0, 334,
  554, 334, 334, 334, 334, 814, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 826, 334, 334, 334, 334, 334,
  334, 832, 334, 334, 837, 334, 334, 334, 824, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 373,
  373, 373, 0, 0, 295, 0, 0, 334, 334, 334, 334, 334, 334, 334, 846, 334, 334, 334, 0, 373, 373, 373, 373, 373, 373,
  373, 632, 373, 373, 373, 373, 661, 905, 0, 373, 334, 908, 0, 0, 0, 914, 0, 0, 334, 9043, 795, 853, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 869, 373, 373, 373, 1117, 373, 1119, 373, 0, 0, 373, 334, 0, 0, 0, 0, 0, 0, 1559, 0, 0,
  0, 0, 0, 1564, 0, 0, 0, 373, 883, 373, 885, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1291, 1292,
  373, 373, 0, 0, 1125, 0, 0, 0, 0, 0, 1128, 0, 0, 0, 0, 0, 0, 0, 1127, 0, 0, 0, 0, 0, 0, 1133, 0, 0, 0, 1150, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1159, 0, 0, 0, 0, 0, 509, 295, 510, 295, 295, 518, 295, 295, 526, 295, 295, 334, 1217, 334, 334,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 295, 1388, 1243, 1244, 334, 334, 295, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 334, 334, 1499, 334, 334, 334, 334, 1346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1353, 295, 295, 295,
  295, 295, 295, 0, 926, 1021, 991, 795, 334, 334, 334, 1025, 334, 1417, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 334, 0, 912, 0, 918, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0, 0, 1469, 0, 0, 0,
  0, 0, 295, 295, 295, 295, 1478, 295, 295, 295, 295, 295, 295, 295, 295, 295, 1009, 295, 295, 295, 295, 295, 295, 0,
  925, 0, 0, 795, 334, 334, 334, 334, 334, 334, 334, 1494, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  334, 1240, 1241, 334, 1684, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1632, 1764, 0, 1766, 334, 334, 334, 334, 334,
  334, 334, 1033, 334, 334, 334, 1036, 334, 334, 334, 334, 334, 334, 373, 373, 1778, 373, 373, 373, 373, 373, 373, 0, 0,
  0, 0, 1788, 226, 203, 224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 334, 554, 32768, 34816, 0, 0, 0, 0, 30720, 0,
  0, 0, 0, 202, 202, 276, 286, 299, 312, 286, 299, 299, 299, 286, 286, 326, 326, 326, 326, 326, 326, 326, 326, 326, 338,
  326, 326, 326, 355, 299, 355, 326, 326, 366, 366, 366, 377, 366, 366, 366, 377, 377, 377, 377, 377, 377, 377, 377,
  366, 366, 377, 1, 10242, 3, 0, 0, 440, 441, 0, 443, 0, 0, 446, 0, 0, 0, 0, 0, 0, 0, 1184, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  204, 0, 0, 0, 0, 0, 0, 204, 454, 0, 0, 0, 457, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295, 295, 295, 1001, 295, 0, 0, 487,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497, 0, 0, 0, 201, 224, 0, 224, 0, 0, 0, 0, 0, 0, 0, 0, 201, 202, 203, 0, 0, 0, 0, 0,
  0, 0, 1155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1460, 0, 0, 0, 0, 1465, 0, 502, 0, 505, 0, 0, 0, 295, 295, 295, 514, 295, 295,
  522, 295, 528, 295, 295, 295, 295, 295, 295, 295, 775, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 0,
  681, 0, 0, 531, 295, 534, 295, 295, 295, 295, 0, 505, 0, 0, 457, 505, 0, 0, 543, 505, 0, 0, 0, 487, 0, 497, 0, 546, 0,
  0, 0, 0, 334, 334, 334, 334, 1863, 334, 373, 373, 373, 373, 1869, 373, 0, 1871, 556, 334, 334, 566, 334, 573, 334,
  577, 334, 334, 582, 584, 334, 334, 334, 334, 295, 334, 334, 334, 334, 1252, 334, 334, 334, 334, 334, 334, 295, 334,
  334, 1250, 334, 334, 334, 334, 334, 1254, 334, 334, 334, 584, 608, 0, 373, 373, 373, 618, 373, 373, 628, 373, 637,
  373, 641, 373, 373, 373, 1285, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1680, 373, 373, 373, 373,
  647, 650, 653, 373, 373, 373, 373, 0, 662, 0, 373, 334, 0, 0, 0, 295, 0, 0, 0, 0, 0, 334, 334, 334, 334, 334, 334,
  373, 373, 373, 373, 373, 373, 0, 0, 699, 0, 220, 220, 0, 0, 0, 0, 0, 704, 0, 0, 0, 0, 0, 710, 334, 334, 811, 334, 334,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1387, 295, 334, 0, 0, 295, 0, 0, 334, 334, 334, 843, 334, 334,
  845, 334, 826, 334, 334, 334, 1658, 334, 334, 334, 334, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 373,
  373, 0, 1855, 0, 334, 9043, 795, 373, 373, 373, 373, 373, 373, 373, 373, 373, 866, 373, 373, 373, 373, 1421, 373, 373,
  373, 373, 373, 373, 1425, 373, 373, 373, 334, 870, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 879, 373, 373,
  373, 373, 657, 373, 373, 373, 0, 0, 0, 643, 578, 0, 0, 0, 373, 373, 902, 373, 662, 0, 0, 373, 334, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1302, 0, 0, 1305, 0, 920, 0, 922, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 681, 0, 0, 0, 0, 935, 936, 0, 938,
  939, 0, 941, 0, 0, 0, 0, 946, 0, 0, 0, 0, 0, 675, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 279, 279, 279, 1, 10242, 3, 0, 951, 0,
  0, 0, 0, 956, 0, 0, 0, 0, 0, 0, 963, 964, 0, 0, 0, 214, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 214, 0, 0, 0, 230, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1146, 0, 0, 0, 295, 295, 295, 1005, 295, 295, 1007, 295, 295, 295, 295, 1011, 295, 295, 295,
  1013, 334, 334, 1042, 334, 334, 1044, 334, 1046, 1047, 334, 334, 334, 334, 1052, 334, 334, 334, 1704, 334, 334, 334,
  334, 334, 334, 334, 334, 334, 334, 334, 1711, 334, 1072, 9043, 1073, 373, 1074, 373, 1076, 373, 373, 373, 373, 373,
  373, 373, 373, 0, 0, 1815, 0, 1817, 0, 1818, 0, 373, 373, 1087, 373, 373, 373, 1090, 373, 373, 373, 373, 373, 373,
  1096, 373, 373, 0, 0, 1533, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 419, 0, 0, 0, 0, 373, 1099, 1100, 373, 1102, 1103, 373,
  373, 373, 373, 1108, 373, 1110, 373, 373, 373, 373, 1612, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 1731, 0, 0,
  1632, 0, 373, 1115, 373, 373, 373, 373, 1120, 0, 0, 1121, 1122, 0, 1123, 0, 0, 0, 0, 0, 676, 749, 750, 0, 0, 0, 0,
  755, 0, 0, 0, 0, 0, 716, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 573876, 69632, 573876, 69632, 0, 0, 0, 1125, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1132, 0, 0, 0, 0, 0, 81920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 0, 0, 0, 1136, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1318, 0, 334, 334, 1245, 334, 295, 334, 1249, 334, 1251, 334, 334, 334, 1253, 334, 334,
  334, 0, 373, 373, 373, 373, 621, 373, 373, 373, 373, 373, 373, 373, 0, 0, 373, 334, 0, 0, 0, 0, 0, 1282, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1293, 373, 373, 373, 1420, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 334, 1123, 0, 1125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 67584, 0, 0, 0, 1307, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1319, 0, 0, 0, 1322, 0, 1324, 1325, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1157, 0, 0, 0, 0, 0, 334,
  1379, 334, 334, 334, 334, 1384, 334, 334, 334, 1385, 334, 334, 334, 295, 334, 0, 0, 0, 295, 0, 0, 0, 546, 0, 334, 334,
  556, 334, 334, 577, 334, 1390, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0,
  373, 373, 1405, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1413, 373, 1415, 373, 373, 373, 1521, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 373, 1527, 373, 373, 373, 0, 0, 0, 1456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 740,
  0, 0, 0, 295, 295, 295, 334, 334, 334, 334, 1486, 334, 334, 334, 334, 334, 334, 334, 1492, 0, 295, 1570, 295, 295,
  295, 1573, 295, 1575, 334, 334, 1578, 334, 334, 334, 334, 295, 1248, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  1373, 334, 334, 334, 334, 334, 334, 334, 1584, 334, 334, 334, 334, 1588, 1589, 1590, 334, 334, 334, 334, 1593, 334, 0,
  0, 0, 295, 0, 507, 0, 0, 0, 334, 599, 600, 334, 334, 605, 1596, 334, 373, 373, 373, 1601, 373, 373, 373, 373, 373,
  373, 373, 1606, 373, 1608, 0, 1624, 1625, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 421, 0, 0, 334, 1656, 334, 334, 334,
  334, 1660, 334, 334, 334, 334, 334, 334, 373, 373, 1669, 0, 1696, 0, 0, 1699, 0, 0, 0, 0, 0, 0, 295, 295, 295, 295,
  295, 295, 295, 295, 295, 1202, 1203, 1712, 334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 1269, 373, 1723, 373, 373, 0, 0, 0, 0, 0, 0, 1730, 0, 0, 0, 1632, 0, 0, 0, 417, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1342, 0, 0, 0, 1736, 0, 0, 0, 0, 295, 334, 334, 334, 334, 334, 334, 1743, 334, 334, 334, 0, 373, 373, 373, 373,
  622, 373, 373, 633, 373, 373, 373, 373, 662, 0, 0, 373, 334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1304, 0, 334, 373,
  373, 373, 373, 1750, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 1729, 0, 0, 0, 0, 1733, 1632, 0, 0, 0, 1761, 0, 0,
  1632, 0, 0, 0, 334, 334, 334, 334, 334, 334, 334, 1828, 334, 373, 373, 373, 373, 373, 334, 1775, 373, 373, 373, 373,
  373, 373, 373, 373, 1784, 0, 0, 0, 0, 0, 0, 1169, 968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 928, 0, 0, 0, 0, 0, 0, 373, 1806,
  373, 373, 373, 373, 373, 373, 1813, 1814, 0, 1816, 0, 0, 0, 0, 0, 216, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 55296, 0,
  114688, 122880, 0, 0, 0, 0, 0, 0, 217, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 0, 1822, 334, 334, 334, 334, 1826, 334, 334,
  334, 1830, 373, 373, 1832, 373, 373, 373, 1611, 373, 373, 373, 373, 373, 373, 0, 0, 1620, 0, 0, 0, 0, 0, 795, 334,
  334, 334, 334, 334, 334, 334, 334, 334, 809, 0, 0, 334, 1860, 334, 334, 334, 1864, 373, 1866, 373, 373, 373, 1870, 0,
  0, 0, 0, 0, 673792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 418, 0, 420, 0, 0, 0, 32768, 34816, 0, 204, 0, 0, 30720, 259, 259,
  259, 0, 259, 259, 259, 0, 300, 0, 0, 300, 300, 300, 204, 204, 259, 259, 259, 259, 259, 259, 259, 259, 259, 339, 259,
  259, 259, 259, 300, 259, 259, 259, 339, 339, 339, 378, 339, 339, 339, 378, 378, 378, 378, 378, 378, 378, 378, 339,
  339, 378, 1, 10242, 3, 0, 425, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 0, 0, 0, 0, 0, 747520, 0, 0, 567296, 567296,
  567296, 567296, 567296, 747520, 567296, 567296, 0, 0, 220, 220, 0, 0, 0, 683, 0, 0, 0, 0, 0, 0, 0, 0, 0, 982, 0, 0, 0,
  0, 0, 0, 295, 769, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 334, 334, 334, 334, 9043,
  795, 373, 373, 373, 373, 373, 373, 862, 373, 373, 373, 373, 373, 373, 889, 890, 373, 373, 373, 373, 373, 373, 373,
  373, 1091, 373, 373, 373, 373, 373, 373, 373, 373, 891, 373, 373, 373, 373, 373, 373, 373, 0, 0, 1348, 0, 0, 0, 0, 0,
  0, 0, 295, 295, 295, 295, 295, 295, 295, 525, 295, 295, 295, 295, 295, 295, 295, 295, 295, 1362, 295, 295, 295, 295,
  295, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1491, 334, 0, 0, 1859, 334, 334, 334, 334, 334, 1865, 373,
  373, 373, 373, 373, 0, 0, 0, 373, 334, 909, 0, 0, 0, 915, 0, 0, 0, 1883, 334, 334, 334, 1885, 373, 373, 373, 0, 334,
  334, 373, 373, 334, 373, 334, 373, 334, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 0, 32768, 34816, 0, 0,
  0, 0, 30720, 260, 260, 260, 268, 260, 260, 260, 287, 301, 287, 287, 301, 301, 301, 287, 287, 327, 327, 327, 327, 327,
  327, 327, 327, 327, 340, 327, 327, 327, 327, 301, 327, 327, 327, 340, 340, 340, 379, 340, 340, 340, 379, 379, 379,
  379, 379, 379, 379, 379, 340, 340, 379, 1, 10242, 3, 668, 672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1344, 0, 0,
  1543, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1549, 0, 0, 0, 0, 0, 295, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 819, 334,
  820, 334, 334, 334, 1644, 295, 295, 295, 295, 295, 295, 334, 1650, 334, 334, 334, 334, 334, 1654, 334, 0, 0, 0, 295,
  490, 0, 0, 460, 490, 334, 553, 334, 334, 334, 576, 334, 334, 1657, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  373, 1668, 373, 373, 373, 1808, 1809, 373, 1811, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 720, 0, 0, 0, 0, 0, 0, 0, 0, 334,
  334, 1875, 1876, 334, 334, 373, 373, 1879, 1880, 373, 373, 0, 0, 0, 0, 0, 0, 0, 1690, 0, 0, 0, 0, 0, 1632, 295, 295,
  295, 295, 295, 295, 540, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1314, 0, 0, 0, 0, 0, 0, 0, 220, 220, 0, 0, 0, 0, 0, 0, 0, 706,
  0, 0, 0, 0, 0, 295, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1746, 0, 0, 1321, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 495, 0, 0, 334, 1713, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1281, 373, 373,
  1724, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1632, 0, 0, 0, 334, 334, 334, 334, 334, 334, 334, 334, 1829, 373, 373, 373,
  373, 373, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 269, 0, 0, 0, 288, 302, 288, 288, 302, 302, 302, 288, 288, 328,
  288, 288, 288, 288, 288, 288, 288, 288, 341, 288, 288, 288, 356, 302, 356, 288, 288, 367, 367, 367, 380, 367, 367,
  367, 380, 380, 380, 380, 380, 380, 380, 380, 367, 367, 380, 1, 10242, 3, 0, 0, 758, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763,
  295, 295, 295, 295, 295, 295, 295, 295, 776, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 778, 295,
  295, 295, 334, 9043, 795, 373, 373, 373, 373, 857, 373, 373, 373, 373, 373, 373, 373, 373, 661, 394, 0, 373, 334, 0,
  0, 0, 899, 373, 373, 373, 0, 0, 0, 373, 334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1301, 0, 0, 0, 0, 0, 0, 0, 937, 0, 0, 0, 0, 0,
  943, 0, 0, 0, 0, 0, 0, 295, 295, 295, 515, 295, 295, 295, 295, 295, 295, 0, 0, 0, 0, 795, 334, 334, 334, 334, 334, 0,
  0, 952, 0, 0, 0, 0, 0, 958, 0, 0, 0, 0, 0, 0, 0, 1338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 692, 0, 0, 695, 0, 0, 0, 0, 0, 967,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 0, 0, 0, 0, 0, 976, 977, 0, 979, 0, 0, 0, 0, 0, 0, 0, 0, 989, 295, 1015,
  295, 295, 295, 295, 0, 0, 0, 0, 795, 334, 334, 334, 334, 334, 1221, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  1370, 334, 334, 334, 334, 334, 334, 334, 1375, 334, 334, 0, 0, 0, 1151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1161, 0, 0, 0,
  418, 489, 0, 0, 0, 0, 0, 492, 0, 0, 0, 0, 500, 373, 373, 1258, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 1682, 373, 0, 1306, 0, 0, 0, 0, 0, 1311, 0, 0, 0, 0, 0, 1317, 0, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 220, 220, 98304, 0, 0, 0, 1320, 0, 0, 0, 0, 0, 0, 0, 1327, 0, 0, 0, 0, 0, 0, 295, 511, 295, 295, 295, 295,
  295, 527, 295, 295, 0, 0, 1429, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 682, 0, 0, 0, 0, 1455, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 696, 0, 0, 1467, 1468, 0, 1470, 0, 0, 0, 0, 1474, 295, 1476, 295, 295, 295, 295, 295, 295, 295, 295,
  295, 295, 777, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 789, 295, 0, 0, 0, 0, 295, 1481, 295, 334, 1483, 334,
  1485, 334, 334, 334, 334, 334, 1490, 334, 334, 334, 0, 373, 373, 373, 373, 624, 373, 373, 373, 373, 373, 373, 373,
  905, 905, 373, 334, 908, 1123, 0, 0, 0, 334, 334, 1506, 373, 1508, 373, 373, 1511, 373, 373, 373, 373, 373, 373, 373,
  373, 876, 373, 373, 373, 373, 373, 373, 373, 1519, 373, 373, 373, 373, 373, 373, 373, 1524, 373, 373, 1526, 373, 373,
  1528, 373, 373, 373, 1837, 0, 0, 0, 0, 0, 0, 1840, 0, 1842, 334, 334, 334, 1368, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 1051, 334, 334, 334, 373, 373, 1531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 724, 0, 0, 0,
  295, 295, 295, 295, 1572, 295, 295, 295, 334, 334, 334, 334, 334, 334, 1581, 0, 0, 0, 1762, 1763, 1632, 0, 0, 0, 334,
  334, 1769, 1770, 334, 334, 1773, 1774, 334, 373, 373, 373, 373, 1780, 1781, 1782, 1783, 373, 0, 0, 0, 0, 0, 0, 1472,
  0, 295, 295, 295, 295, 295, 295, 1479, 295, 1846, 334, 334, 334, 334, 373, 373, 373, 1851, 1852, 373, 373, 373, 0, 0,
  0, 0, 0, 0, 0, 0, 1691, 0, 0, 0, 0, 1632, 32768, 34816, 0, 0, 0, 0, 30720, 261, 261, 261, 0, 261, 261, 261, 289, 303,
  289, 289, 303, 303, 303, 289, 289, 329, 329, 329, 329, 329, 329, 329, 329, 329, 342, 329, 329, 329, 329, 303, 329,
  329, 361, 342, 342, 342, 381, 342, 342, 342, 381, 381, 381, 381, 381, 381, 381, 381, 342, 342, 381, 1, 10242, 3, 334,
  559, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1055, 668, 672, 0, 0, 0, 0, 0, 0, 0,
  678, 0, 0, 0, 0, 0, 0, 334, 334, 1797, 1798, 334, 334, 334, 1802, 334, 373, 767, 295, 295, 295, 295, 295, 295, 295,
  295, 295, 295, 295, 295, 295, 295, 295, 334, 334, 1366, 295, 295, 295, 783, 295, 295, 295, 295, 295, 295, 295, 295, 0,
  0, 0, 0, 0, 0, 426, 0, 0, 334, 823, 334, 334, 334, 334, 334, 829, 334, 334, 334, 334, 334, 836, 334, 334, 373, 373,
  373, 373, 373, 373, 373, 373, 1604, 373, 373, 373, 373, 373, 888, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  893, 373, 373, 373, 373, 373, 0, 0, 295, 0, 0, 334, 801, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1498, 334, 334,
  1500, 334, 1502, 334, 334, 9043, 795, 373, 373, 373, 373, 373, 858, 373, 373, 373, 373, 373, 373, 373, 0, 0, 373, 334,
  0, 0, 912, 0, 0, 373, 373, 884, 373, 373, 373, 373, 373, 373, 892, 373, 373, 373, 373, 373, 373, 1104, 1105, 373, 373,
  373, 373, 373, 373, 373, 373, 0, 0, 0, 664, 665, 0, 0, 0, 373, 901, 373, 373, 0, 0, 0, 373, 334, 0, 0, 0, 0, 0, 0, 0,
  1299, 0, 0, 0, 0, 0, 0, 1027, 334, 1029, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1037, 334, 334, 334, 0, 373,
  373, 373, 373, 625, 373, 373, 373, 373, 373, 373, 373, 1675, 373, 373, 373, 1678, 373, 373, 373, 373, 373, 334, 334,
  9043, 373, 373, 373, 373, 373, 1078, 1079, 373, 373, 1082, 373, 373, 373, 373, 1673, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 1094, 373, 373, 373, 373, 295, 295, 295, 295, 295, 295, 295, 1209, 295, 295, 295, 295, 0,
  334, 334, 334, 334, 373, 373, 373, 373, 0, 334, 334, 373, 373, 334, 373, 334, 334, 1232, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 1239, 334, 334, 334, 0, 373, 373, 373, 373, 626, 373, 373, 373, 373, 373, 373, 373, 1522, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 1623, 1403, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 334, 0, 1440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1439, 0, 295, 295, 295, 334,
  334, 1484, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1497, 334, 334, 334, 334, 334, 334, 334, 1542, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 698, 0, 0, 334, 334, 1824, 1825, 334, 334, 334, 334, 334, 373, 373, 373, 373,
  1833, 1834, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1843, 334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 1719,
  373, 373, 1720, 373, 373, 0, 0, 0, 0, 1688, 0, 0, 0, 0, 0, 0, 0, 0, 1632, 0, 0, 334, 1874, 334, 334, 334, 334, 373,
  1878, 373, 373, 373, 373, 0, 0, 0, 906, 907, 0, 0, 912, 0, 0, 0, 918, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 270,
  0, 0, 0, 290, 304, 290, 314, 304, 304, 304, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 343, 290, 290, 290,
  290, 304, 290, 290, 290, 343, 343, 343, 382, 343, 343, 343, 382, 382, 382, 382, 382, 382, 382, 382, 343, 343, 382, 1,
  10242, 3, 0, 455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1551, 0, 334, 560, 334, 334, 570, 334, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 334, 1662, 334, 334, 334, 334, 373, 373, 373, 0, 0, 295, 0, 0, 334, 841, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 1396, 373, 373, 373, 373, 1400, 373, 373, 373, 334, 9043, 795, 373, 373, 373, 373, 373, 859,
  373, 373, 373, 373, 373, 373, 373, 0, 0, 373, 334, 0, 1123, 0, 0, 0, 334, 334, 9043, 373, 373, 373, 373, 373, 373,
  373, 1080, 373, 373, 373, 373, 373, 1089, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1278, 373, 373, 373, 373,
  373, 373, 1086, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1097, 373, 373, 649, 373, 373, 373, 373,
  373, 0, 0, 0, 373, 334, 0, 0, 0, 0, 295, 0, 0, 0, 334, 334, 334, 373, 334, 334, 334, 0, 0, 1165, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1176, 334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1755, 373, 0, 0, 0, 1759, 32768, 34816, 233,
  246, 0, 208, 30720, 0, 0, 0, 0, 0, 0, 0, 291, 305, 313, 313, 305, 305, 305, 317, 321, 313, 313, 313, 313, 313, 313,
  313, 313, 313, 344, 313, 313, 313, 313, 305, 313, 313, 313, 368, 368, 368, 383, 368, 368, 368, 383, 383, 383, 383,
  383, 383, 383, 383, 368, 368, 383, 1, 10242, 3, 0, 439, 0, 0, 0, 0, 444, 0, 0, 0, 0, 0, 450, 0, 0, 0, 0, 0, 734, 0, 0,
  0, 0, 0, 0, 0, 0, 742, 0, 295, 532, 295, 295, 295, 539, 295, 439, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1436, 0, 0, 0, 0, 0, 0,
  0, 0, 492, 0, 0, 418, 0, 545, 0, 489, 0, 0, 0, 334, 551, 334, 0, 0, 0, 595, 0, 453, 0, 0, 0, 334, 334, 334, 334, 334,
  334, 1381, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 295, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 561, 334, 334, 571, 334, 334, 334, 578, 334, 334, 334, 334, 589, 334, 334, 373, 373, 373, 373, 373, 373,
  373, 1718, 373, 373, 373, 373, 373, 373, 1614, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 452, 0, 334,
  492, 418, 594, 532, 0, 0, 492, 0, 0, 551, 334, 334, 561, 571, 334, 0, 0, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 1683, 0, 0, 687, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 741, 0, 0, 0, 700, 220, 220, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1450, 0, 0, 0, 0, 679, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51200, 0, 744, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 743, 0, 0, 921, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 756, 0, 0, 334, 1028,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1229, 334, 334, 9043, 373, 373, 373, 373,
  373, 373, 373, 373, 1081, 373, 373, 373, 373, 874, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1109, 373,
  373, 373, 373, 0, 0, 1179, 0, 0, 0, 0, 0, 1185, 0, 0, 0, 0, 0, 0, 0, 1352, 0, 0, 295, 295, 295, 295, 295, 295, 295,
  295, 334, 334, 334, 334, 334, 334, 334, 334, 334, 373, 1257, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 1529, 0, 1347, 0, 0, 0, 0, 1351, 0, 0, 0, 295, 295, 295, 295, 295, 1357, 295, 295, 295, 1359, 295,
  295, 1361, 295, 295, 295, 295, 295, 295, 334, 334, 334, 334, 334, 334, 334, 1489, 334, 334, 334, 334, 334, 1389, 334,
  1391, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 1401, 373, 373, 0, 0, 1686, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1694,
  1632, 373, 1404, 373, 1406, 373, 373, 373, 373, 373, 373, 1411, 373, 373, 373, 373, 373, 1260, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 0, 1619, 0, 0, 0, 0, 373, 373, 1419, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 334, 1123, 0, 1125, 0, 0, 1298, 0, 0, 0, 0, 0, 1303, 0, 0, 0, 0, 0, 1545, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1552,
  0, 1569, 295, 295, 295, 295, 295, 295, 295, 334, 1577, 334, 334, 334, 334, 334, 1394, 334, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 334, 1583, 334, 334, 334, 334, 1587, 334, 334, 334, 334, 334,
  334, 334, 334, 334, 1661, 334, 334, 334, 334, 334, 1667, 373, 373, 334, 334, 373, 1599, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 1607, 373, 373, 651, 654, 373, 373, 373, 373, 0, 0, 0, 373, 334, 0, 0, 0, 295, 0, 0, 0, 0, 0, 334,
  334, 334, 334, 603, 334, 295, 295, 1645, 1646, 295, 295, 295, 334, 334, 334, 1651, 1652, 1653, 334, 334, 334, 0, 373,
  373, 373, 619, 373, 373, 373, 373, 373, 373, 373, 373, 0, 662, 0, 373, 334, 0, 0, 0, 373, 1670, 1671, 1672, 373, 373,
  373, 373, 373, 373, 373, 1679, 373, 373, 373, 373, 886, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1265,
  373, 373, 373, 373, 373, 0, 0, 0, 1698, 0, 0, 0, 0, 0, 0, 0, 295, 295, 295, 295, 295, 295, 295, 295, 1201, 295, 295,
  334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 0, 1757, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0,
  0, 0, 51200, 0, 0, 0, 51200, 51200, 51200, 0, 0, 0, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200,
  51200, 51200, 1789, 0, 0, 0, 0, 0, 334, 334, 334, 334, 334, 334, 1801, 334, 1803, 373, 373, 652, 373, 373, 373, 373,
  373, 0, 0, 0, 373, 334, 0, 0, 0, 295, 0, 0, 0, 0, 0, 334, 334, 334, 563, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 1053, 334, 0, 0, 334, 334, 1861, 1862, 334, 334, 373, 373, 1867, 1868, 373, 373, 0, 0, 0, 0,
  0, 0, 1536, 0, 0, 0, 0, 0, 0, 0, 445, 0, 447, 0, 0, 0, 0, 0, 0, 334, 373, 1893, 1894, 334, 373, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 220, 185, 185, 0, 0, 0, 211, 212, 213, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 1546, 1547, 0, 1548, 0, 0,
  0, 1550, 0, 0, 32768, 34816, 0, 211, 213, 213, 30720, 262, 262, 262, 0, 262, 262, 277, 292, 306, 292, 292, 306, 306,
  306, 318, 322, 330, 330, 330, 330, 330, 330, 330, 330, 330, 345, 330, 330, 330, 330, 357, 330, 330, 330, 345, 345,
  345, 384, 345, 345, 345, 384, 384, 396, 384, 396, 396, 396, 396, 397, 397, 396, 1, 10242, 3, 37041, 0, 0, 0, 0, 0, 0,
  184, 185, 0, 0, 0, 0, 0, 406, 0, 0, 0, 427, 428, 0, 0, 0, 0, 0, 0, 220, 220, 220, 0, 0, 0, 0, 232, 0, 233, 234, 0, 0,
  0, 0, 0, 208, 0, 0, 0, 0, 199, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 410, 411, 412, 413, 0, 0,
  0, 0, 0, 0, 0, 0, 422, 0, 0, 0, 438, 0, 0, 0, 0, 461, 0, 0, 0, 0, 0, 0, 0, 22928, 185, 0, 0, 0, 0, 0, 0, 0, 184, 185,
  0, 0, 102400, 0, 0, 0, 0, 0, 468, 469, 0, 0, 0, 0, 0, 475, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 743424, 0, 0,
  504, 0, 0, 507, 0, 295, 295, 513, 295, 295, 521, 295, 295, 295, 530, 295, 295, 295, 295, 537, 295, 295, 0, 0, 541,
  412, 0, 458, 0, 542, 0, 0, 0, 470, 0, 427, 0, 0, 0, 0, 0, 479, 0, 0, 0, 0, 0, 295, 334, 334, 334, 1740, 1741, 334,
  334, 334, 334, 334, 1382, 334, 334, 334, 334, 334, 334, 334, 334, 334, 295, 334, 334, 334, 334, 1066, 334, 334, 334,
  334, 458, 0, 0, 475, 0, 0, 0, 0, 0, 0, 507, 475, 475, 334, 334, 555, 558, 334, 565, 334, 334, 334, 575, 334, 334, 334,
  334, 585, 587, 334, 334, 334, 0, 373, 373, 616, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1107, 373, 373, 373, 373,
  373, 373, 334, 585, 587, 0, 373, 373, 617, 620, 373, 627, 373, 373, 373, 639, 642, 373, 373, 872, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 1111, 373, 373, 0, 712, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 947, 0,
  0, 0, 0, 295, 0, 0, 334, 334, 334, 334, 334, 334, 334, 334, 847, 334, 334, 373, 373, 373, 373, 373, 373, 1717, 373,
  373, 373, 373, 373, 373, 373, 660, 0, 0, 0, 373, 334, 0, 0, 0, 900, 373, 373, 373, 0, 0, 0, 373, 334, 0, 0, 0, 0, 0,
  0, 0, 1445, 0, 0, 0, 0, 0, 0, 0, 0, 0, 391168, 220, 0, 391168, 0, 0, 391168, 295, 295, 295, 295, 1019, 295, 0, 0, 0,
  0, 795, 334, 334, 334, 334, 334, 1706, 334, 334, 1707, 334, 334, 334, 334, 334, 334, 334, 576, 334, 580, 334, 583,
  334, 334, 590, 334, 1040, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 838, 334, 1056,
  334, 334, 334, 334, 295, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1255, 373, 373, 1116, 373, 373, 373, 373,
  0, 0, 373, 334, 0, 0, 0, 1124, 0, 0, 0, 488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1330, 0, 0, 0, 668, 0, 0, 0, 1126, 0,
  672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1461, 0, 0, 1464, 0, 0, 1148, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 949,
  373, 373, 1272, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1112, 373, 373, 295, 295, 295, 1482,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 834, 334, 334, 334, 0, 0, 1555, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 972, 0, 0, 0, 295, 295, 1571, 295, 295, 295, 295, 295, 334, 334, 334, 1579, 334, 334, 334, 0, 373, 612,
  373, 373, 623, 373, 373, 634, 373, 373, 373, 643, 1703, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 1039, 334, 334, 1714, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1414, 373, 373,
  334, 373, 373, 373, 1749, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1540, 0, 1760, 0, 0,
  0, 0, 1632, 0, 0, 0, 334, 1768, 334, 334, 334, 334, 334, 1849, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 373, 334,
  0, 910, 0, 0, 0, 916, 0, 334, 334, 373, 1777, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1541, 0, 1858, 334, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 0, 0, 0, 1728, 0, 0, 0, 0, 0, 0, 1632,
  0, 0, 0, 334, 334, 334, 334, 1771, 334, 334, 1872, 0, 334, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 0,
  0, 0, 0, 0, 0, 1689, 0, 0, 0, 0, 0, 0, 1632, 0, 0, 0, 1767, 334, 334, 334, 334, 334, 334, 815, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 1032, 334, 334, 334, 334, 334, 334, 334, 1038, 334, 1891, 1892, 334, 373, 334, 373, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 220, 208, 0, 0, 0, 0, 32768, 34816, 247, 0, 0, 0, 30720, 0, 0, 0, 271, 0, 0, 0, 0, 295, 0, 0,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 849, 346, 0, 0, 0, 0, 295, 0, 0, 0, 369, 369, 369, 385, 369, 369,
  369, 385, 385, 385, 385, 385, 385, 385, 385, 369, 369, 385, 1, 10242, 3, 0, 0, 426, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220,
  220, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 0, 0, 426, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 334, 334, 334,
  1799, 334, 334, 334, 334, 373, 685, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1134, 0, 681, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1160, 0, 0, 295, 295, 295, 295, 773, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295, 0, 0, 334, 334, 334, 334, 844, 334, 334, 334, 334, 334, 334, 1395, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 1275, 373, 373, 373, 373, 373, 373, 373, 373, 373, 877, 373, 373, 373, 373, 373, 373,
  850, 9043, 795, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 868, 373, 373, 0, 1532, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1329, 0, 0, 1332, 0, 0, 0, 0, 918, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1463, 0, 0, 0, 0, 1178, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1190, 373, 1271, 373, 1273, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1412,
  373, 373, 373, 373, 0, 0, 0, 1308, 1309, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 739, 0, 0, 0, 0, 1378, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 295, 334, 334, 1064, 334, 334, 334, 334, 334, 334, 0, 0, 1737, 0, 0, 295,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1043, 334, 334, 334, 334, 334, 1049, 334, 334, 334, 334, 334, 1369,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1663, 334, 334, 334, 373, 373, 373, 592, 0, 495, 0, 295, 0, 0,
  0, 0, 0, 334, 334, 334, 562, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1503, 669,
  673, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1174, 0, 0, 32768, 34816, 0, 0, 0, 0, 30720, 214, 214, 214, 0, 214,
  214, 214, 0, 307, 0, 0, 307, 307, 307, 0, 0, 214, 214, 214, 214, 214, 214, 214, 214, 214, 347, 214, 214, 214, 214,
  307, 214, 214, 214, 347, 347, 347, 386, 347, 347, 347, 386, 386, 386, 386, 386, 386, 386, 386, 347, 347, 386, 1,
  10242, 3, 295, 533, 295, 295, 538, 295, 295, 0, 0, 0, 0, 0, 0, 506, 0, 0, 0, 0, 427, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  754, 0, 0, 0, 0, 0, 544, 0, 0, 0, 0, 470, 0, 0, 547, 0, 0, 0, 334, 334, 334, 334, 373, 373, 373, 373, 0, 334, 334,
  373, 373, 1889, 1890, 606, 334, 588, 0, 373, 373, 373, 373, 373, 373, 629, 373, 373, 373, 373, 644, 646, 373, 373,
  655, 373, 373, 373, 373, 0, 0, 0, 644, 579, 0, 0, 0, 0, 0, 795, 334, 334, 334, 334, 334, 334, 806, 334, 334, 334, 373,
  373, 373, 373, 373, 373, 1513, 373, 373, 373, 373, 373, 373, 875, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1277,
  373, 373, 373, 373, 373, 373, 0, 0, 220, 220, 0, 0, 0, 0, 703, 0, 0, 0, 0, 0, 0, 0, 1473, 295, 295, 295, 295, 295,
  295, 295, 1480, 0, 0, 713, 0, 0, 0, 0, 0, 0, 0, 0, 0, 723, 0, 0, 0, 0, 0, 795, 334, 334, 334, 334, 334, 804, 334, 334,
  334, 334, 572, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 813, 334, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 1665, 334, 373, 373, 373, 0, 0, 746, 747, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399360, 0, 0, 0, 0, 0,
  295, 0, 723, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1393, 334, 334, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 0, 0, 0, 1787, 0, 0, 975, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1331, 0, 0, 990, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 295, 295, 295, 295, 295, 295, 1200, 295, 295, 295, 295, 295, 295, 1017, 295, 295, 1020, 0, 0, 0, 0, 795, 334,
  334, 334, 334, 334, 1495, 334, 1496, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1224, 1225, 334, 334, 334, 334, 334,
  334, 334, 1057, 334, 1059, 334, 295, 1062, 334, 334, 334, 334, 334, 334, 334, 334, 1659, 334, 334, 334, 334, 334, 334,
  334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 1856, 334, 334, 9043, 373, 373, 373, 1075, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 1423, 373, 373, 373, 373, 373, 373, 334, 0, 1149, 0, 0, 0, 0, 1154, 0, 0, 1156, 0, 1158, 0,
  0, 0, 0, 0, 295, 334, 1739, 334, 334, 334, 334, 334, 1744, 334, 334, 0, 1164, 0, 1166, 0, 0, 0, 0, 0, 0, 0, 0, 1173,
  0, 0, 0, 0, 0, 795, 334, 334, 334, 334, 801, 334, 334, 334, 334, 334, 1383, 334, 334, 334, 334, 334, 334, 334, 334,
  295, 334, 334, 334, 334, 334, 334, 334, 1069, 334, 0, 0, 1192, 0, 0, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295,
  295, 295, 0, 0, 682, 0, 295, 295, 1205, 295, 1206, 1207, 295, 295, 295, 295, 295, 295, 0, 334, 334, 334, 334, 373,
  373, 373, 373, 0, 334, 1887, 373, 1888, 334, 373, 334, 1231, 334, 334, 334, 1234, 334, 334, 1237, 334, 334, 334, 334,
  334, 334, 334, 1705, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1710, 334, 373, 1283, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 1294, 1295, 1296, 0, 0, 0, 0, 0, 0, 0, 0, 1300, 0, 0, 0, 0, 0, 0, 1636, 0, 0, 0,
  1640, 0, 0, 0, 0, 0, 0, 1444, 0, 0, 1447, 0, 0, 0, 0, 0, 0, 414, 415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 959, 0, 0, 0, 0, 0,
  965, 1427, 1428, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1451, 0, 0, 334, 334, 1598, 373, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 1676, 373, 373, 373, 373, 1681, 373, 373, 0, 0, 1633, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1565, 1566, 1567, 334, 1747, 373, 373, 373, 373, 373, 373, 373, 1754, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1692, 0, 0, 1632, 0, 0, 0, 1792, 0, 1794, 334, 1796, 334, 334, 334, 334, 334, 334, 334, 373, 1397, 373, 373, 373, 373,
  373, 373, 373, 1805, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 334, 334, 1820, 0, 334, 334,
  334, 334, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 373, 334, 0, 0, 0, 0, 0, 0, 0, 0,
  1873, 334, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 0, 1882, 239, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 239,
  249, 0, 0, 0, 0, 0, 795, 334, 334, 334, 334, 802, 334, 334, 334, 334, 334, 373, 373, 373, 1510, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 1677, 373, 373, 373, 373, 373, 373, 32768, 34816, 0, 0, 0, 0, 30720, 263, 263, 263, 0, 263,
  263, 278, 0, 308, 0, 215, 308, 308, 308, 0, 0, 278, 278, 278, 278, 278, 278, 278, 278, 278, 348, 278, 278, 278, 278,
  308, 278, 358, 362, 370, 370, 370, 387, 370, 370, 370, 387, 387, 387, 387, 387, 387, 387, 387, 370, 370, 387, 1,
  10242, 3, 37041, 0, 0, 0, 0, 0, 0, 184, 185, 0, 0, 0, 404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 930, 0, 0, 0, 933, 485,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 501, 0, 0, 485, 0, 0, 0, 0, 501, 0, 0, 0, 0, 0, 334, 552, 334, 0, 0, 499,
  295, 0, 0, 0, 0, 0, 334, 334, 334, 334, 569, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1386, 334, 334,
  295, 334, 334, 485, 0, 501, 295, 0, 0, 596, 0, 0, 552, 334, 334, 334, 572, 334, 0, 417, 0, 295, 0, 0, 0, 0, 0, 334,
  334, 334, 602, 570, 334, 0, 0, 0, 533, 0, 508, 0, 0, 0, 334, 334, 334, 334, 334, 334, 1827, 334, 334, 373, 373, 373,
  373, 373, 0, 0, 0, 759, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295, 295, 766, 295, 770, 295, 772, 295, 295, 295, 295, 295, 295,
  295, 295, 295, 779, 295, 295, 295, 295, 295, 295, 295, 495, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1639, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 793, 794, 795, 334, 334, 799, 334, 334, 805, 334, 334, 808, 334, 0, 488, 0, 295, 452, 0, 0, 0, 0, 334, 334, 334,
  601, 334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1785, 0, 1786, 0, 0, 0, 0, 0, 1558, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 295, 295, 295, 295, 1356, 295, 0, 759, 295, 0, 0, 334, 334, 334, 808, 334, 334, 334, 334, 334, 334, 334, 373,
  373, 1509, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1523, 373, 373, 373, 373, 373, 373, 373, 373, 373, 878,
  373, 373, 880, 373, 373, 373, 334, 9043, 795, 373, 373, 373, 856, 373, 373, 863, 373, 373, 867, 373, 373, 373, 373,
  1725, 0, 1727, 0, 0, 0, 0, 0, 0, 0, 1632, 1735, 950, 0, 0, 0, 0, 955, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 0, 0, 0, 0,
  0, 0, 0, 0, 1180, 0, 0, 0, 0, 0, 0, 0, 0, 1187, 0, 0, 0, 0, 0, 795, 334, 334, 334, 800, 334, 334, 334, 334, 334, 334,
  1371, 334, 334, 334, 334, 334, 334, 334, 334, 1377, 295, 295, 295, 295, 295, 295, 1208, 295, 295, 295, 295, 295, 0,
  1214, 334, 334, 373, 373, 373, 373, 373, 1716, 373, 373, 373, 373, 373, 373, 1721, 373, 1256, 373, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 882, 373, 373, 1284, 373, 373, 373, 373, 373, 373, 373, 1289, 373,
  373, 373, 373, 373, 1274, 373, 1276, 373, 373, 373, 373, 373, 1279, 373, 373, 295, 295, 295, 295, 1360, 295, 295, 295,
  295, 295, 295, 295, 295, 334, 334, 334, 334, 334, 334, 1488, 334, 334, 334, 334, 334, 334, 1235, 334, 334, 334, 334,
  334, 334, 334, 334, 1242, 373, 1418, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 334, 0, 593, 0,
  295, 0, 0, 0, 0, 0, 334, 334, 334, 564, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1054,
  334, 1504, 334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1518, 373, 373, 873, 373, 373, 373, 373,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 1426, 373, 334, 1553, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1162,
  0, 0, 0, 1634, 0, 0, 0, 1637, 0, 0, 0, 0, 1642, 0, 0, 0, 0, 0, 795, 796, 798, 334, 334, 334, 803, 334, 807, 334, 334,
  295, 295, 295, 295, 295, 295, 1648, 334, 334, 334, 334, 334, 334, 334, 334, 334, 568, 334, 574, 334, 334, 334, 334,
  334, 586, 334, 334, 334, 334, 812, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1709, 334, 334,
  373, 373, 1685, 0, 0, 1687, 0, 0, 0, 0, 0, 0, 0, 1693, 0, 1632, 0, 0, 1697, 0, 0, 0, 0, 0, 0, 0, 0, 295, 295, 295,
  295, 295, 1199, 295, 295, 295, 295, 295, 334, 373, 373, 373, 373, 373, 1751, 1752, 373, 373, 373, 373, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1537, 0, 0, 0, 0, 0, 0, 1791, 0, 0, 0, 1795, 334, 334, 334, 334, 334, 334, 334, 334, 1804, 373, 1835, 373,
  373, 0, 1838, 0, 0, 0, 0, 0, 0, 0, 334, 1844, 334, 334, 373, 373, 373, 373, 1715, 373, 373, 373, 373, 373, 373, 373,
  373, 373, 1287, 373, 1288, 373, 373, 373, 373, 373, 373, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0, 295,
  1738, 334, 334, 334, 334, 334, 334, 334, 1745, 334, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 293, 309,
  293, 293, 309, 309, 309, 293, 293, 331, 331, 293, 293, 293, 293, 293, 293, 293, 349, 293, 293, 293, 331, 309, 331,
  359, 293, 371, 371, 371, 388, 371, 371, 371, 388, 388, 388, 388, 388, 388, 388, 388, 371, 371, 388, 1, 10242, 3, 438,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 451, 0, 0, 0, 0, 442, 0, 0, 0, 0, 0, 448, 449, 0, 0, 0, 0, 0, 295, 334, 334, 334,
  334, 334, 1742, 334, 334, 334, 334, 1031, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1050, 334, 334, 334,
  334, 503, 0, 0, 0, 0, 0, 295, 295, 295, 295, 295, 295, 524, 295, 529, 295, 295, 295, 295, 295, 295, 295, 787, 295,
  295, 295, 295, 0, 0, 0, 0, 0, 188, 188, 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 472, 0, 0, 0, 334, 334, 334, 295, 295, 295,
  536, 295, 295, 295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121114, 121114, 121114, 1, 10242, 0, 334, 438, 0, 0, 295, 491, 0, 0,
  503, 597, 598, 334, 334, 334, 604, 334, 334, 373, 373, 373, 1779, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 1839, 0, 0,
  0, 334, 334, 1845, 334, 586, 334, 0, 373, 614, 373, 373, 373, 373, 630, 636, 638, 373, 373, 373, 656, 373, 373, 373,
  373, 0, 0, 0, 373, 334, 0, 0, 0, 295, 0, 0, 0, 0, 0, 334, 334, 557, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 334, 334, 822, 0, 0, 220, 220, 701, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 945, 0, 0, 0, 0, 0, 745, 0, 0, 0,
  677, 0, 0, 0, 752, 0, 0, 0, 0, 0, 0, 430, 0, 0, 0, 0, 220, 220, 220, 0, 0, 0, 0, 0, 760, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  295, 295, 295, 1477, 295, 295, 295, 295, 295, 295, 295, 295, 295, 785, 786, 295, 295, 295, 295, 295, 0, 0, 719, 0, 0,
  0, 506, 508, 0, 295, 295, 295, 295, 295, 295, 523, 295, 295, 295, 295, 295, 295, 295, 295, 1008, 295, 295, 295, 295,
  295, 295, 295, 295, 295, 295, 295, 1213, 0, 334, 334, 334, 760, 735, 0, 0, 0, 795, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 825, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 835, 334, 334, 334, 701, 760, 839, 0,
  0, 840, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1030, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 1501, 334, 334, 334, 9043, 795, 373, 373, 855, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 90112, 661,
  0, 373, 334, 0, 0, 0, 0, 0, 0, 953, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 961, 0, 0, 0, 0, 0, 0, 991, 0, 0, 0, 994, 0,
  0, 0, 0, 295, 295, 1000, 295, 295, 295, 295, 295, 295, 295, 496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 684032, 0, 0, 0, 0, 0, 0,
  295, 295, 295, 295, 1006, 295, 295, 295, 295, 295, 1010, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 1212, 295,
  0, 334, 1215, 334, 334, 1041, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1594, 1071,
  334, 9043, 373, 373, 373, 373, 1077, 373, 373, 373, 373, 373, 373, 373, 373, 1262, 373, 373, 373, 1266, 373, 1268,
  373, 373, 0, 0, 0, 1138, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 971, 0, 0, 0, 0, 1177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1188, 0, 0, 0, 0, 471, 0, 0, 0, 0, 0, 477, 0, 0, 0, 483, 484, 0, 0, 0, 1193, 0, 295, 295, 295, 295, 1198, 295, 295,
  295, 295, 295, 295, 0, 0, 922, 922, 795, 1022, 334, 1023, 1024, 334, 1334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1333, 295, 1358, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 1364, 334, 334, 373, 373, 373, 373, 1602,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 1263, 373, 373, 373, 373, 373, 373, 373, 334, 1367, 334, 334, 334, 334,
  334, 334, 334, 1372, 334, 334, 1374, 334, 334, 334, 1058, 334, 334, 295, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  1048, 334, 334, 334, 334, 334, 334, 334, 334, 1380, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 295, 334,
  1063, 334, 1065, 334, 1067, 334, 334, 334, 295, 295, 295, 334, 334, 334, 334, 334, 1487, 334, 334, 334, 334, 334, 334,
  334, 1219, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1227, 334, 334, 334, 1530, 373, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1629, 0, 0, 0, 0, 0, 1544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 985, 0, 987, 0, 0, 1582,
  334, 334, 334, 334, 334, 334, 334, 334, 334, 1591, 334, 1592, 334, 334, 334, 1233, 334, 334, 334, 334, 334, 1238, 334,
  334, 334, 334, 334, 334, 567, 334, 334, 334, 334, 579, 581, 334, 334, 588, 334, 334, 334, 0, 373, 613, 373, 373, 373,
  373, 373, 635, 373, 373, 373, 373, 1118, 373, 373, 0, 0, 373, 334, 0, 0, 0, 0, 0, 0, 1458, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 997, 295, 295, 295, 295, 295, 334, 1597, 373, 373, 1600, 373, 373, 373, 373, 373, 373, 1605, 373, 373, 373, 373,
  1259, 373, 1261, 373, 373, 1264, 373, 373, 373, 373, 373, 373, 659, 373, 0, 0, 0, 373, 334, 0, 0, 0, 295, 295, 295,
  295, 295, 1647, 295, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1246, 1247, 334, 334, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 373, 373, 373, 373, 373, 1512, 373, 1514, 373, 373, 1517, 373, 373, 1655, 334, 334, 334, 334, 334, 334,
  334, 334, 334, 1664, 334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 334, 334, 373, 1, 10242, 3, 1722, 373, 373,
  373, 0, 0, 0, 0, 0, 0, 0, 0, 1732, 0, 1632, 0, 0, 0, 714, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1131, 0, 0, 0, 334, 334,
  1847, 1848, 334, 373, 373, 373, 373, 373, 1853, 1854, 373, 0, 0, 0, 0, 0, 978, 0, 980, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  397312, 397312, 397312, 397312, 1, 10242, 3, 1857, 0, 334, 334, 334, 334, 334, 334, 373, 373, 373, 373, 373, 373, 0,
  0, 0, 0, 0, 1535, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1339, 1340, 0, 0, 1343, 0, 0, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0,
  0, 0, 0, 0, 294, 310, 294, 294, 310, 310, 310, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 350, 294, 294,
  294, 294, 310, 294, 294, 294, 350, 350, 350, 389, 350, 350, 350, 389, 389, 389, 389, 389, 389, 389, 389, 350, 350,
  389, 1, 10242, 3, 729, 0, 0, 732, 0, 0, 0, 0, 0, 0, 732, 0, 0, 0, 0, 0, 0, 69632, 184, 185, 0, 100352, 0, 0, 0, 0, 0,
  0, 690, 691, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1313, 0, 0, 0, 0, 0, 0, 768, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295,
  295, 295, 295, 295, 295, 334, 1365, 334, 0, 0, 295, 0, 0, 334, 802, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1392,
  334, 334, 334, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 334, 9043, 795, 373, 373, 373,
  373, 373, 860, 373, 373, 373, 373, 373, 373, 373, 1409, 373, 373, 373, 373, 373, 373, 373, 373, 1616, 373, 373, 0, 0,
  0, 1621, 0, 0, 919, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1345, 934, 0, 0, 0, 0, 0, 940, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 135168, 135168, 0, 1, 10242, 3, 1014, 295, 295, 295, 295, 295, 934, 0, 0, 0, 795, 334, 334, 334, 334, 334,
  1507, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1290, 373, 373, 373, 373, 1085, 373, 373, 373, 373,
  373, 373, 373, 373, 1092, 373, 373, 373, 373, 373, 373, 1286, 373, 373, 373, 373, 373, 373, 373, 373, 373, 1525, 373,
  373, 373, 373, 373, 373, 1098, 373, 373, 373, 373, 373, 373, 373, 1106, 373, 373, 373, 373, 373, 373, 373, 1408, 373,
  373, 1410, 373, 373, 373, 373, 373, 1416, 1135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1631, 0, 0, 0, 1430, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1172, 0, 0, 0, 0, 373, 373, 1836, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 334, 334,
  1585, 1586, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 1226, 334, 1228, 334, 334, 228, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1643, 32768, 34816, 0, 217, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 0, 295, 295, 295, 295, 519,
  295, 295, 295, 295, 295, 228, 0, 295, 295, 295, 217, 217, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 395264, 395264, 395264, 1,
  10242, 3, 351, 0, 0, 0, 0, 295, 0, 0, 0, 351, 351, 351, 390, 351, 351, 351, 390, 390, 390, 390, 390, 390, 390, 390,
  351, 351, 390, 1, 10242, 3, 295, 295, 771, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 780, 295,
  781, 334, 9043, 795, 373, 373, 373, 373, 373, 373, 373, 864, 373, 373, 373, 373, 373, 1422, 373, 373, 373, 373, 1424,
  373, 373, 373, 373, 334, 966, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 32768, 34816, 218, 0, 0, 0, 30720,
  264, 264, 264, 0, 264, 264, 264, 0, 311, 0, 0, 311, 311, 311, 0, 0, 264, 264, 264, 264, 264, 264, 264, 264, 264, 352,
  264, 264, 264, 264, 311, 264, 264, 264, 352, 352, 352, 391, 352, 352, 352, 391, 391, 391, 391, 391, 391, 391, 391,
  352, 352, 391, 1, 10242, 3, 353, 0, 0, 0, 0, 295, 0, 0, 0, 353, 353, 353, 392, 353, 353, 353, 392, 392, 392, 392, 392,
  392, 392, 392, 353, 353, 392, 1, 10242, 3, 0, 0, 220, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 708, 0, 0, 0, 0, 494, 0, 0, 0,
  0, 0, 0, 0, 0, 334, 334, 334, 334, 334, 334, 334, 334, 334, 334, 818, 334, 334, 334, 334, 334, 37041, 0, 0, 0, 0, 0,
  0, 184, 185, 0, 0, 0, 0, 0, 0, 407, 334, 334, 609, 0, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373,
  1613, 1615, 373, 1617, 1618, 0, 0, 0, 0, 1622, 0, 0, 0, 1137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28672, 0, 0,
  1270, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 898, 32768, 34816, 0, 0, 0, 0, 30720,
  0, 0, 0, 272, 0, 0, 0, 0, 295, 0, 0, 334, 334, 334, 334, 334, 334, 334, 334, 334, 848, 334, 391168, 391168, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 391168, 0, 391168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1341, 0, 0, 0, 0, 391420, 391420, 391168, 0, 0,
  0, 391420, 0, 0, 0, 0, 0, 391168, 0, 0, 0, 0, 391168, 0, 0, 391168, 0, 391168, 391168, 0, 0, 0, 0, 0, 391168, 391168,
  0, 0, 0, 0, 0, 391168, 0, 0, 0, 391168, 391168, 391168, 391168, 0, 391168, 0, 0, 0, 0, 0, 0, 391168, 0, 0, 0, 0,
  391168, 0, 0, 391168, 0, 391168, 391168, 0, 1, 10242, 3, 32768, 34816, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 395264,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51200, 51200, 0, 395264, 395264, 0, 0, 0, 395264, 395264, 395264, 395264,
  395264, 395264, 395264, 395264, 395264, 395264, 395264, 0, 395264, 395264, 395264, 395264, 395264, 395264, 395264,
  395264, 0, 0, 0, 0, 0, 0, 0, 94208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 0, 0, 248, 0, 0, 0, 253, 253, 0, 0, 0, 0, 253, 0,
  0, 0, 0, 0, 0, 397312, 0, 0, 0, 0, 674, 0, 0, 676, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 0, 397312,
  397312, 397312, 397312, 397312, 397312, 397312, 397312, 0, 0, 0, 0, 0, 0, 0, 104448, 104448, 104448, 104448, 104448,
  104448, 104448, 104448, 104448, 0, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 0, 0, 0, 0, 0, 0, 0,
  137216, 137216, 137216, 137216, 137216, 137216, 137216, 137216, 137216, 565248, 899072, 0, 694272, 0, 0, 0, 806912, 0,
  0, 0, 897024, 0, 0, 0, 0, 0, 429, 0, 0, 0, 0, 0, 220, 220, 220, 0, 0, 565248, 565248, 565248, 897024, 0, 0, 0, 0, 0,
  815104, 0, 0, 0, 0, 0, 0, 459, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 81920, 81920, 1, 10242, 3, 0, 817152, 0, 0, 0, 0,
  0, 0, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  26, 58, 90, 122, 154, 473, 477, 693, 186, 218, 250, 282, 314, 346, 378, 410, 442, 510, 542, 574, 606, 638, 670, 477,
  477, 481, 725, 729, 730, 737, 735, 731, 741, 745, 749, 753, 757, 761, 821, 1683, 821, 779, 768, 2138, 1369, 777, 1456,
  899, 783, 789, 812, 820, 821, 795, 796, 828, 821, 1734, 772, 773, 1116, 899, 899, 800, 810, 790, 790, 816, 763, 821,
  821, 826, 821, 1693, 772, 834, 899, 899, 803, 838, 790, 790, 847, 819, 821, 821, 2010, 821, 851, 853, 899, 899, 806,
  790, 790, 790, 857, 821, 821, 863, 1368, 870, 899, 900, 2164, 790, 791, 821, 821, 874, 770, 898, 899, 2165, 790, 842,
  821, 1830, 880, 899, 884, 840, 821, 1830, 897, 1118, 790, 904, 1500, 899, 884, 887, 1165, 909, 1663, 915, 2162, 910,
  2163, 911, 1120, 785, 785, 925, 929, 932, 936, 936, 942, 936, 938, 946, 950, 954, 958, 962, 966, 821, 971, 821, 1637,
  1016, 821, 821, 821, 821, 821, 821, 1058, 977, 821, 821, 821, 1723, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821,
  821, 1722, 1303, 1033, 1048, 1037, 1047, 1209, 1052, 821, 1057, 1062, 1498, 1066, 1011, 821, 1029, 1075, 821, 989,
  1081, 1085, 821, 821, 967, 1053, 821, 866, 1091, 1537, 2156, 821, 1095, 1099, 821, 1106, 1113, 821, 821, 821, 1124,
  821, 1581, 1128, 1132, 1136, 1991, 1191, 821, 1142, 1146, 821, 821, 1152, 821, 1282, 1130, 1159, 1087, 1174, 1101,
  1109, 821, 830, 1015, 865, 1169, 1556, 1173, 1102, 1180, 1831, 987, 1639, 1522, 2159, 1186, 1190, 1162, 2140, 1549,
  1559, 1196, 1406, 1200, 1204, 1219, 1208, 1213, 1223, 1182, 1228, 1447, 1629, 1626, 1630, 1227, 1232, 1236, 1240,
  1248, 821, 821, 1669, 821, 1260, 1258, 2013, 1264, 1268, 1272, 1275, 821, 1606, 821, 1279, 829, 1292, 1704, 1296,
  1309, 1300, 1307, 1956, 1313, 821, 821, 1317, 1570, 1764, 1323, 1379, 1329, 2033, 1358, 1335, 1341, 821, 1345, 1398,
  1355, 821, 821, 1778, 1363, 1373, 1985, 1859, 1390, 2040, 821, 1155, 1396, 1485, 821, 1402, 821, 821, 821, 1410, 1416,
  1423, 1427, 1431, 1435, 1437, 1405, 1462, 1359, 1441, 821, 821, 1451, 1455, 1425, 1495, 1460, 1468, 1397, 1466, 2112,
  821, 1656, 1472, 1376, 1515, 1392, 1484, 1479, 1483, 1752, 1366, 1654, 1489, 1504, 1508, 2130, 1512, 1654, 2043, 1519,
  2128, 821, 1216, 1526, 1077, 821, 1530, 1492, 980, 1534, 1562, 1541, 1563, 1542, 1546, 1553, 1553, 1567, 821, 821,
  821, 1574, 1580, 1758, 1585, 1589, 1593, 1597, 1601, 1604, 821, 2105, 1917, 1610, 1747, 1619, 1714, 1623, 1634, 1643,
  1647, 1651, 1660, 1667, 2131, 1673, 1678, 1613, 1797, 1687, 1691, 1697, 1701, 821, 1708, 821, 1712, 821, 1718, 821,
  821, 1325, 1895, 1856, 1615, 1727, 1733, 1738, 821, 1784, 1721, 1681, 821, 1419, 821, 821, 2131, 1576, 1742, 905,
  1746, 1412, 821, 1071, 821, 1751, 821, 1756, 821, 821, 821, 1692, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821,
  821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 2140,
  2016, 2003, 1893, 1762, 979, 821, 1768, 821, 821, 1775, 821, 1782, 1788, 1795, 821, 1176, 821, 1175, 1777, 1801, 1805,
  1809, 1922, 821, 2026, 2081, 1814, 1927, 2091, 821, 2093, 1818, 1100, 1777, 1822, 1828, 2056, 2149, 1836, 1385, 1243,
  1386, 1244, 1835, 1840, 1850, 1847, 821, 821, 821, 821, 1863, 1148, 1867, 1871, 1875, 1879, 1883, 1887, 821, 821,
  1382, 1899, 1903, 1910, 1916, 1921, 1926, 1138, 893, 1932, 1936, 1940, 821, 1319, 1771, 1946, 1977, 1853, 918, 821,
  1953, 821, 821, 1960, 1967, 821, 821, 1971, 1941, 821, 1949, 1251, 1975, 1729, 1890, 764, 1984, 821, 921, 2067, 821,
  821, 1288, 1989, 821, 1331, 1899, 1995, 1912, 2001, 2007, 821, 1337, 1963, 821, 843, 2020, 821, 1906, 1254, 1997,
  2024, 2030, 821, 2065, 2074, 822, 2037, 1810, 2049, 2053, 2062, 978, 2071, 2075, 1043, 1928, 1348, 1979, 2079, 2085,
  821, 2089, 1285, 2058, 2097, 2102, 859, 1040, 1980, 2045, 973, 2109, 1843, 1444, 2116, 1351, 1022, 2120, 1023, 2121,
  2125, 2135, 2135, 2144, 2147, 821, 821, 821, 821, 821, 1069, 2153, 2169, 2172, 1674, 972, 821, 821, 821, 821, 2098,
  821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 821, 984, 988, 821, 890, 876, 993, 997, 1001, 1005,
  1008, 1824, 1015, 1192, 1942, 1791, 1475, 1020, 1027, 2251, 2256, 2176, 2408, 2190, 2194, 2194, 2194, 2194, 2410,
  2193, 2194, 2194, 2194, 2973, 2976, 2192, 2194, 2195, 2196, 2200, 2203, 2206, 2209, 2213, 2217, 2224, 2226, 2230,
  2220, 2233, 2237, 2239, 2243, 2246, 2250, 2255, 3672, 2322, 2261, 2261, 2261, 2324, 2834, 3307, 2261, 2261, 2185,
  2185, 2185, 2185, 2261, 2185, 3192, 2261, 2261, 2268, 2731, 3133, 2830, 2293, 3404, 2276, 3409, 2295, 2276, 2276,
  2276, 2276, 2335, 2618, 2261, 2261, 2261, 2285, 2828, 2294, 3404, 3404, 3401, 3404, 3404, 3403, 3404, 3404, 2297,
  2276, 2276, 2276, 2281, 2338, 2276, 2301, 2319, 2305, 2320, 2261, 2261, 2261, 2261, 2262, 2953, 2286, 2290, 3305,
  2261, 2261, 2261, 2308, 2185, 3193, 2293, 3404, 2296, 2276, 2276, 2276, 3409, 2261, 2261, 2261, 2330, 2276, 2277,
  2317, 2305, 2261, 3191, 2185, 2185, 2185, 2294, 2318, 2321, 2261, 2261, 2354, 3706, 2833, 3308, 2261, 2261, 2444,
  2258, 2261, 2185, 2185, 2185, 2345, 2261, 3382, 2261, 2261, 2509, 2832, 3191, 2185, 2345, 3404, 3406, 2276, 2276,
  2276, 2261, 2261, 2832, 2490, 2497, 2261, 2261, 3551, 3635, 2185, 2186, 3404, 3404, 3404, 3404, 3401, 3409, 2261,
  2261, 2831, 3443, 3407, 2276, 2276, 2261, 2261, 2294, 3406, 2276, 3408, 2261, 2261, 3576, 2261, 2261, 3612, 3617,
  2294, 3407, 3399, 2349, 3396, 2351, 2701, 2359, 2373, 2387, 2377, 2381, 2381, 2381, 2381, 2402, 2381, 2386, 2382,
  2391, 2395, 2381, 2414, 2381, 2419, 2398, 2426, 2423, 2429, 2432, 2449, 2453, 2455, 3128, 2459, 2463, 2466, 2435,
  2261, 2470, 2415, 2476, 2261, 2261, 2261, 2340, 2947, 3168, 2261, 2261, 2261, 2355, 2486, 2704, 2261, 2261, 2261,
  2365, 2369, 2261, 3338, 3342, 2695, 2699, 2261, 2261, 2261, 2472, 2516, 2260, 2493, 3170, 2520, 2605, 2536, 2546,
  2539, 2542, 2550, 2554, 2558, 2562, 2563, 2563, 2567, 2571, 2261, 2261, 3682, 2608, 2697, 2261, 2261, 2261, 2482,
  2261, 3264, 2261, 2261, 2595, 3137, 2262, 2710, 2583, 2261, 2261, 2632, 3258, 2584, 3297, 2589, 2665, 2478, 3601,
  2665, 2261, 2261, 3710, 2261, 2262, 3658, 3692, 3602, 2261, 2261, 2261, 2593, 3341, 2694, 2698, 2261, 2261, 2806,
  2261, 2261, 2261, 2628, 3101, 2260, 2261, 2602, 2615, 3134, 2626, 2261, 2264, 2261, 2261, 3475, 3374, 2643, 2653,
  2261, 2261, 2676, 3142, 2657, 2261, 2261, 3138, 3332, 2664, 2261, 2261, 2686, 2723, 2261, 3281, 2261, 2910, 3226,
  2684, 3683, 2724, 2728, 2261, 2261, 2261, 2701, 3133, 3411, 2701, 3133, 2261, 3411, 2646, 2737, 2727, 3331, 2736,
  2726, 2261, 2294, 3404, 3404, 3404, 3407, 2276, 3410, 2572, 2692, 2696, 2700, 2261, 3282, 3305, 2261, 2261, 2715,
  2888, 2261, 3154, 2672, 2261, 2261, 2709, 2261, 3566, 2261, 2261, 3414, 2735, 2725, 2261, 2261, 2760, 2660, 2339,
  2694, 2698, 2261, 2323, 3055, 3663, 2709, 2706, 2672, 2261, 2339, 3092, 2261, 2344, 3404, 3404, 2261, 3307, 2261,
  2718, 2751, 2727, 2261, 2261, 2261, 2813, 3364, 2741, 2746, 2261, 2261, 2777, 2257, 2261, 3565, 2261, 3412, 2742,
  2726, 2261, 2261, 2261, 2807, 2702, 2261, 3413, 2765, 3093, 2261, 2259, 3307, 2705, 2716, 2757, 2769, 2773, 2261,
  2261, 2261, 2831, 2777, 2261, 3237, 2261, 2366, 2261, 2471, 2701, 2261, 3144, 3484, 2471, 2261, 2781, 2785, 3306,
  3255, 2261, 3254, 3255, 2261, 2795, 3254, 2261, 3256, 3305, 3254, 2261, 3256, 3306, 3351, 2261, 2261, 3257, 2572,
  3351, 3350, 3257, 2261, 2439, 2988, 2261, 2440, 3135, 2628, 2811, 2817, 2261, 2261, 2804, 2825, 2841, 2272, 2851,
  2855, 2859, 2866, 2863, 2865, 2870, 2873, 2875, 2879, 2879, 2879, 2880, 2804, 2959, 2256, 2261, 2445, 2259, 3282,
  2261, 3696, 2261, 2331, 3582, 3642, 2261, 3751, 2261, 2896, 2908, 2261, 2323, 2914, 3116, 2932, 2930, 2261, 2500,
  2579, 2711, 3012, 2936, 2261, 2261, 2918, 3116, 2952, 2261, 3039, 2951, 3213, 2885, 2261, 2261, 2920, 2924, 2261,
  3749, 2261, 2262, 3628, 3202, 2970, 3235, 2261, 2261, 2921, 2925, 2759, 2261, 2261, 2324, 3627, 3632, 2981, 3089,
  2311, 3236, 3733, 2261, 2993, 2901, 3319, 3680, 2261, 2595, 3137, 3135, 3661, 3091, 3469, 2260, 2261, 2261, 2261,
  2836, 2477, 2261, 2261, 3726, 3113, 2261, 2261, 3190, 2185, 2185, 2960, 2261, 2261, 3306, 2261, 2261, 2897, 2261,
  3136, 2323, 2923, 2700, 2261, 2572, 3741, 3307, 3351, 2261, 3466, 3547, 2261, 2261, 3097, 3073, 2471, 2261, 2261,
  2261, 2997, 3431, 3016, 3664, 3074, 2261, 2261, 2261, 3021, 3309, 3080, 2261, 2261, 2953, 2366, 2729, 3027, 2256,
  2261, 2595, 3359, 3375, 3305, 2261, 2261, 3036, 2894, 2700, 2261, 3137, 3043, 2471, 2261, 2989, 3050, 2471, 2261,
  2261, 3054, 3066, 3064, 3072, 3547, 2261, 2595, 3720, 2261, 2627, 3093, 2512, 3078, 2261, 2261, 3726, 2960, 2261,
  2261, 3307, 2294, 2505, 3546, 2261, 2261, 3059, 2261, 2835, 3010, 2261, 2261, 3087, 3068, 2261, 3727, 2818, 2261,
  2637, 2261, 2576, 3146, 2261, 2261, 2836, 3106, 3547, 2261, 2261, 2835, 3010, 2800, 2261, 3547, 2261, 2676, 2709,
  2261, 2680, 3547, 2261, 2635, 3308, 2261, 3189, 2185, 2966, 3547, 2261, 2836, 2679, 2261, 2261, 2837, 2271, 2729,
  3132, 2261, 2680, 3547, 2680, 3122, 2261, 3083, 2261, 2705, 2361, 2750, 2471, 2887, 2471, 2676, 2364, 2261, 2367,
  2677, 2679, 2676, 2709, 2261, 2705, 2471, 3265, 3289, 2708, 2261, 2261, 2365, 3152, 2261, 2707, 2261, 2717, 2362,
  2755, 2364, 2368, 2261, 2709, 2688, 2471, 3411, 2764, 2471, 2261, 2364, 2368, 2678, 3289, 2365, 2709, 2363, 2261,
  2730, 2958, 2964, 2262, 3032, 3201, 2261, 2261, 3291, 2701, 2261, 2261, 2261, 3102, 2649, 2703, 2261, 3319, 3162,
  2405, 2622, 2523, 2526, 2529, 3174, 2532, 3179, 3179, 3178, 3179, 3183, 3184, 3184, 3184, 3188, 2261, 2261, 3212,
  2884, 3315, 2261, 2261, 2904, 2261, 2261, 3310, 2261, 2831, 2261, 3218, 2261, 3225, 2261, 3271, 3241, 2261, 2785,
  2512, 3254, 2261, 3309, 3257, 2261, 3247, 3252, 3262, 2261, 2788, 2261, 2261, 2511, 3305, 3269, 2261, 2261, 3275,
  3279, 2261, 2261, 3242, 3296, 2847, 3280, 2261, 2791, 2261, 2261, 3208, 2261, 2262, 3301, 3280, 2261, 2833, 2294,
  3404, 3243, 3304, 2261, 2261, 3214, 2886, 3200, 2261, 2261, 2261, 3165, 3290, 3314, 3318, 2261, 2845, 2261, 2261,
  3281, 2620, 2443, 2261, 2261, 3329, 3336, 2261, 2261, 2261, 3189, 2185, 2261, 3195, 3699, 3348, 2261, 3248, 3346,
  2261, 2892, 2261, 3118, 2261, 3357, 3023, 3364, 2262, 3363, 2261, 2261, 3230, 2261, 2262, 3357, 3368, 3376, 2261,
  2261, 2261, 3194, 2261, 3325, 2954, 2261, 2261, 3257, 3597, 2679, 2261, 2261, 2261, 3191, 2261, 3434, 2261, 3502,
  3315, 2261, 2261, 3380, 2953, 2261, 2261, 2261, 3206, 2843, 2261, 2261, 2261, 3210, 3387, 3374, 2261, 2261, 3289,
  3158, 2831, 3443, 2261, 2261, 3308, 2261, 2261, 3169, 3478, 2261, 2899, 2261, 3319, 2261, 3477, 3364, 2261, 2261,
  2261, 3213, 3475, 3428, 2261, 2261, 3309, 3372, 3438, 2261, 2902, 2260, 2261, 3006, 3283, 2261, 3442, 2261, 2261,
  3324, 2261, 2261, 3454, 2261, 3423, 3318, 2902, 2260, 3382, 3444, 2261, 2261, 2261, 3221, 3424, 2902, 2260, 3382,
  3463, 3741, 2831, 3495, 2261, 3459, 2261, 2261, 3340, 2693, 3463, 3742, 3383, 2261, 2261, 2261, 2339, 3742, 3308,
  3257, 2261, 3349, 3351, 3741, 3307, 3351, 2261, 2262, 3719, 3349, 2261, 2798, 3349, 3741, 3307, 3351, 3285, 3599,
  2261, 2902, 2503, 2261, 2894, 2700, 3134, 2921, 2313, 2759, 3482, 2675, 3109, 2179, 3488, 3136, 2758, 3492, 2639,
  3500, 3506, 3046, 3510, 3517, 3520, 3523, 3525, 3514, 3529, 3532, 3538, 3533, 3534, 3539, 2261, 2902, 3194, 2261,
  2903, 2261, 2261, 3292, 3316, 2900, 2261, 2438, 2442, 3137, 2628, 2259, 2261, 2920, 3004, 2901, 2261, 3563, 2261,
  3351, 3353, 2261, 2585, 2261, 2261, 2261, 3291, 2182, 2261, 2261, 2261, 3449, 3543, 2886, 2261, 2261, 2261, 3283,
  2666, 3555, 2261, 3148, 3559, 2261, 2261, 2330, 3570, 3636, 2261, 2261, 2261, 3496, 2441, 3136, 2628, 2261, 2922,
  2926, 2901, 2323, 3574, 3608, 2261, 2945, 2261, 3038, 2323, 3613, 3589, 3636, 2261, 2610, 3623, 3648, 2261, 2262,
  3622, 2262, 3580, 3586, 3593, 3019, 2261, 2261, 3561, 2261, 2261, 3352, 2261, 3287, 3606, 2261, 2261, 2261, 3749,
  3633, 2256, 2261, 2261, 3390, 2722, 3137, 3019, 2701, 2886, 2261, 3351, 3750, 2261, 2261, 2261, 3422, 3317, 2323,
  3653, 3608, 2261, 2953, 2328, 3308, 2822, 3393, 2261, 2261, 3475, 3418, 3581, 3640, 3670, 3636, 3646, 3749, 2261,
  2261, 3448, 2261, 2261, 3652, 3607, 2261, 2980, 2985, 3233, 3658, 3668, 3634, 2261, 2980, 3001, 3547, 2799, 2261,
  3285, 2366, 3718, 2898, 2261, 3320, 2988, 2627, 2702, 2261, 3350, 2261, 2261, 3349, 3286, 2261, 3287, 2261, 2261,
  2324, 3654, 3634, 2261, 2261, 3621, 2323, 3676, 2256, 2610, 3133, 2261, 2261, 2261, 2261, 3286, 2261, 2261, 3453,
  2261, 2261, 3687, 2261, 2611, 2353, 3691, 2261, 2261, 3458, 2261, 2261, 2701, 2261, 3288, 2261, 2261, 2261, 3687,
  2262, 3719, 2261, 3030, 3199, 3284, 3724, 2261, 3136, 2261, 3060, 3067, 3547, 3137, 2261, 2261, 2596, 2262, 2598,
  3135, 2261, 2261, 2597, 2261, 2597, 2261, 3082, 3122, 2261, 2261, 2261, 3031, 2261, 3731, 2595, 2261, 3100, 2261,
  2261, 2258, 3305, 2263, 2263, 2939, 3737, 2261, 2261, 2261, 3473, 3743, 2261, 3747, 3286, 2261, 3134, 2670, 2674,
  2686, 3702, 2261, 2293, 3404, 3405, 2276, 2276, 2276, 3125, 3739, 2941, 3714, 3713, 3714, 3168, 0, 270532608, 2097152,
  2097152, 4096, 262272, 0, 0, 98304, 1048576, 1048576, 1048576, 1048576, 524288, 1210056704, 2097152, 541065216,
  -2143289344, 4194304, 4194304, 4194304, 4194304, 541065216, 4194304, 134518784, 1074079744, 541065216, 4194304,
  4194304, 280640, 37748736, 37748736, 4194304, 37748736, 54525952, -2059403264, 5242880, -2059403264, -2059403264,
  5242880, 5243904, -2142240768, -2059403264, -2059403264, 121634816, -2024800256, -2025848832, -1488977920, 121634816,
  121634816, 121634816, 121634816, -2025848832, 121634816, 4718592, -1488977920, -2025848832, -2025848832, 524288,
  2621440, 4718592, 4718600, 2621440, 541589504, 4718592, -1605892216, -1605892216, -1572337784, -1605892216,
  -1555560568, -1572337784, -1572337784, -2025324544, -2025324544, -1488451704, 4, 16, 32, 131072, 131072, 268435456, 0,
  0, 0, -2147483648, 0, 0, 0, 0, 1, 0, 0, 0, 4096, 264192, 0, 0, 131072, 0, 0, 524296, 524296, 524296, 524296, 512, 768,
  896, 0, 34078728, 0, 262144, 2048, 2048, 2048, 2048, 0, 64, 0, 0, 524288, 524288, 524288, 8, 524296, 524296, 768, 512,
  0, 34078728, 1024, 1024, 1024, 1024, 2048, 262144, 1048576, 4194304, 8388608, 33554432, 134217728, 1073741824, 512,
  34078728, 34078720, 1024, 1024, 1024, 0, 0, 0, 2, 4, 2048, 64, 0, 0, 1, 2, 4, 524296, 524296, 34078728, 34078720, 0,
  0, 1024, 2048, 8192, 0, 1048576, 524288, 524288, 524288, 524296, 524296, 524288, 524296, 0, 0, 1, 4, 16, 32, 33554432,
  67108864, 1073741824, 0, 32768, 0, 0, 2097152, 0, 0, 0, 32768, 0, 8, 2, 2, 0, 67125248, 65538, 131074, 262146,
  33554434, 2, 2, 2, 2, 3, 32770, 2, 2, 6, 130, 134, 536870918, 262274, 393218, 131074, 131074, 262146, 262146, 130,
  130, 262278, 134, 6, 131074, 2, -2147479552, -2147479552, 2097152, 1207959552, 4194304, 4195328, 20971520, 541065216,
  2, 2, 0, 0, 16384, 20447232, 2, 130, 130, 2, 6, 2, 516436394, 2, 516436394, 516436394, 516686254, 516686254,
  516686254, 1053557166, 516686254, 516698542, 516764078, -1612968538, 0, 0, 2097152, 4096, 128, 262144, 0, 0, 0,
  67108864, 0, 516698542, 516764078, 2, 516698542, 516764078, 516698542, 1053688278, 516698542, 516698542, 0, 2, 2, 2,
  14, -2129130494, -2129117917, -2129117917, -2129117917, -2129117913, -2129117917, -2129117917, 512, 1073741824, 0, 0,
  0, 192, 65536, 131072, 0, 0, 0, 224, 0, 8192, 12582912, 402653184, 17825792, 0, 0, 30408704, 256, 0, 64, 64, 256, 256,
  17039360, 256, 4096, 150994944, 0, 0, 2146304, -2147483648, 2, 0, 0, 64, 4096, 0, 134217728, 67108864, 0, -2147483648,
  0, 33554432, 64, 320, 64, 17039360, 156240896, 156240896, 0, 8388608, 8389120, 0, 2097168, 2097168, 234881088,
  2097168, 2359312, 1051300, 3410100, 1640612, 10029732, 3410100, 8650752, 1216684164, 49186, 1216667808, -2145337310,
  -1989096414, 1216618660, 1216618660, 1216651428, 1216651428, 49186, 49186, 1216667808, 1216667808, 1216667812,
  1216667814, 1216667814, 1216667814, 2089214136, 1216667814, 1216667814, 1216667814, 1216618916, 1216667814,
  1216618916, 1216667814, 1216667878, 2089738936, 2089738936, 2089738936, 2089738936, 2089738936, 2089738936,
  2089738942, 2089738942, 2089738940, 0, 0, 0, 1024, 128, 8724480, 1207959552, 0, 0, 7389184, -1996488704, 8708096,
  1207959552, 0, 0, 0, 1540, 8708096, 0, 184, 8839168, 0, 416, 0, 0, 1, 16, 32, 0, 0, 0, 5242880, 0, 8388608, 8650752,
  33554433, 8650752, 1207959552, 0, 0, 1, 48, 524288, 128, 73728, 1207959552, 0, 0, 8388608, 8388608, 0, 0, -2147479552,
  589824, 49152, 0, 0, 0, 2048, 0, 0, 7340032, -1996488704, 0, 0, 8650752, 1, 33554432, 0, -1073741824, -1073741824,
  57344, 0, 56, 128, 512, 32768, 131072, 2097152, 4194304, 1073741824, 57344, 131072, 8650752, 2080374784, 0, 512,
  9175040, 0, 0, 16777216, 1073741824, 9175040, 2080374784, 0, 0, 0, 1668, 128, 57344, 262144, 8388608, 134217728,
  1073741824, 0, 0, 8, 128, 0, 0, 0, 4096, 40960, 57344, 0, 24, 128, 32768, 262144, 134217728, 2048, 8192, 65536,
  262144, 1048576, 2097152, 4194304, 16777216, 134217728, 0, 0, 0, 512, 0, 0, 0, 128, 32768, 0, 0, 0, 160, 8658944, 128,
  1073741824, 0, 0, 128, 1073741824, 0, 49152, 131072, 262144, 8388608, 67108864, 134217728, 1879048192, 0, 0, 0, 8192,
  0, 0, 49152, 131072, 262144, 524288, 8388608, 67108864, 128, 512, 32768, 262144, 524288, 524288, 67108864, 134217728,
  1879048192, 0, 128, 32768, 262144, 67108864, 128, 32768, 262144, 1073741824, 0, 0, 1073741824, 0, 1073741824, 128,
  32768, 262144, 805306368, 1073741824, 16, 128, 262144, 805306368, 512, 262144, 805306368, 1073741824, 2048, 1048576,
  4194304, 16777216, 0, 16, 805306368, 1073741824, 2048, 4194304, 16777216, 0, 0, 19922944, 0, 0, 2097152, 134217728, 0,
  4194304, 0, 33554432, 0, 0, 536870912, 1073741824, 0, 0, 8192, 0, 256, 0, 150994944, 0, 0, 131088, 256, 512, 4194304,
  16777216, 8192, 524288, 268435456, 0, 0, 0, 16, 8192, 67108864, 0, 67108864, 0, 0, 34603008, 0, 0, 0, 64, 0, 0, 0, 12,
  16, 128, 0, 131088, 0, 0, 1, 32768, 0, 0, 1, 35328, 0, 1114112, 1114112, 1114112, 136314881, 1114176, 1114176,
  1114720, -524020734, -522906014, -524020478, -524020734, -523889662, -1059776926, -522906014, -522906014, -522906014,
  -522906014, -523889662, -522906014, -522906014, -489300378, -522906014, -522906014, -455788958, -522906014,
  -522906014, -472523010, -472523010, -472523010, -472523010, -472523010, 0, 512, 131072, 67108864, 0, 0, 0, 49152, 0,
  0, 608, 0, 0, 1, 2097152, 134217728, 0, 0, 16777216, 0, 0, 0, 65536, -2147483648, 2, 4456448, -528482304, 0, 0, 1,
  33554432, 5728, 65536, 5505024, -528482304, 0, 5376, 0, 0, 2, 8, 16384, 8388608, 33554432, 134217728, 0, 0, 5505024,
  -1065353216, 0, 0, 2, 5728, 114688, 5505024, -494927872, 0, 1, 0, 1, 1, 3, 13920, -461373440, 0, 0, 2, 32768, 5505024,
  -478150656, 0, 0, 0, 262144, 0, 256, 0, 0, 524288, 0, 268435456, 0, 268435456, 0, 0, 4, 49152, 1024, 4096, 262144,
  4194304, 4194304, 8388608, 4195328, 541065216, 541065216, 541065216, 2, 32, 64, 512, 1024, 1024, 4096, 65536, 262144,
  0, 0, 32, 64, 0, 12, 48, 192, 2, 12, 48, 192, 4096, 65536, 1048576, 8388608, 134217728, 0, 0, 3072, 5242880, 16, 192,
  0, 0, 6, 7776, 32, 192, 512, 2048, 0, 0, 0, 2048, 262144, 7340032, 16777216, 256, 0, 524288, 0, 1, 256, 512, 1024,
  131072, 0, 1048576, 0, 0, 14, 7920, 114688, 0, 4096, 8388608, 536870912, 67109378, 1140851202, 67110406, 4096,
  1048576, 8388608, 536870912, 0, 4, 32, 64, 512, 0, 12, 16, 192, 2048, 32, 192, 2048, 4096, 49152, 1048576, 33554432,
  536870912, 49152, 1048576, 8388608, 33554432, 536870912, 1073741824, 0, 16, 64, 131072, 0, 0, 12, 128, 0, 4, 64, 2048,
  4096, 114688, 262144, 1048576, 4194304, 16777216, 0, 4, 4096, 49152, 33554432, 0, 67108864, 0, 0, -2147483648, 128,
  4096, 49152, 33554432, 0, 1073741824, 1073741824, 0, 524288, 268435456, 0, 2, 0, 0, 2, 5120, 49152, 536870912,
  1073741824, 0, 2, 1, 0, 2, 2, 67125248, 256, 524288, 0, 0, 0, 32, 0, 0, 0, 56, 49152, 1073741824, 0, 0, 16, 128, 0, 0,
  1, 1908, 0, 32768, 0, 128, 8192, 49152, 8192, 256, 4096, 1073758208, 65536, 8, -2147479552, 0, 2, 3, 3, 0, 0, 0, 256,
  -2145386496, 1050788, 1051044, 3410100, 3410100, 829688756, 3410100, 3410100, 3410100, 3410100, 3410102, 829721525,
  829721525, 829721525, 829721525, 829721525, 0, 0, 0, 1048576, 1048576, 1048576, 0, 0, 0, 20, 1024, 131072, 524288,
  2097152, 8388608, 0, 0, 16, 2097152, 0, 0, 16, 131072, 0, 0, 16, 64, 512, 131072, 0, 64, 234881024, 0, 2, 8, 8388608,
  2359296, 0, 0, 0, 3145728, 36, 128, 2560, 1048576, 4194304, 8388608, 1610612736, -2147483648, 0, 0, 33554432, 2048,
  3407872, 0, 0, 0, 7602176, 2048, 384, 0, 0, 9437184, 67584, 1572864, 0, 0, 16, 536870912, 0, 0, 0, 40960, 68096,
  9961472, 0, 0, 32, 49152, 0, 52, 3407872, 0, 0, 52, 128, 0, 52, 384, 2560, 7602176, 822083584, 0, 0, 0, 8388608, 0, 0,
  0, 4, 0, 0, 0, 8, 0, 8192, 4096, 54, 0, 0, 0, 8691712, 52, 384, 35328, 7602176, 0, 0, 0, 33554432, 0, 0, 0, 16, 0,
  8192, 4096, 16384, 1073741824, 4194304, 0, 0, 0, 2097152, 128, 64, 33554432, 201326592, 0, 0, 0, 4, 32, 128, 512,
  57344, 131072, 2048, 1048576, 0, 0, 64, 1024, 2048, 4096, 8192, 65536, 0, 20, 3145728, 0, 0, 0, 536870912, 0, 0, 4,
  1024, 20, 32, 384, 512, 32768, 262144, 32768, 805306368, 0, 0, 0, 2048, 32768, 262144, 7340032, 384, 512, 262144,
  6291456, 16777216, 805306368, 0, 0, 65536, -2147483648, 0, 0, 64, 33554432, 0, 1, 256, 512, 32768, 24, 128, 8192, 0,
  131072, 524288, 524296, 524288, 524296, 0, 524288, 524288, 34603008, 524288, 524288, 524288, 524288, 524296, 524296,
  524296, 0, 0, 0, 24, 128, 512, 8192, 1024, 524288, 2097152, 8388608, 8, 0, 8192, 16384, 1073741824, 0, 1024, 524288,
  8388608, 0, 2, 12, 16, 128, 262144, 2097152, 8192, 16384, 1073741824, 4194304, 64, 33554432, 67108864, 134217728, 0,
  0, 0, 512, 4194304, 805306368, 0, 0, 512, 1024, 8388608, 0, 0, 512, 805306368, 0, 0, 1024, 8192, 16384, 0, 2, 4096,
  8388608, 16777216, 33554432, 1610612736, 1024, 16384, 0, 0, 256, 512, 6291456, 16777216, 805306368, 2, 1073741824,
  1073741824, 1073741824, 16, 805306368, 0, 1073741826, 262272, 1073741824, 33554432, 1074004096, 1073743872, 33554432,
  67108864, 0, 0, 320, 1107296256, 8388608, 0, 0, 384, 0, -1073741824, 67109378, 67109378, 67109378, 1146880, 68257286,
  17924096, 1146888, 68257286, 1141999110, 1141933574, 1141999110, 68257286, 1141999110, 9535488, 68191750, 68191750,
  68257286, 68257286, 68257286, 68257286, 343115590, 68257286, 1141933574, 68519558, 1142001158, 343648119, 343648119,
  343648119, 343648119, 1417389943, 343648119, 343648119, 1417389943, 1417389943, 343648119, 0, 2, 1540, 98304, 1048576,
  536870912, 1073741824, 0, 0, 2, 1860, 229376, 3145728, 360448, 0, 0, 3588, 761856, 0, 0, 0, 512, 67108864, 0, 0, 512,
  524288, 0, 1908, 761856, 3145728, 4194304, 4, 1536, 32768, 65536, 1048576, 0, 2, 4, 48, 64, 256, 1536, 256, 1536,
  8192, 32768, 196608, 3145728, 4194304, 196608, 524288, 3145728, 4194304, 0, 4, 1536, 0, 0, 0, 696, 9363456,
  2080374784, 1536, 65536, 1048576, 67108864, 0, 0, 2, 4, 64, 256, 1536, 1536, 65536, 131072, 1048576, 1, 48, 8192,
  524288, 0, 0, 64, 256, 512, 1024, 524288, 65536, 1048576, 2097152, 4194304, 67108864, 268435456, 0, 0, 512, 1024,
  8192, 65536, 131072, 524288, 4, 1024, 0, 0, 3584, 0, 2, 4, 512, 1024, 65536, 1048576, 2, 4, 48, 512, 1024, 2048, 4096,
  49152, 65536, 1048576, 1024, 65536, 524288, 1048576, 2097152, 4194304, 0, 1024, 4, 512, 2097152, 4194304, 128, 262144,
  0, 32, 128, 57344, 131072, 0, 4, 2097152, 4194304, 48, 524288, 2097152, 4194304, 268435456, 0, 2097152, 262144, 32,
  128, 2048, 262144, 67108864, 134217728, 1879048192, 32, 524288, 2097152, 4194304, 0, 2097152, 32, 0, 3, 3, 3, 3, 1,
  16, 32, 524288, 0, 0, 524288, 2097152, 0, 0, 8192, 256, 0, 1, 16, 0, 0, 12288, 1677721600, 1, 1, 1, 1, 0, 0, 65536, 0,
  0, 0, 4, 4, 0, 0, 65536, 1048576, 0, 0
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "%ERROR",
  "%OTHER",
  "PragmaContents",
  "Wildcard",
  "DirCommentContents",
  "DirPIContents",
  "CDataSection",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "QName",
  "NCName",
  "S",
  "S",
  "CommentContents",
  "EOF",
  "'outer for'",
  "'!='",
  "'""'",
  "'#)'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'context'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'deterministic'",
  "'digit'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'minus-sign'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nondeterministic'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'strict'",
  "'strip'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'when'",
  "'where'",
  "'window'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 2048
    let $end := $end - $result idiv 256
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 1894 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 32
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 32 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(58, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 47) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 23) then                 (: CommentContents :)
            let $state := p:consume(23, $input, $state)     (: CommentContents :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(33, $input, $state)               (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consume(47, $input, $state)               (: (':' ')') :)
  return $state
};

(:~
 : Try parsing the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(14, $input, $state)          (: %OTHER | S^WS | ('(' ':') :)
    return
      if ($state[$p:l1] = 1) then                           (: %OTHER :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 22) then                 (: S^WS :)
            let $state := p:consume(22, $input, $state)     (: S^WS :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Whitespace-1($input, $state)
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Whitespace-1($input, $state)
  return $state
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'namespace-node' :)
  let $state := p:consume(138, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse BindingExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BindingExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QueryBody($input, $state)
  return $state
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:consume(147, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(10, $input, $state)               (: StringLiteral :)
  return $state
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(66, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(18, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return $state
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'deterministic' | 'function' |
                                                               'nondeterministic' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 113) then                     (: 'function' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 95) then                   (: 'deterministic' :)
          let $state := p:consume(95, $input, $state)       (: 'deterministic' :)
          return $state
        else
          let $state := p:consume(144, $input, $state)      (: 'nondeterministic' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'function' :)
  let $state := p:consume(113, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(144, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'namespace' | 'ne' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'return' | 'satisfies' | 'self' |
                                                               'some' | 'stable' | 'start' | 'to' | 'treat' | 'try' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 190) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionBody($input, $state)
      return $state
    else
      let $state := p:consume(109, $input, $state)          (: 'external' :)
      return $state
  return $state
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:consume(85, $input, $state)               (: 'context' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:consume(128, $input, $state)              (: 'item' :)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: ':=' :)
      let $state := p:consume(49, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(109, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 49) then                   (: ':=' :)
          let $state := p:consume(49, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(164, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 127) then                      (: 'is' :)
      let $state := p:consume(127, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<<' :)
      let $state := p:consume(54, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(60, $input, $state)           (: '>>' :)
      return $state
  return $state
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 57) then                       (: '=' :)
      let $state := p:consume(57, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '!=' :)
      let $state := p:consume(26, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '<' :)
      let $state := p:consume(51, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<=' :)
      let $state := p:consume(55, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '>' :)
      let $state := p:consume(58, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(59, $input, $state)           (: '>=' :)
      return $state
  return $state
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 106) then                      (: 'eq' :)
      let $state := p:consume(106, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ne' :)
      let $state := p:consume(139, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'lt' :)
      let $state := p:consume(133, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'le' :)
      let $state := p:consume(130, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'gt' :)
      let $state := p:consume(118, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(114, $input, $state)          (: 'ge' :)
      return $state
  return $state
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(139, $input, $state)          (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'case' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 61) then                       (: '?' :)
      let $state := p:consume(61, $input, $state)           (: '?' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(32, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(154, $input, $state)           (: QName^Token | S | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1(9, $input, $state)             (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:consume(2, $input, $state)            (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:consume(28, $input, $state)               (: '#)' :)
  return $state
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(65, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 32) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(169, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 193) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: '@' :)
      let $state := p:consume(63, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(156, $input, $state)          (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NodeTest($input, $state)
  return $state
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'child' :)
      let $state := p:consume(81, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant' :)
      let $state := p:consume(92, $input, $state)           (: 'descendant' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'attribute' :)
      let $state := p:consume(73, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'self' :)
      let $state := p:consume(166, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descendant-or-self' :)
      let $state := p:consume(93, $input, $state)           (: 'descendant-or-self' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'following-sibling' :)
      let $state := p:consume(111, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(110, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 73) then                           (: 'attribute' :)
      let $state := p:lookahead2W(146, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (81,                           (: 'child' :)
                              92,                           (: 'descendant' :)
                              93,                           (: 'descendant-or-self' :)
                              110,                          (: 'following' :)
                              111,                          (: 'following-sibling' :)
                              166)) then                    (: 'self' :)
      let $state := p:lookahead2W(143, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 12361                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12369                          (: 'child' '::' :)
          or $state[$p:lk] = 12380                          (: 'descendant' '::' :)
          or $state[$p:lk] = 12381                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 12398                          (: 'following' '::' :)
          or $state[$p:lk] = 12399                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 12454) then                    (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(156, $input, $state)      (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(43, $input, $state)               (: '..' :)
  return $state
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (73,                                (: 'attribute' :)
                         83,                                (: 'comment' :)
                         99,                                (: 'document-node' :)
                         100,                               (: 'element' :)
                         143,                               (: 'node' :)
                         160,                               (: 'processing-instruction' :)
                         164,                               (: 'schema-attribute' :)
                         165,                               (: 'schema-element' :)
                         173)) then                         (: 'text' :)
      let $state := p:lookahead2W(142, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8009                           (: 'attribute' '(' :)
          or $state[$p:lk] = 8019                           (: 'comment' '(' :)
          or $state[$p:lk] = 8035                           (: 'document-node' '(' :)
          or $state[$p:lk] = 8036                           (: 'element' '(' :)
          or $state[$p:lk] = 8079                           (: 'node' '(' :)
          or $state[$p:lk] = 8096                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 8100                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 8101                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 8109) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'parent' :)
      let $state := p:consume(152, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'ancestor' :)
      let $state := p:consume(67, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'preceding-sibling' :)
      let $state := p:consume(157, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'preceding' :)
      let $state := p:consume(156, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(68, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(156, $input, $state)      (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (67,                                (: 'ancestor' :)
                         68,                                (: 'ancestor-or-self' :)
                         152,                               (: 'parent' :)
                         156,                               (: 'preceding' :)
                         157)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(143, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 43                             (: '..' :)
          or $state[$p:lk] = 12355                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 12356                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 12440                          (: 'parent' '::' :)
          or $state[$p:lk] = 12444                          (: 'preceding' '::' :)
          or $state[$p:lk] = 12445) then                    (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(141, $input, $state)          (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  return $state
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(66, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(141, $input, $state)        (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
    return
      if ($state[$p:l1] != 65) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-PredicateList-1($input, $state)
  return $state
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(160, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(130, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 190) then                      (: '{' :)
      let $state := p:consume(190, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(193, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(169, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 193) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(83, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(173, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse URIExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  return $state
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(137, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(130, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 190) then                      (: '{' :)
      let $state := p:consume(190, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrefixExpr($input, $state)
      let $state := p:consume(193, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(169, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 193) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URIExpr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(73, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(159, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 190) then                      (: '{' :)
      let $state := p:consume(190, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(193, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(169, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 193) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(100, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(159, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 190) then                      (: '{' :)
      let $state := p:consume(190, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(193, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(169, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 193) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(98, $input, $state)               (: 'document' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(56, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(3, $input, $state)             (: PITarget :)
  let $state := p:consume(17, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(12, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:consume(5, $input, $state)            (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(8, $input, $state)             (: '?>' :)
  let $state := p:consume(62, $input, $state)               (: '?>' :)
  return $state
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(52, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(4, $input, $state)                (: DirCommentContents :)
  let $state := p:lookahead1(5, $input, $state)             (: '-->' :)
  let $state := p:consume(41, $input, $state)               (: '-->' :)
  return $state
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51                             (: '<' :)
          or $state[$p:l1] = 52                             (: '<!--' :)
          or $state[$p:l1] = 56) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 6) then                        (: CDataSection :)
      let $state := p:consume(6, $input, $state)            (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 14) then                       (: ElementContentChar :)
      let $state := p:consume(14, $input, $state)           (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: AposAttrContentChar :)
      let $state := p:consume(16, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: PredefinedEntityRef :)
      let $state := p:consume(11, $input, $state)           (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 18) then                       (: CharRef :)
      let $state := p:consume(18, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: '{{' :)
      let $state := p:consume(191, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 194) then                      (: '}}' :)
      let $state := p:consume(194, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: QuotAttrContentChar :)
      let $state := p:consume(15, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(112, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 27) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 12) then                 (: EscapeQuot :)
            let $state := p:consume(12, $input, $state)     (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(113, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 30) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 13) then                 (: EscapeApos :)
            let $state := p:consume(13, $input, $state)     (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(13, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27) then                       (: '"' :)
      let $state := p:consume(27, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(27, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(30, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(30, $input, $state)           (: "'" :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(17, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 21) then                         (: S :)
        $state
      else
        let $state := p:consume(21, $input, $state)         (: S :)
        let $state := p:lookahead1(157, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 21                      (: S :)
               and $state[$p:l1] != 46                      (: '/>' :)
               and $state[$p:l1] != 58) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QName($input, $state)
            let $state := p:lookahead1(10, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 21) then             (: S :)
                let $state := p:consume(21, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(6, $input, $state)   (: '=' :)
            let $state := p:consume(57, $input, $state)     (: '=' :)
            let $state := p:lookahead1(16, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 21) then             (: S :)
                let $state := p:consume(21, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(118, $input, $state)         (: CDataSection | PredefinedEntityRef | ElementContentChar |
                                                               CharRef | '<' | '<!--' | '</' | '<?' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 53) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(51, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: '/>' :)
      let $state := p:consume(46, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(58, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(53, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1(11, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: S :)
          let $state := p:consume(21, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(7, $input, $state)         (: '>' :)
      let $state := p:consume(58, $input, $state)           (: '>' :)
      return $state
  return $state
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 52) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51                             (: '<' :)
          or $state[$p:l1] = 52                             (: '<!--' :)
          or $state[$p:l1] = 56) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(181, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(150, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(167, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(42, $input, $state)               (: '.' :)
  return $state
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(167, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: IntegerLiteral :)
      let $state := p:consume(7, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 8) then                        (: DecimalLiteral :)
      let $state := p:consume(8, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(9, $input, $state)            (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: StringLiteral :)
      let $state := p:consume(10, $input, $state)           (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 137) then                          (: 'namespace' :)
      let $state := p:lookahead2W(132, $input, $state)      (: NCName^Token | S^WS | '(' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (98,                           (: 'document' :)
                              150,                          (: 'ordered' :)
                              181)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(64, $input, $state)       (: S^WS | '(' | ('(' ':') | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7                              (: IntegerLiteral :)
          or $state[$p:lk] = 8                              (: DecimalLiteral :)
          or $state[$p:lk] = 9                              (: DoubleLiteral :)
          or $state[$p:lk] = 10) then                       (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 29) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 42) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 48790) then                    (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 48821) then                    (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51                             (: '<' :)
          or $state[$p:lk] = 52                             (: '<!--' :)
          or $state[$p:lk] = 56                             (: '<?' :)
          or $state[$p:lk] = 73                             (: 'attribute' :)
          or $state[$p:lk] = 83                             (: 'comment' :)
          or $state[$p:lk] = 100                            (: 'element' :)
          or $state[$p:lk] = 160                            (: 'processing-instruction' :)
          or $state[$p:lk] = 173                            (: 'text' :)
          or $state[$p:lk] = 5257                           (: 'namespace' NCName^Token :)
          or $state[$p:lk] = 17801                          (: 'namespace' 'and' :)
          or $state[$p:lk] = 18313                          (: 'namespace' 'ascending' :)
          or $state[$p:lk] = 19849                          (: 'namespace' 'case' :)
          or $state[$p:lk] = 20105                          (: 'namespace' 'cast' :)
          or $state[$p:lk] = 20361                          (: 'namespace' 'castable' :)
          or $state[$p:lk] = 21129                          (: 'namespace' 'collation' :)
          or $state[$p:lk] = 22409                          (: 'namespace' 'count' :)
          or $state[$p:lk] = 23433                          (: 'namespace' 'default' :)
          or $state[$p:lk] = 24201                          (: 'namespace' 'descending' :)
          or $state[$p:lk] = 24969                          (: 'namespace' 'div' :)
          or $state[$p:lk] = 25993                          (: 'namespace' 'else' :)
          or $state[$p:lk] = 26249                          (: 'namespace' 'empty' :)
          or $state[$p:lk] = 27017                          (: 'namespace' 'end' :)
          or $state[$p:lk] = 27273                          (: 'namespace' 'eq' :)
          or $state[$p:lk] = 27785                          (: 'namespace' 'except' :)
          or $state[$p:lk] = 28809                          (: 'namespace' 'for' :)
          or $state[$p:lk] = 29321                          (: 'namespace' 'ge' :)
          or $state[$p:lk] = 29833                          (: 'namespace' 'group' :)
          or $state[$p:lk] = 30345                          (: 'namespace' 'gt' :)
          or $state[$p:lk] = 30601                          (: 'namespace' 'idiv' :)
          or $state[$p:lk] = 32137                          (: 'namespace' 'instance' :)
          or $state[$p:lk] = 32393                          (: 'namespace' 'intersect' :)
          or $state[$p:lk] = 32649                          (: 'namespace' 'is' :)
          or $state[$p:lk] = 33417                          (: 'namespace' 'le' :)
          or $state[$p:lk] = 33929                          (: 'namespace' 'let' :)
          or $state[$p:lk] = 34185                          (: 'namespace' 'lt' :)
          or $state[$p:lk] = 34697                          (: 'namespace' 'mod' :)
          or $state[$p:lk] = 35721                          (: 'namespace' 'ne' :)
          or $state[$p:lk] = 37513                          (: 'namespace' 'only' :)
          or $state[$p:lk] = 38025                          (: 'namespace' 'or' :)
          or $state[$p:lk] = 38281                          (: 'namespace' 'order' :)
          or $state[$p:lk] = 41353                          (: 'namespace' 'return' :)
          or $state[$p:lk] = 41609                          (: 'namespace' 'satisfies' :)
          or $state[$p:lk] = 43401                          (: 'namespace' 'stable' :)
          or $state[$p:lk] = 43657                          (: 'namespace' 'start' :)
          or $state[$p:lk] = 44937                          (: 'namespace' 'to' :)
          or $state[$p:lk] = 45193                          (: 'namespace' 'treat' :)
          or $state[$p:lk] = 46217                          (: 'namespace' 'union' :)
          or $state[$p:lk] = 47753                          (: 'namespace' 'where' :)
          or $state[$p:lk] = 48738                          (: 'document' '{' :)
          or $state[$p:lk] = 48777) then                    (: 'namespace' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Constructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionCall($input, $state)
      return $state
  return $state
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(141, $input, $state)          (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  return $state
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 73) then                           (: 'attribute' :)
      let $state := p:lookahead2W(171, $input, $state)      (: %OTHER | QName^Token | S^WS | EOF | OuterFor | '!=' |
                                                               '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                               '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 19785) then                    (: 'attribute' 'case' :)
          let $state := p:lookahead3W(160, $input, $state)  (: QName^Token | S^WS | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 21065) then               (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(60, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 23369) then               (: 'attribute' 'default' :)
          let $state := p:lookahead3W(95, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 26185) then               (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 28745) then               (: 'attribute' 'for' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 32073) then               (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 37449) then               (: 'attribute' 'only' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 43337) then               (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18249,                    (: 'attribute' 'ascending' :)
                                  24137)) then              (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(124, $input, $state)  (: S^WS | OuterFor | ('(' ':') | ',' | 'collation' |
                                                               'count' | 'empty' | 'for' | 'group' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (22345,                    (: 'attribute' 'count' :)
                                  33865)) then              (: 'attribute' 'let' :)
          let $state := p:lookahead3W(63, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (26953,                    (: 'attribute' 'end' :)
                                  43593)) then              (: 'attribute' 'start' :)
          let $state := p:lookahead3W(114, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (29769,                    (: 'attribute' 'group' :)
                                  38217)) then              (: 'attribute' 'order' :)
          let $state := p:lookahead3W(77, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (20041,                    (: 'attribute' 'cast' :)
                                  20297,                    (: 'attribute' 'castable' :)
                                  45129)) then              (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(75, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (25929,                    (: 'attribute' 'else' :)
                                  41289,                    (: 'attribute' 'return' :)
                                  41545,                    (: 'attribute' 'satisfies' :)
                                  47689)) then              (: 'attribute' 'where' :)
          let $state := p:lookahead3W(168, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = (17737,                    (: 'attribute' 'and' :)
                                  24905,                    (: 'attribute' 'div' :)
                                  27209,                    (: 'attribute' 'eq' :)
                                  27721,                    (: 'attribute' 'except' :)
                                  29257,                    (: 'attribute' 'ge' :)
                                  30281,                    (: 'attribute' 'gt' :)
                                  30537,                    (: 'attribute' 'idiv' :)
                                  32329,                    (: 'attribute' 'intersect' :)
                                  32585,                    (: 'attribute' 'is' :)
                                  33353,                    (: 'attribute' 'le' :)
                                  34121,                    (: 'attribute' 'lt' :)
                                  34633,                    (: 'attribute' 'mod' :)
                                  35657,                    (: 'attribute' 'ne' :)
                                  37961,                    (: 'attribute' 'or' :)
                                  44873,                    (: 'attribute' 'to' :)
                                  46153)) then              (: 'attribute' 'union' :)
          let $state := p:lookahead3W(165, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 100) then                     (: 'element' :)
      let $state := p:lookahead2W(170, $input, $state)      (: %OTHER | QName^Token | S^WS | EOF | OuterFor | '!=' |
                                                               '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                               '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 19812) then                    (: 'element' 'case' :)
          let $state := p:lookahead3W(160, $input, $state)  (: QName^Token | S^WS | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 21092) then               (: 'element' 'collation' :)
          let $state := p:lookahead3W(60, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 23396) then               (: 'element' 'default' :)
          let $state := p:lookahead3W(95, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 26212) then               (: 'element' 'empty' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 28772) then               (: 'element' 'for' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 32100) then               (: 'element' 'instance' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 37476) then               (: 'element' 'only' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 43364) then               (: 'element' 'stable' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18276,                    (: 'element' 'ascending' :)
                                  24164)) then              (: 'element' 'descending' :)
          let $state := p:lookahead3W(124, $input, $state)  (: S^WS | OuterFor | ('(' ':') | ',' | 'collation' |
                                                               'count' | 'empty' | 'for' | 'group' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (22372,                    (: 'element' 'count' :)
                                  33892)) then              (: 'element' 'let' :)
          let $state := p:lookahead3W(63, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (26980,                    (: 'element' 'end' :)
                                  43620)) then              (: 'element' 'start' :)
          let $state := p:lookahead3W(114, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (29796,                    (: 'element' 'group' :)
                                  38244)) then              (: 'element' 'order' :)
          let $state := p:lookahead3W(77, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (20068,                    (: 'element' 'cast' :)
                                  20324,                    (: 'element' 'castable' :)
                                  45156)) then              (: 'element' 'treat' :)
          let $state := p:lookahead3W(75, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (25956,                    (: 'element' 'else' :)
                                  41316,                    (: 'element' 'return' :)
                                  41572,                    (: 'element' 'satisfies' :)
                                  47716)) then              (: 'element' 'where' :)
          let $state := p:lookahead3W(168, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = (17764,                    (: 'element' 'and' :)
                                  24932,                    (: 'element' 'div' :)
                                  27236,                    (: 'element' 'eq' :)
                                  27748,                    (: 'element' 'except' :)
                                  29284,                    (: 'element' 'ge' :)
                                  30308,                    (: 'element' 'gt' :)
                                  30564,                    (: 'element' 'idiv' :)
                                  32356,                    (: 'element' 'intersect' :)
                                  32612,                    (: 'element' 'is' :)
                                  33380,                    (: 'element' 'le' :)
                                  34148,                    (: 'element' 'lt' :)
                                  34660,                    (: 'element' 'mod' :)
                                  35684,                    (: 'element' 'ne' :)
                                  37988,                    (: 'element' 'or' :)
                                  44900,                    (: 'element' 'to' :)
                                  46180)) then              (: 'element' 'union' :)
          let $state := p:lookahead3W(165, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (137,                          (: 'namespace' :)
                              160)) then                    (: 'processing-instruction' :)
      let $state := p:lookahead2W(149, $input, $state)      (: %OTHER | NCName^Token | S^WS | EOF | OuterFor | '!=' |
                                                               '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                               '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = (19849,                         (: 'namespace' 'case' :)
                             19872)) then                   (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(160, $input, $state)  (: QName^Token | S^WS | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = (21129,                    (: 'namespace' 'collation' :)
                                  21152)) then              (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(60, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (23433,                    (: 'namespace' 'default' :)
                                  23456)) then              (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(95, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (26249,                    (: 'namespace' 'empty' :)
                                  26272)) then              (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = (28809,                    (: 'namespace' 'for' :)
                                  28832)) then              (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = (32137,                    (: 'namespace' 'instance' :)
                                  32160)) then              (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = (37513,                    (: 'namespace' 'only' :)
                                  37536)) then              (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = (43401,                    (: 'namespace' 'stable' :)
                                  43424)) then              (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18313,                    (: 'namespace' 'ascending' :)
                                  24201,                    (: 'namespace' 'descending' :)
                                  18336,                    (: 'processing-instruction' 'ascending' :)
                                  24224)) then              (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(124, $input, $state)  (: S^WS | OuterFor | ('(' ':') | ',' | 'collation' |
                                                               'count' | 'empty' | 'for' | 'group' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (22409,                    (: 'namespace' 'count' :)
                                  33929,                    (: 'namespace' 'let' :)
                                  22432,                    (: 'processing-instruction' 'count' :)
                                  33952)) then              (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(63, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (27017,                    (: 'namespace' 'end' :)
                                  43657,                    (: 'namespace' 'start' :)
                                  27040,                    (: 'processing-instruction' 'end' :)
                                  43680)) then              (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(114, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (29833,                    (: 'namespace' 'group' :)
                                  38281,                    (: 'namespace' 'order' :)
                                  29856,                    (: 'processing-instruction' 'group' :)
                                  38304)) then              (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(77, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (20105,                    (: 'namespace' 'cast' :)
                                  20361,                    (: 'namespace' 'castable' :)
                                  45193,                    (: 'namespace' 'treat' :)
                                  20128,                    (: 'processing-instruction' 'cast' :)
                                  20384,                    (: 'processing-instruction' 'castable' :)
                                  45216)) then              (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(75, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (25993,                    (: 'namespace' 'else' :)
                                  41353,                    (: 'namespace' 'return' :)
                                  41609,                    (: 'namespace' 'satisfies' :)
                                  47753,                    (: 'namespace' 'where' :)
                                  26016,                    (: 'processing-instruction' 'else' :)
                                  41376,                    (: 'processing-instruction' 'return' :)
                                  41632,                    (: 'processing-instruction' 'satisfies' :)
                                  47776)) then              (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(168, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = (17801,                    (: 'namespace' 'and' :)
                                  24969,                    (: 'namespace' 'div' :)
                                  27273,                    (: 'namespace' 'eq' :)
                                  27785,                    (: 'namespace' 'except' :)
                                  29321,                    (: 'namespace' 'ge' :)
                                  30345,                    (: 'namespace' 'gt' :)
                                  30601,                    (: 'namespace' 'idiv' :)
                                  32393,                    (: 'namespace' 'intersect' :)
                                  32649,                    (: 'namespace' 'is' :)
                                  33417,                    (: 'namespace' 'le' :)
                                  34185,                    (: 'namespace' 'lt' :)
                                  34697,                    (: 'namespace' 'mod' :)
                                  35721,                    (: 'namespace' 'ne' :)
                                  38025,                    (: 'namespace' 'or' :)
                                  44937,                    (: 'namespace' 'to' :)
                                  46217,                    (: 'namespace' 'union' :)
                                  17824,                    (: 'processing-instruction' 'and' :)
                                  24992,                    (: 'processing-instruction' 'div' :)
                                  27296,                    (: 'processing-instruction' 'eq' :)
                                  27808,                    (: 'processing-instruction' 'except' :)
                                  29344,                    (: 'processing-instruction' 'ge' :)
                                  30368,                    (: 'processing-instruction' 'gt' :)
                                  30624,                    (: 'processing-instruction' 'idiv' :)
                                  32416,                    (: 'processing-instruction' 'intersect' :)
                                  32672,                    (: 'processing-instruction' 'is' :)
                                  33440,                    (: 'processing-instruction' 'le' :)
                                  34208,                    (: 'processing-instruction' 'lt' :)
                                  34720,                    (: 'processing-instruction' 'mod' :)
                                  35744,                    (: 'processing-instruction' 'ne' :)
                                  38048,                    (: 'processing-instruction' 'or' :)
                                  44960,                    (: 'processing-instruction' 'to' :)
                                  46240)) then              (: 'processing-instruction' 'union' :)
          let $state := p:lookahead3W(165, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (83,                           (: 'comment' :)
                              98,                           (: 'document' :)
                              150,                          (: 'ordered' :)
                              173,                          (: 'text' :)
                              181)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(147, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (67,                           (: 'ancestor' :)
                              68,                           (: 'ancestor-or-self' :)
                              81,                           (: 'child' :)
                              92,                           (: 'descendant' :)
                              93,                           (: 'descendant-or-self' :)
                              110,                          (: 'following' :)
                              111,                          (: 'following-sibling' :)
                              152,                          (: 'parent' :)
                              156,                          (: 'preceding' :)
                              157,                          (: 'preceding-sibling' :)
                              166)) then                    (: 'self' :)
      let $state := p:lookahead2W(146, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (19,                           (: QName^Token :)
                              69,                           (: 'and' :)
                              71,                           (: 'ascending' :)
                              77,                           (: 'case' :)
                              78,                           (: 'cast' :)
                              79,                           (: 'castable' :)
                              82,                           (: 'collation' :)
                              87,                           (: 'count' :)
                              90,                           (: 'declare' :)
                              91,                           (: 'default' :)
                              94,                           (: 'descending' :)
                              97,                           (: 'div' :)
                              101,                          (: 'else' :)
                              102,                          (: 'empty' :)
                              105,                          (: 'end' :)
                              106,                          (: 'eq' :)
                              107,                          (: 'every' :)
                              108,                          (: 'except' :)
                              112,                          (: 'for' :)
                              114,                          (: 'ge' :)
                              116,                          (: 'group' :)
                              118,                          (: 'gt' :)
                              119,                          (: 'idiv' :)
                              121,                          (: 'import' :)
                              125,                          (: 'instance' :)
                              126,                          (: 'intersect' :)
                              127,                          (: 'is' :)
                              130,                          (: 'le' :)
                              132,                          (: 'let' :)
                              133,                          (: 'lt' :)
                              135,                          (: 'mod' :)
                              136,                          (: 'module' :)
                              139,                          (: 'ne' :)
                              146,                          (: 'only' :)
                              148,                          (: 'or' :)
                              149,                          (: 'order' :)
                              161,                          (: 'return' :)
                              162,                          (: 'satisfies' :)
                              168,                          (: 'some' :)
                              169,                          (: 'stable' :)
                              170,                          (: 'start' :)
                              175,                          (: 'to' :)
                              176,                          (: 'treat' :)
                              177,                          (: 'try' :)
                              180,                          (: 'union' :)
                              182,                          (: 'validate' :)
                              186,                          (: 'where' :)
                              188)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(142, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7                              (: IntegerLiteral :)
          or $state[$p:lk] = 8                              (: DecimalLiteral :)
          or $state[$p:lk] = 9                              (: DoubleLiteral :)
          or $state[$p:lk] = 10                             (: StringLiteral :)
          or $state[$p:lk] = 29                             (: '$' :)
          or $state[$p:lk] = 31                             (: '(' :)
          or $state[$p:lk] = 42                             (: '.' :)
          or $state[$p:lk] = 51                             (: '<' :)
          or $state[$p:lk] = 52                             (: '<!--' :)
          or $state[$p:lk] = 56                             (: '<?' :)
          or $state[$p:lk] = 4937                           (: 'attribute' QName^Token :)
          or $state[$p:lk] = 4964                           (: 'element' QName^Token :)
          or $state[$p:lk] = 5257                           (: 'namespace' NCName^Token :)
          or $state[$p:lk] = 5280                           (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 7955                           (: QName^Token '(' :)
          or $state[$p:lk] = 8003                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8004                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8005                           (: 'and' '(' :)
          or $state[$p:lk] = 8007                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8013                           (: 'case' '(' :)
          or $state[$p:lk] = 8014                           (: 'cast' '(' :)
          or $state[$p:lk] = 8015                           (: 'castable' '(' :)
          or $state[$p:lk] = 8017                           (: 'child' '(' :)
          or $state[$p:lk] = 8018                           (: 'collation' '(' :)
          or $state[$p:lk] = 8023                           (: 'count' '(' :)
          or $state[$p:lk] = 8026                           (: 'declare' '(' :)
          or $state[$p:lk] = 8027                           (: 'default' '(' :)
          or $state[$p:lk] = 8028                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8029                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8030                           (: 'descending' '(' :)
          or $state[$p:lk] = 8033                           (: 'div' '(' :)
          or $state[$p:lk] = 8034                           (: 'document' '(' :)
          or $state[$p:lk] = 8037                           (: 'else' '(' :)
          or $state[$p:lk] = 8038                           (: 'empty' '(' :)
          or $state[$p:lk] = 8041                           (: 'end' '(' :)
          or $state[$p:lk] = 8042                           (: 'eq' '(' :)
          or $state[$p:lk] = 8043                           (: 'every' '(' :)
          or $state[$p:lk] = 8044                           (: 'except' '(' :)
          or $state[$p:lk] = 8046                           (: 'following' '(' :)
          or $state[$p:lk] = 8047                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8048                           (: 'for' '(' :)
          or $state[$p:lk] = 8050                           (: 'ge' '(' :)
          or $state[$p:lk] = 8052                           (: 'group' '(' :)
          or $state[$p:lk] = 8054                           (: 'gt' '(' :)
          or $state[$p:lk] = 8055                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8057                           (: 'import' '(' :)
          or $state[$p:lk] = 8061                           (: 'instance' '(' :)
          or $state[$p:lk] = 8062                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8063                           (: 'is' '(' :)
          or $state[$p:lk] = 8066                           (: 'le' '(' :)
          or $state[$p:lk] = 8068                           (: 'let' '(' :)
          or $state[$p:lk] = 8069                           (: 'lt' '(' :)
          or $state[$p:lk] = 8071                           (: 'mod' '(' :)
          or $state[$p:lk] = 8072                           (: 'module' '(' :)
          or $state[$p:lk] = 8073                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8075                           (: 'ne' '(' :)
          or $state[$p:lk] = 8082                           (: 'only' '(' :)
          or $state[$p:lk] = 8084                           (: 'or' '(' :)
          or $state[$p:lk] = 8085                           (: 'order' '(' :)
          or $state[$p:lk] = 8086                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8088                           (: 'parent' '(' :)
          or $state[$p:lk] = 8092                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8093                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8097                           (: 'return' '(' :)
          or $state[$p:lk] = 8098                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8102                           (: 'self' '(' :)
          or $state[$p:lk] = 8104                           (: 'some' '(' :)
          or $state[$p:lk] = 8105                           (: 'stable' '(' :)
          or $state[$p:lk] = 8106                           (: 'start' '(' :)
          or $state[$p:lk] = 8111                           (: 'to' '(' :)
          or $state[$p:lk] = 8112                           (: 'treat' '(' :)
          or $state[$p:lk] = 8113                           (: 'try' '(' :)
          or $state[$p:lk] = 8116                           (: 'union' '(' :)
          or $state[$p:lk] = 8117                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8118                           (: 'validate' '(' :)
          or $state[$p:lk] = 8122                           (: 'where' '(' :)
          or $state[$p:lk] = 8124                           (: 'xquery' '(' :)
          or $state[$p:lk] = 17225                          (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 17252                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 17481                          (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 17508                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 18761                          (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 18788                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 20809                          (: 'attribute' 'child' :)
          or $state[$p:lk] = 20836                          (: 'element' 'child' :)
          or $state[$p:lk] = 21321                          (: 'attribute' 'comment' :)
          or $state[$p:lk] = 21348                          (: 'element' 'comment' :)
          or $state[$p:lk] = 23113                          (: 'attribute' 'declare' :)
          or $state[$p:lk] = 23140                          (: 'element' 'declare' :)
          or $state[$p:lk] = 23625                          (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 23652                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 23881                          (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 23908                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 25161                          (: 'attribute' 'document' :)
          or $state[$p:lk] = 25188                          (: 'element' 'document' :)
          or $state[$p:lk] = 25417                          (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 25444                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 25673                          (: 'attribute' 'element' :)
          or $state[$p:lk] = 25700                          (: 'element' 'element' :)
          or $state[$p:lk] = 26441                          (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 26468                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 27465                          (: 'attribute' 'every' :)
          or $state[$p:lk] = 27492                          (: 'element' 'every' :)
          or $state[$p:lk] = 28233                          (: 'attribute' 'following' :)
          or $state[$p:lk] = 28260                          (: 'element' 'following' :)
          or $state[$p:lk] = 28489                          (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 28516                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 30793                          (: 'attribute' 'if' :)
          or $state[$p:lk] = 30820                          (: 'element' 'if' :)
          or $state[$p:lk] = 31049                          (: 'attribute' 'import' :)
          or $state[$p:lk] = 31076                          (: 'element' 'import' :)
          or $state[$p:lk] = 32841                          (: 'attribute' 'item' :)
          or $state[$p:lk] = 32868                          (: 'element' 'item' :)
          or $state[$p:lk] = 34889                          (: 'attribute' 'module' :)
          or $state[$p:lk] = 34916                          (: 'element' 'module' :)
          or $state[$p:lk] = 35145                          (: 'attribute' 'namespace' :)
          or $state[$p:lk] = 35172                          (: 'element' 'namespace' :)
          or $state[$p:lk] = 36681                          (: 'attribute' 'node' :)
          or $state[$p:lk] = 36708                          (: 'element' 'node' :)
          or $state[$p:lk] = 38473                          (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 38500                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 38985                          (: 'attribute' 'parent' :)
          or $state[$p:lk] = 39012                          (: 'element' 'parent' :)
          or $state[$p:lk] = 40009                          (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 40036                          (: 'element' 'preceding' :)
          or $state[$p:lk] = 40265                          (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 40292                          (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 41033                          (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 41060                          (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 42057                          (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 42084                          (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 42313                          (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 42340                          (: 'element' 'schema-element' :)
          or $state[$p:lk] = 42569                          (: 'attribute' 'self' :)
          or $state[$p:lk] = 42596                          (: 'element' 'self' :)
          or $state[$p:lk] = 43081                          (: 'attribute' 'some' :)
          or $state[$p:lk] = 43108                          (: 'element' 'some' :)
          or $state[$p:lk] = 44361                          (: 'attribute' 'text' :)
          or $state[$p:lk] = 44388                          (: 'element' 'text' :)
          or $state[$p:lk] = 45385                          (: 'attribute' 'try' :)
          or $state[$p:lk] = 45412                          (: 'element' 'try' :)
          or $state[$p:lk] = 45897                          (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 45924                          (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 46409                          (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 46436                          (: 'element' 'unordered' :)
          or $state[$p:lk] = 46665                          (: 'attribute' 'validate' :)
          or $state[$p:lk] = 46692                          (: 'element' 'validate' :)
          or $state[$p:lk] = 48201                          (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 48228                          (: 'element' 'xquery' :)
          or $state[$p:lk] = 48713                          (: 'attribute' '{' :)
          or $state[$p:lk] = 48723                          (: 'comment' '{' :)
          or $state[$p:lk] = 48738                          (: 'document' '{' :)
          or $state[$p:lk] = 48740                          (: 'element' '{' :)
          or $state[$p:lk] = 48777                          (: 'namespace' '{' :)
          or $state[$p:lk] = 48790                          (: 'ordered' '{' :)
          or $state[$p:lk] = 48800                          (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 48813                          (: 'text' '{' :)
          or $state[$p:lk] = 48821                          (: 'unordered' '{' :)
          or $state[$p:lk] = 12469577                       (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 12469604                       (: 'element' 'and' '{' :)
          or $state[$p:lk] = 12469641                       (: 'namespace' 'and' '{' :)
          or $state[$p:lk] = 12469664                       (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 12470089                       (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 12470116                       (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 12470153                       (: 'namespace' 'ascending' '{' :)
          or $state[$p:lk] = 12470176                       (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 12471625                       (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 12471652                       (: 'element' 'case' '{' :)
          or $state[$p:lk] = 12471689                       (: 'namespace' 'case' '{' :)
          or $state[$p:lk] = 12471712                       (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 12471881                       (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 12471908                       (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 12471945                       (: 'namespace' 'cast' '{' :)
          or $state[$p:lk] = 12471968                       (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 12472137                       (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 12472164                       (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 12472201                       (: 'namespace' 'castable' '{' :)
          or $state[$p:lk] = 12472224                       (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 12472905                       (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 12472932                       (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 12472969                       (: 'namespace' 'collation' '{' :)
          or $state[$p:lk] = 12472992                       (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 12474185                       (: 'attribute' 'count' '{' :)
          or $state[$p:lk] = 12474212                       (: 'element' 'count' '{' :)
          or $state[$p:lk] = 12474249                       (: 'namespace' 'count' '{' :)
          or $state[$p:lk] = 12474272                       (: 'processing-instruction' 'count' '{' :)
          or $state[$p:lk] = 12475209                       (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 12475236                       (: 'element' 'default' '{' :)
          or $state[$p:lk] = 12475273                       (: 'namespace' 'default' '{' :)
          or $state[$p:lk] = 12475296                       (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 12475977                       (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 12476004                       (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 12476041                       (: 'namespace' 'descending' '{' :)
          or $state[$p:lk] = 12476064                       (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 12476745                       (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 12476772                       (: 'element' 'div' '{' :)
          or $state[$p:lk] = 12476809                       (: 'namespace' 'div' '{' :)
          or $state[$p:lk] = 12476832                       (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 12477769                       (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 12477796                       (: 'element' 'else' '{' :)
          or $state[$p:lk] = 12477833                       (: 'namespace' 'else' '{' :)
          or $state[$p:lk] = 12477856                       (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 12478025                       (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 12478052                       (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 12478089                       (: 'namespace' 'empty' '{' :)
          or $state[$p:lk] = 12478112                       (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 12478793                       (: 'attribute' 'end' '{' :)
          or $state[$p:lk] = 12478820                       (: 'element' 'end' '{' :)
          or $state[$p:lk] = 12478857                       (: 'namespace' 'end' '{' :)
          or $state[$p:lk] = 12478880                       (: 'processing-instruction' 'end' '{' :)
          or $state[$p:lk] = 12479049                       (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 12479076                       (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 12479113                       (: 'namespace' 'eq' '{' :)
          or $state[$p:lk] = 12479136                       (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 12479561                       (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 12479588                       (: 'element' 'except' '{' :)
          or $state[$p:lk] = 12479625                       (: 'namespace' 'except' '{' :)
          or $state[$p:lk] = 12479648                       (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 12480585                       (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 12480612                       (: 'element' 'for' '{' :)
          or $state[$p:lk] = 12480649                       (: 'namespace' 'for' '{' :)
          or $state[$p:lk] = 12480672                       (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 12481097                       (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 12481124                       (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 12481161                       (: 'namespace' 'ge' '{' :)
          or $state[$p:lk] = 12481184                       (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 12481609                       (: 'attribute' 'group' '{' :)
          or $state[$p:lk] = 12481636                       (: 'element' 'group' '{' :)
          or $state[$p:lk] = 12481673                       (: 'namespace' 'group' '{' :)
          or $state[$p:lk] = 12481696                       (: 'processing-instruction' 'group' '{' :)
          or $state[$p:lk] = 12482121                       (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 12482148                       (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 12482185                       (: 'namespace' 'gt' '{' :)
          or $state[$p:lk] = 12482208                       (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 12482377                       (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 12482404                       (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 12482441                       (: 'namespace' 'idiv' '{' :)
          or $state[$p:lk] = 12482464                       (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 12483913                       (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 12483940                       (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 12483977                       (: 'namespace' 'instance' '{' :)
          or $state[$p:lk] = 12484000                       (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 12484169                       (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 12484196                       (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 12484233                       (: 'namespace' 'intersect' '{' :)
          or $state[$p:lk] = 12484256                       (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 12484425                       (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 12484452                       (: 'element' 'is' '{' :)
          or $state[$p:lk] = 12484489                       (: 'namespace' 'is' '{' :)
          or $state[$p:lk] = 12484512                       (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 12485193                       (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 12485220                       (: 'element' 'le' '{' :)
          or $state[$p:lk] = 12485257                       (: 'namespace' 'le' '{' :)
          or $state[$p:lk] = 12485280                       (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 12485705                       (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 12485732                       (: 'element' 'let' '{' :)
          or $state[$p:lk] = 12485769                       (: 'namespace' 'let' '{' :)
          or $state[$p:lk] = 12485792                       (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 12485961                       (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 12485988                       (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 12486025                       (: 'namespace' 'lt' '{' :)
          or $state[$p:lk] = 12486048                       (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 12486473                       (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 12486500                       (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 12486537                       (: 'namespace' 'mod' '{' :)
          or $state[$p:lk] = 12486560                       (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 12487497                       (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 12487524                       (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 12487561                       (: 'namespace' 'ne' '{' :)
          or $state[$p:lk] = 12487584                       (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 12489289                       (: 'attribute' 'only' '{' :)
          or $state[$p:lk] = 12489316                       (: 'element' 'only' '{' :)
          or $state[$p:lk] = 12489353                       (: 'namespace' 'only' '{' :)
          or $state[$p:lk] = 12489376                       (: 'processing-instruction' 'only' '{' :)
          or $state[$p:lk] = 12489801                       (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 12489828                       (: 'element' 'or' '{' :)
          or $state[$p:lk] = 12489865                       (: 'namespace' 'or' '{' :)
          or $state[$p:lk] = 12489888                       (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 12490057                       (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 12490084                       (: 'element' 'order' '{' :)
          or $state[$p:lk] = 12490121                       (: 'namespace' 'order' '{' :)
          or $state[$p:lk] = 12490144                       (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 12493129                       (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 12493156                       (: 'element' 'return' '{' :)
          or $state[$p:lk] = 12493193                       (: 'namespace' 'return' '{' :)
          or $state[$p:lk] = 12493216                       (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 12493385                       (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 12493412                       (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 12493449                       (: 'namespace' 'satisfies' '{' :)
          or $state[$p:lk] = 12493472                       (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 12495177                       (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 12495204                       (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 12495241                       (: 'namespace' 'stable' '{' :)
          or $state[$p:lk] = 12495264                       (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 12495433                       (: 'attribute' 'start' '{' :)
          or $state[$p:lk] = 12495460                       (: 'element' 'start' '{' :)
          or $state[$p:lk] = 12495497                       (: 'namespace' 'start' '{' :)
          or $state[$p:lk] = 12495520                       (: 'processing-instruction' 'start' '{' :)
          or $state[$p:lk] = 12496713                       (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 12496740                       (: 'element' 'to' '{' :)
          or $state[$p:lk] = 12496777                       (: 'namespace' 'to' '{' :)
          or $state[$p:lk] = 12496800                       (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 12496969                       (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 12496996                       (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 12497033                       (: 'namespace' 'treat' '{' :)
          or $state[$p:lk] = 12497056                       (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 12497993                       (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 12498020                       (: 'element' 'union' '{' :)
          or $state[$p:lk] = 12498057                       (: 'namespace' 'union' '{' :)
          or $state[$p:lk] = 12498080                       (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 12499529                       (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 12499556                       (: 'element' 'where' '{' :)
          or $state[$p:lk] = 12499593                       (: 'namespace' 'where' '{' :)
          or $state[$p:lk] = 12499616) then                 (: 'processing-instruction' 'where' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FilterExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 44                                 (: '/' :)
    and $state[$p:l1] != 45) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 44) then                   (: '/' :)
          let $state := p:consume(44, $input, $state)       (: '/' :)
          return $state
        else
          let $state := p:consume(45, $input, $state)       (: '//' :)
          return $state
      let $state := p:lookahead1W(162, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | ('(' ':') | '.' | '..' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '/' :)
      let $state := p:consume(44, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(172, $input, $state)      (: %OTHER | Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               EOF | OuterFor | '!=' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 1                          (: %OTHER :)
              or $state[$p:l1] = 24                         (: EOF :)
              or $state[$p:l1] = 25                         (: OuterFor :)
              or $state[$p:l1] = 26                         (: '!=' :)
              or $state[$p:l1] = 34                         (: ')' :)
              or $state[$p:l1] = 35                         (: '*' :)
              or $state[$p:l1] = 37                         (: '+' :)
              or $state[$p:l1] = 39                         (: ',' :)
              or $state[$p:l1] = 40                         (: '-' :)
              or $state[$p:l1] = 50                         (: ';' :)
              or $state[$p:l1] = 54                         (: '<<' :)
              or $state[$p:l1] = 55                         (: '<=' :)
              or $state[$p:l1] = 57                         (: '=' :)
              or $state[$p:l1] = 58                         (: '>' :)
              or $state[$p:l1] = 59                         (: '>=' :)
              or $state[$p:l1] = 60                         (: '>>' :)
              or $state[$p:l1] = 66                         (: ']' :)
              or $state[$p:l1] = 192                        (: '|' :)
              or $state[$p:l1] = 193) then                  (: '}' :)
          $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 45) then                       (: '//' :)
      let $state := p:consume(45, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(162, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | ('(' ':') | '.' | '..' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'lax' :)
      let $state := p:consume(129, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(171, $input, $state)          (: 'strict' :)
      return $state
  return $state
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(182, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 190) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: 'as' :)
          let $state := p:consume(70, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(155, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 182) then                          (: 'validate' :)
      let $state := p:lookahead2W(152, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'lax' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'strict' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18102                          (: 'validate' 'as' :)
          or $state[$p:lk] = 33206                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 43958                          (: 'validate' 'strict' :)
          or $state[$p:lk] = 48822) then                    (: 'validate' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 32) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(163, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 37                               (: '+' :)
      and $state[$p:l1] != 40) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 40) then                 (: '-' :)
            let $state := p:consume(40, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(37, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ValueExpr($input, $state)
  return $state
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(140, $input, $state)          (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'cast' :)
      let $state := p:consume(78, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(138, $input, $state)          (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | ']' | 'and' | 'ascending' | 'case' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 79) then                       (: 'castable' :)
      let $state := p:consume(79, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(137, $input, $state)          (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | ']' | 'and' | 'ascending' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 176) then                      (: 'treat' :)
      let $state := p:consume(176, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(136, $input, $state)          (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | ']' | 'and' | 'ascending' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 125) then                      (: 'instance' :)
      let $state := p:consume(125, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(145, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | ']' | 'and' | 'ascending' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 108                              (: 'except' :)
      and $state[$p:l1] != 126) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 126) then                (: 'intersect' :)
            let $state := p:consume(126, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(108, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(163, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 180                                (: 'union' :)
    and $state[$p:l1] != 192) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 180) then                  (: 'union' :)
          let $state := p:consume(180, $input, $state)      (: 'union' :)
          return $state
        else
          let $state := p:consume(192, $input, $state)      (: '|' :)
          return $state
      let $state := p:lookahead1W(163, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 35                                 (: '*' :)
    and $state[$p:l1] != 97                                 (: 'div' :)
    and $state[$p:l1] != 119                                (: 'idiv' :)
    and $state[$p:l1] != 135) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: '*' :)
          let $state := p:consume(35, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 97) then                   (: 'div' :)
          let $state := p:consume(97, $input, $state)       (: 'div' :)
          return $state
        else if ($state[$p:l1] = 119) then                  (: 'idiv' :)
          let $state := p:consume(119, $input, $state)      (: 'idiv' :)
          return $state
        else
          let $state := p:consume(135, $input, $state)      (: 'mod' :)
          return $state
      let $state := p:lookahead1W(163, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37                                 (: '+' :)
    and $state[$p:l1] != 40) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: '+' :)
          let $state := p:consume(37, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(40, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(163, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 175) then                      (: 'to' :)
      let $state := p:consume(175, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(163, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-RangeExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26                             (: '!=' :)
          or $state[$p:l1] = 51                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<<' :)
          or $state[$p:l1] = 55                             (: '<=' :)
          or $state[$p:l1] = 57                             (: '=' :)
          or $state[$p:l1] = 58                             (: '>' :)
          or $state[$p:l1] = 59                             (: '>=' :)
          or $state[$p:l1] = 60                             (: '>>' :)
          or $state[$p:l1] = 106                            (: 'eq' :)
          or $state[$p:l1] = 114                            (: 'ge' :)
          or $state[$p:l1] = 118                            (: 'gt' :)
          or $state[$p:l1] = 127                            (: 'is' :)
          or $state[$p:l1] = 130                            (: 'le' :)
          or $state[$p:l1] = 133                            (: 'lt' :)
          or $state[$p:l1] = 139) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 106                        (: 'eq' :)
              or $state[$p:l1] = 114                        (: 'ge' :)
              or $state[$p:l1] = 118                        (: 'gt' :)
              or $state[$p:l1] = 130                        (: 'le' :)
              or $state[$p:l1] = 133                        (: 'lt' :)
              or $state[$p:l1] = 139) then                  (: 'ne' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 54                         (: '<<' :)
              or $state[$p:l1] = 60                         (: '>>' :)
              or $state[$p:l1] = 127) then                  (: 'is' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeComp($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(163, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 69) then                           (: 'and' :)
      $state
    else
      let $state := p:consume(69, $input, $state)           (: 'and' :)
      let $state := p:lookahead1W(163, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 148) then                          (: 'or' :)
      $state
    else
      let $state := p:consume(148, $input, $state)          (: 'or' :)
      let $state := p:lookahead1W(163, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return $state
};

(:~
 : Parse CatchErrorVal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorVal($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse CatchErrorDesc.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorDesc($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse CatchErrorCode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorCode($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse CatchVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchVars($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CatchErrorCode($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39) then                       (: ',' :)
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(18, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CatchErrorDesc($input, $state)
      let $state := p:lookahead1W(66, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:consume(39, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(18, $input, $state)   (: S^WS | '$' | ('(' ':') :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-CatchErrorVal($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: Wildcard :)
      let $state := p:consume(3, $input, $state)            (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(97, $input, $state)         (: S^WS | '(' | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 192) then                        (: '|' :)
        $state
      else
        let $state := p:consume(192, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(156, $input, $state)    (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(80, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(156, $input, $state)          (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CatchErrorList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CatchVars($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(177, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(190, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TryTargetExpr($input, $state)
  let $state := p:consume(193, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(125, $input, $state)        (: %OTHER | S^WS | EOF | OuterFor | ('(' ':') | ')' | ',' |
                                                               ';' | ']' | 'ascending' | 'case' | 'catch' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'else' | 'empty' | 'end' | 'for' | 'group' | 'let' |
                                                               'only' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 80) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(174, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:consume(101, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(77, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(158, $input, $state)          (: QName^Token | S^WS | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(161, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 77) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(179, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(91, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(161, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(18, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(74, $input, $state)       (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:consume(122, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 168) then                      (: 'some' :)
      let $state := p:consume(168, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(107, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(122, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(162, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(161, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(87, $input, $state)               (: 'count' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71                             (: 'ascending' :)
          or $state[$p:l1] = 94) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 71) then                   (: 'ascending' :)
          let $state := p:consume(71, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(94, $input, $state)       (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | OuterFor | ('(' ':') | ',' | 'collation' |
                                                               'count' | 'empty' | 'for' | 'group' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 102) then                      (: 'empty' :)
      let $state := p:consume(102, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(83, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 115) then                  (: 'greatest' :)
          let $state := p:consume(115, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(131, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | OuterFor | ('(' ':') | ',' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 82) then                       (: 'collation' :)
      let $state := p:consume(82, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderModifier($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(120, $input, $state)        (: S^WS | OuterFor | ('(' ':') | ',' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(164, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 149) then                      (: 'order' :)
      let $state := p:consume(149, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(76, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(169, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(49, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(149, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(76, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpecList($input, $state)
  return $state
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | OuterFor | ('(' ':') | ',' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 82) then                       (: 'collation' :)
      let $state := p:consume(82, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(120, $input, $state)        (: S^WS | OuterFor | ('(' ':') | ',' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(18, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(116, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(76, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(186, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 186) then                      (: 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'group' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 149                            (: 'order' :)
          or $state[$p:l1] = 169) then                      (: 'stable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'count' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CountClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InitialClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(167, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(187, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(122, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 146) then                      (: 'only' :)
      let $state := p:consume(146, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(105, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(185, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  return $state
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  return $state
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  return $state
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'previous' :)
      let $state := p:consume(159, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(18, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 140) then                      (: 'next' :)
      let $state := p:consume(140, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(18, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(170, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(185, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(178, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(187, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(122, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105                            (: 'end' :)
          or $state[$p:l1] = 146) then                      (: 'only' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(112, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(92, $input, $state)           (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 178) then                      (: 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TumblingWindowClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(18, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(70, $input, $state)       (: S^WS | ('(' ':') | ':=' | 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:consume(49, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(132, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(49, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return $state
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(72, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(18, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(101, $input, $state)      (: S^WS | ('(' ':') | 'as' | 'at' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | 'at' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 72) then                   (: 'at' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-PositionalVar($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:consume(122, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: OuterFor :)
      let $state := p:consume(25, $input, $state)           (: OuterFor :)
      return $state
    else
      let $state := p:consume(112, $input, $state)          (: 'for' :)
      return $state
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(122, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return $state
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 112) then                          (: 'for' :)
      let $state := p:lookahead2W(96, $input, $state)       (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 25                             (: OuterFor :)
          or $state[$p:lk] = 7536) then                     (: 'for' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 132) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LetClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(119, $input, $state)        (: S^WS | OuterFor | ('(' ':') | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 161) then                         (: 'return' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ReturnClause($input, $state)
  return $state
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 112) then                          (: 'for' :)
      let $state := p:lookahead2W(151, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '$' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'sliding' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'tumbling' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] eq 177) then                     (: 'try' :)
      let $state := p:lookahead2W(147, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (120,                          (: 'if' :)
                              179)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(142, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (107,                          (: 'every' :)
                              132,                          (: 'let' :)
                              168)) then                    (: 'some' :)
      let $state := p:lookahead2W(145, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '$' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 25                             (: OuterFor :)
          or $state[$p:lk] = 7536                           (: 'for' '$' :)
          or $state[$p:lk] = 7556                           (: 'let' '$' :)
          or $state[$p:lk] = 42864                          (: 'for' 'sliding' :)
          or $state[$p:lk] = 45680) then                    (: 'for' 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7531                           (: 'every' '$' :)
          or $state[$p:lk] = 7592) then                     (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8115) then                     (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8056) then                     (: 'if' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 48817) then                    (: 'try' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TryCatchExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 61) then                       (: '?' :)
      let $state := p:consume(61, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: '*' :)
      let $state := p:consume(36, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(38, $input, $state)           (: '+' :)
      return $state
  return $state
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  return $state
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(143, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(173, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(83, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(160, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(131, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 10) then                   (: StringLiteral :)
          let $state := p:consume(10, $input, $state)       (: StringLiteral :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeName($input, $state)
  return $state
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(164, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  return $state
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:consume(35, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(73, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(161, $input, $state)          (: QName^Token | S^WS | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(66, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:consume(39, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(155, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementName($input, $state)
  return $state
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(165, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  return $state
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  return $state
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:consume(35, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(100, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(161, $input, $state)          (: QName^Token | S^WS | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(66, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:consume(39, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(155, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(67, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 61) then               (: '?' :)
              let $state := p:consume(61, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(99, $input, $state)               (: 'document-node' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 100) then                  (: 'element' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 99) then                       (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TextTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyKindTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (73,                                (: 'attribute' :)
                         83,                                (: 'comment' :)
                         99,                                (: 'document-node' :)
                         100,                               (: 'element' :)
                         128,                               (: 'item' :)
                         143,                               (: 'node' :)
                         160,                               (: 'processing-instruction' :)
                         164,                               (: 'schema-attribute' :)
                         165,                               (: 'schema-element' :)
                         173)) then                         (: 'text' :)
      let $state := p:lookahead2W(150, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '*' | '+' | '+' | ',' | '-' | ':=' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' |
                                                               'and' | 'ascending' | 'at' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8009                           (: 'attribute' '(' :)
          or $state[$p:lk] = 8019                           (: 'comment' '(' :)
          or $state[$p:lk] = 8035                           (: 'document-node' '(' :)
          or $state[$p:lk] = 8036                           (: 'element' '(' :)
          or $state[$p:lk] = 8079                           (: 'node' '(' :)
          or $state[$p:lk] = 8096                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 8100                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 8101                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 8109) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8064) then                     (: 'item' '(' :)
      let $state := p:consume(128, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(19, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(34, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AtomicType($input, $state)
      return $state
  return $state
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 103) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(150, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '*' | '+' | '+' | ',' | '-' | ':=' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' |
                                                               'and' | 'ascending' | 'at' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8039) then                     (: 'empty-sequence' '(' :)
      let $state := p:consume(103, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(19, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(34, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(148, $input, $state)      (: %OTHER | S^WS | EOF | OuterFor | '!=' | ('(' ':') | ')' |
                                                               '*' | '*' | '+' | '+' | ',' | '-' | ':=' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' |
                                                               'and' | 'ascending' | 'at' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 36                         (: '*' :)
              or $state[$p:l1] = 38                         (: '+' :)
              or $state[$p:l1] = 61) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(70, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'variable' :)
  let $state := p:consume(183, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(155, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: ':=' :)
      let $state := p:consume(49, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(109, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 49) then                   (: ':=' :)
          let $state := p:consume(49, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(164, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(68, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(15, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(121, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:consume(136, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(59, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace' :)
      let $state := p:consume(137, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(127, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(57, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'at' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace' :)
      let $state := p:consume(137, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(127, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(57, $input, $state)           (: '=' :)
      return $state
    else
      let $state := p:consume(91, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(38, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:consume(100, $input, $state)          (: 'element' :)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:consume(137, $input, $state)          (: 'namespace' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(68, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(15, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(121, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:consume(163, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(93, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 10) then                      (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'at' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 121) then                          (: 'import' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 41849) then                    (: 'import' 'schema' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaImport($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ModuleImport($input, $state)
      return $state
  return $state
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(137, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(127, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(57, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 89) then                       (: 'decimal-separator' :)
      let $state := p:consume(89, $input, $state)           (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'grouping-separator' :)
      let $state := p:consume(117, $input, $state)          (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'infinity' :)
      let $state := p:consume(123, $input, $state)          (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'minus-sign' :)
      let $state := p:consume(134, $input, $state)          (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 64) then                       (: 'NaN' :)
      let $state := p:consume(64, $input, $state)           (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'percent' :)
      let $state := p:consume(155, $input, $state)          (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'per-mille' :)
      let $state := p:consume(154, $input, $state)          (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'zero-digit' :)
      let $state := p:consume(189, $input, $state)          (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'digit' :)
      let $state := p:consume(96, $input, $state)           (: 'digit' :)
      return $state
    else
      let $state := p:consume(153, $input, $state)          (: 'pattern-separator' :)
      return $state
  return $state
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: 'ancestor' :)
      let $state := p:consume(67, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(68, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'and' :)
      let $state := p:consume(69, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ascending' :)
      let $state := p:consume(71, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'case' :)
      let $state := p:consume(77, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'cast' :)
      let $state := p:consume(78, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'castable' :)
      let $state := p:consume(79, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'child' :)
      let $state := p:consume(81, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'collation' :)
      let $state := p:consume(82, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'count' :)
      let $state := p:consume(87, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'declare' :)
      let $state := p:consume(90, $input, $state)           (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'default' :)
      let $state := p:consume(91, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant' :)
      let $state := p:consume(92, $input, $state)           (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descendant-or-self' :)
      let $state := p:consume(93, $input, $state)           (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'descending' :)
      let $state := p:consume(94, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'div' :)
      let $state := p:consume(97, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'document' :)
      let $state := p:consume(98, $input, $state)           (: 'document' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'else' :)
      let $state := p:consume(101, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'empty' :)
      let $state := p:consume(102, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'end' :)
      let $state := p:consume(105, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'eq' :)
      let $state := p:consume(106, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'every' :)
      let $state := p:consume(107, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'except' :)
      let $state := p:consume(108, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'following' :)
      let $state := p:consume(110, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'following-sibling' :)
      let $state := p:consume(111, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'for' :)
      let $state := p:consume(112, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'ge' :)
      let $state := p:consume(114, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'group' :)
      let $state := p:consume(116, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'gt' :)
      let $state := p:consume(118, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'idiv' :)
      let $state := p:consume(119, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'import' :)
      let $state := p:consume(121, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'instance' :)
      let $state := p:consume(125, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'intersect' :)
      let $state := p:consume(126, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'is' :)
      let $state := p:consume(127, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'le' :)
      let $state := p:consume(130, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'let' :)
      let $state := p:consume(132, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'lt' :)
      let $state := p:consume(133, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'mod' :)
      let $state := p:consume(135, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'module' :)
      let $state := p:consume(136, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace' :)
      let $state := p:consume(137, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ne' :)
      let $state := p:consume(139, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'only' :)
      let $state := p:consume(146, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'or' :)
      let $state := p:consume(148, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'order' :)
      let $state := p:consume(149, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'ordered' :)
      let $state := p:consume(150, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'parent' :)
      let $state := p:consume(152, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'preceding' :)
      let $state := p:consume(156, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'preceding-sibling' :)
      let $state := p:consume(157, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'return' :)
      let $state := p:consume(161, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'satisfies' :)
      let $state := p:consume(162, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'self' :)
      let $state := p:consume(166, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'some' :)
      let $state := p:consume(168, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'stable' :)
      let $state := p:consume(169, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'start' :)
      let $state := p:consume(170, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'to' :)
      let $state := p:consume(175, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'treat' :)
      let $state := p:consume(176, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'try' :)
      let $state := p:consume(177, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'union' :)
      let $state := p:consume(180, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'unordered' :)
      let $state := p:consume(181, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'validate' :)
      let $state := p:consume(182, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'where' :)
      let $state := p:consume(186, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'xquery' :)
      let $state := p:consume(188, $input, $state)          (: 'xquery' :)
      return $state
    else
      let $state := p:consume(19, $input, $state)           (: QName^Token :)
      return $state
  return $state
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(153, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'attribute' :)
      let $state := p:consume(73, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'comment' :)
      let $state := p:consume(83, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'document-node' :)
      let $state := p:consume(99, $input, $state)           (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'element' :)
      let $state := p:consume(100, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'empty-sequence' :)
      let $state := p:consume(103, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'if' :)
      let $state := p:consume(120, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'item' :)
      let $state := p:consume(128, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'node' :)
      let $state := p:consume(143, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'processing-instruction' :)
      let $state := p:consume(160, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'schema-attribute' :)
      let $state := p:consume(164, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'schema-element' :)
      let $state := p:consume(165, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'text' :)
      let $state := p:consume(173, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'typeswitch' :)
      let $state := p:consume(179, $input, $state)          (: 'typeswitch' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(122, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'grouping-separator' | 'infinity' |
                                                               'minus-sign' | 'pattern-separator' | 'per-mille' |
                                                               'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 50) then                          (: ';' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(25, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:consume(57, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(15, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(10, $input, $state)         (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'decimal-format' :)
      let $state := p:consume(88, $input, $state)           (: 'decimal-format' :)
      let $state := p:lookahead1W(155, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
    else
      let $state := p:consume(91, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:consume(88, $input, $state)           (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  return $state
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 124) then                      (: 'inherit' :)
      let $state := p:consume(124, $input, $state)          (: 'inherit' :)
      return $state
    else
      let $state := p:consume(141, $input, $state)          (: 'no-inherit' :)
      return $state
  return $state
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 158) then                      (: 'preserve' :)
      let $state := p:consume(158, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(142, $input, $state)          (: 'no-preserve' :)
      return $state
  return $state
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(86, $input, $state)               (: 'copy-namespaces' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(39, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InheritMode($input, $state)
  return $state
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(91, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(149, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(102, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 115) then                      (: 'greatest' :)
      let $state := p:consume(115, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(131, $input, $state)          (: 'least' :)
      return $state
  return $state
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:consume(151, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 150) then                      (: 'ordered' :)
      let $state := p:consume(150, $input, $state)          (: 'ordered' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'unordered' :)
      return $state
  return $state
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:consume(84, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(91, $input, $state)           (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 172) then                      (: 'strip' :)
      let $state := p:consume(172, $input, $state)          (: 'strip' :)
      return $state
    else
      let $state := p:consume(158, $input, $state)          (: 'preserve' :)
      return $state
  return $state
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:consume(74, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(91, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(82, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(75, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(91, $input, $state)           (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 158) then                      (: 'preserve' :)
      let $state := p:consume(158, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(172, $input, $state)          (: 'strip' :)
      return $state
  return $state
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 90) then                           (: 'declare' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' :)
      let $state :=
        if ($state[$p:lk] eq 23386) then                    (: 'declare' 'default' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 19290) then                    (: 'declare' 'boundary-space' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5397338) then                  (: 'declare' 'default' 'collation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 19034) then                    (: 'declare' 'base-uri' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 21594) then                    (: 'declare' 'construction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 38746) then                    (: 'declare' 'ordering' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 9788250) then                  (: 'declare' 'default' 'order' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 22106) then                    (: 'declare' 'copy-namespaces' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DecimalFormatDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(91, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 100) then                      (: 'element' :)
      let $state := p:consume(100, $input, $state)          (: 'element' :)
      return $state
    else
      let $state := p:consume(113, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(137, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(166, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               EOF | OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 90) then                         (: 'declare' :)
        let $state := p:lookahead2W(134, $input, $state)    (: S^WS | EOF | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'base-uri' | 'boundary-space' |
                                                               'cast' | 'castable' | 'construction' | 'context' |
                                                               'copy-namespaces' | 'decimal-format' | 'default' |
                                                               'deterministic' | 'div' | 'eq' | 'except' | 'function' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' |
                                                               'nondeterministic' | 'option' | 'or' | 'ordering' |
                                                               'to' | 'treat' | 'union' | 'variable' | '|' :)
        return $state
      else if ($state[$p:l1] eq 121) then                   (: 'import' :)
        let $state := p:lookahead2W(129, $input, $state)    (: S^WS | EOF | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'or' | 'schema' | 'to' | 'treat' | 'union' | '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 19034                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 19290                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 21594                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 22106                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 22618                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 23386                            (: 'declare' 'default' :)
      and $state[$p:lk] != 34937                            (: 'import' 'module' :)
      and $state[$p:lk] != 35162                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 38746                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 41849) then                      (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 90) then                     (: 'declare' :)
            let $state := p:lookahead2W(117, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'namespace' | 'ordering' :)
            let $state :=
              if ($state[$p:lk] eq 23386) then              (: 'declare' 'default' :)
                let $state := p:lookahead3W(111, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 6576986                  (: 'declare' 'default' 'element' :)
                or $state[$p:lk] = 7428954) then            (: 'declare' 'default' 'function' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 35162) then              (: 'declare' 'namespace' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 121) then                (: 'import' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Import($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(166, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               EOF | OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 90) then                         (: 'declare' :)
        let $state := p:lookahead2W(133, $input, $state)    (: S^WS | EOF | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'context' |
                                                               'deterministic' | 'div' | 'eq' | 'except' | 'function' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'nondeterministic' |
                                                               'option' | 'or' | 'to' | 'treat' | 'union' | 'variable' |
                                                               '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 21850                            (: 'declare' 'context' :)
      and $state[$p:lk] != 24410                            (: 'declare' 'deterministic' :)
      and $state[$p:lk] != 29018                            (: 'declare' 'function' :)
      and $state[$p:lk] != 36954                            (: 'declare' 'nondeterministic' :)
      and $state[$p:lk] != 37722                            (: 'declare' 'option' :)
      and $state[$p:lk] != 46938) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 90) then                     (: 'declare' :)
            let $state := p:lookahead2W(115, $input, $state) (: S^WS | ('(' ':') | 'context' | 'deterministic' |
                                                                'function' | 'nondeterministic' | 'option' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 46938) then              (: 'declare' 'variable' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 21850) then              (: 'declare' 'context' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 37722) then              (: 'declare' 'option' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-OptionDecl($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-FunctionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return $state
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(10, $input, $state)               (: StringLiteral :)
  return $state
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'and' :)
      let $state := p:consume(69, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ascending' :)
      let $state := p:consume(71, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'case' :)
      let $state := p:consume(77, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'cast' :)
      let $state := p:consume(78, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'castable' :)
      let $state := p:consume(79, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'collation' :)
      let $state := p:consume(82, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'count' :)
      let $state := p:consume(87, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'default' :)
      let $state := p:consume(91, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'descending' :)
      let $state := p:consume(94, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'div' :)
      let $state := p:consume(97, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'else' :)
      let $state := p:consume(101, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'empty' :)
      let $state := p:consume(102, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'end' :)
      let $state := p:consume(105, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'eq' :)
      let $state := p:consume(106, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'except' :)
      let $state := p:consume(108, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'for' :)
      let $state := p:consume(112, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'ge' :)
      let $state := p:consume(114, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'group' :)
      let $state := p:consume(116, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'gt' :)
      let $state := p:consume(118, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'idiv' :)
      let $state := p:consume(119, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'instance' :)
      let $state := p:consume(125, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'intersect' :)
      let $state := p:consume(126, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'is' :)
      let $state := p:consume(127, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'le' :)
      let $state := p:consume(130, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'let' :)
      let $state := p:consume(132, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'lt' :)
      let $state := p:consume(133, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'mod' :)
      let $state := p:consume(135, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ne' :)
      let $state := p:consume(139, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'only' :)
      let $state := p:consume(146, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'or' :)
      let $state := p:consume(148, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'order' :)
      let $state := p:consume(149, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'return' :)
      let $state := p:consume(161, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'satisfies' :)
      let $state := p:consume(162, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'stable' :)
      let $state := p:consume(169, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'start' :)
      let $state := p:consume(170, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'to' :)
      let $state := p:consume(175, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'treat' :)
      let $state := p:consume(176, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'union' :)
      let $state := p:consume(180, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'where' :)
      let $state := p:consume(186, $input, $state)          (: 'where' :)
      return $state
    else
      let $state := p:consume(20, $input, $state)           (: NCName^Token :)
      return $state
  return $state
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(137, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(127, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(57, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(94, $input, $state)           (: S^WS | EOF | ('(' ':') | 'declare' | 'import' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  return $state
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(50, $input, $state)               (: ';' :)
  return $state
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(188, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 104) then                      (: 'encoding' :)
      let $state := p:consume(104, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(10, $input, $state)           (: StringLiteral :)
      return $state
    else
      let $state := p:consume(184, $input, $state)          (: 'version' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(10, $input, $state)           (: StringLiteral :)
      let $state := p:lookahead1W(73, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 104) then                  (: 'encoding' :)
          let $state := p:consume(104, $input, $state)      (: 'encoding' :)
          let $state := p:lookahead1W(15, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(10, $input, $state)       (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 188) then                          (: 'xquery' :)
      let $state := p:lookahead2W(128, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' |
                                                               'encoding' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | 'version' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 26812                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 47292) then                    (: 'xquery' 'version' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'module' :)
      let $state := p:lookahead2W(126, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 35208) then                    (: 'module' 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LibraryModule($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MainModule($input, $state)
      return $state
  return $state
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               OuterFor | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Module($input, $state)
  let $state := p:consume(24, $input, $state)               (: EOF :)
  return $state
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 22) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 33) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:matchW($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:matchW($input, $state[$p:e2], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-XQuery($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : Parse start symbol BindingExpression from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-BindingExpression($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-BindingExpression($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : Parse start symbol NamespaceNodeTest from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-NamespaceNodeTest($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-NamespaceNodeTest($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

                                                                      (: line 628 "XQueryV11-20081203.ebnf" :)
                                                                      declare variable $input external;
                                                                      p:parse-XQuery(collection(concat(".?select=", $input, ";unparsed=yes")))
                                                                      (: line 12789 "XQueryV11-20081203.xquery" :)
(: End :)
