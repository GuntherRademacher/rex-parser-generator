xquery version "1.0" encoding "UTF-8";

(: This file was generated on Thu Dec 26, 2024 07:00 (UTC+01) by REx v6.1-SNAPSHOT which is Copyright (c) 1979-2024 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q XQueryV11-20091215.ebnf -xquery -u -tree -main :)

declare namespace p="XQueryV11-20091215";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  63, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 32, 30, 30, 30, 30, 30, 30, 33, 6, 34, 6, 30, 6, 35, 36,
  37, 38, 39, 40, 41, 42, 43, 30, 30, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1010, 1028, 1045, 1064,
  1072, 1080, 1088, 1282, 1282, 1282, 1282, 1282, 1282, 1431, 1282, 1274, 1274, 1275, 1274, 1274, 1274, 1275, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1276, 1282, 1282, 1282, 1282, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1274, 1274, 1274, 1274, 1274, 1274, 1362, 1275, 1273, 1272, 1274, 1274, 1274, 1274,
  1274, 1275, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1278, 1053, 1274, 1274, 1274, 1274, 1203, 1056, 1274,
  1274, 1274, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
  1274, 1281, 1282, 1055, 1280, 1282, 1408, 1282, 1282, 1282, 1282, 1282, 1273, 1274, 1274, 1279, 1140, 1328, 1407,
  1282, 1402, 1408, 1140, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1364, 1274, 1275, 1151, 1402, 1317, 1216,
  1402, 1408, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1404, 1282, 1282, 1282, 1408, 1282, 1282, 1282, 1387,
  1251, 1274, 1274, 1271, 1274, 1274, 1274, 1274, 1275, 1275, 1418, 1272, 1274, 1278, 1282, 1273, 1109, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1273, 1109, 1274, 1274, 1274, 1274, 1118, 1282, 1274, 1274, 1274, 1274, 1274,
  1274, 1131, 1017, 1274, 1274, 1274, 1132, 1276, 1280, 1444, 1274, 1274, 1274, 1274, 1274, 1274, 1169, 1402, 1404,
  1217, 1274, 1187, 1402, 1282, 1282, 1444, 1131, 1363, 1274, 1274, 1272, 1201, 1212, 1178, 1190, 1431, 1227, 1187,
  1402, 1280, 1282, 1238, 1261, 1363, 1274, 1274, 1272, 1101, 1212, 1193, 1190, 1282, 1249, 1432, 1402, 1259, 1282,
  1444, 1250, 1271, 1274, 1274, 1272, 1269, 1169, 1292, 1123, 1282, 1282, 994, 1402, 1282, 1282, 1444, 1131, 1363, 1274,
  1274, 1272, 1360, 1169, 1218, 1190, 1432, 1227, 1020, 1402, 1282, 1282, 1002, 1033, 1305, 1301, 1204, 1033, 1142,
  1020, 1219, 1216, 1431, 1282, 1431, 1402, 1282, 1282, 1444, 1109, 1272, 1274, 1274, 1272, 1110, 1020, 1293, 1216,
  1433, 1282, 1020, 1402, 1282, 1282, 1002, 1109, 1272, 1274, 1274, 1272, 1110, 1020, 1293, 1216, 1433, 1284, 1020,
  1402, 1282, 1282, 1002, 1109, 1272, 1274, 1274, 1272, 1274, 1020, 1179, 1216, 1431, 1282, 1020, 1402, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1274,
  1274, 1274, 1274, 1276, 1282, 1274, 1274, 1274, 1274, 1275, 1282, 1273, 1274, 1274, 1274, 1274, 1275, 1313, 1407,
  1325, 1403, 1402, 1408, 1282, 1282, 1282, 1282, 1230, 1337, 1054, 1273, 1347, 1357, 1313, 1161, 1372, 1404, 1402,
  1408, 1282, 1282, 1282, 1282, 1284, 1037, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1279, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1269, 1100, 1279, 1282, 1282,
  1282, 1282, 1416, 1281, 1416, 1203, 1051, 1349, 1202, 1229, 1282, 1282, 1282, 1282, 1284, 1282, 1339, 1283, 1303,
  1279, 1282, 1282, 1282, 1282, 1427, 1281, 1429, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1278, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
  1274, 1280, 1274, 1274, 1276, 1276, 1274, 1274, 1274, 1274, 1276, 1276, 1274, 1419, 1274, 1274, 1274, 1276, 1274,
  1274, 1274, 1274, 1274, 1274, 1109, 1143, 1241, 1277, 1132, 1278, 1274, 1277, 1241, 1277, 1094, 1282, 1282, 1282,
  1273, 1329, 1177, 1282, 1273, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1277, 999, 1273, 1274, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1441, 1053, 1274, 1274, 1274, 1274, 1277, 1282, 1282, 1282, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1402, 1405, 1385, 1282, 1282, 1282, 1274, 1274, 1274, 1274, 1274,
  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1278, 1282, 1282, 1282,
  1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1408, 1402, 1408, 1395, 1377, 1274, 1273, 1274, 1274, 1274, 1280,
  1401, 1402, 1293, 1406, 1292, 1401, 1402, 1404, 1401, 1385, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1273,
  1274, 1274, 1274, 1275, 1429, 1273, 1274, 1274, 1274, 1275, 1282, 1401, 1402, 1175, 1402, 1402, 1157, 1382, 1282,
  1274, 1274, 1274, 1279, 1279, 1282, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 6, 6,
  6, 6, 6, 62, 62, 6, 6, 62, 62, 6, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 6, 6, 30, 30, 6, 6, 6, 6, 62, 62, 30,
  30, 30, 30, 32, 30, 30, 30, 6, 6, 6, 30, 30, 6, 6, 30, 6, 30, 30, 30, 33, 6, 34, 6, 30, 6, 6, 6, 6, 6, 30, 30, 30, 30,
  30, 30, 6, 35, 36, 37, 38, 39, 40, 41, 42, 43, 30, 30, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 6, 6, 6, 6, 6, 62, 6, 30, 6, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 62, 62, 62,
  62, 6, 62, 62, 62, 6, 6, 30, 30, 30, 30, 30, 6, 6, 30, 30, 62, 30, 30, 30, 30, 30, 30, 30, 6, 30, 6, 30, 30, 30, 30,
  6, 30, 62, 62, 6, 62, 62, 62, 6, 62, 62, 30, 6, 6, 30, 30, 6, 6, 62, 30, 62, 62, 6, 62, 62, 62, 62, 62, 6, 6, 62, 62,
  30, 30, 62, 62, 6, 6, 62, 62, 62, 6, 6, 6, 6, 62, 30, 6, 30, 6, 6, 6, 30, 30, 6, 6, 6, 30, 30, 6, 6, 62, 6, 62, 62,
  62, 62, 6, 6, 6, 62, 62, 6, 6, 6, 6, 30, 30, 6, 30, 6, 6, 30, 6, 6, 62, 6, 6, 30, 30, 30, 6, 30, 30, 6, 30, 30, 30,
  30, 6, 30, 6, 30, 30, 62, 62, 30, 30, 30, 6, 6, 6, 6, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 6, 6, 6,
  6, 6, 6, 6, 6, 30, 6, 62, 62, 62, 62, 62, 62, 6, 62, 62, 6, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 6, 30, 62, 30, 30,
  62, 62, 62, 62, 62, 30, 30, 62, 30, 30, 30, 30, 30, 30, 62, 62, 62, 62, 62, 62, 30, 6, 30, 6, 6, 30, 6, 6, 30, 30, 6,
  30, 30, 30, 6, 30, 6, 30, 6, 30, 6, 6, 30, 30, 6, 30, 30, 6, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 62, 6,
  6, 6, 6, 62, 62, 6, 62, 6, 6, 6, 6, 6, 6, 30, 62, 6, 6, 6, 6, 6, 62, 6, 62, 62, 62, 62, 62, 62, 62, 62, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 30, 6, 30, 6, 30, 6, 30, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6, 6, 62, 62, 6, 30, 30, 30, 6, 62, 62, 62, 6, 30,
  30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 8194, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 4111, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
  31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
  89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8192, 8234, 8237, 8259, 8237,
  8237, 8237, 8206, 8237, 8237, 8253, 8218, 8275, 8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295, 18561, 13620, 9622,
  13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783,
  9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025,
  8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829,
  8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196,
  9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654,
  9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 15732,
  15742, 9720, 16113, 8275, 8295, 12726, 8295, 8295, 9737, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 9755, 11098,
  10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953,
  16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573,
  9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813,
  8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330,
  9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 13747, 9800, 8295, 10005, 8295, 8296, 8295, 15553, 9948, 8295, 8278, 9818,
  9840, 8295, 12726, 8295, 15670, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 10479, 11098, 10449, 8295, 8295,
  8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418,
  8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164,
  8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983,
  9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435,
  9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 9859, 9903, 8295, 15675, 8295, 8295, 9905, 21197, 9885, 9923, 9898, 9939, 8275, 8295, 14253, 8295,
  17305, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 9488, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784,
  8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433,
  13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688,
  8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028,
  9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602,
  9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119,
  10000, 8295, 8909, 9972, 8295, 9991, 10021, 8295, 24402, 24404, 10066, 8275, 8295, 12726, 8295, 8295, 8295, 8585,
  8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996,
  8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618,
  8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526,
  8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458,
  9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373,
  8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 8909, 8295,
  8295, 8295, 21197, 8295, 8295, 8295, 13741, 8275, 8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295, 18561, 13620, 9622,
  13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783,
  9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025,
  8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829,
  8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196,
  9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654,
  9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 8909, 8295, 8295, 8295, 22578, 8295,
  8295, 8295, 13741, 10088, 8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098,
  10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953,
  16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573,
  9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813,
  8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330,
  9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 12577, 10107, 8295, 9084, 8295, 9721, 8295, 23130, 10260, 8295, 16122,
  12571, 10125, 8295, 12726, 8295, 9302, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8872, 11098, 10449, 8295,
  8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838,
  8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609,
  9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811,
  8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419,
  9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 10072, 10144, 10188, 10221, 10184, 10188, 10216, 10156, 10204, 10168, 10237, 10251, 8275,
  8295, 10284, 8295, 8295, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 8454, 8295, 8295, 8295, 9770,
  8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470,
  8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688,
  8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479,
  8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504,
  9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 16119, 22155, 8295, 8909, 10314, 8295, 22424, 21197, 10336, 10350, 22161, 10366, 8275, 8295, 14291, 8295, 8295,
  8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 9956, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658,
  8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495,
  8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744,
  12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100,
  9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102,
  18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 11657, 8295,
  8909, 8295, 8295, 8295, 21197, 10393, 10403, 10419, 10432, 8275, 8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295,
  18561, 13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 10465,
  9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445,
  13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768,
  8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156,
  9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386,
  9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 8909, 8295, 8295,
  8295, 21197, 10495, 10544, 10530, 10505, 8275, 8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295, 18561, 13620, 9622,
  13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 9345,
  9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025,
  8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829,
  8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196,
  9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654,
  9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 9311, 8295, 8909, 25460, 8295, 9314, 19642, 19655,
  19665, 25466, 10560, 8275, 8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098,
  10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953,
  16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573,
  9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813,
  8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330,
  9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 10602, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 10624, 10664, 10650,
  10634, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743, 18874, 8295, 10268, 10701,
  8295, 10723, 10811, 19265, 13868, 8295, 17243, 17244, 15189, 14507, 10743, 10743, 10743, 24886, 8295, 8295, 8295,
  22008, 8551, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743, 11050, 9112, 8295, 8295, 8295, 19997,
  19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 18873, 8295, 8295, 13407, 10809, 15408, 17244, 17244, 10760,
  23265, 10743, 18872, 8295, 9079, 21964, 10045, 17244, 21523, 10743, 24917, 10788, 19055, 10807, 17241, 15426, 10743,
  24648, 8295, 10827, 10848, 10868, 10896, 11122, 8557, 10915, 24248, 14985, 10963, 10997, 11022, 11046, 10295, 11048,
  11066, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 8909,
  8295, 8295, 8295, 21197, 8295, 8295, 19329, 11138, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290,
  14505, 9403, 10743, 11164, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295, 17243, 17244, 15189, 14507,
  10743, 10743, 10743, 18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743,
  10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 18873, 8295, 8295,
  8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034,
  8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985,
  11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 16119, 11208, 8295, 8909, 8295, 8295, 8295, 21197, 11227, 11252, 11240, 11263, 8275, 8295, 12726,
  8295, 8295, 11288, 8585, 11306, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312,
  9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507,
  8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660,
  8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672,
  9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552,
  9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295,
  9824, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 8295, 8295, 10128, 11325, 11359, 8295, 12726, 8295, 8295, 8295,
  19265, 13870, 8295, 10290, 14505, 9403, 10743, 11378, 8295, 10268, 8295, 19302, 8295, 10811, 19265, 13868, 8295,
  17243, 17244, 15189, 14507, 10743, 10743, 10743, 11402, 8295, 8295, 8295, 11427, 9975, 19265, 15166, 16243, 17244,
  17244, 17244, 10742, 10743, 10743, 15487, 25848, 8295, 8295, 21808, 9975, 19265, 15170, 17244, 17244, 17244, 21706,
  10743, 10743, 25843, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 21964,
  10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743,
  11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867,
  11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 14260, 8295, 12853, 10514, 8295, 10441, 21197, 8295, 12223,
  8295, 18614, 11445, 8295, 11466, 8295, 8295, 8295, 8585, 8294, 8295, 25745, 11546, 12307, 12404, 11825, 11098, 26270,
  8295, 8295, 8295, 9770, 8312, 9784, 8328, 11921, 11489, 11591, 11811, 12410, 11519, 12393, 12056, 9275, 8295, 25953,
  16400, 19838, 8418, 8593, 11535, 11562, 11578, 11544, 11633, 11681, 12404, 11697, 13162, 8539, 18025, 8295, 26377,
  8573, 9238, 12151, 11755, 11766, 11617, 12181, 12338, 11647, 8722, 8744, 12212, 18526, 11740, 11797, 11782, 11503,
  11841, 11882, 11898, 8904, 8925, 23811, 11914, 11937, 12015, 12438, 11953, 9065, 9100, 9128, 11866, 11604, 11987,
  12350, 9196, 9224, 12003, 12041, 12074, 12097, 12123, 12139, 12167, 12197, 12239, 12287, 12303, 12025, 25750, 12081,
  12323, 11855, 12366, 12382, 12426, 12454, 12254, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 25043, 8295, 8909,
  22294, 8295, 8295, 23683, 12470, 12484, 12500, 23695, 8275, 8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295, 18561,
  13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402,
  8991, 8783, 9275, 8295, 25953, 12517, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 12556, 12532,
  8539, 18025, 11335, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 12593, 8722, 8744, 12212, 18526, 8768,
  8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156,
  9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386,
  9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 8909, 8295, 8295,
  8295, 25064, 12627, 12637, 12653, 12666, 8275, 8295, 12726, 8295, 8295, 8295, 8585, 12691, 8295, 18561, 13620, 9622,
  13618, 12711, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783,
  9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025,
  8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829,
  8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196,
  9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654,
  9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 12748, 22469, 8295, 8909, 8295, 8295, 8295, 21197, 12775,
  12785, 12758, 12801, 12826, 8295, 12726, 8295, 8295, 8295, 8585, 12848, 8295, 18561, 13620, 9622, 13618, 12869, 11098,
  10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953,
  16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573,
  9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813,
  8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330,
  9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 12914, 12988, 8295, 8909, 8295, 8295, 8295, 21197, 12959, 12969, 12985,
  13007, 13054, 8295, 12726, 8295, 8295, 8295, 8585, 13074, 8295, 18561, 13620, 9622, 13618, 9567, 11098, 10449, 8295,
  8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838,
  8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609,
  9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811,
  8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419,
  9435, 9474, 9504, 9552, 9602, 13095, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 13118, 8295, 8295, 8909, 16150, 8295, 8295, 21197, 8295, 13152, 8295, 18350, 8275, 8295,
  12726, 8295, 8295, 13186, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 13204, 11098, 10449, 8295, 8295, 8295, 9770,
  8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470,
  8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688,
  8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479,
  8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504,
  9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 16119, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 8295, 8295, 19819, 13265, 8275, 8295, 12726, 8295, 8295, 8295,
  8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344,
  8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523,
  13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212,
  18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128,
  9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566,
  9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909,
  8295, 8295, 8295, 21197, 13290, 17311, 13660, 16390, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290,
  14505, 9403, 10743, 18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295, 16249, 17244, 15189, 24224,
  10743, 10743, 10743, 18875, 8295, 8295, 8295, 21814, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743,
  10743, 24783, 25848, 8295, 8295, 21808, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 25843, 8295,
  8295, 25898, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743,
  17034, 8295, 14847, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743,
  14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 13290, 17311, 13660, 16390, 10680, 8295,
  12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743, 18874, 8295, 10268, 8295, 8295, 8295, 10811,
  19265, 13868, 8295, 16249, 17244, 15189, 24224, 10743, 10743, 10743, 18875, 8295, 8295, 8295, 21814, 9975, 19265,
  15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743, 24783, 25848, 8295, 8295, 21808, 9975, 19265, 15170, 17244,
  17244, 17244, 21706, 10743, 10743, 25843, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872,
  8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964,
  17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192,
  16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295,
  21197, 13290, 17311, 13660, 16390, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290, 14505, 9403,
  10743, 18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295, 16249, 17244, 15189, 24224, 10743, 10743,
  10743, 18875, 8295, 8295, 8295, 21215, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743, 24783,
  25848, 8295, 8295, 21808, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 25843, 8295, 8295, 8295,
  10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034, 8295,
  8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985, 11184,
  17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 13290, 17311, 13660, 16390, 10680, 8295, 12726, 8295, 8295,
  8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743, 18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295,
  16249, 17244, 15189, 24224, 10743, 10743, 10743, 18875, 8295, 8295, 8295, 21814, 9975, 19265, 15166, 16243, 17244,
  17244, 17244, 10742, 10743, 10743, 24783, 25848, 8295, 8295, 18853, 9975, 19265, 15170, 17244, 17244, 17244, 21706,
  10743, 10743, 25843, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 21964,
  10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743,
  11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867,
  11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 13290, 17311,
  13660, 16390, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743, 17129, 8295, 10268,
  8295, 8295, 8295, 10811, 19265, 13868, 8295, 16249, 17244, 15189, 24224, 10743, 10743, 10743, 13315, 8295, 8295, 8295,
  21814, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743, 24783, 25848, 8295, 8295, 21808, 9975,
  19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 25843, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188,
  10743, 10743, 18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743,
  11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048,
  10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909,
  8295, 8295, 8295, 21197, 13290, 17311, 13660, 16390, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290,
  14505, 9403, 10743, 18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295, 16249, 17244, 15189, 24224,
  10743, 10743, 10743, 18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743,
  10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 18873, 8295, 8295,
  8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034,
  8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985,
  11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295, 15878, 13290, 17311, 13660, 16390, 10680, 8295, 12726,
  8295, 8295, 8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743, 18874, 8295, 10268, 8295, 8295, 25114, 10811, 19265,
  13868, 8295, 16249, 17244, 15189, 24224, 10743, 10743, 10743, 18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166,
  16243, 17244, 17244, 17244, 10742, 10743, 10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265, 15170, 17244, 17244,
  17244, 21706, 10743, 10743, 18873, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295,
  8295, 21964, 10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241,
  11188, 10743, 11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066,
  21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295, 21197,
  13290, 17311, 13660, 16390, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743,
  18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295, 16249, 17244, 15189, 24224, 10743, 10743, 10743,
  18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743, 11050, 8295, 8295,
  8295, 8295, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 18873, 8295, 8295, 8295, 10809, 15408,
  17244, 17244, 11188, 10743, 10743, 18872, 8295, 17997, 21964, 10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965,
  17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399,
  10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119,
  8295, 8295, 8909, 8295, 8295, 8295, 21197, 13333, 13363, 13346, 13379, 8275, 8295, 12726, 8295, 8295, 8295, 8585,
  8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 13404, 9770, 8312, 9784, 8328, 9658, 8344,
  8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523,
  13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212,
  18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128,
  9458, 9156, 9180, 8620, 13423, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566,
  9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 8909,
  8295, 8295, 8295, 21197, 13469, 13483, 13499, 13516, 8275, 8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295, 18561,
  13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402,
  8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162,
  8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842,
  8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180,
  8620, 9196, 9224, 9254, 9330, 9366, 13541, 9419, 9435, 9474, 13571, 9552, 9602, 13611, 13102, 18566, 9373, 8386, 9447,
  9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 9843, 8295, 8909, 13170, 8295, 10377,
  13636, 13688, 13702, 13718, 13731, 13763, 15779, 13811, 25849, 18330, 13833, 13849, 13887, 22708, 13925, 19497, 13962,
  14009, 13976, 8295, 10268, 14025, 8295, 14043, 14060, 20275, 13868, 8295, 16249, 17244, 24435, 24224, 10743, 10743,
  21775, 18875, 25925, 18637, 8295, 21814, 9975, 14081, 19412, 14103, 17244, 14340, 17244, 14119, 10743, 10744, 24783,
  14154, 25513, 12991, 21209, 10091, 14180, 14206, 14222, 17244, 17244, 14391, 26028, 10743, 14238, 13795, 21116, 15222,
  10809, 15408, 17244, 18400, 16313, 10743, 21316, 14276, 15565, 8295, 21964, 10045, 24812, 15838, 23433, 17034, 8295,
  8295, 21965, 20976, 25362, 8960, 14313, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985, 11184,
  18261, 14333, 21533, 14356, 10772, 14380, 17221, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 11144, 8785, 14426, 8909, 25467, 8295, 8295, 22412, 14443, 17311, 13660, 16390, 10680, 8295, 12726, 8295,
  8295, 8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743, 18874, 8295, 10268, 8295, 23865, 8295, 10811, 19265, 13868,
  8295, 16249, 17244, 15189, 24224, 10743, 10743, 10743, 18875, 8295, 8295, 13131, 14869, 19385, 19265, 13863, 16243,
  17244, 22086, 17244, 10742, 10743, 25547, 24783, 25848, 8295, 8295, 21808, 9975, 19265, 15170, 17244, 17244, 17244,
  21706, 10743, 10743, 25843, 23063, 8295, 8295, 15158, 18202, 14503, 17244, 14523, 10743, 10743, 18872, 8295, 8295,
  21964, 10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188,
  10743, 11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 26458, 14573, 10298, 15004, 11192, 16066, 21696,
  20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 14597, 8909, 8295, 8295, 12732, 14620, 14651,
  14666, 14681, 14694, 10680, 10109, 12726, 13038, 8295, 8295, 19265, 13870, 8295, 10290, 14505, 16219, 22047, 18874,
  20227, 19310, 14889, 8295, 25723, 19928, 19265, 15771, 15571, 14720, 17244, 25086, 16287, 16921, 10743, 10743, 17903,
  8295, 19028, 8295, 21814, 9040, 14786, 15166, 16243, 14808, 24218, 10927, 14825, 25572, 18762, 24783, 25848, 8295,
  8295, 14863, 9975, 19265, 15170, 17244, 17244, 22488, 21706, 10743, 20661, 25843, 8295, 8295, 14885, 10809, 15408,
  17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 25139, 23382, 14905, 11188, 18926, 25653, 22590, 8295, 18803,
  14925, 18723, 19123, 11050, 8295, 21964, 17241, 22641, 24117, 11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399,
  15030, 14962, 15001, 10298, 15004, 11192, 15020, 21696, 21681, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144,
  8295, 10569, 8909, 8295, 15046, 15062, 15089, 15105, 15119, 15135, 15148, 10680, 8295, 12726, 8295, 8295, 8295, 16495,
  25976, 10726, 15945, 15186, 22540, 20529, 18874, 21080, 15205, 20576, 8295, 8295, 22366, 18303, 15238, 25790, 15254,
  25604, 15189, 16590, 18769, 20535, 10743, 18875, 8295, 13033, 15282, 21814, 9975, 19265, 15166, 16243, 17244, 17244,
  17244, 10742, 10743, 10743, 24783, 15322, 21816, 19592, 21808, 9975, 19265, 15170, 15345, 16250, 15362, 17378, 10743,
  21707, 15380, 8295, 8295, 8295, 15401, 15408, 15424, 16281, 14946, 10743, 24617, 18872, 17816, 8295, 26136, 20628,
  19357, 11188, 15442, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8698, 21964, 17241, 15458, 17886, 11122,
  8557, 17244, 10743, 14985, 11184, 17035, 24490, 10977, 16548, 21938, 10298, 15004, 11192, 16066, 21696, 20867, 11114,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 22431, 8909, 11473, 15503, 22718, 15524, 15587, 15601, 15617,
  15630, 10680, 15656, 13438, 15691, 15717, 20945, 15758, 21183, 15795, 15824, 15864, 15808, 15894, 17129, 13388, 23855,
  15938, 15961, 15978, 10811, 19265, 15996, 16015, 23308, 17245, 24448, 16035, 24734, 25401, 16082, 16098, 18498, 16138,
  16175, 21814, 13595, 19170, 16204, 8938, 16266, 16303, 16339, 16355, 16377, 16416, 16444, 15385, 8295, 24948, 18467,
  16477, 16519, 16541, 24849, 17162, 16564, 16758, 10743, 16606, 16625, 16647, 16663, 21073, 10809, 16686, 20995, 16712,
  16748, 20301, 16774, 16808, 24297, 16825, 21964, 16858, 16887, 11188, 16908, 17034, 26217, 16958, 26295, 16981, 17017,
  17051, 17085, 8295, 15296, 23100, 17115, 14410, 14581, 17149, 25995, 21399, 15908, 17185, 17216, 17237, 17261, 23551,
  17294, 17327, 17343, 11192, 17579, 17368, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295,
  8909, 8295, 17401, 8295, 17419, 17470, 17484, 17500, 17513, 10680, 15329, 12726, 8295, 8295, 8295, 19265, 13870, 8295,
  10290, 14505, 23903, 20655, 18874, 20237, 11665, 8295, 8295, 20917, 16486, 19265, 13868, 20233, 17546, 17244, 15189,
  24224, 17064, 10743, 10743, 18875, 8295, 8295, 8295, 21814, 9975, 19265, 15166, 16243, 17244, 23207, 17244, 10742,
  10743, 16361, 24783, 25848, 8295, 8295, 21808, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 25843,
  8295, 8295, 8295, 21145, 17569, 17244, 18715, 11188, 10743, 24561, 18872, 8295, 8295, 21964, 10045, 17244, 11188,
  10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 10981, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244,
  10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 13775, 21696, 22913, 11114, 8295, 8295,
  8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 16455, 13079, 21862, 17595, 17609, 17625, 17638, 10680,
  8295, 12726, 8295, 20047, 8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743, 16233, 8295, 10268, 8295, 8295, 17523,
  10811, 19265, 13868, 8295, 16249, 17244, 15189, 24224, 10743, 10743, 10743, 18875, 8295, 8295, 8295, 8295, 9975,
  19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265, 15170,
  17244, 17244, 17244, 21706, 10743, 10743, 18873, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743,
  18872, 8295, 17664, 21964, 10045, 17244, 11188, 10743, 17034, 20156, 13555, 13901, 17241, 15426, 10743, 11050, 8295,
  17681, 17707, 14770, 21299, 11122, 13648, 17756, 16428, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004,
  11192, 16066, 22928, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295,
  8295, 21197, 13290, 17311, 13660, 16390, 10680, 18876, 17792, 8295, 8295, 17814, 19265, 17832, 8295, 14297, 22768,
  17850, 17885, 17902, 8295, 17919, 17945, 8295, 8295, 10811, 19265, 13868, 8295, 16249, 17244, 15189, 19784, 10743,
  10743, 22956, 18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743,
  11050, 24161, 8295, 8295, 8295, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 18873, 8295, 17994,
  8295, 10809, 15408, 17244, 17244, 21004, 10743, 17978, 18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034,
  8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 15346, 10743, 18013,
  11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 11144, 8295, 11168, 8909, 24890, 13986, 18047, 15922, 18089, 18101, 18117, 18130, 10680, 8295,
  18173, 8295, 8295, 23929, 18195, 18218, 14549, 14557, 14505, 18242, 18277, 18874, 8295, 10268, 22596, 25507, 8295,
  10811, 18295, 18319, 9531, 18375, 18396, 19446, 10947, 18416, 18435, 25580, 18875, 13020, 18454, 18514, 13347, 18542,
  19265, 18582, 16243, 17244, 25209, 17244, 10742, 10743, 13946, 17864, 8295, 8295, 18602, 18630, 9975, 19265, 15170,
  17244, 17244, 18653, 17030, 10743, 10743, 18873, 20731, 18673, 23329, 10809, 15408, 17244, 17244, 17722, 24137, 10743,
  14131, 8295, 12611, 10033, 18703, 18739, 19365, 23516, 18785, 8295, 8295, 18819, 21513, 17776, 16785, 18869, 14457,
  12926, 17241, 11188, 10743, 23669, 8557, 17244, 10743, 14985, 11184, 17035, 18892, 24470, 10295, 11048, 10298, 24923,
  18908, 16066, 21696, 20867, 18942, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 16836,
  25119, 12898, 18966, 18980, 18996, 19009, 10680, 19052, 12726, 23704, 20047, 10683, 24040, 13870, 10685, 12675, 21382,
  19071, 19120, 16233, 19141, 10268, 12759, 8295, 19139, 19159, 14087, 13868, 8295, 19186, 18380, 19202, 24224, 24687,
  21635, 22188, 18875, 19245, 8295, 26404, 8295, 9975, 19264, 15166, 17929, 20756, 17244, 17244, 19282, 25295, 10743,
  11050, 8295, 19326, 20186, 22617, 9975, 19266, 15170, 17244, 19345, 17244, 21706, 19104, 20800, 16809, 8295, 8295,
  8295, 20004, 15408, 17769, 17244, 11188, 19099, 10743, 21730, 19381, 17834, 19401, 19435, 17244, 24855, 10743, 17034,
  9284, 8295, 19462, 17241, 15426, 10743, 11050, 26099, 21964, 17241, 23216, 20884, 11122, 8557, 17244, 10743, 14985,
  11184, 17035, 9399, 10770, 10295, 11048, 23462, 19482, 13938, 16066, 22943, 20867, 11114, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 11144, 8295, 9739, 8909, 8295, 10578, 8295, 17099, 19536, 19546, 19562, 19575, 10680, 19608, 12726,
  13817, 8295, 9348, 24325, 13870, 9350, 11343, 19628, 19681, 19717, 18874, 10791, 10268, 15508, 18226, 8295, 10811,
  19265, 13868, 8295, 16249, 17001, 19739, 24080, 25649, 17069, 21309, 19869, 18140, 8295, 8295, 8295, 9975, 19265,
  15166, 16243, 17244, 17244, 19775, 19800, 18419, 10743, 11050, 11362, 16942, 14044, 13317, 18798, 19265, 15170, 16994,
  17244, 14750, 16323, 10743, 23578, 18873, 8295, 8295, 19816, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872,
  8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034, 19835, 8295, 21965, 17241, 15426, 10743, 11050, 19248, 21964,
  17241, 11188, 10743, 11122, 8557, 17244, 10743, 22554, 19854, 21988, 9399, 10770, 10295, 11048, 10298, 15004, 11192,
  16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 13871, 11450, 8295, 14164, 12695,
  19904, 19944, 19958, 19974, 19987, 10680, 13243, 13453, 17272, 8295, 15701, 20020, 20036, 20069, 18359, 20085, 20115,
  20131, 18874, 20182, 13525, 8295, 13231, 17530, 10811, 19265, 13868, 13993, 16249, 17244, 15189, 20202, 18279, 10743,
  10743, 17454, 8295, 20253, 8295, 19585, 9975, 20273, 15166, 20166, 17244, 17244, 17244, 20291, 10743, 10743, 11050,
  8295, 8295, 18493, 8295, 20324, 19265, 20362, 17244, 14735, 17244, 20881, 10743, 20400, 14317, 20441, 19520, 8295,
  20474, 20490, 15266, 20829, 20518, 20551, 26020, 18872, 20567, 20600, 20616, 23154, 17244, 20644, 24094, 17034, 14487,
  26051, 23142, 20677, 20705, 19723, 20721, 8295, 9869, 20747, 20689, 20781, 11122, 20816, 20765, 17733, 21438, 20852,
  23474, 12107, 13672, 20458, 19293, 10298, 15004, 11192, 16696, 21696, 20867, 20900, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 11144, 8295, 8295, 20933, 8295, 18031, 8728, 20961, 21020, 21034, 21050, 21063, 21096, 11706, 12726,
  21112, 21132, 21238, 21168, 12943, 21231, 21269, 21254, 21285, 21332, 18874, 8295, 10268, 23937, 11429, 20909, 10811,
  21362, 13868, 8295, 16249, 21380, 24188, 18073, 10743, 21398, 21415, 18875, 8295, 18150, 19019, 21454, 19879, 19265,
  12936, 21476, 19759, 14909, 17244, 10742, 24623, 10743, 21498, 21549, 18480, 8295, 8295, 9975, 19265, 15170, 17169,
  17244, 17244, 21706, 21570, 10743, 18873, 14027, 15980, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872,
  22824, 8295, 21964, 23198, 17244, 19217, 23585, 21574, 8295, 8295, 12540, 21590, 15426, 21613, 11050, 8295, 21964,
  17241, 11188, 10743, 20415, 11411, 17244, 21633, 23917, 21651, 21723, 20425, 14976, 10295, 11048, 10298, 15004, 11192,
  21746, 24542, 20867, 21799, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 23872, 11148,
  21832, 21848, 10608, 21878, 21891, 10680, 16156, 12726, 8295, 8295, 8295, 19265, 13870, 16159, 20453, 14505, 9403,
  10743, 18874, 18844, 10268, 11211, 10586, 8295, 10832, 19265, 13868, 16670, 25182, 19754, 15189, 21924, 21783, 18921,
  22208, 20146, 8295, 12058, 8295, 11720, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743, 23606,
  14843, 8295, 16842, 13249, 21960, 24050, 23544, 25232, 17244, 17244, 21706, 21981, 10743, 18873, 22004, 8295, 8295,
  10809, 15408, 17244, 22024, 24763, 10743, 22043, 18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034, 8295,
  8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 22063, 11184,
  17035, 22079, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 13290, 17311, 13660, 16390, 10680, 8295, 12726, 8295,
  14481, 8295, 25329, 22102, 22109, 8706, 10852, 26435, 22125, 22145, 8295, 10268, 8295, 8295, 8295, 10811, 19265,
  13868, 8295, 16249, 17244, 15189, 24224, 10743, 10743, 10743, 18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166,
  16243, 17244, 17244, 17244, 10742, 10743, 10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265, 15170, 17244, 17244,
  17244, 21706, 10743, 10743, 18873, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295,
  8295, 21964, 10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241,
  22177, 22204, 11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066,
  21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 22566, 22225, 8295, 22224, 20099,
  22241, 22255, 22271, 22284, 10680, 13136, 12884, 22310, 22340, 23996, 14190, 19419, 13274, 16061, 22382, 17960, 22882,
  18874, 8295, 25022, 16965, 22398, 9536, 19466, 19265, 13868, 8295, 21482, 23492, 16892, 24224, 16609, 10743, 22447,
  18875, 8295, 8295, 22465, 21554, 19612, 19265, 20338, 16243, 16725, 16732, 22485, 22504, 25543, 22680, 17448, 8295,
  9208, 22525, 22612, 9975, 16525, 23091, 22027, 22633, 22657, 21706, 25874, 22676, 22696, 8295, 14470, 17403, 10809,
  15408, 14940, 17244, 11188, 22744, 10743, 19695, 14427, 8295, 21964, 10045, 18657, 11188, 10743, 17740, 19143, 19701,
  21965, 22764, 24381, 10743, 11050, 11965, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 16049, 22784, 24709,
  9399, 10770, 22800, 22848, 22870, 15004, 11192, 17352, 25284, 22898, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295,
  11144, 8295, 8295, 15073, 8295, 24657, 14635, 22324, 22977, 22991, 23007, 23020, 23056, 8295, 12726, 9907, 8295,
  25931, 23079, 13299, 20584, 12810, 23116, 23170, 20792, 11006, 8295, 10268, 8295, 8295, 11290, 23186, 23370, 18832,
  16019, 23232, 14764, 15189, 23241, 23257, 24553, 10743, 18875, 23281, 22832, 8295, 8295, 9975, 19265, 15166, 23302,
  17244, 17244, 17244, 10742, 10743, 10743, 11050, 8295, 23324, 8295, 11714, 23345, 21364, 18586, 17244, 23406, 11030,
  23431, 22748, 19085, 14838, 8295, 8295, 8295, 10809, 23449, 17244, 23490, 18751, 10743, 23508, 18872, 21908, 8295,
  23532, 10045, 17244, 23567, 14402, 23601, 8295, 9293, 21965, 17241, 15426, 10743, 11050, 17665, 23622, 10050, 11188,
  22509, 23638, 8557, 17244, 10743, 14985, 23654, 21429, 9399, 10770, 23720, 11048, 24459, 23736, 14364, 16066, 21696,
  20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 22728, 8295, 9802, 15539, 21197, 23752,
  23765, 23781, 23794, 10680, 15215, 13586, 15640, 23827, 12501, 15306, 23843, 17133, 12263, 23888, 23953, 24276, 18874,
  23969, 23985, 8295, 24012, 16461, 24028, 24590, 25160, 17648, 16249, 20376, 24066, 24224, 24115, 24774, 24133, 14538,
  24153, 11309, 8295, 8295, 16188, 17691, 13909, 24177, 24204, 17244, 16871, 24240, 24264, 18438, 11050, 18179, 13500,
  24292, 18157, 20257, 24313, 24352, 24378, 24511, 20986, 15468, 18256, 16792, 22854, 8295, 23286, 24397, 14704, 21152,
  24420, 24506, 17553, 24527, 24701, 10880, 21460, 8295, 24577, 25341, 22660, 24606, 24639, 25301, 11724, 8295, 21965,
  18062, 24673, 24725, 20216, 8295, 14604, 24750, 8949, 26076, 24480, 24799, 24835, 21346, 11080, 11184, 17035, 9399,
  10770, 10295, 8967, 12271, 19229, 24871, 24906, 21696, 21666, 24939, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144,
  8295, 8295, 8909, 8295, 13058, 8295, 21197, 24972, 24982, 24998, 25011, 10680, 8295, 13219, 19036, 25038, 8295, 19265,
  13870, 8295, 10290, 15364, 25635, 17974, 17869, 8295, 10268, 8295, 16631, 25059, 19888, 19265, 13868, 8295, 25080,
  17244, 20836, 24224, 25392, 10743, 10743, 25102, 20053, 8295, 8295, 20346, 25135, 14792, 25155, 25176, 25198, 25225,
  25248, 25269, 25409, 21766, 11050, 13188, 8295, 8295, 8295, 9975, 25317, 15170, 25357, 17244, 17244, 15848, 10743,
  10743, 16934, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 13787, 8295, 21901, 21964, 10045,
  17244, 25378, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122,
  8557, 20384, 15478, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 24362, 26449, 11192, 16066, 17200, 20867, 11114,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 11272, 8295, 25425, 8295, 22354, 25446, 10707, 25483,
  25496, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10320, 14505, 25529, 25563, 18874, 8295, 10268, 8295,
  8295, 8295, 9049, 19265, 18555, 8295, 25596, 17244, 15189, 24224, 21757, 10743, 10743, 18875, 8295, 8295, 14138, 8295,
  9975, 14065, 16503, 16243, 24819, 17244, 17244, 10742, 20308, 10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265,
  15170, 17244, 17244, 17244, 21706, 10743, 10743, 18873, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743,
  10743, 18872, 15999, 8295, 21964, 10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050,
  8295, 21964, 17241, 11188, 10743, 18950, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298,
  15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8752, 8295,
  11386, 11382, 25620, 25669, 25683, 25699, 25712, 10680, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290,
  14505, 17434, 22129, 18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295, 16249, 17244, 15189, 24224,
  10743, 10743, 10743, 18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743,
  10743, 11050, 8295, 8295, 8295, 25739, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743, 18873, 17278,
  8295, 8295, 10809, 15408, 25253, 17244, 23390, 24099, 22449, 18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743,
  17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743,
  14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295,
  8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295, 21197, 13290, 12832, 25766, 25779, 10680, 8295,
  19512, 8295, 8295, 8295, 23358, 25806, 25813, 24956, 14505, 25829, 25865, 18874, 8295, 10268, 11092, 25890, 8295,
  10811, 19265, 13868, 8295, 16249, 17244, 15189, 21597, 10743, 10743, 17385, 22815, 8295, 8295, 8295, 8295, 9975,
  19265, 15166, 16243, 17244, 17244, 17244, 10742, 10743, 10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265, 15170,
  17244, 17244, 17244, 21706, 10743, 10743, 21944, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743,
  18872, 8295, 8295, 21964, 10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295,
  21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004,
  11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 11144, 8295, 8295, 8909, 8295, 8295,
  8295, 21197, 13290, 17311, 13660, 16390, 25914, 8295, 12726, 8295, 8295, 8295, 19265, 13870, 8295, 10290, 14505,
  20502, 10899, 18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295, 16249, 17244, 16577, 24224, 10743,
  10743, 22961, 18875, 25947, 8295, 8295, 8295, 17798, 19265, 25969, 16243, 17244, 25992, 17244, 10742, 10743, 26011,
  11050, 8295, 26044, 8295, 8295, 9975, 24336, 15170, 23415, 17244, 10939, 21706, 26067, 10743, 18873, 8295, 8295, 8295,
  10809, 15408, 17244, 14809, 11188, 10743, 10743, 26092, 8295, 8295, 21964, 10045, 17244, 11188, 10743, 21617, 8295,
  15962, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557, 17244, 10743, 14985, 11184,
  17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295, 8295, 8295, 8295, 8295, 8295,
  8295, 11144, 8295, 8295, 8909, 8295, 8295, 8295, 18687, 13290, 17311, 13660, 16390, 10680, 8295, 12726, 8295, 8295,
  8295, 19265, 13870, 8295, 10290, 14505, 9403, 10743, 18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295,
  16249, 17244, 15189, 24224, 10743, 10743, 10743, 18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166, 16243, 17244,
  17244, 17244, 10742, 10743, 10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265, 15170, 17244, 17244, 17244, 21706,
  10743, 10743, 18873, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 21964,
  10045, 17244, 11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743,
  11122, 8557, 17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867,
  11114, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 11971, 26166, 23040, 26115, 9519, 26152, 23030,
  26161, 26127, 8275, 8295, 12726, 8295, 23804, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 10449,
  8295, 8295, 8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400,
  19838, 8418, 8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140,
  8644, 8609, 9164, 8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904,
  8925, 23811, 8983, 9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366,
  9389, 9419, 9435, 9474, 9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295,
  8295, 8295, 8295, 8295, 8295, 8295, 16119, 8295, 8295, 8909, 8295, 8295, 9582, 21197, 26182, 26192, 9586, 26208, 8275,
  8295, 12726, 8295, 8295, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 8295,
  9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593,
  8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636,
  9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012,
  8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474,
  9504, 9552, 9602, 9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295,
  8295, 8295, 16119, 8295, 8295, 8909, 8295, 8295, 8295, 19916, 26233, 26247, 26263, 26286, 8275, 8295, 12726, 8295,
  12603, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 10449, 8295, 8295, 8295, 9770, 8312, 9784,
  8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418, 8593, 8470, 8507, 8433,
  13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164, 8636, 9688, 8660, 8688,
  8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983, 9012, 8479, 8672, 9028,
  9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 9389, 9419, 9435, 9474, 9504, 9552, 9602,
  9618, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 16119,
  8295, 8295, 8909, 8295, 8295, 8295, 21197, 8295, 8295, 8295, 18340, 10680, 8295, 12726, 8295, 8295, 8295, 19265,
  13870, 8295, 10290, 14505, 9403, 10743, 18874, 8295, 10268, 8295, 8295, 8295, 10811, 19265, 13868, 8295, 17243, 17244,
  15189, 14507, 10743, 10743, 10743, 18875, 8295, 8295, 8295, 8295, 9975, 19265, 15166, 16243, 17244, 17244, 17244,
  10742, 10743, 10743, 11050, 8295, 8295, 8295, 8295, 9975, 19265, 15170, 17244, 17244, 17244, 21706, 10743, 10743,
  18873, 8295, 8295, 8295, 10809, 15408, 17244, 17244, 11188, 10743, 10743, 18872, 8295, 8295, 21964, 10045, 17244,
  11188, 10743, 17034, 8295, 8295, 21965, 17241, 15426, 10743, 11050, 8295, 21964, 17241, 11188, 10743, 11122, 8557,
  17244, 10743, 14985, 11184, 17035, 9399, 10770, 10295, 11048, 10298, 15004, 11192, 16066, 21696, 20867, 11114, 8295,
  8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 8295, 26354, 8295, 26311, 26321, 26337, 26349,
  26370, 8295, 8295, 8295, 8295, 8295, 8585, 8294, 8295, 18561, 13620, 9622, 13618, 8358, 11098, 25430, 8295, 8295,
  8295, 9770, 8312, 9784, 8328, 9658, 8344, 8996, 8374, 9660, 8402, 8991, 8783, 9275, 8295, 25953, 16400, 19838, 8418,
  8593, 8470, 8507, 8433, 13618, 8495, 8523, 13618, 8445, 13162, 8539, 18025, 8295, 26377, 8573, 9140, 8644, 8609, 9164,
  8636, 9688, 8660, 8688, 8722, 8744, 12212, 18526, 8768, 8842, 8801, 8829, 8858, 8888, 8813, 8904, 8925, 23811, 8983,
  9012, 8479, 8672, 9028, 9065, 9100, 9128, 9458, 9156, 9180, 8620, 9196, 9224, 9254, 9330, 9366, 26393, 9419, 9435,
  9474, 26420, 9552, 9602, 18564, 13102, 18566, 9373, 8386, 9447, 9638, 9654, 9676, 9704, 9266, 8295, 8295, 8295, 8295,
  8295, 8295, 8295, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 45246, 45246, 45246, 45246, 0, 47295, 47295, 47295, 47295, 32768,
  34816, 47295, 47295, 47295, 47295, 47295, 30720, 47295, 47295, 47295, 47295, 47295, 47295, 1, 8194, 3, 0, 0, 0, 0,
  45246, 47295, 0, 47295, 45246, 45246, 47295, 47295, 47295, 47295, 47295, 47295, 47295, 47295, 47295, 47295, 47295,
  47295, 47295, 47295, 47295, 47295, 47295, 0, 45246, 47295, 47295, 45246, 47295, 47295, 47295, 47295, 47295, 47295,
  47295, 47295, 47295, 47295, 47295, 228, 47295, 47295, 47295, 47295, 540672, 194, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 194, 194, 194, 567296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194, 757760, 567296, 765952, 567296,
  567296, 784384, 790528, 796672, 567296, 808960, 567296, 827392, 567296, 567296, 567296, 888832, 808960, 827392,
  888832, 0, 0, 0, 0, 790528, 827392, 0, 0, 827392, 0, 0, 0, 774144, 757760, 565248, 765952, 565248, 565248, 565248,
  784384, 790528, 796672, 565248, 565248, 808960, 565248, 827392, 565248, 565248, 0, 540672, 0, 0, 0, 0, 0, 0, 0,
  667648, 0, 0, 679936, 0, 565248, 565248, 565248, 770048, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 0, 0, 565248, 565248, 565248, 565248, 727040, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 727040,
  565248, 565248, 765952, 565248, 770048, 565248, 565248, 784384, 565248, 790528, 796672, 565248, 565248, 808960,
  565248, 565248, 827392, 567296, 567296, 567296, 567296, 722944, 567296, 567296, 739328, 567296, 753664, 567296,
  567296, 567296, 567296, 794624, 800768, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 565248, 892928, 565248, 565248, 565248, 565248, 565248, 565248, 0, 544768, 0, 0, 0, 0, 0, 0, 0, 0, 573881,
  573881, 0, 671744, 0, 0, 0, 0, 0, 0, 800768, 0, 0, 0, 565248, 565248, 665600, 565248, 565248, 565248, 565248, 565248,
  565248, 565248, 565248, 565248, 882688, 565248, 565248, 565248, 565248, 565248, 565248, 0, 565248, 665600, 565248,
  565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 722944, 565248, 565248, 565248, 739328,
  565248, 565248, 565248, 753664, 565248, 565248, 565248, 565248, 565248, 794624, 565248, 565248, 739328, 565248,
  565248, 565248, 753664, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 794624, 800768, 0, 786432, 0, 0, 0, 0,
  0, 0, 0, 886784, 0, 909312, 0, 0, 0, 0, 0, 997, 0, 0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 289, 0, 347, 347, 347,
  567296, 567296, 567296, 567296, 731136, 567296, 567296, 567296, 768000, 567296, 567296, 823296, 567296, 567296,
  567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296,
  665600, 0, 722944, 0, 0, 0, 0, 800768, 565248, 565248, 565248, 823296, 565248, 565248, 565248, 565248, 565248, 868352,
  872448, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 675840, 0, 0, 0, 0, 0, 0, 833536, 905216, 565248,
  565248, 565248, 565248, 681984, 684032, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  731136, 565248, 565248, 565248, 565248, 565248, 768000, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 868352, 872448, 565248, 565248, 565248, 884736, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  745472, 565248, 565248, 772096, 565248, 565248, 802816, 565248, 565248, 565248, 565248, 565248, 0, 0, 0, 0, 0, 0,
  688128, 0, 0, 0, 0, 0, 0, 0, 1658, 0, 0, 0, 0, 0, 0, 0, 0, 535, 0, 347, 347, 347, 347, 573, 347, 0, 733184, 0, 0, 0,
  829440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 792576, 0, 0, 0, 0, 0, 0, 880640, 0, 0, 0, 0, 0, 0, 0, 0,
  226, 227, 0, 228, 0, 0, 0, 0, 567296, 829440, 567296, 567296, 567296, 876544, 890880, 899072, 911360, 0, 0, 0, 0,
  890880, 899072, 565248, 542720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 201, 565248, 565248, 565248, 829440,
  565248, 565248, 565248, 565248, 565248, 876544, 890880, 899072, 565248, 565248, 911360, 565248, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 802816, 0, 825344, 565248, 565248, 565248, 565248, 733184, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 565248, 565248, 565248, 690176, 565248, 702464, 565248, 565248, 565248, 565248, 733184, 743424, 565248,
  565248, 761856, 565248, 565248, 565248, 565248, 702464, 565248, 565248, 565248, 565248, 565248, 733184, 743424,
  565248, 565248, 565248, 761856, 565248, 565248, 0, 540672, 0, 0, 0, 0, 0, 0, 195, 667648, 0, 0, 679936, 0, 565248,
  565248, 565248, 829440, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 876544, 565248, 890880, 565248,
  899072, 0, 858112, 862208, 0, 913408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0, 0, 0, 0, 0, 772096, 0, 0, 0,
  878592, 0, 0, 0, 856064, 874496, 0, 0, 0, 0, 936, 936, 807, 1037, 347, 1038, 1039, 347, 347, 347, 347, 347, 347, 347,
  347, 1694, 347, 347, 383, 383, 383, 383, 383, 383, 1633, 383, 383, 383, 383, 383, 383, 383, 383, 383, 0, 0, 1849,
  1850, 0, 1851, 0, 567296, 858112, 567296, 874496, 0, 745472, 0, 0, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 565248, 565248, 565248, 888832, 565248, 565248, 565248, 565248, 565248, 667648, 0, 565248, 565248, 565248,
  745472, 565248, 772096, 565248, 565248, 802816, 565248, 565248, 835584, 565248, 858112, 565248, 874496, 565248,
  565248, 915456, 835584, 565248, 565248, 858112, 565248, 565248, 874496, 882688, 565248, 565248, 565248, 915456, 0, 0,
  0, 0, 0, 998, 0, 0, 1001, 0, 0, 0, 0, 289, 289, 289, 289, 289, 773, 289, 289, 289, 289, 289, 289, 698368, 0, 0,
  710656, 729088, 0, 0, 0, 0, 0, 0, 907264, 0, 778240, 0, 0, 0, 0, 1479, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 195, 195,
  0, 0, 0, 831488, 0, 870400, 0, 708608, 0, 0, 0, 0, 0, 851968, 0, 0, 0, 0, 0, 1144, 0, 0, 0, 0, 0, 0, 1150, 0, 0, 0, 0,
  0, 0, 841728, 0, 0, 0, 0, 567296, 567296, 567296, 710656, 567296, 567296, 567296, 567296, 684032, 0, 768000, 0, 0, 0,
  0, 0, 565248, 565248, 681984, 684032, 565248, 565248, 565248, 565248, 565248, 694272, 565248, 729088, 565248, 565248,
  565248, 565248, 565248, 565248, 565248, 565248, 565248, 786432, 565248, 817152, 565248, 565248, 565248, 884736,
  565248, 565248, 565248, 694272, 708608, 710656, 565248, 565248, 729088, 565248, 565248, 565248, 565248, 565248,
  565248, 831488, 747520, 737280, 755712, 759808, 0, 0, 847872, 0, 894976, 0, 659456, 849920, 0, 0, 0, 0, 0, 1158, 1159,
  1160, 0, 0, 0, 0, 0, 1164, 0, 0, 0, 776192, 0, 0, 0, 0, 0, 0, 0, 567296, 686080, 567296, 567296, 780288, 567296,
  567296, 567296, 567296, 684032, 0, 768000, 0, 0, 0, 0, 0, 565809, 565809, 682545, 684593, 686080, 780288, 0, 661504,
  565248, 686080, 565248, 565248, 565248, 724992, 565248, 780288, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 854016, 854016, 0, 0, 0, 0, 0, 0, 0, 0, 739328, 0, 0, 0, 0, 0, 0, 0, 0, 1569, 0, 0, 0, 0, 0, 0, 0, 0, 1580, 0,
  0, 0, 0, 0, 0, 0, 0, 28672, 0, 0, 0, 0, 0, 0, 0, 0, 77824, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565248, 903168, 565248,
  724992, 565248, 755712, 565248, 565248, 565248, 565248, 565248, 661504, 565248, 565248, 686080, 565248, 542720, 920,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 425, 0, 0, 0, 0, 565248, 565248, 724992, 565248, 565248, 755712, 780288,
  565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 0, 0, 0, 0, 718848, 0, 0, 903168, 0, 692224,
  0, 0, 0, 804864, 0, 0, 901120, 0, 0, 0, 1662, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 0, 383, 383,
  0, 0, 839680, 0, 669696, 0, 860160, 669696, 692224, 567296, 782336, 860160, 782336, 565248, 669696, 692224, 565248,
  565248, 749568, 782336, 804864, 843776, 860160, 901120, 673792, 565248, 565248, 804864, 565248, 565248, 565248,
  565248, 565248, 565248, 677888, 0, 704512, 866304, 0, 0, 0, 0, 565248, 565248, 565248, 565248, 708608, 710656, 565248,
  565248, 565248, 565248, 565248, 565248, 831488, 565248, 669696, 673792, 692224, 565248, 565248, 565248, 565248,
  749568, 782336, 804864, 843776, 565248, 860160, 565248, 565248, 0, 540672, 0, 0, 0, 0, 677, 681, 0, 667648, 0, 0,
  679936, 0, 565248, 901120, 0, 0, 0, 0, 813056, 0, 0, 0, 0, 1662, 0, 0, 798720, 0, 0, 0, 0, 395527, 395527, 395264, 0,
  0, 0, 0, 395527, 0, 0, 0, 0, 802, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 758, 759, 0, 0, 0, 917504, 716800, 716800, 565248,
  712704, 716800, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 897024, 565248, 565248, 0, 540672, 0,
  0, 81920, 0, 0, 0, 0, 667648, 0, 0, 679936, 0, 0, 0, 0, 399360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 712704,
  716800, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 897024, 0, 0, 0, 0, 815104, 0, 0, 0, 1662, 0,
  0, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 0, 565248, 565248, 565248,
  565248, 735232, 806912, 565248, 565248, 866304, 565248, 565248, 735232, 565248, 806912, 565248, 565248, 565248,
  866304, 700416, 0, 0, 0, 0, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  741376, 565248, 565248, 565248, 565248, 757760, 565248, 819200, 0, 0, 0, 663552, 565248, 565248, 565248, 565248,
  864256, 663552, 565248, 565248, 565248, 565248, 565248, 565248, 768000, 565248, 565248, 565248, 786432, 565248,
  565248, 817152, 823296, 565248, 864256, 706560, 0, 837632, 565248, 751616, 845824, 565248, 565248, 751616, 845824,
  565248, 763904, 714752, 565248, 714752, 306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 483, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 216, 0, 565248, 565248, 0, 540672, 676, 676, 0, 0, 0, 0, 0, 667648, 0, 0, 679936, 0, 0, 0,
  0, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 741376, 567296, 567296, 567296, 0, 0, 0,
  741376, 0, 757760, 765952, 0, 0, 784384, 790528, 796672, 0, 194, 55296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249,
  0, 194, 194, 194, 0, 0, 194, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 193, 540672, 22936, 195, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 530615, 8194, 3, 0, 187, 0, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 1670, 0, 289, 289,
  1673, 1674, 289, 289, 289, 0, 0, 0, 57344, 0, 57344, 57344, 0, 57344, 57344, 57344, 0, 0, 57344, 0, 0, 0, 0, 0, 0, 0,
  57344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 412, 0, 0, 0, 0, 57344, 0, 0, 0, 57344, 0, 0, 0, 57344, 57344, 57344,
  57344, 57344, 0, 0, 0, 57344, 57344, 0, 530615, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 194, 0, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0,
  671744, 0, 0, 0, 0, 61440, 61440, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 289, 289, 289, 0, 0, 61440, 61440, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 194, 194, 0, 0, 0, 61440, 0, 0, 32768, 34816,
  61440, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 1493, 1494, 0, 1496, 1497, 289, 1499, 289, 289, 289, 289, 0, 0, 0, 0, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1687, 61440, 61440, 61440, 0, 0, 61440, 1, 8194, 3, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 192, 192, 540672, 409, 410, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 289, 289, 1208, 195, 63488, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 436, 0, 540672, 194, 22939, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 404, 404,
  404, 192, 0, 0, 192, 192, 65728, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 32768, 34816, 192, 192, 192, 192,
  192, 30720, 192, 192, 192, 192, 65728, 192, 192, 65728, 65728, 65728, 192, 65728, 65728, 65728, 65728, 65728, 192,
  192, 192, 231, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 65728,
  192, 65728, 65728, 192, 192, 65728, 65728, 192, 192, 65728, 192, 192, 65728, 192, 192, 192, 192, 192, 192, 192, 192,
  192, 192, 192, 229, 192, 192, 65728, 192, 65728, 0, 0, 192, 192, 0, 65728, 192, 192, 65728, 65728, 192, 65728, 65728,
  65767, 65767, 65767, 65728, 65728, 65728, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 228, 228, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 573881, 573881, 573881, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 383, 383, 383, 383, 71680, 0, 0, 0, 71680, 71680, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 347, 347, 347, 347, 574,
  347, 0, 71680, 0, 0, 0, 0, 0, 71680, 0, 0, 0, 71680, 71680, 0, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 71680,
  71680, 71680, 0, 71680, 71680, 71680, 71680, 71680, 71680, 0, 0, 71680, 71680, 71680, 0, 8194, 3, 0, 59392, 0, 0, 0,
  0, 0, 199, 0, 199, 253, 199, 0, 0, 0, 0, 255, 199, 0, 0, 0, 73728, 0, 73728, 73728, 0, 0, 0, 73728, 73728, 73728,
  73728, 73728, 73728, 73728, 73728, 73728, 73728, 0, 73728, 73728, 73728, 73728, 73728, 73728, 0, 0, 0, 14718, 0, 0, 0,
  0, 0, 0, 73728, 73728, 14718, 14718, 14718, 73728, 73728, 14718, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 198, 0, 0, 0, 0, 0,
  0, 0, 0, 228, 228, 0, 671744, 0, 0, 0, 0, 565248, 565248, 565248, 770048, 565248, 565248, 565248, 565248, 565248,
  565248, 565248, 565248, 0, 14336, 565248, 565248, 0, 540672, 0, 0, 0, 194, 0, 0, 0, 667648, 0, 0, 679936, 0, 0, 0, 0,
  75776, 0, 75776, 75776, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 198, 198,
  198, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 75776,
  75776, 75776, 75776, 0, 75776, 75776, 75776, 75776, 75776, 0, 0, 0, 77824, 77824, 77824, 1, 8194, 3, 0, 0, 0, 0, 0, 0,
  0, 209, 210, 0, 0, 0, 0, 0, 0, 0, 216, 0, 0, 0, 0, 0, 0, 0, 0, 740, 0, 0, 692, 0, 0, 0, 0, 1, 184, 3, 0, 0, 188, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 359, 0, 0, 0, 289, 0, 0, 0, 0, 79872, 0, 79872, 79872, 0, 0, 0, 79872, 79872, 79872, 79872,
  79872, 79872, 1, 0, 3, 37050, 0, 407, 0, 0, 0, 0, 79872, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 79872, 79872,
  79872, 79872, 79872, 79872, 79872, 79872, 79872, 0, 79872, 79872, 79872, 79872, 79872, 0, 194, 195, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 497, 0, 0, 0, 0, 0, 0, 0, 717, 0, 719, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 364, 0, 0, 0, 289, 0, 0, 0,
  749, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 539, 0, 0, 15201, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 1133, 347, 347, 347, 347, 1413, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 0, 0, 0, 0, 0, 0, 1852, 0, 0, 1565, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 700, 0, 0, 0, 1588, 0,
  0, 0, 0, 0, 0, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1664, 0, 0, 0, 0, 0, 0, 0, 0, 289, 289,
  289, 289, 289, 289, 289, 775, 289, 289, 289, 289, 0, 0, 0, 1678, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 603, 0, 0, 347, 347, 347, 1690, 347, 347, 347, 347, 347, 347, 347, 1697, 383, 383, 383, 383, 0, 0, 0,
  0, 1457, 0, 0, 1460, 1461, 0, 0, 0, 383, 383, 1703, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  669, 383, 383, 347, 347, 1735, 347, 347, 1736, 347, 347, 347, 347, 347, 1739, 347, 347, 347, 347, 347, 347, 347, 1081,
  347, 347, 347, 1085, 347, 347, 347, 347, 347, 347, 347, 1269, 347, 347, 347, 347, 347, 347, 347, 347, 347, 862, 347,
  347, 15201, 807, 383, 383, 0, 0, 289, 347, 1769, 347, 347, 347, 347, 347, 347, 1775, 347, 347, 347, 383, 383, 1810,
  383, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 0, 1654, 0, 0, 0, 1779, 383, 383, 383, 383, 383, 383, 1785, 383, 383,
  383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 685, 0, 0, 687, 0, 0, 0, 1662, 0, 0, 0, 1798, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 1271, 347, 347, 347, 347, 347, 347, 1808, 383, 383, 383, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 347, 1856, 347, 347, 347, 347, 347, 347, 347, 347, 383, 1865, 383, 383, 0, 0, 0, 0, 0, 0, 0, 1762,
  0, 1662, 0, 0, 0, 0, 718, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 774144, 0, 0, 0, 821248, 0, 383, 347, 383, 347, 383, 347,
  383, 347, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1662, 0, 0, 84371, 84371, 84371, 0, 0, 84371, 1, 8194, 3, 37050, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 383, 383, 86016, 674, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 215, 0,
  0, 0, 0, 289, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  0, 0, 196, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 727, 0, 0, 0, 0, 0, 88371, 0, 88371, 88371, 0, 0, 0, 88371, 0, 0,
  88371, 0, 0, 0, 0, 196, 0, 0, 0, 0, 0, 0, 0, 0, 88371, 88371, 88371, 88371, 0, 88371, 88371, 0, 0, 88371, 88371,
  88371, 88371, 88371, 0, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 225, 0, 0, 0, 228, 0, 0, 0, 0, 0, 106496, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 687, 761, 567296, 0, 90112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 966, 0, 0, 404, 404, 404,
  0, 0, 404, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 0, 38912, 0, 0, 0, 0, 0, 0, 0, 0, 425, 0, 347, 347, 347, 347, 571,
  347, 193, 194, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1151, 0, 0, 383, 383, 674, 404, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 226, 0, 0, 0, 0, 0, 0, 0, 383, 674, 921, 0, 922, 0, 0, 0, 928, 0, 0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 289,
  0, 1732, 347, 347, 737, 984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 745, 0, 540672, 194, 195, 0, 96256, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 228, 217, 0, 0, 0, 0, 0, 0, 573882, 69632, 573882, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 0, 234,
  0, 0, 0, 0, 758321, 565809, 766513, 565809, 565809, 565809, 784945, 791089, 797233, 565809, 565809, 809521, 565809,
  827953, 565809, 565809, 565809, 565809, 733745, 565809, 565809, 565809, 565809, 565809, 565809, 565870, 565870,
  565870, 565870, 690798, 565870, 766574, 565870, 770670, 565870, 565870, 785006, 565870, 791150, 797294, 565870,
  565870, 809582, 565870, 565870, 828014, 0, 0, 800768, 0, 0, 0, 565248, 565809, 666161, 565809, 565809, 565809, 565809,
  565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 0, 0, 565809, 723505,
  565809, 565809, 565809, 739889, 565809, 565809, 565809, 754225, 565809, 565809, 565809, 565809, 565809, 795185,
  801329, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 893489, 565809,
  565809, 565809, 565809, 565809, 889393, 565809, 565809, 565809, 565809, 565809, 667648, 0, 565809, 565809, 565809,
  565809, 565809, 694833, 565809, 729649, 565809, 565809, 565809, 565809, 565809, 565809, 565870, 565870, 565870,
  682606, 684654, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 731758, 0, 565870, 666222,
  565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 723566, 565870, 565870, 565870, 0, 0,
  0, 0, 0, 0, 688128, 0, 0, 0, 0, 0, 0, 0, 73728, 0, 0, 0, 0, 0, 0, 0, 0, 228, 228, 0, 0, 0, 694, 0, 0, 565870, 565870,
  739950, 565870, 565870, 565870, 754286, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 795246, 801390,
  893550, 565870, 565870, 565870, 565870, 565870, 565870, 0, 544768, 0, 0, 0, 0, 0, 0, 0, 429, 0, 0, 0, 0, 0, 0, 0, 0,
  741, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1572, 0, 0, 0, 567296, 829440, 567296, 567296, 567296, 876544, 890880,
  899072, 911360, 0, 0, 0, 0, 890880, 899072, 565809, 565809, 565809, 823857, 565809, 565809, 565809, 565809, 565809,
  868913, 873009, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 786993, 565809, 817713,
  565809, 565809, 565809, 885297, 565809, 565809, 565809, 830001, 565809, 565809, 565809, 565809, 565809, 877105,
  891441, 899633, 565809, 565809, 911921, 565809, 565809, 690737, 565809, 703025, 565809, 565809, 565809, 565809,
  733745, 743985, 565809, 565809, 762417, 565809, 565809, 565809, 770609, 565809, 565809, 565809, 565809, 565809,
  565809, 565809, 565809, 0, 0, 565870, 565870, 0, 540672, 0, 0, 0, 0, 0, 0, 0, 667648, 0, 0, 679936, 0, 565870, 565870,
  703086, 565870, 565870, 565870, 565870, 565870, 733806, 744046, 565870, 565870, 565870, 762478, 565870, 565870,
  565870, 565870, 565870, 565870, 677888, 0, 704512, 866304, 0, 0, 0, 0, 565809, 565809, 565809, 565809, 709169, 711217,
  565809, 565809, 565809, 565809, 565809, 565809, 832049, 565870, 565870, 565870, 830062, 565870, 565870, 565870,
  565870, 565870, 565870, 565870, 877166, 565870, 891502, 565870, 899694, 565870, 565870, 911982, 565870, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 802816, 0, 825344, 567296, 858112, 567296, 874496, 0, 745472, 0, 0, 565809, 565809, 565809, 565809,
  565809, 565809, 565809, 565809, 565809, 565809, 565809, 741937, 565809, 565809, 565809, 746033, 565809, 772657,
  565809, 565809, 803377, 565809, 565809, 836145, 565809, 858673, 565809, 875057, 565809, 565809, 916017, 836206,
  565870, 565870, 858734, 565870, 565870, 875118, 883310, 565870, 565870, 565870, 916078, 0, 0, 0, 0, 0, 1657, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 395264, 228, 0, 395264, 0, 395264, 565870, 565870, 565870, 694894, 709230, 711278, 565870,
  565870, 729710, 565870, 565870, 565870, 565870, 565870, 565870, 832110, 686080, 780288, 0, 662065, 565809, 686641,
  565809, 565809, 565809, 725553, 565809, 780849, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809,
  565809, 883249, 565809, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 0, 696320, 0,
  0, 0, 565809, 903729, 565809, 725553, 565809, 756273, 565809, 565809, 565809, 565809, 565809, 662126, 565870, 565870,
  686702, 565870, 542720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 967, 0, 565870, 565870, 725614, 565870, 565870,
  756334, 780910, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 0, 0, 0, 0, 718848, 0, 0,
  903790, 0, 692224, 0, 0, 0, 804864, 0, 0, 901120, 0, 0, 0, 1662, 0, 0, 0, 347, 347, 347, 347, 347, 1803, 347, 347,
  347, 0, 0, 839680, 0, 669696, 0, 860160, 669696, 692224, 567296, 782336, 860160, 782336, 565809, 670257, 692785,
  565809, 565809, 750129, 782897, 805425, 844337, 860721, 901681, 674353, 565809, 565809, 805425, 565809, 565809,
  565809, 565809, 565809, 565809, 565809, 731697, 565809, 565809, 565809, 565809, 565809, 768561, 565809, 565809,
  565870, 670318, 674414, 692846, 565870, 565870, 565870, 565870, 750190, 782958, 805486, 844398, 565870, 860782,
  565870, 565870, 565870, 565870, 565870, 565870, 768622, 565870, 565870, 565870, 787054, 565870, 565870, 817774,
  823918, 565870, 565870, 901742, 0, 0, 0, 0, 813056, 0, 0, 0, 0, 1662, 0, 0, 798720, 0, 0, 0, 0, 702464, 761856, 0,
  911360, 0, 0, 720896, 0, 0, 0, 0, 0, 197, 198, 0, 197, 198, 0, 0, 197, 0, 0, 0, 917504, 716800, 716800, 565809,
  713265, 717361, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 897585, 565870, 565809, 565870,
  565809, 565870, 565809, 565870, 854577, 854638, 0, 0, 0, 0, 0, 0, 0, 444, 0, 0, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 1863, 383, 383, 383, 383, 713326, 717422, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870,
  897646, 0, 0, 0, 0, 815104, 0, 0, 0, 1662, 0, 0, 0, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809,
  565809, 565809, 621, 565870, 565870, 0, 0, 565809, 565809, 565809, 565809, 727601, 565809, 565809, 565809, 565809,
  565809, 565870, 565870, 727662, 565870, 565870, 565870, 565870, 565870, 565870, 868974, 873070, 565870, 565870,
  565870, 885358, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 675840, 0, 0, 0, 0, 0, 0, 833536, 905216,
  565809, 565809, 735793, 807473, 565809, 565809, 866865, 565870, 565870, 735854, 565870, 807534, 565870, 565870,
  565870, 866926, 700416, 0, 0, 0, 0, 565809, 565809, 565809, 565809, 565809, 565809, 565870, 565870, 565870, 565870,
  565870, 565870, 565870, 565870, 565870, 565870, 889454, 565870, 565870, 565870, 565870, 565870, 565870, 565870,
  565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 565870, 741998, 565870, 565870, 565870, 565870,
  758382, 565870, 819200, 0, 0, 0, 664113, 565809, 565809, 565809, 565809, 864817, 664174, 565870, 565870, 565870,
  565870, 565870, 565870, 565870, 746094, 565870, 565870, 772718, 565870, 565870, 803438, 565870, 565870, 864878,
  706560, 0, 837632, 565809, 752177, 846385, 565809, 565870, 752238, 846446, 565870, 763904, 715313, 565809, 715374, 0,
  100352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100352, 100352, 0, 100352, 100352, 100352, 100352, 100352, 100352, 100352, 100352,
  100352, 100352, 0, 100352, 100352, 100352, 100352, 100352, 100352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 500,
  38912, 0, 0, 0, 24576, 0, 0, 753664, 0, 794624, 0, 0, 0, 0, 653312, 0, 0, 0, 195, 0, 0, 0, 681984, 0, 0, 0, 0, 0, 0,
  0, 0, 289, 289, 1596, 289, 289, 289, 289, 289, 892928, 565248, 565248, 565248, 565248, 565248, 565248, 0, 544768, 194,
  0, 0, 0, 194, 0, 195, 195, 195, 0, 0, 195, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 63488, 0, 0, 565248, 565248,
  565248, 194, 0, 195, 0, 0, 0, 688128, 0, 0, 0, 0, 0, 0, 0, 403456, 0, 0, 0, 0, 0, 0, 0, 0, 1482, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 102708, 0, 102708, 102708, 0, 0, 0, 102708, 102708, 102708, 102708, 102708, 102708, 102708, 102708, 102708,
  102708, 0, 102708, 102708, 102708, 102708, 102708, 102708, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102805, 102805, 102805,
  102708, 102708, 102806, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 464, 497, 0, 347, 347, 347, 347, 570, 347, 567296, 0, 0,
  108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 0, 0, 0, 565248, 565248, 0, 540672, 0, 108544, 0, 0, 0, 0, 0, 667648,
  0, 0, 679936, 0, 0, 0, 228, 228, 228, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 205, 0, 0, 0, 0, 0, 1, 8194, 3, 0, 0, 0, 114688,
  0, 0, 0, 114688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 729, 0, 0, 0, 114688, 0, 114688, 114688, 0, 0, 0,
  114688, 114688, 114688, 114688, 114688, 114688, 114688, 114688, 114688, 114688, 0, 114688, 114688, 114688, 114688,
  114688, 0, 0, 0, 114688, 114688, 114688, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 494, 0, 541, 347, 563, 347, 347, 347, 347,
  540672, 194, 195, 0, 0, 98304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 366, 0, 0, 0, 289, 0, 567296, 53248, 0, 110592, 118784,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 0, 0, 0, 0, 565248, 565248, 0, 540672, 0, 110592, 0, 0, 0, 0, 0, 667648, 0, 0,
  679936, 0, 0, 0, 228, 228, 228, 0, 0, 0, 0, 0, 0, 0, 449, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 271, 30720, 271, 271,
  271, 0, 1, 8194, 3, 0, 0, 0, 0, 116736, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 1668, 0, 0, 0, 289, 289, 289, 289, 289, 289,
  289, 1027, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 544, 0, 0, 547, 0, 0, 0, 117045, 0, 117045, 117045, 0, 0, 0, 117045,
  117045, 117045, 117045, 117045, 117045, 117045, 117045, 117045, 117045, 0, 117045, 117045, 117045, 117045, 117045,
  117045, 0, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1179, 0, 0, 0, 0, 0, 117045, 117045, 117045, 1,
  8194, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 942, 0, 0, 0, 0, 0, 0, 0, 949, 0, 0, 0, 0, 957, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  463, 0, 0, 0, 0, 540672, 194, 195, 92160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 0, 567296, 0, 0, 0, 120832,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 238, 0, 0, 0, 0, 0, 0, 0, 12288, 0, 0, 0, 565248, 565248, 565248, 565248, 565248,
  565248, 565248, 565248, 565248, 565248, 565248, 0, 696320, 0, 0, 0, 1, 8194, 534713, 0, 0, 0, 0, 0, 189, 0, 0, 0, 189,
  0, 0, 0, 0, 973, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 433, 434, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 122880, 0, 0, 122880, 0,
  0, 0, 0, 0, 0, 0, 681984, 0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 233, 0, 199, 199, 233, 0, 0, 112640, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1152, 0, 565248, 565248, 0, 540672, 112640, 112640, 0, 0, 0, 0, 0, 667648, 0, 0, 679936, 0, 0, 0,
  228, 228, 228, 0, 0, 0, 0, 0, 447, 0, 0, 0, 0, 734, 0, 0, 0, 0, 0, 0, 690, 0, 0, 0, 0, 426, 427, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1190, 0, 0, 0, 0, 0, 126976, 126976, 126976, 0, 0, 126976, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 0, 0,
  479, 0, 0, 553, 0, 0, 289, 0, 289, 0, 0, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 541, 0, 0, 0, 0, 0, 383, 675, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1194, 0, 0, 0, 0, 131072, 0, 131072, 131072, 0, 0, 0, 131072, 0, 0, 131072, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 991, 0, 0, 131072, 131072, 131072, 131072, 0, 131072, 131072, 0, 0, 131072,
  131072, 131072, 131072, 131072, 0, 0, 0, 131072, 131072, 0, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 695, 0, 0, 0, 698, 0, 0,
  0, 0, 0, 0, 750, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1362, 0, 0, 747520, 737280, 755712, 759808, 0, 0, 847872, 0,
  894976, 0, 659456, 849920, 0, 0, 1662, 0, 0, 0, 228, 228, 228, 0, 0, 0, 0, 446, 0, 448, 0, 450, 0, 0, 0, 228, 228,
  228, 0, 0, 0, 445, 0, 0, 0, 0, 0, 451, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 133120, 0, 133120, 133120,
  133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 0, 133120, 133120, 133120, 133120, 133120, 133120, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1166, 0, 0, 0, 133120, 133120, 133120, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 709,
  228, 228, 0, 0, 0, 0, 712, 0, 903168, 0, 692224, 0, 0, 0, 804864, 0, 0, 901120, 0, 0, 0, 1724, 0, 0, 0, 0, 1577, 0, 0,
  1579, 0, 0, 0, 0, 0, 0, 1585, 0, 565248, 901120, 0, 0, 0, 0, 813056, 0, 0, 0, 0, 1764, 0, 0, 798720, 0, 0, 0, 228,
  228, 228, 0, 0, 444, 0, 0, 0, 0, 0, 0, 0, 1000, 0, 1002, 0, 0, 0, 289, 1006, 1007, 0, 0, 0, 1764, 0, 0, 0, 565248,
  565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248,
  565248, 0, 0, 233, 233, 0, 0, 32768, 34816, 233, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 1730, 0, 289, 289, 1731, 289, 289,
  0, 347, 347, 347, 383, 347, 347, 347, 347, 347, 347, 347, 347, 383, 383, 383, 1811, 383, 383, 383, 383, 383, 383, 0,
  0, 0, 0, 1821, 0, 283, 290, 310, 290, 310, 310, 290, 290, 290, 310, 329, 329, 310, 329, 329, 329, 329, 329, 329, 344,
  329, 329, 344, 348, 329, 329, 329, 290, 329, 369, 372, 372, 372, 384, 372, 372, 372, 372, 372, 372, 372, 372, 384,
  384, 384, 372, 372, 384, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55296, 0, 0,
  0, 194, 195, 0, 0, 0, 0, 413, 0, 0, 416, 417, 0, 0, 0, 0, 0, 1894, 347, 347, 347, 347, 347, 1900, 383, 383, 383, 383,
  0, 0, 0, 1456, 0, 0, 0, 0, 0, 0, 0, 0, 1331, 0, 0, 0, 0, 0, 0, 0, 438, 0, 0, 228, 228, 228, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 462, 0, 0, 0, 0, 0, 0, 0, 0, 485, 0, 0, 0, 0, 491, 0, 0, 495, 0, 0, 0, 499, 289, 289, 503, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 526, 289, 289, 289, 289, 1024, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  217, 289, 0, 0, 0, 0, 0, 533, 0, 0, 0, 0, 0, 0, 430, 0, 0, 0, 0, 1590, 0, 0, 0, 289, 289, 289, 289, 289, 289, 289,
  289, 0, 1029, 0, 0, 0, 1032, 0, 0, 0, 533, 0, 430, 0, 557, 558, 0, 0, 0, 347, 347, 564, 347, 347, 347, 347, 347, 347,
  347, 1884, 383, 383, 383, 383, 383, 383, 383, 383, 1125, 383, 383, 383, 383, 383, 383, 383, 0, 466, 499, 347, 564,
  347, 347, 347, 347, 614, 591, 594, 347, 0, 383, 383, 0, 0, 0, 0, 0, 0, 678, 682, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 804, 0, 0, 0, 0, 0, 0, 626, 383, 383, 383, 383, 383, 383, 383, 652, 383, 657, 383, 660, 383, 383, 671, 0,
  715, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1337, 0, 747, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1181, 0, 0,
  0, 765, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1017, 289, 289, 289, 289, 289, 289, 1011, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 785, 289, 289, 289, 289, 289, 1034, 0, 0, 0, 0, 0, 807,
  347, 347, 347, 347, 347, 347, 347, 347, 1045, 15201, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1100, 383, 383,
  383, 383, 0, 0, 1455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 978, 0, 0, 0, 0, 982, 0, 1142, 0, 0, 0, 0, 0, 0, 0, 0, 1147, 0, 0, 0,
  0, 0, 0, 241, 0, 242, 243, 0, 0, 0, 0, 0, 217, 1209, 289, 289, 289, 289, 289, 289, 289, 289, 1216, 289, 289, 289, 289,
  289, 289, 514, 289, 289, 289, 289, 524, 289, 289, 529, 289, 289, 289, 289, 289, 1226, 0, 0, 1228, 0, 0, 0, 1226, 347,
  347, 347, 1234, 347, 1236, 347, 1238, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1248, 383, 383, 383,
  1140, 0, 1142, 0, 0, 1318, 0, 0, 0, 0, 0, 1323, 0, 0, 0, 228, 228, 228, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 197, 198, 0,
  0, 0, 0, 0, 383, 1451, 383, 383, 0, 0, 0, 0, 0, 1458, 0, 0, 0, 0, 1462, 0, 0, 0, 228, 228, 94208, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 347, 347, 565, 347, 347, 347, 383, 383, 383, 1645, 383, 383, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1322, 0, 0,
  0, 0, 0, 1662, 1795, 0, 1797, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1070, 347, 347, 347, 347, 0, 0,
  0, 1825, 0, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 383, 1885, 383, 383, 383, 383, 383, 383, 383, 0, 1854,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 1279, 383, 1281, 383, 383, 1284, 383, 383, 383,
  383, 383, 383, 1546, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1707, 383, 383, 383, 383, 383, 383, 383, 202, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1475, 0, 0, 289, 0, 289, 0, 0, 289, 289, 289, 0, 0, 0, 266, 0, 0, 0, 0, 1656,
  0, 0, 0, 0, 0, 0, 0, 1660, 0, 0, 0, 0, 1342, 0, 0, 0, 0, 0, 1347, 0, 0, 0, 0, 0, 475, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1571, 0, 0, 0, 0, 0, 347, 1387, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 0, 0, 383, 383,
  1409, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 383, 383, 1422, 1423, 383, 0, 0, 0, 0, 0, 926, 0, 0, 0, 932,
  0, 0, 0, 0, 0, 534, 0, 0, 0, 0, 534, 0, 0, 0, 0, 0, 0, 0, 347, 347, 347, 568, 347, 347, 383, 383, 383, 1841, 383,
  1843, 383, 1845, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1721, 0, 0, 1662, 1725, 0, 0, 203, 204, 205, 206, 207, 208, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 289, 1675, 289, 0, 0, 205, 0, 32768, 34816, 0, 267, 267, 207, 268, 30720, 268,
  275, 275, 0, 0, 0, 248, 0, 0, 252, 0, 0, 0, 0, 0, 0, 248, 0, 257, 275, 284, 291, 311, 291, 311, 311, 291, 291, 291,
  325, 330, 330, 338, 330, 342, 343, 343, 343, 343, 343, 330, 343, 343, 330, 349, 343, 343, 343, 291, 343, 373, 373,
  373, 385, 373, 373, 373, 373, 373, 373, 373, 373, 385, 385, 385, 373, 373, 385, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0,
  289, 289, 1372, 289, 289, 289, 289, 1375, 289, 289, 807, 808, 810, 347, 347, 347, 815, 347, 819, 347, 347, 347, 347,
  347, 824, 347, 347, 347, 347, 347, 1253, 347, 347, 347, 347, 347, 347, 347, 347, 1260, 347, 347, 347, 347, 347, 1267,
  347, 347, 347, 347, 347, 347, 347, 1273, 347, 347, 347, 347, 347, 830, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 383, 1698, 383, 383, 383, 289, 289, 289, 1012, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  1016, 289, 289, 289, 289, 289, 1046, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1408,
  15201, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1101, 383, 383, 383, 0, 926, 0, 932, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1583, 0, 0, 0, 0, 0, 1184, 0, 0, 0, 0, 984, 0, 0, 0, 0, 0, 0, 0, 0, 988, 0, 0, 0, 0, 0, 0, 0,
  0, 1356, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 726, 0, 0, 0, 347, 347, 347, 1517, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 1071, 347, 347, 0, 0, 1603, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1613,
  1614, 347, 347, 347, 347, 347, 1389, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 383, 1421, 383, 383, 383,
  1822, 0, 0, 0, 0, 347, 347, 347, 347, 347, 1832, 347, 347, 347, 347, 383, 1809, 383, 383, 383, 1813, 383, 383, 383,
  383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1662, 0, 0, 0, 0, 383, 383, 1840, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 0, 0, 0,
  0, 347, 347, 0, 1890, 0, 0, 0, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1818,
  0, 1819, 0, 0, 235, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 250, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209, 0, 0, 0, 0, 0,
  223, 0, 0, 0, 0, 0, 228, 0, 0, 0, 0, 0, 0, 209, 258, 32768, 34816, 0, 235, 235, 258, 0, 30720, 0, 0, 0, 277, 0, 285,
  292, 312, 292, 312, 312, 292, 292, 292, 326, 331, 331, 339, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 350,
  331, 331, 331, 292, 331, 331, 374, 374, 374, 386, 374, 374, 374, 374, 374, 374, 374, 374, 386, 386, 386, 374, 374,
  386, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 289, 1371, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0,
  347, 347, 347, 347, 347, 580, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 0, 0, 347, 347, 347, 702,
  703, 0, 0, 0, 0, 0, 0, 228, 228, 0, 0, 0, 0, 0, 0, 428, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1359, 0, 0, 0, 0, 0, 0, 289, 289,
  289, 793, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 800, 807, 809, 347, 347, 347, 347, 347, 347, 347, 347, 347, 822, 347, 347,
  347, 347, 347, 347, 347, 1391, 347, 347, 347, 347, 347, 347, 347, 1396, 0, 0, 0, 972, 0, 0, 0, 0, 0, 0, 0, 0, 0, 981,
  0, 0, 0, 0, 1667, 0, 0, 0, 0, 289, 289, 289, 289, 289, 289, 289, 515, 289, 520, 289, 289, 289, 289, 527, 289, 289,
  1142, 0, 0, 0, 0, 0, 1145, 0, 0, 0, 0, 0, 0, 0, 0, 0, 431, 0, 0, 0, 0, 0, 0, 1235, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 1743, 1262, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 0, 460, 1314, 383, 383, 1140, 0, 1142, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1149, 0, 0, 0, 1153, 0, 1366, 1367, 0,
  0, 0, 1370, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 347, 1386, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 1543, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 1552, 1688, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 383, 383, 383,
  1283, 383, 383, 383, 383, 383, 383, 383, 1748, 383, 383, 383, 383, 383, 383, 383, 383, 921, 921, 922, 1140, 0, 0, 0,
  0, 928, 0, 211, 234, 213, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 725, 0, 0, 0, 0, 0, 0, 211, 0, 32768, 34816, 0, 0, 0,
  0, 0, 30720, 0, 0, 212, 0, 0, 0, 249, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 0, 0, 0, 0, 55557, 34816, 0, 0, 0, 0, 0, 30720,
  0, 0, 0, 0, 0, 1465, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 693, 0, 0, 0, 796, 0, 212, 286, 293, 313, 293, 322, 313, 293, 293,
  293, 313, 332, 332, 313, 332, 332, 332, 332, 332, 332, 345, 332, 332, 345, 351, 332, 332, 332, 293, 332, 332, 375,
  375, 375, 387, 375, 375, 375, 375, 375, 375, 375, 375, 387, 387, 387, 375, 375, 387, 1, 8194, 3, 37050, 0, 0, 0, 0, 0,
  0, 458, 0, 0, 0, 0, 0, 444, 0, 444, 0, 422, 423, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 435, 0, 0, 0, 0, 26624, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 57344, 57344, 0, 453, 0, 0, 0, 0, 0, 0, 0, 461, 0, 0, 0, 0, 0, 0, 489, 0, 0, 0, 0, 0,
  0, 426, 498, 0, 0, 468, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480, 0, 0, 0, 306, 0, 306, 306, 0, 0, 0, 306, 306, 306,
  306, 306, 306, 306, 306, 306, 306, 0, 306, 306, 306, 306, 306, 289, 289, 289, 505, 289, 289, 513, 289, 519, 289, 522,
  289, 525, 289, 289, 289, 0, 0, 0, 0, 796, 0, 0, 0, 0, 0, 0, 0, 0, 430, 0, 0, 0, 0, 0, 0, 0, 0, 0, 545, 0, 0, 468, 545,
  0, 0, 0, 496, 0, 537, 0, 552, 0, 347, 347, 567, 347, 347, 347, 588, 347, 595, 619, 0, 383, 383, 0, 0, 555, 545, 0, 0,
  0, 0, 0, 0, 347, 347, 347, 567, 347, 347, 347, 347, 347, 347, 1531, 347, 347, 347, 347, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 1285, 383, 383, 383, 383, 577, 347, 584, 347, 588, 347, 347, 593, 595, 347, 347, 347, 347, 347, 0,
  0, 0, 0, 32768, 34816, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 276, 383, 629, 383, 383, 640, 383, 649, 383, 653, 383, 383, 659,
  662, 666, 383, 383, 0, 0, 0, 0, 0, 1760, 0, 0, 0, 1662, 0, 1766, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 0, 30720, 0, 0,
  0, 279, 714, 0, 0, 0, 0, 0, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 539, 347, 347, 347, 347, 347, 347, 730, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1586, 0, 748, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1351, 0, 790, 289, 792, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1473, 0, 0, 0, 0, 0, 801, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 805, 806, 0, 798, 854, 347,
  347, 347, 857, 347, 347, 838, 347, 347, 347, 347, 15201, 807, 383, 383, 0, 0, 0, 1759, 0, 0, 0, 0, 0, 1662, 0, 0, 0,
  0, 556, 0, 0, 0, 0, 0, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 383, 902, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 912, 383, 383, 383, 918, 383, 675, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 934, 0, 936, 0, 0, 0, 306, 306, 306,
  1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 195, 195, 953, 0, 0, 0, 0, 958, 0, 0, 0, 0, 0, 964, 0, 0, 0,
  0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 432, 0, 0, 0, 0, 0, 0, 0, 0, 969, 0, 0, 0, 0, 0, 0, 976, 0, 0, 0, 0, 980,
  0, 0, 0, 0, 996, 0, 0, 0, 0, 0, 0, 0, 0, 289, 289, 1008, 289, 1021, 289, 289, 289, 289, 289, 289, 0, 0, 0, 1030, 0, 0,
  1033, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 347, 617, 347, 0, 383, 383, 0, 0, 0, 0, 0, 0, 679, 683, 0, 0, 0, 0,
  0, 0, 807, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1261, 347, 347, 347, 1048, 347,
  347, 347, 1051, 347, 347, 347, 347, 347, 347, 1057, 347, 347, 347, 347, 347, 1402, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 15201, 807, 866, 868, 347, 1059, 347, 1061, 1062, 347, 347, 347, 347, 1067, 347, 347, 347,
  347, 347, 347, 347, 347, 1417, 347, 347, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1287, 383, 383,
  347, 1075, 347, 347, 347, 347, 347, 347, 347, 1083, 1084, 347, 1086, 347, 347, 1089, 15201, 1090, 383, 1091, 383,
  1093, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1127, 383, 383, 383, 383, 383, 1104, 383, 383, 383, 1107, 383,
  383, 383, 383, 383, 383, 383, 1114, 383, 383, 383, 347, 347, 383, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 0, 753664, 0,
  794624, 0, 0, 0, 0, 653312, 0, 1117, 1118, 383, 1120, 1121, 383, 383, 383, 383, 1126, 383, 1128, 383, 383, 383, 383,
  383, 1746, 383, 383, 383, 383, 383, 383, 1752, 383, 383, 383, 383, 1134, 383, 383, 383, 383, 1139, 0, 0, 0, 1140, 0,
  0, 0, 0, 0, 238, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 757, 0, 0, 0, 688, 0, 0, 0, 0, 1199, 0, 1201, 0, 0, 1204, 0, 0, 0, 0,
  289, 289, 289, 289, 771, 289, 289, 289, 289, 289, 289, 289, 516, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0,
  1031, 0, 0, 0, 289, 289, 289, 1212, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1217, 289, 1218, 1219,
  289, 289, 289, 289, 289, 1225, 0, 0, 0, 0, 0, 0, 0, 0, 347, 347, 347, 347, 347, 347, 1833, 347, 347, 347, 383, 347,
  1263, 347, 347, 1266, 347, 1268, 347, 347, 347, 347, 347, 1272, 347, 347, 347, 347, 347, 347, 845, 347, 347, 347, 347,
  0, 0, 347, 347, 347, 347, 347, 347, 859, 347, 347, 347, 347, 347, 15201, 807, 867, 383, 383, 1302, 1303, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 887, 383, 383, 383, 1315, 383, 1140, 0, 1142, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 742, 0, 743, 0, 0, 0, 0, 0, 1326, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1338, 0, 0, 0, 1341, 0, 1343, 1344,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 692, 0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 1380, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 347,
  347, 1896, 1897, 347, 347, 383, 383, 1902, 1903, 383, 347, 1398, 347, 1400, 347, 347, 347, 347, 1405, 347, 347, 347,
  1406, 347, 347, 347, 347, 347, 347, 1050, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1069, 347, 347, 347, 1072,
  347, 347, 347, 1411, 347, 347, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 383, 383, 1282, 383, 383, 383,
  1286, 383, 1288, 383, 383, 1438, 383, 1440, 383, 383, 383, 383, 383, 383, 1447, 383, 383, 383, 383, 383, 383, 1634,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 1308, 383, 383, 1310, 383, 383, 383, 1450, 383, 383, 383, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1324, 0, 0, 1478, 0, 0, 0, 0, 0, 0, 1483, 1484, 0, 0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1176, 0, 0, 0, 0, 0, 1503, 289, 289, 289, 0, 0, 0, 1507, 347, 347, 347, 347, 1512, 347, 347, 347, 347, 347, 347, 1080,
  347, 347, 347, 347, 347, 347, 1087, 1088, 347, 347, 347, 347, 347, 1518, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 0, 732, 347, 347, 347, 383, 1541, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1550, 383, 383, 383,
  383, 875, 383, 879, 383, 383, 383, 383, 383, 885, 383, 383, 383, 0, 0, 0, 0, 1317, 0, 0, 0, 0, 0, 0, 0, 0, 1161, 0, 0,
  0, 0, 0, 0, 0, 1575, 0, 1576, 0, 0, 0, 1578, 0, 0, 0, 0, 0, 0, 0, 0, 0, 723, 0, 0, 0, 0, 0, 0, 1601, 1602, 0, 347,
  347, 1606, 347, 347, 347, 347, 347, 347, 1612, 347, 347, 347, 347, 347, 347, 1241, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 834, 347, 347, 347, 347, 347, 347, 1616, 1617, 1618, 347, 347, 347, 347, 1621, 347, 347, 347, 1626,
  347, 383, 383, 1278, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 0, 383, 1631, 383, 383,
  383, 383, 383, 383, 383, 1636, 383, 383, 1639, 383, 383, 383, 383, 876, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 897, 383, 383, 383, 383, 383, 383, 1644, 1646, 383, 1648, 1649, 0, 0, 0, 0, 1653, 0, 1655, 0, 0, 0, 0,
  32768, 34816, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 280, 347, 347, 1689, 347, 347, 347, 1692, 347, 347, 347, 347, 383, 383,
  1699, 383, 383, 0, 675, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 538, 0, 543, 0, 0, 1728, 0, 0, 0, 0, 0, 289, 289, 289,
  289, 289, 0, 347, 347, 347, 347, 347, 347, 1254, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1245, 347,
  347, 347, 347, 0, 0, 289, 347, 347, 347, 347, 347, 347, 1773, 347, 347, 347, 347, 347, 383, 0, 0, 0, 0, 347, 347, 347,
  347, 1912, 347, 383, 383, 383, 383, 1916, 383, 383, 383, 1781, 383, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 0, 0,
  1876, 0, 347, 347, 1792, 0, 0, 1662, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 838, 1807, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1817, 0, 0, 0, 0, 0, 457, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1333, 0, 0, 0, 0, 0, 383, 1839, 383, 383, 383, 383, 383, 383, 383, 1847, 1848, 0, 0, 0, 0, 0, 472, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 347, 0, 0, 0, 289, 0, 0, 0, 1855, 347, 347, 347, 347, 1859, 1860, 347, 347, 347, 1864, 383, 383, 1866,
  383, 1868, 383, 383, 383, 383, 0, 0, 0, 0, 0, 0, 0, 0, 347, 347, 347, 347, 1898, 347, 383, 383, 383, 383, 1904, 1905,
  0, 0, 0, 0, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 1280, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  911, 383, 383, 383, 383, 383, 383, 0, 236, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1363, 0, 0, 0, 236, 236, 32768,
  34816, 0, 0, 0, 236, 269, 30720, 269, 269, 269, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 347, 618, 347, 0, 383,
  383, 383, 1136, 383, 1138, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 935, 0, 0, 269, 269, 294, 0, 294, 0, 0, 294, 294,
  294, 236, 269, 269, 236, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 352, 269, 269, 269, 294, 269, 269, 376,
  376, 376, 388, 376, 376, 376, 376, 376, 376, 376, 376, 388, 388, 388, 376, 376, 388, 1, 8194, 3, 37050, 0, 0, 0, 0, 0,
  0, 753, 0, 0, 0, 0, 0, 0, 0, 0, 0, 756, 0, 0, 0, 0, 0, 0, 807, 347, 347, 347, 347, 347, 816, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 1420, 383, 383, 383, 383, 289, 289, 289, 1379, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0,
  0, 347, 1895, 347, 347, 347, 1899, 383, 1901, 383, 383, 383, 270, 270, 295, 314, 295, 314, 314, 295, 295, 295, 314,
  333, 333, 314, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 353, 333, 333, 333, 295, 333, 333, 353, 353, 353,
  389, 353, 353, 353, 353, 353, 353, 353, 353, 389, 389, 389, 353, 353, 389, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 799,
  746, 0, 0, 733, 0, 0, 0, 710, 799, 1476, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1663, 0, 0, 1665, 0, 0, 0, 1669,
  0, 0, 1672, 289, 289, 289, 289, 289, 289, 1014, 289, 289, 289, 289, 289, 1018, 289, 289, 289, 0, 0, 0, 347, 1679, 347,
  347, 347, 347, 347, 1683, 347, 347, 347, 1686, 347, 347, 347, 347, 347, 1414, 347, 347, 347, 347, 347, 383, 383, 383,
  383, 383, 383, 1747, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1558, 383, 383, 0, 0, 0, 0, 347, 1734, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 1740, 347, 347, 347, 347, 347, 347, 1390, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 1624, 347, 347, 383, 383, 0, 439, 0, 228, 228, 228, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1003, 0, 0, 289,
  289, 289, 482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1474, 0, 531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1486, 0, 0, 0, 0, 347, 565, 347, 347, 347, 347, 347, 347, 347, 347, 0, 383, 383, 383, 383, 1137, 383, 383, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 686, 0, 0, 627, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1714,
  672, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 937, 0, 0, 0, 705, 0, 0, 0, 0, 228, 228, 0, 0, 0, 0, 0, 0, 807,
  347, 347, 347, 347, 1041, 1042, 347, 1044, 347, 0, 0, 716, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 0, 0, 0, 347, 347,
  347, 347, 347, 347, 347, 616, 347, 599, 0, 383, 383, 383, 639, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 1448, 383, 383, 383, 0, 0, 1340, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1485, 0, 0, 1755, 383, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1662, 0, 0, 0, 0, 0, 811008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 220, 245, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 0,
  214, 0, 0, 0, 0, 0, 214, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 1610, 347, 347, 347, 347, 347, 347, 347, 860,
  347, 347, 347, 347, 15201, 807, 383, 383, 0, 0, 296, 315, 296, 315, 315, 296, 296, 296, 315, 334, 315, 315, 315, 315,
  315, 315, 346, 315, 315, 346, 354, 315, 315, 315, 296, 315, 315, 377, 377, 377, 390, 377, 377, 377, 377, 377, 377,
  377, 377, 390, 390, 390, 377, 377, 390, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 944, 0, 0, 946, 0, 0, 0, 0, 0, 0, 959, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1189, 0, 0, 0, 0, 0, 1195, 0, 0, 440, 228, 228, 228, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1148, 0, 0,
  0, 0, 0, 289, 289, 289, 506, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1381, 0, 0, 0, 0, 0, 347,
  289, 0, 0, 0, 0, 0, 0, 534, 0, 0, 0, 0, 0, 0, 0, 0, 739, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 347, 347, 568, 347, 347, 347,
  347, 347, 347, 347, 0, 383, 383, 383, 383, 1293, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1788, 0, 1790,
  0, 0, 383, 630, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 888, 383, 289, 289, 289, 780,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 784, 289, 289, 786, 289, 289, 289, 289, 289, 791, 289, 0,
  0, 0, 0, 0, 0, 0, 797, 0, 0, 0, 0, 0, 473, 0, 0, 0, 413, 0, 0, 0, 0, 0, 0, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 1,
  8194, 534713, 0, 0, 0, 0, 0, 0, 0, 532, 426, 560, 347, 562, 347, 347, 572, 347, 807, 347, 347, 347, 812, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 835, 347, 347, 347, 347, 347, 347, 828, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 1407, 347, 347, 383, 383, 871, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 1115, 383, 383, 383, 383, 890, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  1131, 1132, 383, 0, 0, 955, 0, 0, 0, 0, 0, 0, 0, 0, 0, 965, 0, 0, 0, 0, 1186, 0, 0, 984, 0, 0, 0, 0, 1192, 0, 0, 0, 0,
  1157, 0, 0, 0, 0, 0, 0, 0, 1163, 0, 0, 0, 0, 1171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 948, 0, 950, 951, 0, 0, 0, 971, 0,
  0, 0, 0, 0, 0, 0, 0, 979, 0, 0, 0, 0, 0, 876544, 567296, 567296, 567296, 702464, 567296, 567296, 733184, 567296,
  761856, 567296, 992, 0, 994, 0, 0, 0, 0, 0, 0, 0, 0, 1004, 0, 289, 289, 289, 0, 0, 795, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 565248, 289, 289, 289, 1023, 289, 289,
  289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 1232, 347, 347, 347, 1167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1177, 0, 0, 0, 0, 197, 0,
  1, 8194, 3, 0, 0, 0, 0, 0, 0, 69632, 0, 1183, 0, 0, 0, 0, 1188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 962, 0, 0, 0, 0, 0, 0, 347,
  347, 347, 1265, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1523, 347, 347, 0, 1339, 0, 0, 0, 0,
  0, 0, 0, 1346, 0, 0, 0, 1350, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 282, 289, 289, 1504, 289, 0, 0,
  0, 0, 347, 1509, 347, 1511, 347, 347, 347, 347, 347, 347, 347, 1404, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  1623, 347, 347, 347, 383, 383, 347, 1516, 347, 347, 347, 347, 347, 347, 347, 1521, 347, 1522, 347, 347, 347, 347, 347,
  347, 347, 1416, 347, 347, 347, 383, 383, 383, 383, 383, 1122, 1123, 383, 383, 383, 383, 383, 383, 383, 383, 383, 883,
  383, 383, 383, 383, 383, 383, 383, 1553, 383, 383, 1555, 383, 383, 383, 1557, 383, 383, 383, 1560, 0, 0, 0, 0, 1200,
  0, 0, 0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 289, 289, 1599, 289, 1587, 0, 0, 0, 0, 0, 1592, 0, 289, 289, 289, 289,
  1597, 289, 289, 289, 0, 794, 0, 0, 0, 0, 0, 0, 798, 0, 0, 0, 0, 692, 0, 0, 0, 696, 0, 0, 0, 0, 0, 0, 0, 984, 0, 0, 0,
  0, 0, 1193, 0, 0, 383, 1643, 383, 383, 383, 383, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 437, 0, 1793, 1794,
  1662, 0, 0, 0, 347, 347, 1800, 1801, 347, 347, 347, 1805, 1806, 1880, 1881, 347, 347, 347, 347, 347, 383, 383, 383,
  1886, 383, 1887, 383, 383, 383, 383, 891, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1549, 383, 383, 383,
  383, 383, 1924, 1925, 347, 383, 347, 383, 347, 383, 0, 0, 0, 0, 0, 0, 0, 1720, 0, 0, 0, 0, 1662, 0, 0, 271, 271, 297,
  316, 297, 316, 316, 297, 297, 297, 316, 335, 335, 316, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 355, 335,
  335, 335, 297, 335, 370, 355, 355, 355, 391, 355, 355, 355, 355, 355, 355, 355, 355, 391, 391, 391, 355, 355, 391, 1,
  8194, 3, 37050, 0, 0, 0, 0, 0, 0, 975, 0, 977, 0, 0, 0, 0, 0, 0, 0, 960, 0, 0, 0, 0, 0, 0, 0, 0, 460, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 424, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1584, 0, 0, 0, 0, 0, 347, 347, 347, 609, 347, 347, 347, 347,
  347, 347, 0, 383, 383, 383, 383, 1305, 383, 383, 383, 383, 383, 383, 383, 383, 1311, 383, 383, 383, 383, 1427, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1298, 383, 383, 383, 383, 383, 383, 632, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 1640, 1641, 383, 0, 0, 0, 689, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1573,
  0, 0, 763, 0, 0, 289, 289, 289, 769, 289, 289, 289, 289, 289, 289, 289, 289, 1013, 289, 289, 1015, 289, 289, 289, 289,
  1019, 289, 289, 807, 347, 347, 347, 347, 813, 347, 347, 347, 347, 347, 347, 347, 347, 347, 825, 347, 347, 841, 347,
  347, 347, 347, 347, 848, 347, 347, 0, 0, 347, 813, 347, 347, 347, 347, 347, 1530, 347, 347, 347, 347, 347, 1535, 383,
  383, 383, 383, 383, 1872, 0, 0, 0, 0, 0, 1875, 0, 1877, 347, 347, 938, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1661, 0, 0, 1009, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1221, 15201, 383,
  383, 383, 383, 383, 1095, 1096, 383, 383, 1099, 383, 383, 383, 383, 383, 383, 1844, 383, 1846, 0, 0, 0, 0, 0, 0, 0,
  737, 0, 0, 0, 0, 0, 0, 0, 0, 228, 228, 0, 0, 711, 693, 0, 0, 0, 0, 1155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84371,
  84371, 84371, 347, 1250, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1257, 347, 347, 347, 347, 347, 347, 347, 1520,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1534, 383, 1536, 383, 383, 1539, 0, 0, 0, 1464, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 988, 289, 289, 289, 0, 0, 0, 1491, 0, 0, 0, 0, 0, 289, 1498, 289, 289, 289, 289, 289, 1026, 289, 289,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 546, 548, 289, 289, 289, 289, 1505, 0, 0, 0, 347, 347, 1510, 347, 347, 347,
  347, 347, 347, 347, 846, 347, 347, 347, 0, 0, 347, 347, 347, 0, 0, 1589, 0, 0, 0, 0, 0, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 778, 1867, 383, 1869, 383, 383, 383, 0, 0, 0, 0, 0, 0, 0, 0, 1878, 347, 347, 347, 347, 587,
  347, 591, 347, 594, 347, 347, 601, 347, 347, 499, 0, 0, 0, 228, 228, 228, 0, 443, 0, 0, 0, 0, 0, 0, 0, 0, 1345, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 298, 317, 298, 317, 324, 298, 298, 298, 317, 317, 317, 317, 317, 317, 317, 317, 317, 317, 356,
  317, 317, 317, 298, 317, 317, 356, 356, 356, 392, 356, 356, 356, 356, 356, 356, 356, 356, 392, 392, 392, 356, 356,
  392, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 986, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 425, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1005, 289, 289, 289, 347, 581, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 0, 30720, 77824, 77824, 77824, 0, 77824, 0, 77824, 77824, 0, 0, 0, 77824,
  77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 0, 77824, 77824, 77824, 77824, 77824, 0, 0, 0, 347,
  347, 347, 610, 347, 581, 347, 347, 347, 347, 0, 383, 383, 383, 383, 1453, 1454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1582, 0,
  0, 0, 0, 0, 383, 383, 633, 383, 383, 645, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1637, 1638, 383, 383, 383,
  383, 347, 347, 347, 842, 347, 347, 347, 347, 347, 347, 347, 0, 0, 347, 852, 347, 347, 347, 347, 829, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 1055, 347, 347, 347, 347, 347, 347, 1077, 347, 1079, 347, 347, 1082, 347,
  347, 347, 347, 347, 347, 347, 347, 861, 347, 347, 347, 15201, 807, 383, 383, 15201, 383, 383, 383, 383, 383, 383, 383,
  1097, 383, 383, 383, 383, 383, 383, 1103, 1353, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126976, 126976, 126976,
  0, 1564, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665600, 567296, 567296, 0, 0, 289, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 1777, 347, 383, 0, 0, 0, 0, 924, 0, 0, 0, 930, 0, 0, 0, 0, 0, 0, 999, 0, 0, 0, 0, 0, 0, 289, 289,
  289, 770, 289, 289, 289, 289, 289, 289, 289, 289, 242, 242, 0, 259, 32768, 34816, 242, 0, 217, 259, 0, 30720, 0, 0, 0,
  0, 264, 264, 0, 0, 0, 0, 0, 264, 0, 0, 0, 0, 289, 767, 289, 289, 289, 289, 289, 289, 289, 289, 777, 289, 0, 0, 299,
  318, 299, 323, 323, 299, 299, 299, 327, 323, 323, 340, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 357, 323,
  323, 323, 299, 323, 323, 378, 378, 378, 393, 378, 378, 378, 378, 378, 378, 378, 378, 393, 393, 393, 378, 378, 393, 1,
  8194, 3, 37050, 0, 0, 0, 0, 0, 0, 1202, 0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 1373, 289, 289, 289, 289, 289, 289, 501,
  289, 289, 509, 289, 289, 517, 289, 289, 289, 523, 289, 289, 289, 530, 289, 0, 0, 0, 0, 532, 0, 0, 0, 0, 540, 0, 0, 0,
  0, 0, 474, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 947, 0, 0, 0, 0, 952, 549, 445, 0, 0, 0, 0, 0, 0, 532, 0, 0, 426, 0, 551, 0,
  498, 347, 582, 347, 347, 347, 589, 347, 347, 347, 347, 600, 347, 347, 347, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 222,
  30720, 222, 222, 222, 0, 532, 0, 0, 562, 347, 347, 572, 347, 582, 347, 347, 347, 347, 0, 383, 623, 383, 383, 634, 383,
  383, 646, 383, 383, 383, 655, 383, 383, 383, 383, 670, 383, 0, 0, 0, 0, 925, 0, 0, 0, 931, 0, 0, 0, 0, 0, 0, 1567, 0,
  0, 1570, 0, 0, 0, 0, 0, 0, 807, 347, 347, 347, 347, 347, 347, 1043, 347, 347, 0, 0, 690, 691, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1178, 0, 0, 0, 347, 347, 856, 347, 347, 347, 347, 347, 347, 347, 347, 347, 15201, 807, 383, 383, 383, 383,
  1647, 383, 383, 0, 0, 0, 1652, 0, 0, 0, 0, 0, 693, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 694, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  954, 0, 956, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1206, 289, 289, 289, 289, 1010, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 789, 289, 15201, 383, 383, 383, 383, 383, 383, 383, 383, 1098, 383, 383, 383, 383,
  383, 383, 1429, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1111, 383, 383, 383, 383, 383, 383, 0, 1197, 0, 0, 0, 0,
  0, 1203, 0, 0, 0, 0, 0, 1207, 289, 289, 289, 289, 1025, 289, 289, 1028, 0, 0, 0, 0, 0, 0, 0, 0, 987, 0, 0, 0, 0, 0, 0,
  0, 289, 289, 1224, 289, 0, 0, 0, 0, 0, 0, 1231, 0, 347, 1233, 347, 347, 347, 347, 347, 831, 347, 832, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 1738, 347, 347, 347, 347, 347, 1301, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 1312, 383, 0, 0, 0, 0, 1718, 0, 0, 0, 0, 0, 0, 0, 1662, 0, 0, 0, 347, 1799, 347, 347, 347, 347,
  1804, 347, 347, 1325, 0, 0, 0, 1328, 0, 0, 1330, 0, 0, 0, 1334, 0, 0, 0, 0, 432, 0, 0, 0, 0, 0, 347, 347, 347, 347,
  347, 347, 347, 1834, 347, 1836, 383, 1365, 0, 0, 1368, 0, 0, 289, 289, 289, 289, 289, 1374, 289, 289, 289, 1376, 289,
  289, 1378, 289, 289, 289, 289, 289, 289, 0, 0, 1383, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 347, 347, 620, 0,
  383, 383, 347, 1410, 347, 1412, 347, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 643, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 896, 383, 383, 898, 383, 900, 383, 1425, 383, 383, 383, 1428, 383, 1430, 383, 383, 383,
  383, 383, 383, 383, 1436, 1463, 0, 0, 0, 0, 0, 1466, 0, 1468, 0, 0, 0, 0, 0, 0, 0, 721, 0, 0, 0, 0, 0, 0, 0, 0, 494,
  0, 0, 0, 0, 541, 0, 0, 0, 1477, 0, 0, 0, 1480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1487, 0, 0, 1490, 0, 0, 0, 0, 0, 0, 289,
  289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 347, 347, 347, 347, 347, 347, 1514, 347, 347, 347, 1527, 347, 347, 347, 347,
  347, 347, 347, 347, 383, 383, 383, 383, 383, 644, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1309, 383, 383,
  383, 383, 383, 0, 0, 0, 347, 1605, 347, 347, 347, 347, 347, 347, 1611, 347, 347, 347, 347, 347, 347, 347, 1693, 347,
  347, 347, 383, 383, 383, 383, 1700, 1615, 347, 347, 347, 347, 347, 347, 347, 347, 1622, 347, 347, 347, 347, 383, 1629,
  1642, 383, 383, 383, 383, 383, 383, 0, 0, 1651, 0, 0, 0, 0, 0, 0, 1329, 0, 0, 0, 0, 0, 1335, 1336, 0, 0, 0, 0, 0, 347,
  347, 347, 1680, 1681, 1682, 347, 347, 347, 347, 347, 347, 347, 347, 1052, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  1737, 347, 347, 347, 347, 347, 347, 1701, 1702, 383, 383, 383, 383, 383, 383, 383, 383, 1709, 383, 383, 383, 383, 383,
  647, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1307, 383, 383, 383, 383, 383, 383, 383, 1727, 0, 0, 0, 0, 0,
  0, 289, 289, 289, 289, 289, 0, 347, 347, 347, 347, 347, 347, 1403, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  850, 0, 0, 347, 814, 347, 0, 0, 289, 347, 347, 347, 347, 347, 347, 347, 1774, 347, 347, 347, 347, 383, 0, 0, 0, 347,
  347, 347, 347, 383, 383, 383, 383, 0, 347, 347, 383, 1277, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 1712, 383, 383, 383, 347, 383, 347, 383, 1928, 1929, 347, 383, 0, 0, 0, 0, 0, 0, 0, 754, 0, 0, 0, 0, 0, 0, 0, 0,
  755, 0, 0, 0, 0, 0, 0, 694, 218, 219, 220, 221, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0, 0, 486, 0, 0, 0, 492, 493, 0, 0,
  496, 0, 0, 0, 0, 0, 220, 0, 32768, 34816, 0, 221, 221, 219, 220, 30720, 220, 220, 220, 0, 0, 0, 347, 347, 347, 347,
  347, 347, 1608, 347, 347, 347, 347, 347, 347, 347, 347, 1270, 347, 347, 347, 347, 347, 347, 347, 347, 1392, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 1418, 347, 383, 383, 383, 383, 383, 220, 287, 300, 319, 300, 319, 319, 300, 300,
  300, 328, 336, 336, 341, 336, 336, 336, 336, 336, 336, 336, 336, 336, 336, 358, 336, 336, 336, 300, 336, 336, 358,
  358, 358, 394, 358, 358, 358, 358, 358, 358, 358, 358, 394, 394, 394, 358, 358, 394, 1, 8194, 3, 37050, 0, 0, 0, 0, 0,
  0, 1357, 0, 0, 0, 0, 0, 0, 0, 0, 0, 697, 0, 0, 699, 0, 0, 0, 0, 194, 195, 0, 0, 0, 0, 0, 414, 0, 0, 0, 418, 419, 420,
  421, 452, 0, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1349, 0, 0, 0, 0, 0, 469, 0, 0, 0, 0, 0, 0, 414, 476, 477,
  478, 0, 0, 0, 0, 1369, 0, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 1382, 0, 0, 0, 0, 1385, 289, 289, 504,
  289, 289, 512, 289, 289, 289, 521, 289, 289, 289, 289, 528, 289, 0, 0, 0, 0, 0, 0, 0, 0, 537, 0, 542, 0, 545, 0, 0, 0,
  0, 32768, 34816, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 1187, 0, 984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 990, 0, 0, 0, 0,
  0, 550, 420, 0, 469, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 484, 0, 0, 0, 0, 347, 347, 347, 586, 347, 347, 347, 347, 596,
  598, 347, 347, 347, 347, 0, 547, 554, 0, 469, 0, 484, 484, 0, 0, 0, 347, 347, 566, 569, 347, 576, 0, 0, 0, 347, 607,
  608, 347, 576, 347, 615, 347, 596, 598, 0, 383, 383, 383, 383, 1705, 383, 383, 383, 383, 1708, 383, 383, 383, 383,
  383, 383, 908, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1446, 383, 383, 383, 383, 383, 383, 628, 631, 383, 638,
  383, 383, 383, 651, 654, 383, 383, 383, 663, 667, 383, 383, 383, 383, 1745, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 1753, 383, 289, 779, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1220, 289, 347, 827,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 459, 0, 889, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 1754, 383, 903, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 916,
  383, 383, 383, 383, 1782, 383, 1784, 383, 383, 383, 383, 0, 0, 0, 0, 0, 0, 0, 0, 1763, 1662, 0, 0, 0, 0, 0, 0, 0, 985,
  0, 474, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1470, 0, 0, 0, 0, 0, 0, 1035, 0, 0, 0, 0, 807, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 826, 383, 383, 1135, 383, 383, 383, 383, 0, 0, 0, 0, 0, 1141, 0, 679, 0, 0, 0,
  347, 347, 347, 347, 347, 347, 1609, 347, 347, 347, 347, 347, 347, 347, 347, 1533, 347, 347, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 0, 0, 0, 1820, 0, 0, 0, 1143, 0, 683, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 989, 0, 0, 0, 0, 383,
  383, 383, 1292, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 0, 0, 1562, 0, 0, 0, 0, 347, 347, 347,
  1607, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 863, 347, 15201, 807, 383, 383, 383, 383, 1632, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 0, 1561, 0, 0, 1744, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 899, 383, 0, 0, 289, 347, 347, 347, 347, 347, 1772, 347, 347, 347, 347, 347, 347, 383,
  0, 0, 0, 347, 347, 347, 347, 383, 383, 383, 383, 0, 347, 1922, 383, 0, 0, 0, 347, 347, 347, 1919, 383, 383, 383, 1921,
  0, 347, 347, 383, 0, 0, 0, 0, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 1313, 383, 383, 1780, 383, 383, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 0, 0, 1459, 0, 0, 0, 0,
  0, 0, 0, 1891, 0, 1893, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 878, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 1124, 383, 383, 383, 383, 383, 383, 383, 383, 909, 383, 383, 383, 383, 383, 383, 383, 383, 882, 383,
  383, 383, 383, 383, 383, 383, 383, 347, 383, 1926, 1927, 347, 383, 347, 383, 0, 0, 0, 0, 0, 0, 0, 984, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1165, 0, 254, 254, 0, 260, 32768, 34816, 254, 0, 0, 260, 0, 30720, 0, 0, 0, 281, 0, 0, 289,
  0, 289, 0, 0, 289, 289, 289, 260, 0, 0, 260, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 270, 30720, 270, 270, 270, 278, 0,
  379, 379, 379, 395, 379, 379, 379, 379, 379, 379, 379, 379, 395, 395, 395, 379, 379, 395, 1, 8194, 3, 37050, 0, 0, 0,
  0, 0, 0, 1481, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1469, 0, 0, 1472, 0, 0, 0, 347, 855, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 864, 15201, 807, 383, 383, 383, 383, 1842, 383, 383, 383, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1321, 0, 0, 0, 1196, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 289, 289, 289, 289, 383, 383, 1291, 383, 383, 1294, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 1787, 383, 0, 0, 0, 1791, 0, 0, 0, 0, 1327, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 104448, 0, 0, 0, 347, 347, 1399, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1247, 347,
  383, 383, 1439, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 661, 383, 383, 383, 383, 383, 1756,
  0, 1758, 0, 0, 0, 0, 0, 0, 1662, 1765, 0, 0, 1767, 0, 0, 0, 1662, 0, 1796, 0, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 1068, 347, 347, 347, 347, 347, 289, 0, 0, 0, 0, 0, 0, 0, 535, 0, 0, 0, 0, 0, 0, 0, 0, 0, 535, 0, 0, 0, 0,
  383, 383, 635, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 665, 383, 383, 383, 383, 673, 0, 0, 0,
  0, 0, 0, 680, 684, 0, 0, 0, 0, 0, 0, 71680, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71680, 71680, 71680, 0, 0, 0, 347, 347, 347,
  347, 1691, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 907, 383, 383, 383, 383, 383, 383, 383, 383, 917,
  383, 383, 383, 383, 1704, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 914, 383, 383, 383, 0, 0, 222,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 222, 301, 0, 301, 0, 0, 301, 301, 301, 0, 222, 222, 0, 222, 222, 222,
  222, 222, 222, 222, 222, 222, 222, 360, 222, 222, 222, 301, 222, 222, 360, 360, 360, 396, 360, 360, 360, 360, 360,
  360, 360, 360, 396, 396, 396, 360, 360, 396, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 100352, 100352, 0, 0, 100352,
  100352, 0, 0, 0, 0, 0, 0, 0, 455, 456, 0, 0, 0, 0, 0, 0, 0, 0, 465, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 0, 272, 30720,
  272, 272, 272, 0, 0, 0, 0, 470, 0, 0, 0, 0, 0, 0, 0, 0, 0, 479, 0, 0, 0, 0, 32768, 34816, 0, 0, 0, 225, 0, 30720, 0,
  0, 0, 0, 766, 289, 289, 289, 289, 289, 289, 289, 776, 289, 289, 289, 578, 347, 347, 347, 347, 590, 592, 347, 347, 599,
  347, 347, 347, 347, 0, 548, 0, 0, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 744, 0, 0, 0, 0, 32768, 34816, 0, 266, 266, 0, 0,
  30720, 0, 0, 0, 0, 0, 71680, 71680, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 212, 213, 0, 0, 0, 0, 901, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1449, 383, 0, 970, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  114688, 0, 0, 0, 1074, 347, 1076, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1274, 347,
  15201, 383, 383, 383, 1092, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1710, 383, 383, 383, 383, 0, 0, 0,
  1170, 0, 0, 1172, 0, 1174, 0, 0, 0, 0, 0, 1180, 0, 0, 0, 347, 347, 347, 347, 347, 580, 347, 347, 347, 347, 0, 383,
  383, 0, 0, 0, 0, 0, 0, 1761, 0, 0, 1662, 0, 0, 0, 0, 222, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0, 0, 262, 262, 0, 0, 0, 0, 0,
  262, 0, 0, 0, 0, 0, 1566, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 724, 0, 0, 0, 0, 0, 0, 0, 0, 1185, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1191, 0, 0, 0, 0, 1249, 347, 347, 347, 1252, 347, 347, 1255, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 1696, 383, 383, 383, 383, 383, 347, 347, 1264, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 1524, 347, 383, 383, 383, 1304, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1130, 383, 383, 383,
  383, 383, 1316, 0, 0, 0, 0, 0, 0, 0, 0, 1320, 0, 0, 0, 0, 533, 0, 0, 0, 0, 416, 0, 0, 0, 0, 0, 0, 211, 232, 0, 232, 0,
  0, 0, 0, 0, 0, 224, 0, 0, 0, 0, 228, 0, 0, 0, 0, 383, 383, 383, 1426, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 1299, 383, 383, 383, 0, 0, 0, 1604, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 602,
  347, 0, 0, 0, 0, 289, 1768, 347, 347, 347, 347, 347, 347, 347, 347, 1776, 347, 347, 1778, 0, 0, 1824, 0, 1826, 347,
  1828, 347, 347, 347, 347, 347, 347, 347, 347, 383, 0, 0, 0, 923, 0, 0, 0, 929, 0, 0, 0, 0, 0, 0, 0, 1467, 0, 0, 0, 0,
  0, 0, 0, 0, 961, 0, 963, 0, 0, 0, 0, 968, 1838, 383, 383, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 0, 0, 0, 1319, 0,
  0, 0, 0, 0, 1853, 0, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 641, 383, 383, 383, 383,
  656, 658, 383, 383, 668, 383, 383, 383, 0, 1917, 0, 347, 347, 347, 347, 383, 383, 383, 383, 0, 347, 347, 383, 0, 0, 0,
  1918, 347, 347, 347, 1920, 383, 383, 383, 0, 347, 347, 383, 0, 0, 0, 0, 347, 347, 1910, 1911, 347, 347, 383, 383,
  1914, 1915, 383, 0, 0, 0, 0, 347, 1909, 347, 347, 347, 347, 383, 1913, 383, 383, 383, 383, 906, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 913, 383, 383, 383, 383, 272, 288, 302, 0, 302, 0, 223, 302, 302, 302, 0, 288, 288,
  0, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 361, 288, 288, 288, 302, 367, 371, 380, 380, 380, 397, 380, 380,
  380, 380, 380, 380, 380, 380, 397, 397, 397, 380, 380, 397, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 395264, 0, 0, 395264,
  0, 0, 0, 395264, 395264, 0, 0, 0, 0, 0, 395264, 395264, 0, 0, 0, 0, 0, 194, 195, 0, 0, 0, 412, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1332, 0, 0, 0, 0, 0, 0, 289, 502, 289, 289, 289, 289, 289, 518, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0,
  1229, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1685, 347, 347, 347, 583, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 0, 0, 0, 0, 32768, 63753, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 1591, 0, 0, 1594,
  289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 347, 347, 347, 347, 347, 347, 347, 1515, 604, 0, 0, 563, 347, 347, 347,
  347, 583, 347, 347, 347, 347, 0, 383, 624, 762, 0, 0, 0, 289, 289, 768, 289, 772, 289, 774, 289, 289, 289, 289, 289,
  0, 0, 0, 0, 1508, 347, 347, 347, 347, 347, 347, 347, 347, 1066, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1695,
  347, 383, 383, 383, 383, 383, 807, 347, 347, 811, 347, 347, 817, 347, 347, 820, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 15201, 807, 383, 383, 383, 870, 383, 383, 877, 383, 383, 881, 383, 383, 383, 383, 383, 383, 383,
  383, 1431, 383, 383, 383, 383, 383, 383, 383, 0, 939, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1348, 0, 0, 0, 1352,
  0, 0, 0, 939, 0, 0, 807, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 823, 347, 347, 0, 0, 0, 1156, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1360, 1361, 0, 0, 1364, 0, 0, 1198, 0, 0, 0, 0, 0, 0, 0, 0, 1205, 0, 289, 289, 289,
  289, 511, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 781, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 0, 0, 1506, 0, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1419, 383, 383, 383, 383, 383, 347, 347,
  1251, 347, 347, 347, 347, 347, 1256, 347, 347, 347, 347, 347, 347, 347, 347, 1242, 1243, 347, 347, 347, 347, 347, 347,
  1275, 1276, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1551, 383, 1377, 289, 289, 289, 289,
  289, 289, 289, 289, 0, 0, 0, 1384, 0, 0, 347, 347, 1857, 1858, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383,
  1783, 383, 383, 383, 383, 383, 0, 1789, 0, 0, 0, 1397, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 837, 347, 1437, 383, 383, 383, 383, 383, 1443, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1547, 383,
  383, 383, 383, 383, 383, 383, 0, 1489, 0, 0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 289, 289, 289, 0, 1227, 0, 0, 0, 0, 0,
  0, 347, 347, 347, 347, 1831, 347, 347, 347, 347, 347, 383, 347, 347, 347, 347, 1529, 347, 347, 1532, 347, 347, 347,
  383, 383, 383, 383, 383, 1306, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1548, 383, 383, 383, 383, 383, 383,
  383, 383, 1554, 383, 383, 383, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 926, 0, 0, 0, 0, 0, 0, 0, 1666, 0, 0, 0, 0,
  1671, 289, 289, 289, 289, 289, 289, 1676, 383, 1715, 0, 0, 1717, 0, 0, 0, 0, 0, 0, 1722, 0, 1662, 0, 1726, 0, 0, 289,
  347, 347, 347, 1770, 1771, 347, 347, 347, 347, 347, 347, 347, 383, 0, 0, 1716, 0, 0, 0, 0, 0, 0, 0, 0, 1723, 1662, 0,
  0, 0, 0, 32768, 34816, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 100352, 100352, 100352, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 459, 0,
  0, 0, 0, 464, 0, 464, 0, 0, 1823, 0, 0, 0, 1827, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1837, 383, 383, 383,
  1870, 383, 383, 0, 1873, 0, 0, 0, 0, 0, 0, 347, 1879, 0, 0, 303, 320, 303, 320, 320, 303, 303, 303, 320, 337, 337,
  320, 320, 320, 320, 320, 320, 337, 320, 320, 337, 362, 320, 320, 320, 303, 368, 320, 381, 381, 381, 398, 381, 381,
  381, 381, 381, 381, 381, 381, 398, 398, 398, 381, 381, 398, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 397312, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 567296, 567296, 567296, 567296, 567296, 745472, 567296, 467, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  481, 289, 0, 0, 0, 0, 0, 0, 0, 0, 538, 0, 543, 0, 0, 0, 0, 706, 0, 708, 0, 228, 228, 0, 0, 0, 0, 0, 0, 736, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 244, 0, 0, 0, 244, 0, 0, 579, 347, 585, 347, 347, 347, 347, 347, 597, 347, 347, 347, 347, 347, 500,
  0, 0, 0, 347, 347, 347, 347, 347, 612, 347, 347, 347, 347, 0, 383, 383, 0, 1757, 0, 0, 0, 0, 0, 0, 0, 1662, 0, 0, 0,
  0, 487, 0, 0, 490, 0, 0, 0, 0, 0, 0, 0, 0, 722, 0, 0, 0, 0, 0, 0, 0, 0, 543, 605, 606, 347, 347, 347, 347, 613, 347,
  347, 597, 347, 0, 383, 625, 688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 701, 0, 0, 704, 0, 0, 0, 0, 0, 228, 228,
  710, 0, 0, 0, 0, 0, 488, 0, 0, 0, 0, 0, 0, 0, 0, 433, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 741, 0, 0, 0, 0, 0, 746, 0, 0,
  764, 0, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 507, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 1214, 1215, 289, 289, 289, 289, 289, 289, 289, 289, 839, 840, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  0, 0, 851, 347, 347, 347, 347, 347, 858, 347, 347, 347, 347, 347, 347, 15201, 807, 383, 383, 383, 383, 1544, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 1433, 383, 383, 383, 383, 869, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 1713, 383, 383, 383, 904, 905, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 1434, 383, 383, 383, 0, 0, 940, 0, 0, 0, 0, 945, 0, 0, 0, 0, 0, 0, 0, 0, 1146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  940, 1036, 1029, 807, 347, 347, 347, 1040, 347, 347, 347, 347, 347, 347, 347, 847, 347, 347, 347, 0, 0, 347, 347, 347,
  347, 347, 347, 347, 1049, 347, 347, 347, 347, 347, 347, 347, 347, 1056, 347, 347, 347, 347, 347, 1063, 347, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 15201, 807, 383, 383, 15201, 383, 383, 383, 383, 1094, 383, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 1749, 383, 1750, 1751, 383, 383, 383, 383, 383, 1105, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 1113, 383, 383, 383, 383, 642, 648, 650, 383, 383, 383, 383, 383, 664, 383, 383, 383, 0, 1168, 1169, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1471, 0, 0, 0, 0, 289, 1210, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 508, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1213, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 1222, 1223, 289, 289, 0, 0, 0, 0, 0, 1230, 0, 0, 347, 347, 347, 347, 347, 347, 347, 347, 1862,
  347, 383, 383, 383, 383, 347, 347, 1237, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1628,
  383, 0, 1354, 1355, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 61440, 61440, 61440, 347, 347, 347, 1388,
  347, 347, 347, 347, 347, 347, 347, 1393, 347, 347, 1395, 347, 347, 347, 347, 843, 347, 347, 347, 347, 347, 347, 0,
  765, 347, 347, 347, 347, 347, 347, 844, 347, 347, 849, 347, 0, 0, 347, 347, 347, 347, 347, 347, 347, 1861, 347, 347,
  383, 383, 383, 383, 1812, 383, 1814, 1815, 1816, 383, 0, 0, 0, 0, 0, 0, 1719, 0, 0, 0, 0, 0, 1662, 0, 0, 0, 347, 347,
  347, 347, 1802, 347, 347, 347, 347, 347, 347, 347, 347, 1401, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 1258, 1259, 347, 347, 1424, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1432, 383, 383, 383, 1435, 383, 0, 0,
  1907, 0, 347, 347, 347, 347, 347, 347, 383, 383, 383, 383, 383, 892, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  1445, 383, 383, 383, 383, 383, 383, 383, 1488, 0, 0, 0, 1492, 0, 0, 0, 0, 289, 289, 289, 1500, 289, 289, 289, 289,
  782, 289, 783, 289, 289, 289, 289, 289, 787, 788, 289, 289, 347, 1526, 347, 1528, 347, 347, 347, 347, 347, 347, 347,
  383, 383, 383, 383, 383, 1442, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1112, 383, 383, 383, 383, 383, 1540,
  383, 1542, 383, 383, 1545, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 0, 1650, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0,
  0, 0, 0, 247, 248, 0, 347, 347, 347, 347, 1619, 347, 1620, 347, 347, 347, 347, 347, 347, 1627, 383, 383, 383, 872,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 886, 383, 383, 383, 383, 1441, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 1786, 383, 383, 0, 0, 0, 0, 0, 1630, 383, 383, 383, 383, 383, 383, 1635, 383, 383, 383, 383, 383, 383,
  383, 383, 880, 383, 383, 383, 884, 383, 383, 383, 383, 0, 0, 1677, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1684,
  347, 347, 347, 347, 347, 347, 1415, 347, 347, 347, 347, 383, 383, 383, 383, 383, 893, 383, 383, 895, 383, 383, 383,
  383, 383, 383, 383, 0, 0, 0, 1140, 0, 0, 0, 0, 0, 0, 0, 0, 1729, 0, 0, 0, 289, 289, 289, 289, 289, 0, 347, 347, 347,
  347, 347, 347, 1519, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1054, 347, 347, 347, 347, 1733, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1741, 347, 347, 347, 347, 347, 1240, 347, 347, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 383, 383, 383, 1538, 383, 347, 347, 347, 347, 1882, 1883, 347, 383, 383, 383, 383, 383, 383,
  1888, 1889, 383, 0, 920, 749, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 0, 214, 0, 0, 0, 0, 1892, 0, 347, 347, 347,
  347, 347, 347, 383, 383, 383, 383, 383, 1556, 383, 383, 383, 383, 383, 383, 0, 0, 0, 0, 1874, 0, 0, 0, 347, 347, 1923,
  347, 383, 347, 383, 347, 383, 347, 383, 0, 0, 0, 0, 0, 0, 0, 1173, 0, 0, 0, 0, 0, 0, 0, 0, 559, 0, 347, 347, 347, 347,
  575, 347, 0, 0, 304, 321, 304, 321, 321, 304, 304, 304, 321, 321, 321, 321, 321, 321, 321, 321, 321, 321, 363, 321,
  321, 321, 304, 321, 321, 363, 363, 363, 399, 363, 363, 363, 363, 363, 363, 363, 363, 399, 399, 399, 363, 363, 399, 1,
  8194, 3, 37050, 0, 0, 0, 0, 0, 0, 707, 0, 0, 228, 228, 0, 0, 0, 0, 0, 713, 0, 0, 0, 471, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 100352, 0, 0, 0, 0, 0, 0, 0, 743, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102674, 0, 0, 0, 0, 807, 347, 347, 347,
  347, 814, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 760, 0, 347, 347, 853, 919, 0, 0, 0, 0, 0, 0, 927, 0,
  0, 0, 933, 0, 0, 0, 0, 751, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 239, 0, 0, 0, 256, 0, 993, 0, 995, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 289, 289, 289, 289, 289, 289, 1502, 289, 289, 1022, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 799, 0, 0,
  0, 0, 0, 0, 947, 0, 0, 0, 807, 347, 347, 347, 347, 347, 347, 347, 347, 347, 821, 347, 347, 347, 347, 347, 347, 347,
  1047, 347, 347, 347, 347, 347, 347, 347, 1053, 347, 347, 347, 347, 347, 347, 347, 1065, 347, 347, 347, 347, 347, 347,
  347, 1073, 1058, 347, 347, 347, 347, 347, 1064, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1244, 347, 1246,
  347, 347, 347, 347, 347, 347, 347, 1078, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1394, 347, 347,
  347, 15201, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1102, 383, 0, 1906, 0, 1908, 347, 347,
  347, 347, 347, 347, 383, 383, 383, 383, 383, 1108, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1559, 383, 0, 0,
  0, 0, 289, 289, 1211, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 510, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 347, 347, 347, 347, 347, 1513, 347, 347, 347, 347, 347, 347, 1239, 347, 347,
  347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1625, 347, 383, 383, 1525, 347, 347, 347, 347, 347, 347, 347, 347,
  347, 347, 383, 383, 1537, 383, 383, 383, 874, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 894, 383,
  383, 383, 383, 383, 383, 383, 383, 1110, 383, 383, 383, 383, 383, 383, 1116, 0, 0, 237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 671744, 0, 0, 0, 0, 0, 0, 289, 0, 289, 237, 0, 289, 289, 289, 225, 0, 0, 225, 0, 0, 0, 0, 77824, 0, 77824, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 0, 364, 364, 364, 400, 364, 364, 364, 364, 364, 364, 364, 364, 400,
  400, 400, 364, 364, 400, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1162, 0, 0, 0, 0, 0,
  0, 0, 0, 347, 347, 347, 574, 347, 347, 347, 347, 347, 347, 0, 383, 383, 383, 1106, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 383, 383, 383, 1129, 383, 383, 383, 383, 383, 636, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 383, 1109, 383, 383, 383, 383, 383, 383, 383, 383, 910, 383, 383, 383, 383, 915, 383, 383, 807, 347, 347, 347,
  347, 347, 347, 818, 347, 347, 347, 347, 347, 347, 347, 347, 347, 833, 347, 347, 347, 836, 347, 347, 226, 226, 0, 0,
  32768, 34816, 226, 0, 0, 0, 273, 30720, 273, 273, 273, 0, 0, 0, 347, 347, 347, 347, 611, 347, 347, 347, 347, 347, 0,
  383, 383, 383, 873, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 0, 0, 0, 1563, 273, 273, 305, 0, 305,
  0, 0, 305, 305, 305, 0, 273, 273, 0, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 365, 273, 273, 273, 305, 273,
  273, 365, 365, 365, 401, 365, 365, 365, 365, 365, 365, 365, 365, 401, 401, 401, 365, 365, 401, 1, 8194, 3, 37050, 0,
  0, 0, 0, 0, 0, 752, 0, 0, 0, 0, 0, 0, 0, 760, 0, 0, 1182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565809, 565809,
  565809, 565809, 565809, 565809, 565809, 565809, 565809, 565809, 565870, 0, 366, 366, 366, 402, 366, 366, 366, 366,
  366, 366, 366, 366, 402, 402, 402, 366, 366, 402, 1, 8194, 3, 37050, 0, 0, 0, 0, 0, 0, 803, 0, 0, 702, 0, 0, 703, 0,
  0, 0, 0, 289, 0, 0, 0, 0, 0, 0, 0, 536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 536, 0, 0, 0, 0, 0, 0, 0, 347, 347, 347, 575, 347,
  347, 347, 347, 347, 347, 0, 383, 383, 383, 1140, 0, 1142, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 466, 383, 383,
  637, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1295, 383, 1297, 383, 383, 383, 383, 383, 1300,
  0, 731, 0, 0, 0, 0, 0, 738, 0, 0, 0, 0, 0, 0, 0, 0, 1358, 0, 0, 0, 0, 0, 0, 0, 0, 194, 195, 0, 0, 0, 0, 0, 0, 415, 0,
  0, 0, 0, 0, 0, 943, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 0, 941, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 788480, 0, 0, 0, 0, 0, 1020, 289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 539, 0, 0, 0, 0, 0, 347,
  347, 1060, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 1742, 347, 383, 383, 1119, 383, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1444, 383, 383, 383, 383, 383, 383, 383, 383, 1296, 383, 383,
  383, 383, 383, 383, 383, 1154, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1581, 0, 0, 0, 0, 0, 0, 1289, 1290, 383,
  383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 1706, 383, 383, 383, 383, 1711, 383, 383, 383, 383,
  383, 383, 1452, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1659, 0, 0, 0, 0, 0, 0, 0, 395264, 395264, 0, 395264, 0, 0, 0, 0,
  395264, 0, 395264, 0, 395264, 0, 395264, 395264, 0, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 1495, 0, 289, 289, 289, 289,
  1501, 289, 289, 395264, 0, 0, 0, 395264, 0, 0, 0, 395264, 395264, 0, 0, 0, 0, 0, 0, 395264, 395264, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 395264, 0, 395264, 0, 0, 0, 399360, 0, 399360, 399360, 0, 0, 0, 399360, 399360, 399360, 399360, 399360,
  399360, 399360, 399360, 399360, 399360, 0, 399360, 399360, 399360, 399360, 399360, 0, 0, 0, 399360, 399360, 399360, 1,
  8194, 3, 0, 0, 0, 0, 0, 0, 0, 1568, 0, 0, 0, 0, 0, 0, 0, 1574, 0, 401408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 401408, 401408,
  0, 401408, 401408, 401408, 401408, 401408, 401408, 401408, 401408, 401408, 401408, 0, 401408, 401408, 401408, 401408,
  401408, 401408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 573882, 0, 671744, 0, 0, 0, 0, 0, 0, 401408, 401408,
  401408, 401408, 1, 8194, 3, 0, 0, 0, 0, 0, 0, 0, 1593, 289, 1595, 289, 289, 289, 1598, 289, 1600, 0, 51200, 0, 51200,
  0, 51200, 51200, 0, 0, 0, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 0, 51200, 51200,
  51200, 51200, 51200, 51200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51200, 51200, 51200, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 540672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 731136, 823296, 0, 0, 567296, 681984, 684032,
  903168, 0, 692224, 0, 0, 0, 804864, 0, 0, 901120, 0, 0, 0, 0, 0, 0, 974, 0, 0, 0, 0, 0, 0, 0, 0, 0, 983, 565248,
  901120, 0, 0, 0, 0, 813056, 0, 0, 0, 0, 0, 0, 0, 798720, 0, 0, 0, 347, 347, 347, 573, 347, 347, 347, 347, 347, 347, 0,
  383, 383, 383, 383, 1871, 383, 0, 0, 0, 0, 0, 0, 0, 0, 347, 347, 1829, 1830, 347, 347, 347, 347, 1835, 347, 383
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  53, 98, 129, 114, 145, 161, 177, 193, 209, 305, 68, 226, 226, 226, 226, 82, 242, 258, 274, 290, 324, 340, 356, 372,
  515, 642, 388, 721, 404, 420, 436, 452, 468, 484, 500, 531, 547, 563, 579, 595, 611, 627, 658, 674, 690, 706, 222,
  226, 226, 226, 226, 226, 312, 737, 741, 748, 743, 747, 749, 753, 756, 760, 764, 768, 772, 776, 877, 781, 877, 877,
  1738, 877, 877, 877, 877, 1532, 877, 877, 877, 877, 877, 877, 877, 877, 1489, 971, 877, 1547, 979, 985, 989, 993, 997,
  1001, 1004, 1385, 1078, 1048, 805, 836, 1124, 787, 877, 1659, 792, 872, 842, 796, 877, 1534, 877, 1457, 812, 1123,
  1124, 1302, 1660, 907, 907, 907, 841, 842, 842, 847, 850, 877, 877, 1472, 1079, 1124, 817, 877, 907, 907, 822, 884,
  842, 842, 842, 826, 877, 877, 877, 833, 1079, 1303, 907, 907, 907, 856, 842, 842, 863, 877, 877, 1673, 1300, 869, 907,
  907, 900, 842, 842, 876, 877, 1600, 1080, 882, 907, 900, 842, 843, 877, 1672, 1122, 906, 908, 842, 859, 1546, 1080,
  906, 900, 842, 2186, 888, 907, 842, 892, 899, 858, 905, 912, 2107, 2184, 1661, 922, 901, 2181, 919, 926, 930, 934,
  941, 943, 951, 948, 944, 955, 959, 963, 967, 937, 829, 877, 1406, 877, 877, 1379, 877, 1176, 877, 877, 877, 877, 1096,
  877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 1203, 1011, 1319, 1015, 1478, 1351,
  1021, 877, 1025, 1026, 1063, 1031, 2093, 1229, 1041, 1392, 1045, 877, 1780, 1579, 1052, 877, 1104, 1062, 1067, 877,
  877, 1356, 1077, 877, 2133, 1508, 1084, 1088, 1667, 1496, 1103, 877, 1094, 1100, 877, 877, 877, 1865, 2002, 1202,
  1108, 1116, 1120, 1128, 1132, 877, 1138, 1146, 877, 877, 1773, 1949, 1312, 2136, 1150, 1157, 1154, 877, 1255, 877,
  877, 877, 877, 1502, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 852, 1195, 1164, 877, 1946, 877, 1641,
  1617, 1170, 1201, 1195, 1174, 1356, 1948, 1591, 1180, 1184, 1194, 1199, 1556, 1073, 1207, 1211, 1224, 1228, 1233,
  1239, 1246, 1253, 1259, 1263, 1269, 1273, 1279, 1283, 1275, 1290, 1569, 1294, 1307, 808, 1848, 1311, 877, 877, 1971,
  877, 1723, 1316, 1323, 1541, 1327, 1331, 1334, 1338, 2003, 1343, 1348, 1607, 1447, 1428, 1355, 1360, 2203, 1364, 1701,
  1469, 877, 877, 1484, 1214, 1606, 1820, 1476, 1482, 1488, 1493, 877, 1500, 1729, 1506, 1573, 813, 1584, 1577, 1511,
  1444, 1166, 1397, 2130, 1583, 1588, 1134, 915, 1397, 2196, 1595, 1599, 1630, 1855, 1604, 1613, 1034, 1621, 877, 1625,
  1629, 1634, 974, 1638, 975, 1450, 1649, 1653, 1657, 877, 877, 877, 1665, 1671, 1190, 1677, 1681, 1685, 1689, 1693,
  1695, 877, 2171, 1510, 2054, 1699, 1705, 1709, 818, 1713, 1720, 1827, 2024, 1744, 877, 877, 1727, 799, 1529, 1561,
  1071, 2069, 877, 1733, 877, 1877, 1737, 1813, 877, 1415, 1742, 877, 2088, 2051, 2055, 1793, 1748, 877, 1752, 1395,
  877, 1759, 1913, 877, 877, 1766, 877, 877, 2049, 2053, 1235, 1985, 1782, 1036, 877, 2104, 1037, 877, 2170, 1767, 877,
  2049, 802, 1792, 2001, 1771, 877, 1368, 1372, 877, 1377, 1716, 1615, 865, 1142, 1830, 2087, 1383, 1389, 1401, 1405,
  1421, 2178, 1265, 877, 1777, 877, 1786, 1790, 2000, 877, 2119, 1265, 877, 1797, 1218, 1803, 2010, 877, 1807, 877,
  1811, 1220, 1817, 877, 1824, 1939, 2148, 1834, 783, 1934, 1055, 1840, 1644, 1844, 1852, 1859, 1187, 1058, 1645, 1863,
  1872, 1869, 1847, 877, 877, 877, 877, 1881, 1339, 1885, 1892, 1896, 1900, 1904, 1908, 1912, 877, 2063, 2159, 1917,
  1961, 2036, 1160, 1090, 1069, 877, 1921, 1434, 1249, 877, 837, 1925, 1441, 1929, 1017, 1933, 895, 1782, 1938, 877,
  1465, 1943, 2013, 877, 1373, 1954, 877, 1027, 1976, 1958, 1965, 1982, 837, 1989, 877, 877, 1888, 2012, 877, 877, 1993,
  2169, 877, 1974, 1978, 1997, 2007, 1836, 1875, 877, 2166, 1799, 877, 1410, 1414, 877, 877, 1419, 1216, 1608, 1425,
  1432, 1438, 1968, 1344, 1454, 788, 1464, 980, 2017, 877, 2021, 2028, 2034, 2040, 2046, 877, 2059, 2067, 877, 2073,
  2062, 2077, 2030, 2081, 851, 2042, 2067, 980, 2085, 2113, 2092, 2097, 777, 2101, 1950, 2111, 2117, 2123, 878, 1112,
  1286, 1554, 2127, 1242, 1522, 2142, 1111, 2140, 981, 1007, 1006, 2193, 2153, 2146, 2152, 1460, 1460, 1762, 2157, 877,
  877, 877, 2163, 2175, 2190, 2200, 2207, 2211, 2215, 1297, 877, 1512, 1516, 1567, 1520, 1526, 1755, 1538, 1609, 1545,
  1551, 877, 1560, 1565, 1140, 1754, 2301, 2493, 2219, 3454, 2229, 2233, 2815, 2815, 2252, 2239, 2245, 2815, 2815, 2815,
  2815, 2816, 2243, 2234, 2815, 2813, 2249, 2235, 2815, 2551, 2553, 2260, 2266, 2268, 2264, 2272, 2276, 2280, 2284,
  2288, 2292, 2296, 2299, 2303, 2307, 2313, 2498, 2498, 2498, 2320, 2991, 2329, 2498, 2498, 2225, 2628, 3225, 2498,
  2498, 2498, 2352, 2392, 2392, 2392, 3070, 2363, 3525, 2369, 2498, 2337, 3289, 2498, 2338, 3291, 2498, 2342, 2351,
  2498, 2324, 2493, 3201, 3439, 2498, 2498, 2498, 2354, 2510, 2498, 2498, 2498, 2399, 2392, 2392, 3069, 3068, 2376,
  2368, 2368, 2498, 2492, 2334, 2504, 3433, 3436, 2498, 3440, 2498, 2498, 2498, 2335, 2487, 2358, 2358, 2358, 2358,
  2498, 2358, 2488, 2367, 2368, 3687, 2498, 2498, 2498, 2494, 2395, 2358, 2358, 2358, 2396, 2498, 2498, 2359, 2369,
  2498, 2498, 2318, 2498, 2509, 2509, 3609, 3066, 2392, 2392, 2486, 2358, 2498, 2498, 2498, 2498, 2322, 2509, 2498,
  2392, 2392, 2392, 2487, 2498, 3606, 2509, 3068, 2397, 2498, 3438, 2498, 2498, 3580, 2837, 2483, 2392, 2392, 2393,
  2358, 2358, 3438, 3066, 2392, 2392, 2392, 2392, 2394, 2395, 2358, 2396, 2498, 2498, 3606, 2710, 2398, 3068, 2393,
  2358, 2397, 2498, 3067, 2398, 2392, 2358, 2373, 2389, 2389, 2398, 3371, 3722, 3700, 2414, 2420, 2473, 2476, 2480,
  2403, 2412, 2419, 2419, 2419, 2419, 2434, 2429, 2432, 2419, 2419, 2418, 2424, 3347, 2406, 2419, 2419, 2445, 2419,
  2438, 2442, 2450, 2425, 2454, 2457, 2468, 2469, 2466, 2460, 2408, 2698, 2704, 2708, 2498, 2498, 3606, 3743, 3690,
  2525, 2498, 2498, 2498, 2499, 2347, 2536, 3438, 2545, 2557, 2562, 2571, 2583, 2309, 2744, 2587, 2590, 2594, 2598,
  2616, 2611, 2615, 2601, 2604, 2604, 2604, 2607, 2498, 2498, 2345, 2498, 3691, 2620, 2498, 2711, 2716, 3692, 2668,
  2498, 2498, 2496, 3442, 2967, 2674, 2678, 2688, 3298, 2692, 2498, 2498, 2498, 2575, 2702, 2706, 2710, 2498, 2498,
  3609, 2498, 2498, 2498, 3546, 2333, 2622, 2498, 2715, 2727, 3073, 2762, 2498, 2498, 3611, 2527, 2796, 2741, 2772,
  2498, 2498, 3630, 3770, 3064, 3016, 2627, 2754, 2498, 2498, 2498, 2696, 2759, 2770, 2498, 2498, 2498, 3678, 2498,
  2498, 2498, 3703, 2703, 2707, 2498, 2498, 2498, 2508, 2509, 2722, 2498, 3673, 3072, 2784, 2848, 2498, 2498, 2498,
  3760, 2498, 3523, 2498, 2498, 2498, 3807, 3227, 2806, 2836, 2788, 2498, 2498, 2498, 2748, 2332, 2622, 2972, 2498,
  2498, 3728, 2498, 2498, 2723, 2498, 3673, 3688, 2810, 2848, 2498, 2498, 2509, 2509, 2509, 2509, 2498, 3740, 2498,
  2820, 2825, 2787, 2498, 2498, 2528, 3189, 2498, 3522, 2498, 2498, 2539, 2498, 3072, 2498, 3227, 2823, 2836, 2788,
  2498, 3674, 2831, 2848, 2829, 2737, 2789, 2498, 2498, 3743, 2498, 2498, 3757, 3121, 2835, 2787, 2498, 2498, 2540,
  2498, 2498, 3744, 3228, 2852, 2857, 2789, 2498, 2498, 2558, 3413, 2498, 3688, 2842, 2847, 3744, 2829, 2853, 2498,
  2498, 3764, 2498, 2498, 3794, 3222, 2498, 3521, 2498, 2498, 3229, 3230, 2858, 2790, 2498, 2498, 2498, 2997, 3377,
  3064, 2498, 2841, 2862, 3744, 2829, 2870, 2498, 2498, 3796, 3191, 2498, 2498, 2750, 2498, 3632, 3809, 2498, 3605,
  2498, 3229, 2869, 2498, 2498, 2498, 2998, 3525, 3104, 2498, 2622, 2776, 2498, 3065, 3672, 3492, 3442, 2330, 2345,
  3292, 2874, 2498, 3603, 2498, 2499, 3551, 3621, 2325, 2883, 2498, 2498, 2624, 2514, 2498, 3644, 3809, 3063, 3024,
  2886, 2498, 2498, 2629, 2498, 2890, 2498, 2498, 3643, 2896, 3063, 3201, 2498, 3525, 3106, 3442, 2493, 2498, 3643,
  3107, 2324, 2493, 2498, 2499, 3734, 2323, 3064, 3202, 2498, 3200, 3202, 2498, 3201, 2498, 2499, 3801, 2498, 2507,
  2509, 2509, 2498, 2498, 2392, 2656, 2324, 2493, 3201, 3016, 2498, 2498, 2498, 3000, 2914, 2498, 3062, 2498, 2633,
  2498, 2650, 2920, 2909, 2999, 2924, 2950, 2943, 2954, 2955, 2946, 2959, 2955, 2963, 2963, 2963, 2963, 2966, 2498,
  2498, 2498, 3005, 3033, 2498, 2498, 2498, 3127, 2529, 2565, 3191, 2498, 2636, 3693, 2669, 2977, 2498, 2498, 2498,
  3204, 2462, 2984, 2498, 2990, 2532, 3004, 3009, 3013, 3020, 2498, 2498, 3028, 3023, 2498, 2498, 2498, 3235, 2778,
  3032, 2498, 2498, 2659, 2623, 3051, 3181, 2498, 2498, 2697, 2703, 3198, 2498, 3055, 2498, 2720, 2497, 3688, 3316,
  2498, 2498, 3156, 3156, 2500, 3043, 3384, 3593, 3077, 2498, 2498, 2498, 3344, 3088, 3097, 3102, 3618, 3111, 2498,
  2498, 2498, 3392, 2779, 2497, 2498, 2498, 2729, 3084, 2316, 2498, 2498, 2541, 2498, 2971, 2663, 2498, 3808, 2498,
  2499, 3544, 2498, 3129, 3119, 3675, 2498, 2766, 3671, 2528, 3797, 2915, 2498, 2773, 3071, 2498, 2683, 2498, 3607,
  3092, 3133, 3156, 2498, 2791, 3435, 2498, 2344, 2498, 3738, 3166, 2498, 2498, 2498, 3416, 3177, 3135, 2497, 2498,
  2791, 3437, 3440, 2498, 3808, 2498, 3072, 3742, 2498, 2548, 3156, 2498, 2498, 2778, 2497, 3248, 2498, 2498, 2498,
  3438, 3309, 2521, 3135, 2498, 2800, 2804, 2736, 3165, 2497, 2498, 2498, 2791, 2622, 3134, 2877, 2498, 2498, 2795,
  2498, 2498, 2498, 3442, 3441, 2498, 3750, 2567, 2915, 3071, 2539, 2498, 2498, 2902, 3730, 2498, 3438, 3150, 2498,
  2899, 2776, 2498, 2910, 2498, 2498, 2329, 2498, 2331, 2520, 3160, 2498, 2933, 2936, 2940, 2926, 2498, 2498, 2498,
  3439, 2517, 3164, 3093, 3160, 2498, 2992, 2498, 2498, 3464, 3105, 2498, 3442, 2498, 2498, 3367, 3796, 2914, 2498,
  3063, 2498, 2498, 2894, 3064, 3155, 2498, 2446, 3170, 3174, 3185, 2498, 2498, 2916, 2733, 2354, 2926, 2498, 2498,
  2352, 2353, 3713, 3675, 2498, 2997, 3702, 3062, 2926, 2498, 2498, 2929, 3715, 2498, 2498, 2498, 3440, 2498, 3748,
  2498, 2498, 3064, 2498, 2498, 2498, 3164, 3711, 3675, 2498, 2498, 3065, 2498, 2841, 2846, 3745, 3691, 2498, 2681,
  3609, 3746, 2498, 2680, 2684, 2498, 2498, 3607, 2498, 3744, 3748, 2498, 2682, 3747, 2498, 2681, 2498, 3000, 2621,
  2498, 2498, 3763, 2498, 3770, 3744, 2498, 2684, 3607, 3744, 2498, 2684, 3608, 2684, 3217, 2498, 2498, 3067, 2392,
  2392, 2358, 3336, 3361, 2498, 2498, 3079, 2498, 3605, 2498, 2498, 2498, 3441, 2498, 2222, 2498, 2498, 3218, 3234,
  3239, 2980, 3243, 3252, 3256, 3260, 3265, 3263, 3269, 3269, 3271, 3269, 3275, 3276, 3276, 3280, 2498, 3704, 2774,
  2498, 2498, 3139, 3091, 3443, 2498, 3438, 3296, 2653, 2498, 2498, 3302, 3306, 3526, 2379, 2498, 3037, 2566, 3192,
  2879, 2755, 2661, 2498, 3038, 2999, 2906, 3359, 3363, 2498, 2498, 3140, 3093, 3324, 3375, 3317, 3330, 3406, 2498,
  2498, 2498, 3524, 3404, 3399, 2498, 2498, 3146, 3351, 2498, 3438, 3369, 3677, 2325, 3670, 2498, 2498, 3154, 2498,
  2498, 3442, 3410, 3399, 2498, 3061, 2900, 3114, 2986, 3395, 3399, 2498, 2498, 2498, 3608, 2498, 2498, 3205, 2705,
  2498, 3426, 3399, 2498, 3080, 2498, 2498, 2498, 3676, 3430, 2795, 2498, 2528, 3290, 2498, 2621, 2775, 2498, 2498,
  3444, 3458, 3399, 2498, 2498, 3212, 3597, 3630, 3291, 2498, 2639, 3532, 3400, 2498, 2629, 3566, 3400, 2498, 2498,
  3388, 2498, 3771, 3282, 3226, 2498, 3144, 3606, 2710, 2224, 2498, 2629, 2498, 3146, 3321, 2498, 3042, 3047, 3180,
  3772, 3284, 2498, 2498, 3415, 3654, 3282, 2498, 3014, 2625, 2670, 3770, 3063, 3015, 3062, 3015, 3015, 3014, 2626,
  2498, 3762, 2498, 3196, 2498, 3209, 2498, 3771, 3065, 3203, 3064, 3462, 2498, 2624, 3667, 2706, 3015, 3771, 3065,
  2493, 3771, 3065, 2493, 2792, 2498, 2498, 3446, 3381, 2574, 2578, 2498, 2336, 2498, 3468, 3724, 2335, 3418, 3574,
  3621, 3490, 2498, 3488, 3474, 3486, 2865, 3496, 2642, 3500, 3508, 3504, 3507, 2645, 2646, 3507, 3512, 3514, 3514,
  3514, 3514, 3515, 2498, 2498, 2498, 3547, 2765, 3637, 3691, 2530, 2498, 3536, 2385, 3540, 2576, 3675, 2498, 2710,
  2331, 2498, 2498, 3555, 3583, 2498, 2498, 2498, 3599, 2794, 2498, 2498, 2498, 3601, 3560, 2384, 3564, 2498, 3204,
  2705, 2709, 2498, 2498, 2498, 2901, 3780, 3588, 2382, 3622, 3637, 3691, 2531, 2334, 2498, 2498, 3556, 2498, 3525,
  2493, 2498, 3246, 3156, 2498, 2780, 2497, 2498, 2575, 2579, 3519, 2498, 2765, 3637, 3749, 2494, 2498, 3582, 2498,
  3282, 3314, 3677, 3570, 2493, 2498, 2793, 2499, 3779, 3587, 3592, 2331, 2498, 3556, 2498, 3283, 2710, 2498, 2498,
  2498, 2779, 2494, 2498, 3649, 2498, 3312, 2498, 2498, 3213, 3292, 2498, 3779, 3098, 3616, 3620, 2498, 3626, 3005,
  2498, 3334, 2498, 3341, 2991, 3636, 3690, 2531, 3686, 2498, 3641, 2493, 2498, 2495, 2498, 3530, 3648, 2498, 2498,
  2335, 3697, 2623, 3653, 3121, 2792, 2498, 3336, 3362, 2498, 2498, 2336, 3288, 3292, 2498, 2898, 2335, 3653, 3619,
  2623, 2498, 2498, 2573, 2577, 2498, 3658, 2498, 2498, 3447, 3327, 2499, 3664, 3682, 3619, 3628, 3519, 2498, 2255,
  2495, 3444, 2498, 3415, 3664, 3660, 2623, 2498, 2498, 2498, 3336, 2256, 2498, 2498, 2498, 3612, 2496, 3445, 2498,
  3445, 3065, 2498, 3708, 2498, 3337, 3398, 2498, 3068, 2392, 2393, 3719, 2498, 2498, 3226, 2710, 2991, 2498, 3577,
  2498, 2498, 3451, 3399, 2495, 3444, 2498, 3445, 2777, 2498, 3445, 2498, 3354, 3675, 2498, 2997, 2332, 2621, 2973,
  3062, 2497, 2498, 3728, 2498, 3690, 2498, 2496, 2346, 3689, 2498, 2498, 3470, 2351, 2345, 2498, 2344, 3691, 2498,
  3115, 3482, 2498, 2498, 3519, 2498, 2900, 3060, 3482, 2498, 3417, 3654, 3620, 2498, 2498, 2498, 3610, 3360, 2499,
  3060, 3481, 2498, 3422, 3399, 2498, 3068, 2393, 2358, 2358, 2398, 2498, 2498, 3440, 3482, 2499, 3754, 2499, 2347,
  3690, 2498, 3355, 2498, 2928, 3058, 3060, 3123, 3061, 2664, 2996, 3060, 3768, 2901, 3477, 3480, 3776, 3784, 3784,
  3803, 3788, 3791, 2498, 3481, 0, 270532608, 2097152, 2097152, 536870912, 0, 256, 402653184, 0, 0, 4195328, 1142947840,
  2097152, 138412032, 541065216, -2143289344, 4194304, 4194304, 4194304, 280608, 4195328, 4195328, -2009071616,
  138412032, 20971520, -2009071616, 541065216, 541065216, 541065216, 4194304, 67409920, 1074079744, 541065216, 4194304,
  4194304, 4194304, 8388608, 256, 1048576, 0, 64, 139460608, -2008023040, -1958739968, 54525952, -2092957696, 54525952,
  54525952, -1958739968, 54525952, 54525952, 54525952, 188743680, -2092957696, -2092957696, 4718592, -1421869056,
  -1958739968, -1958739968, -1957691392, -1421869056, -1958739968, 524288, 2621440, 4718592, 4718656, 2621440,
  -2142765056, 4718592, 138936320, -1605894144, -2142765056, 4718592, -2142765056, -1605892160, -1605892160,
  -1589114944, -1605892160, -1605892160, -1605892160, -1958215680, -1555560512, 4, 8, 16, 131072, 268435456, 0, 0,
  2097152, 4194304, 0, 4194304, 4325376, 128, 1024, 1024, 0, 0, 32768, 524288, 0, 0, 8, 8388608, 16777216, 0, 0, 8, 64,
  8388608, 8388608, 0, 0, 0, 2, 0, 0, 0, 4, 0, 4096, 8192, 4096, 264192, 0, 0, 1, 32, 64, 0, 0, 8192, 0, 0, 0, 6, 8, 64,
  524352, 524352, 524352, 524352, 1024, 524352, 524352, 768, 896, 512, 1024, 1024, 1024, 1024, 0, 0, 524288, 524288,
  524352, 768, 512, 0, 0, 33792, 786432, 2097152, 12582912, 16777216, 268435456, 1073741824, 3336, 524352, 524288,
  524352, 524288, 524288, 524288, 524288, 524352, 524352, 524352, 0, 0, 0, 18, 10, 34, 16386, 32770, 2, 2, 2, 16781312,
  2, 65538, 8388610, 2, 2, 0, 16781312, 8194, 2, 2, 2, 2, 6, 2, 6, 2, 2, -2018374534, 98306, 32770, 32770, 65538, 2, 2,
  2, 38, 6, 5111808, 34, 34, 34, 1073807362, 34, 65574, 2, 0, 0, 2, 2048, -2018374534, 2, -2018374534, -2018374534,
  129171582, 129171582, -2018374534, 129171582, 263389310, 129171582, -2018308994, -2018308994, 0, 0, 1, 2560,
  -2018308994, -2018292610, -2018308994, -2018308994, -2018292610, 263422078, 2, 14, 14, 541459202, 541462355,
  541462359, 541462355, 541462355, -2018308994, -2018292610, 670499702, 0, 0, 1048576, 524288, 64, 524352, 524352,
  524352, 512, 128, 268435456, 0, 0, 0, -2147483648, 0, 0, 0, 0, 1, 2, 4096, 16384, 32768, 0, 0, 1048576, 1048576,
  1048576, 1048576, 0, 0, 4456448, 7602176, 128, 0, 32, 32, 1024, 2048, 24576, 524288, 128, 2048, 75497472, 0, 0, 0,
  4096, 0, 0, 0, 6960, 0, 67108864, 33554432, 0, 0, 1048576, 67108864, 0, 0, 0, 32, 130, 32, 2048, 524288, 4194304,
  20971520, 5242880, -1958739968, -1958739968, 5243904, 8519680, 0, 0, 0, 2048, 162, 32, 128, 128, 0, 65536, 0, 262144,
  0, 8519680, 1073741824, 0, 0, 4, 16, 65536, 33554432, 134217728, 536870912, 0, 0, 128, 78120448, 78120448, 1074790400,
  608333904, 24592, 608333904, 24592, 608333904, 608333904, 608333904, 1074814992, 608309329, 608309329, 1152935440,
  608309329, 608325713, 608325713, 608333905, 608333905, 608333937, 1044869468, 1044869468, 1044869468, 1044869468,
  1044869469, 1044869469, 1044869469, 608309459, 608333905, 608333905, 608309459, 1044607068, 608333905, 608333905,
  608333905, 608333905, 162, 0, 0, 1073741824, 0, 0, 0, 512, 0, 0, 0, 768, 0, 4325376, 0, -2130706432, 0, 0, 1073152,
  1073741824, 0, 32768, -2147483648, 268436484, 268438540, 273026060, 273026060, 273026060, 272763916, 1372458636, 64,
  4362240, 603979776, 0, 0, 1179648, 0, 0, 2097152, 0, 0, 4980736, 0, 0, 0, 1, 2864, 2752512, 4354048, 603979776, 0, 0,
  0, 8192, 1149239296, 0, 0, 4345856, 4354048, 210, 0, 0, 4, 64, 16384, 0, 0, 0, 0, 92, 4419584, 1040187392, 0, 348,
  4681728, 1040187392, 0, 32, 512, 1024, 2048, 4096, 2048, 4096, 32768, 131072, 524288, 1048576, 2097152, 8388608,
  67108864, 0, 0, 0, 1536, 0, 2621440, 4194304, 0, 0, 0, 4325376, 0, 16777216, -2147483648, 0, 0, 36864, 603979776, 0,
  0, 6, 24, 1149239296, 0, 20480, 28672, 65536, 131072, 4194304, 33554432, 64, 28672, 65536, 4325376, -2130706432,
  4325376, 608342081, 0, 96, 0, 256, 4194304, 0, 4587520, 0, 0, 0, 34048, 28, 64, 256, 28672, 4325376, 603979776, 0, 0,
  8388608, 8192, 256, 65536, 4587520, 1040187392, 0, 0, 0, 32768, -2147483648, 0, 0, 8, 32, 256, 33554432, 64, 28672,
  131072, 4194304, 33554432, 67108864, 939524096, 0, 0, 0, 262144, 4194304, 0, 0, 0, 28, 0, 1572864, 20480, 28672, 0,
  12, 16, 64, 256, 28672, 4096, 24576, 131072, 4194304, 541065216, 4194304, 4194304, 4194304, 4194304, 4195328, 0,
  16384, 12, 64, 256, 4096, 24576, 65536, 131072, 0, 12, 64, 16384, 131072, 4194304, 16384, 65536, 131072, 262144,
  4194304, 268435456, 64, 536870912, 0, 64, 16384, 16384, 131072, 67108864, 536870912, 0, 0, 16384, 131072, 33554432,
  67108864, 939524096, 16384, 131072, 262144, 33554432, 67108864, 16384, 131072, 536870912, 0, 0, 33554434, 268436484,
  16384, 131072, 402653184, 536870912, 0, 64, 131072, 402653184, 536870912, -2147483648, 0, 0, 26, 1703936, 256, 131072,
  402653184, 536870912, 8, 402653184, 536870912, 0, 8, 402653184, 536870912, 1024, 2097152, 8388608, 0, 0, 1073741824,
  1, 0, 0, 1, 8, 32, 65544, 128, 256, 4096, 0, 262144, 0, 1073741824, 262144, 134217728, 0, 0, 0, 3670016, 0, 8, 4096,
  33554432, 0, 65544, 65536, 0, 0, 0, 6, 64, 24576, 65536, 557056, 0, 557056, 557088, 68157440, 557088, 557360,
  1886030641, 1885473281, 1886030641, 1885538817, 1617595185, 1886030641, 1919589169, 1886030641, 1886030641,
  1885473409, 1885473281, 1886030641, 1886030641, 1885538817, 1886030641, 1886030641, 1886030641, 1886030641,
  1919589169, 1902833459, 1886030641, 1886030641, -236195969, -236195969, -236195969, -236195969, 0, 0, 0, 3694592, 304,
  0, 0, 0, 4194304, 0, 32768, 2752512, 1883242496, 0, 0, 1073743872, 4194304, 2228224, 1883242496, 0, 0, 8, 192, 2688,
  0, 0, 0, 8388608, 64, 1614807040, 0, 0, 0, 33554432, 0, 0, 2, 1916796928, 0, 0, 0, 67108864, 3, 3888, 57344, 2752512,
  1900019712, 0, 0, 0, 268435456, 0, 0, 7, 3960, 122880, -239075328, 0, 0, 0, 536870912, 7, 3960, 122880, 2752512, 256,
  33554432, -2147483648, 0, 0, 0, 4096, 0, 128, 33554432, 1, 16, 32, 256, 512, 512, 2048, 32768, 131072, 1, 512, 2048,
  131072, 0, 6144, 838860800, 0, 1, 0, 1, 0, 0, 0, 16777216, 0, 0, 0, 524288, 524288, 524288, 0, 0, 0, 16, 64,
  805306368, 1073741824, 0, 0, 16, 24576, 0, 96, 65536, 8388608, -2147483648, 1, 6, 24, 96, 256, 1024, 2048, 24576,
  65536, 256, 512, 1024, 2048, 16384, 57344, 65536, 131072, 524288, 2097152, 8388608, 0, 1073741824, 0, 805306368,
  1073741824, -2147483648, 0, 1, 1, 1, 1, 32768, 524288, 4194304, 268435456, 0, 0, 19, 19, 1, 2, 16, 32, 256, 2048,
  32768, 524288, 4194304, 16777216, 268435456, 536870912, 1, 6, 8, 16, 96, 0, 524288, 0, 0, 26, 192, 2048, 524288,
  268435456, 536870912, 0, 2048, 268435456, 536870912, 0, 0, 524288, 16777216, 268435456, 536870912, 0, 6, 8, 96, 65536,
  -2147483648, 24576, 16777216, 268435456, 536870912, 8, 64, 2048, 24576, 32768, 65536, 524288, 2097152, 4194304,
  805306368, 1073741824, 65536, 16777216, 268435456, 536870912, 128, 65536, 262144, 0, 134217728, 0, 0, 0, 536870912, 0,
  536870912, 0, 0, 8, 268435456, 0, 0, 512, 1024, 32768, 0, 24576, 536870912, 0, 1, 96, 16384, 32768, 16384, 0, 0,
  1048576, 4, 2048, 536879104, 65536, 1048576, 33554432, 0, 0, 0, 12, 64, 256, 16384, 1073743872, 0, 0, 1, 4,
  1073743872, 1073743872, 1048576, -2147450880, 4194560, -2147188736, 1048584, 0, 1, 2048, 4194304, 268435456,
  536870912, 1048584, 1048584, 1048584, 117440544, 1048584, 1179656, 1705050, 525650, 1705050, 525394, 525522, 1705050,
  -2142468782, 1705050, 1705050, -2146663342, 1705050, 1705050, 1705050, 1705050, 1705050, 414844378, 1705050, 1705051,
  414861274, 414861274, 414861274, 414861274, 414861274, 414861274, 0, 0, 32, 16777216, 33554432, 0, 4096, 2048, 8192,
  536870912, 2097152, 0, 0, 0, 117440512, 0, 0, 0, 112, 0, 26, 64, 1024, 1703936, 64, 1280, 524288, 0, 2, 16, 32,
  16777216, 33554432, 67108864, 0, 0, 192, 0, 10, 1280, 3801088, 411041792, 0, 2, 16, 64, 1024, 131072, 1572864, 0, 0,
  4718592, 0, 27, 0, 0, 128, 256, 131072, 0, 18176, 411041792, 0, 2, 8192, 3, 38, 134217734, 65570, 18176, 3801088,
  411041792, 0, 2, 24576, 268435456, 536870912, 128, 256, 65536, 262144, 1048576, 4194304, 0, 0, 0, 32, 16777216,
  100663296, 0, 0, 128, 8388608, 1024, 524288, 0, 0, 130, 0, 16, 192, 256, 1024, 2048, 57344, 131072, 0, 768, 16384,
  402653184, 10, 16, 192, 768, 16384, 131072, 3145728, 8388608, 402653184, 0, 0, 0, 1024, 16384, 131072, 3670016,
  8388608, 402653184, 192, 256, 131072, 3145728, 100663296, 0, 0, 4, 8, 128, 512, 3072, 0, 128, 256, 3145728, 0, 128,
  768, 3145728, 0, 128, 256, 262144, 262144, 2048, 2048, 2048, 0, 0, 0, 32, 0, 0, 0, 8, 0, 0, 0, 10, 16, 0, 128, 256,
  2097152, 1140850688, 4194304, 4194432, 0, 128, 768, 2097152, 0, 268435456, 0, 512, 1024, 131072, 16, 134217728, 0, 0,
  256, 4096, 4096, 134217728, 134217728, 0, 4, 1, 4, 0, 1, 1, 0, 0, 2, 0, 0, 134217728, 1048832, 0, 0, 64, 131072,
  536870912, 0, 268436484, 268436484, 268436484, 4587520, 273026060, 71696384, 4587536, 272763916, 272763916, 38141954,
  273026060, 273026060, 273026060, 273026060, 38141954, 274074892, 273030156, 1374605037, 1374605037, 1374605037,
  1374605037, 0, 0, 67108864, 0, 0, 256, 262144, 0, 0, 0, 1024, 192, 3080, 0, 0, 0, 256, 2097152, 4, 3720, 917504,
  12582912, 1441792, 0, 0, 7176, 20200, 3047424, 0, 0, 768, 16384, 0, 4, 20200, 3047424, 12582912, 0, 1024, 268435456,
  0, 0, 512, 3072, 131072, 786432, 0, 7168, 0, 0, 768, 2097152, 8, 3072, 262144, 4194304, 262144, 524288, 4194304,
  8388608, 1048576, 64, 0, 4, 8, 3072, 0, 0, 0, 512, 3072, 16384, 32768, 131072, 262144, 524288, 2097152, 4194304,
  16777216, 32768, 2097152, 0, 0, 768, 402653184, 0, 0, 256, 0, 0, 0, 1048576, 0, 0, 0, 128, 0, 75497472, 32768, 262144,
  2097152, 4194304, 8388608, 16777216, 268435456, 1073741824, 0, 0, 4, 16, 33554432, 536870912, 0, 0, 4096, 8192,
  536870912, 0, 8192, 256, 1048576, 0, 0, 2, 0, 0, 1024, 524288, 2097152, 8388608, 0, 8, 2048, 0, 0, 8, 1024, 2048,
  262144, 4194304, 1, 96, 16384, 2097152, 8388608, 16777216, 4, 8, 96, 1024, 4096, 32768, 131072, 1048576, 0, 0, 64,
  536870912, 0, 0, 0, 131072, 0, 0, 2048, 16384, 262144, 2097152, 2, 1024, 0, 0, 0, 64, 0, 0, 0, 80, 4329472, 8, 1024,
  8388608, 16777216, 268435456, 0, 2, 0, 1073741824, 0, 1, 1, 96, 2097152, 0, 4, 64, 24576, 65536, 268435456, 536870912,
  0, 96, 2097152, 8388608, 16777216, 268435456, 0, 8388608, 8192, 1048832, 1, 32, 64, 2097152, 8388608, 0, 8, 32, 64,
  2097152, 1, 32, 0, 0, 24576, 0, 0, 0, 16384, 0, 4, 64, 0, 0, 4096, 128, 1, 0, 5, 0, 4, 3080, 393216, 4194304, 0, 0,
  512, 268435456, 0, 0, 0, 19, 0, 0, 32768, 0, 0, 0, 4, 12, 12, 4, 8, 96, 128, 512, 12, 12, 12, 12, 0, 12, 12, 13, 12,
  13, 0, 4, 4096, 128, 65536, 0, 262144, 8, 13, 13, 12, 12, 13, 2, 16, 0, 0, 0, 1073741824
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "%ERROR",
  "%OTHER",
  "PragmaContents",
  "DirCommentContents",
  "DirPIContents",
  "CDataSection",
  "Wildcard",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "QName",
  "NCName",
  "S",
  "S",
  "CommentContents",
  "EOF",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'context'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'deterministic'",
  "'digit'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'minus-sign'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nondeterministic'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'private'",
  "'processing-instruction'",
  "'public'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'strict'",
  "'strip'",
  "'switch'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'when'",
  "'where'",
  "'window'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 2048
    let $end := $end - $result idiv 256
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 1929 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 16
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 16 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(59, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 45) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 23) then                 (: CommentContents :)
            let $state := p:consumeT(23, $input, $state)    (: CommentContents :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(33, $input, $state)              (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consumeT(45, $input, $state)              (: (':' ')') :)
  return $state
};

(:~
 : Try parsing the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(14, $input, $state)          (: %OTHER | S^WS | ('(' ':') :)
    return
      if ($state[$p:l1] = 1) then                           (: %OTHER :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 22) then                 (: S^WS :)
            let $state := p:consumeT(22, $input, $state)    (: S^WS :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Whitespace-1($input, $state)
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Whitespace-1($input, $state)
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QueryBody", $count, $begin, $end)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QueryBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModule", $count, $begin, $end)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:consume(146, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(16, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(10, $input, $state)               (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OptionDecl", $count, $begin, $end)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionBody", $count, $begin, $end)
};

(:~
 : Parse DeterministicOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DeterministicOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: 'deterministic' :)
      let $state := p:consume(94, $input, $state)           (: 'deterministic' :)
      return $state
    else
      let $state := p:consume(143, $input, $state)          (: 'nondeterministic' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DeterministicOption", $count, $begin, $end)
};

(:~
 : Parse PrivateOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrivateOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'private' :)
      let $state := p:consume(159, $input, $state)          (: 'private' :)
      return $state
    else
      let $state := p:consume(161, $input, $state)          (: 'public' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrivateOption", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FunctionOptions (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionOptions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(115, $input, $state)        (: S^WS | ('(' ':') | 'deterministic' | 'function' |
                                                               'nondeterministic' | 'private' | 'public' :)
    return
      if ($state[$p:l1] = 112) then                         (: 'function' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 159                      (: 'private' :)
                or $state[$p:l1] = 161) then                (: 'public' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-PrivateOption($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DeterministicOption($input, $state)
            return $state
        return p:parse-FunctionOptions-1($input, $state)
};

(:~
 : Parse FunctionOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionOptions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionOptions-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionOptions", $count, $begin, $end)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'deterministic' | 'function' |
                                                               'nondeterministic' | 'private' | 'public' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionOptions($input, $state)
  let $state := p:consume(112, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(154, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'namespace' | 'ne' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'return' | 'satisfies' | 'self' |
                                                               'some' | 'stable' | 'start' | 'to' | 'treat' | 'try' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:consume(69, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(166, $input, $state)      (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionBody($input, $state)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'external' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDecl", $count, $begin, $end)
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:consume(84, $input, $state)               (: 'context' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:consume(127, $input, $state)              (: 'item' :)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:consume(69, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(166, $input, $state)      (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: ':=' :)
      let $state := p:consume(47, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 47) then                   (: ':=' :)
          let $state := p:consume(47, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(174, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemDecl", $count, $begin, $end)
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDefaultValue", $count, $begin, $end)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 126) then                      (: 'is' :)
      let $state := p:consume(126, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 52) then                       (: '<<' :)
      let $state := p:consume(52, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(58, $input, $state)           (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeComp", $count, $begin, $end)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 55) then                       (: '=' :)
      let $state := p:consume(55, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '!=' :)
      let $state := p:consume(25, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: '<' :)
      let $state := p:consume(49, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<=' :)
      let $state := p:consume(53, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '>' :)
      let $state := p:consume(56, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(57, $input, $state)           (: '>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GeneralComp", $count, $begin, $end)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: 'eq' :)
      let $state := p:consume(105, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'ne' :)
      let $state := p:consume(138, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'lt' :)
      let $state := p:consume(132, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'le' :)
      let $state := p:consume(129, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'gt' :)
      let $state := p:consume(117, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(113, $input, $state)          (: 'ge' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueComp", $count, $begin, $end)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(144, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               '?' | ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 59) then                       (: '?' :)
      let $state := p:consume(59, $input, $state)           (: '?' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleType", $count, $begin, $end)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(32, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(162, $input, $state)           (: QName^Token | S | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1(9, $input, $state)             (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:consume(2, $input, $state)            (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:consume(28, $input, $state)               (: '#)' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Pragma", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(67, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 32) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 195) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExtensionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 63) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PredicateList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PredicateList", $count, $begin, $end)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 61) then                       (: '@' :)
      let $state := p:consume(61, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NodeTest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevForwardStep", $count, $begin, $end)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'child' :)
      let $state := p:consume(80, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant' :)
      let $state := p:consume(91, $input, $state)           (: 'descendant' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'attribute' :)
      let $state := p:consume(72, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'self' :)
      let $state := p:consume(167, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant-or-self' :)
      let $state := p:consume(92, $input, $state)           (: 'descendant-or-self' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'following-sibling' :)
      let $state := p:consume(110, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(109, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardAxis", $count, $begin, $end)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 72) then                            (: 'attribute' :)
      let $state := p:lookahead2W(256, 152, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'child' :)
      let $state := p:lookahead2W(512, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant' :)
      let $state := p:lookahead2W(768, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant-or-self' :)
      let $state := p:lookahead2W(1024, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'following' :)
      let $state := p:lookahead2W(1280, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'following-sibling' :)
      let $state := p:lookahead2W(1536, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'self' :)
      let $state := p:lookahead2W(1792, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 302                            (: 'attribute' '::' :)
          or $state[$p:lk] = 558                            (: 'child' '::' :)
          or $state[$p:lk] = 814                            (: 'descendant' '::' :)
          or $state[$p:lk] = 1070                           (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 1326                           (: 'following' '::' :)
          or $state[$p:lk] = 1582                           (: 'following-sibling' '::' :)
          or $state[$p:lk] = 1838) then                     (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevForwardStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardStep", $count, $begin, $end)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(41, $input, $state)               (: '..' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevReverseStep", $count, $begin, $end)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 72) then                            (: 'attribute' :)
      let $state := p:lookahead2W(256, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:lookahead2W(512, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'document-node' :)
      let $state := p:lookahead2W(768, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state := p:lookahead2W(1024, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                                '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                                'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' |
                                                                'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace-node' :)
      let $state := p:lookahead2W(1280, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                                '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                                'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' |
                                                                'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'node' :)
      let $state := p:lookahead2W(1536, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                                '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                                'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' |
                                                                'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(1792, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                                '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                                'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' |
                                                                'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'schema-attribute' :)
      let $state := p:lookahead2W(2048, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                                '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                                'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' |
                                                                'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'schema-element' :)
      let $state := p:lookahead2W(2304, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                                '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                                'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' |
                                                                'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'text' :)
      let $state := p:lookahead2W(2560, 148, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                                '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                                'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' |
                                                                'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 287                            (: 'attribute' '(' :)
          or $state[$p:lk] = 543                            (: 'comment' '(' :)
          or $state[$p:lk] = 799                            (: 'document-node' '(' :)
          or $state[$p:lk] = 1055                           (: 'element' '(' :)
          or $state[$p:lk] = 1311                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 1567                           (: 'node' '(' :)
          or $state[$p:lk] = 1823                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 2079                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 2335                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 2591) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeTest", $count, $begin, $end)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 151) then                      (: 'parent' :)
      let $state := p:consume(151, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ancestor' :)
      let $state := p:consume(66, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'preceding-sibling' :)
      let $state := p:consume(156, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'preceding' :)
      let $state := p:consume(155, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(67, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(46, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseAxis", $count, $begin, $end)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 41) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(164, $input, $state)      (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseStep", $count, $begin, $end)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 66) then                            (: 'ancestor' :)
      let $state := p:lookahead2W(256, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'ancestor-or-self' :)
      let $state := p:lookahead2W(512, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'parent' :)
      let $state := p:lookahead2W(768, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'preceding' :)
      let $state := p:lookahead2W(1024, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'preceding-sibling' :)
      let $state := p:lookahead2W(1280, 149, $input, $state) (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 41                             (: '..' :)
          or $state[$p:lk] = 302                            (: 'ancestor' '::' :)
          or $state[$p:lk] = 558                            (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 814                            (: 'parent' '::' :)
          or $state[$p:lk] = 1070                           (: 'preceding' '::' :)
          or $state[$p:lk] = 1326) then                     (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(146, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AxisStep", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DynamicFunctionInvocation (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DynamicFunctionInvocation-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37) then                           (: ',' :)
      $state
    else
      let $state := p:consume(37, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-DynamicFunctionInvocation-1($input, $state)
};

(:~
 : Parse DynamicFunctionInvocation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DynamicFunctionInvocation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | ')' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-DynamicFunctionInvocation-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DynamicFunctionInvocation", $count, $begin, $end)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(63, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(64, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Predicate", $count, $begin, $end)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Param", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(68, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 37) then                         (: ',' :)
        $state
      else
        let $state := p:consume(37, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParamList", $count, $begin, $end)
};

(:~
 : Parse InlineFunction.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InlineFunction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(112, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:consume(69, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(166, $input, $state)      (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InlineFunction", $count, $begin, $end)
};

(:~
 : Parse LiteralFunctionItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LiteralFunctionItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:consume(27, $input, $state)               (: '#' :)
  let $state := p:lookahead1W(15, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(7, $input, $state)                (: IntegerLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "LiteralFunctionItem", $count, $begin, $end)
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 112) then                           (: 'function' :)
      let $state := p:lookahead2W(256, 62, $input, $state)  (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 287) then                      (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InlineFunction($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LiteralFunctionItem($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionItemExpr", $count, $begin, $end)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(160, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(132, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: '{' :)
      let $state := p:consume(192, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(195, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 195) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompPIConstructor", $count, $begin, $end)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(82, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(175, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompTextConstructor", $count, $begin, $end)
};

(:~
 : Parse URIExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "URIExpr", $count, $begin, $end)
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PrefixExpr", $count, $begin, $end)
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prefix", $count, $begin, $end)
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(136, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(132, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: '{' :)
      let $state := p:consume(192, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrefixExpr($input, $state)
      let $state := p:consume(195, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 195) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URIExpr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompNamespaceConstructor", $count, $begin, $end)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(72, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(167, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: '{' :)
      let $state := p:consume(192, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(195, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 195) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompAttrConstructor", $count, $begin, $end)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContentExpr", $count, $begin, $end)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(99, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(167, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: '{' :)
      let $state := p:consume(192, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(195, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 195) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompElemConstructor", $count, $begin, $end)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(97, $input, $state)               (: 'document' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompDocConstructor", $count, $begin, $end)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 97) then                       (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComputedConstructor", $count, $begin, $end)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(54, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(3, $input, $state)             (: PITarget :)
  let $state := p:consume(17, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(12, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:consume(4, $input, $state)            (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(8, $input, $state)             (: '?>' :)
  let $state := p:consume(60, $input, $state)               (: '?>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirPIConstructor", $count, $begin, $end)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(50, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(3, $input, $state)                (: DirCommentContents :)
  let $state := p:lookahead1(5, $input, $state)             (: '-->' :)
  let $state := p:consume(39, $input, $state)               (: '-->' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49                             (: '<' :)
          or $state[$p:l1] = 50                             (: '<!--' :)
          or $state[$p:l1] = 54) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 5) then                        (: CDataSection :)
      let $state := p:consume(5, $input, $state)            (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 14) then                       (: ElementContentChar :)
      let $state := p:consume(14, $input, $state)           (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemContent", $count, $begin, $end)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: AposAttrContentChar :)
      let $state := p:consume(16, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AposAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExpr", $count, $begin, $end)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: PredefinedEntityRef :)
      let $state := p:consume(11, $input, $state)           (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 18) then                       (: CharRef :)
      let $state := p:consume(18, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: '{{' :)
      let $state := p:consume(193, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: '}}' :)
      let $state := p:consume(196, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnclosedExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CommonContent", $count, $begin, $end)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: QuotAttrContentChar :)
      let $state := p:consume(15, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QuotAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(116, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 26) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 12) then                 (: EscapeQuot :)
            let $state := p:consume(12, $input, $state)     (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(117, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 30) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 13) then                 (: EscapeApos :)
            let $state := p:consume(13, $input, $state)     (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(13, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26) then                       (: '"' :)
      let $state := p:consume(26, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(26, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(30, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(30, $input, $state)           (: "'" :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeValue", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(18, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 21) then                         (: S :)
        $state
      else
        let $state := p:consume(21, $input, $state)         (: S :)
        let $state := p:lookahead1(165, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 21                      (: S :)
               and $state[$p:l1] != 44                      (: '/>' :)
               and $state[$p:l1] != 56) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QName($input, $state)
            let $state := p:lookahead1(10, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 21) then             (: S :)
                let $state := p:consume(21, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(6, $input, $state)   (: '=' :)
            let $state := p:consume(55, $input, $state)     (: '=' :)
            let $state := p:lookahead1(17, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 21) then             (: S :)
                let $state := p:consume(21, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-DirAttributeList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(123, $input, $state)         (: CDataSection | PredefinedEntityRef | ElementContentChar |
                                                               CharRef | '<' | '<!--' | '</' | '<?' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 51) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(49, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '/>' :)
      let $state := p:consume(44, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(56, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(51, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1(11, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: S :)
          let $state := p:consume(21, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(7, $input, $state)         (: '>' :)
      let $state := p:consume(56, $input, $state)           (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemConstructor", $count, $begin, $end)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 50) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirectConstructor", $count, $begin, $end)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49                             (: '<' :)
          or $state[$p:l1] = 50                             (: '<!--' :)
          or $state[$p:l1] = 54) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComputedConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Constructor", $count, $begin, $end)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(183, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnorderedExpr", $count, $begin, $end)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(149, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderedExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37) then                           (: ',' :)
      $state
    else
      let $state := p:consume(37, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | ')' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionCall", $count, $begin, $end)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(40, $input, $state)               (: '.' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemExpr", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | ')' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedExpr", $count, $begin, $end)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarRef", $count, $begin, $end)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: IntegerLiteral :)
      let $state := p:consume(7, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 8) then                        (: DecimalLiteral :)
      let $state := p:consume(8, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(9, $input, $state)            (: DoubleLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: StringLiteral :)
      let $state := p:consume(10, $input, $state)           (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 19) then                            (: QName^Token :)
      let $state := p:lookahead2W(256, 62, $input, $state)  (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ancestor' :)
      let $state := p:lookahead2W(512, 62, $input, $state)  (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'ancestor-or-self' :)
      let $state := p:lookahead2W(768, 62, $input, $state)  (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'and' :)
      let $state := p:lookahead2W(1024, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'ascending' :)
      let $state := p:lookahead2W(1280, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'attribute' :)
      let $state := p:lookahead2W(1536, 168, $input, $state) (: QName^Token | S^WS | '#' | ('(' ':') | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                                'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                                'comment' | 'count' | 'declare' | 'default' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                                'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                                'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                                'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                                'preceding' | 'preceding-sibling' |
                                                                'processing-instruction' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                'validate' | 'where' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'case' :)
      let $state := p:lookahead2W(1792, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'cast' :)
      let $state := p:lookahead2W(2048, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'castable' :)
      let $state := p:lookahead2W(2304, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'child' :)
      let $state := p:lookahead2W(2560, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:lookahead2W(2816, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:lookahead2W(3072, 63, $input, $state) (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'count' :)
      let $state := p:lookahead2W(3328, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'declare' :)
      let $state := p:lookahead2W(3584, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'default' :)
      let $state := p:lookahead2W(3840, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant' :)
      let $state := p:lookahead2W(4096, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant-or-self' :)
      let $state := p:lookahead2W(4352, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descending' :)
      let $state := p:lookahead2W(4608, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'div' :)
      let $state := p:lookahead2W(4864, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'document' :)
      let $state := p:lookahead2W(5120, 97, $input, $state) (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state := p:lookahead2W(5376, 168, $input, $state) (: QName^Token | S^WS | '#' | ('(' ':') | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                                'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                                'comment' | 'count' | 'declare' | 'default' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                                'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                                'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                                'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                                'preceding' | 'preceding-sibling' |
                                                                'processing-instruction' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                'validate' | 'where' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'else' :)
      let $state := p:lookahead2W(5632, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'empty' :)
      let $state := p:lookahead2W(5888, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'end' :)
      let $state := p:lookahead2W(6144, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'eq' :)
      let $state := p:lookahead2W(6400, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'every' :)
      let $state := p:lookahead2W(6656, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'except' :)
      let $state := p:lookahead2W(6912, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'following' :)
      let $state := p:lookahead2W(7168, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'following-sibling' :)
      let $state := p:lookahead2W(7424, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'for' :)
      let $state := p:lookahead2W(7680, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'ge' :)
      let $state := p:lookahead2W(7936, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'group' :)
      let $state := p:lookahead2W(8192, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'gt' :)
      let $state := p:lookahead2W(8448, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'idiv' :)
      let $state := p:lookahead2W(8704, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'import' :)
      let $state := p:lookahead2W(8960, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'instance' :)
      let $state := p:lookahead2W(9216, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'intersect' :)
      let $state := p:lookahead2W(9472, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'is' :)
      let $state := p:lookahead2W(9728, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'le' :)
      let $state := p:lookahead2W(9984, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'let' :)
      let $state := p:lookahead2W(10240, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'lt' :)
      let $state := p:lookahead2W(10496, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'mod' :)
      let $state := p:lookahead2W(10752, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'module' :)
      let $state := p:lookahead2W(11008, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'namespace' :)
      let $state := p:lookahead2W(11264, 137, $input, $state) (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '{' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'ne' :)
      let $state := p:lookahead2W(11520, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'only' :)
      let $state := p:lookahead2W(11776, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'or' :)
      let $state := p:lookahead2W(12032, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'order' :)
      let $state := p:lookahead2W(12288, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'ordered' :)
      let $state := p:lookahead2W(12544, 97, $input, $state) (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'parent' :)
      let $state := p:lookahead2W(12800, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'preceding' :)
      let $state := p:lookahead2W(13056, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'preceding-sibling' :)
      let $state := p:lookahead2W(13312, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(13568, 136, $input, $state) (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '{' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'return' :)
      let $state := p:lookahead2W(13824, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'satisfies' :)
      let $state := p:lookahead2W(14080, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'self' :)
      let $state := p:lookahead2W(14336, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'some' :)
      let $state := p:lookahead2W(14592, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'stable' :)
      let $state := p:lookahead2W(14848, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'start' :)
      let $state := p:lookahead2W(15104, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'text' :)
      let $state := p:lookahead2W(15360, 63, $input, $state) (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'to' :)
      let $state := p:lookahead2W(15616, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'treat' :)
      let $state := p:lookahead2W(15872, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'try' :)
      let $state := p:lookahead2W(16128, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'union' :)
      let $state := p:lookahead2W(16384, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'unordered' :)
      let $state := p:lookahead2W(16640, 97, $input, $state) (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'validate' :)
      let $state := p:lookahead2W(16896, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'where' :)
      let $state := p:lookahead2W(17152, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'xquery' :)
      let $state := p:lookahead2W(17408, 62, $input, $state) (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7                              (: IntegerLiteral :)
          or $state[$p:lk] = 8                              (: DecimalLiteral :)
          or $state[$p:lk] = 9                              (: DoubleLiteral :)
          or $state[$p:lk] = 10) then                       (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 29) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 40) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 287                            (: QName^Token '(' :)
          or $state[$p:lk] = 543                            (: 'ancestor' '(' :)
          or $state[$p:lk] = 799                            (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 1055                           (: 'and' '(' :)
          or $state[$p:lk] = 1311                           (: 'ascending' '(' :)
          or $state[$p:lk] = 1823                           (: 'case' '(' :)
          or $state[$p:lk] = 2079                           (: 'cast' '(' :)
          or $state[$p:lk] = 2335                           (: 'castable' '(' :)
          or $state[$p:lk] = 2591                           (: 'child' '(' :)
          or $state[$p:lk] = 2847                           (: 'collation' '(' :)
          or $state[$p:lk] = 3359                           (: 'count' '(' :)
          or $state[$p:lk] = 3615                           (: 'declare' '(' :)
          or $state[$p:lk] = 3871                           (: 'default' '(' :)
          or $state[$p:lk] = 4127                           (: 'descendant' '(' :)
          or $state[$p:lk] = 4383                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 4639                           (: 'descending' '(' :)
          or $state[$p:lk] = 4895                           (: 'div' '(' :)
          or $state[$p:lk] = 5151                           (: 'document' '(' :)
          or $state[$p:lk] = 5663                           (: 'else' '(' :)
          or $state[$p:lk] = 5919                           (: 'empty' '(' :)
          or $state[$p:lk] = 6175                           (: 'end' '(' :)
          or $state[$p:lk] = 6431                           (: 'eq' '(' :)
          or $state[$p:lk] = 6687                           (: 'every' '(' :)
          or $state[$p:lk] = 6943                           (: 'except' '(' :)
          or $state[$p:lk] = 7199                           (: 'following' '(' :)
          or $state[$p:lk] = 7455                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 7711                           (: 'for' '(' :)
          or $state[$p:lk] = 7967                           (: 'ge' '(' :)
          or $state[$p:lk] = 8223                           (: 'group' '(' :)
          or $state[$p:lk] = 8479                           (: 'gt' '(' :)
          or $state[$p:lk] = 8735                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8991                           (: 'import' '(' :)
          or $state[$p:lk] = 9247                           (: 'instance' '(' :)
          or $state[$p:lk] = 9503                           (: 'intersect' '(' :)
          or $state[$p:lk] = 9759                           (: 'is' '(' :)
          or $state[$p:lk] = 10015                          (: 'le' '(' :)
          or $state[$p:lk] = 10271                          (: 'let' '(' :)
          or $state[$p:lk] = 10527                          (: 'lt' '(' :)
          or $state[$p:lk] = 10783                          (: 'mod' '(' :)
          or $state[$p:lk] = 11039                          (: 'module' '(' :)
          or $state[$p:lk] = 11295                          (: 'namespace' '(' :)
          or $state[$p:lk] = 11551                          (: 'ne' '(' :)
          or $state[$p:lk] = 11807                          (: 'only' '(' :)
          or $state[$p:lk] = 12063                          (: 'or' '(' :)
          or $state[$p:lk] = 12319                          (: 'order' '(' :)
          or $state[$p:lk] = 12575                          (: 'ordered' '(' :)
          or $state[$p:lk] = 12831                          (: 'parent' '(' :)
          or $state[$p:lk] = 13087                          (: 'preceding' '(' :)
          or $state[$p:lk] = 13343                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 13855                          (: 'return' '(' :)
          or $state[$p:lk] = 14111                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 14367                          (: 'self' '(' :)
          or $state[$p:lk] = 14623                          (: 'some' '(' :)
          or $state[$p:lk] = 14879                          (: 'stable' '(' :)
          or $state[$p:lk] = 15135                          (: 'start' '(' :)
          or $state[$p:lk] = 15647                          (: 'to' '(' :)
          or $state[$p:lk] = 15903                          (: 'treat' '(' :)
          or $state[$p:lk] = 16159                          (: 'try' '(' :)
          or $state[$p:lk] = 16415                          (: 'union' '(' :)
          or $state[$p:lk] = 16671                          (: 'unordered' '(' :)
          or $state[$p:lk] = 16927                          (: 'validate' '(' :)
          or $state[$p:lk] = 17183                          (: 'where' '(' :)
          or $state[$p:lk] = 17439) then                    (: 'xquery' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 12736) then                    (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 16832) then                    (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 98                             (: 'document-node' :)
          or $state[$p:lk] = 102                            (: 'empty-sequence' :)
          or $state[$p:lk] = 112                            (: 'function' :)
          or $state[$p:lk] = 119                            (: 'if' :)
          or $state[$p:lk] = 127                            (: 'item' :)
          or $state[$p:lk] = 137                            (: 'namespace-node' :)
          or $state[$p:lk] = 142                            (: 'node' :)
          or $state[$p:lk] = 165                            (: 'schema-attribute' :)
          or $state[$p:lk] = 166                            (: 'schema-element' :)
          or $state[$p:lk] = 174                            (: 'switch' :)
          or $state[$p:lk] = 181                            (: 'typeswitch' :)
          or $state[$p:lk] = 283                            (: QName^Token '#' :)
          or $state[$p:lk] = 539                            (: 'ancestor' '#' :)
          or $state[$p:lk] = 795                            (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 1051                           (: 'and' '#' :)
          or $state[$p:lk] = 1307                           (: 'ascending' '#' :)
          or $state[$p:lk] = 1563                           (: 'attribute' '#' :)
          or $state[$p:lk] = 1819                           (: 'case' '#' :)
          or $state[$p:lk] = 2075                           (: 'cast' '#' :)
          or $state[$p:lk] = 2331                           (: 'castable' '#' :)
          or $state[$p:lk] = 2587                           (: 'child' '#' :)
          or $state[$p:lk] = 2843                           (: 'collation' '#' :)
          or $state[$p:lk] = 3099                           (: 'comment' '#' :)
          or $state[$p:lk] = 3355                           (: 'count' '#' :)
          or $state[$p:lk] = 3611                           (: 'declare' '#' :)
          or $state[$p:lk] = 3867                           (: 'default' '#' :)
          or $state[$p:lk] = 4123                           (: 'descendant' '#' :)
          or $state[$p:lk] = 4379                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 4635                           (: 'descending' '#' :)
          or $state[$p:lk] = 4891                           (: 'div' '#' :)
          or $state[$p:lk] = 5147                           (: 'document' '#' :)
          or $state[$p:lk] = 5403                           (: 'element' '#' :)
          or $state[$p:lk] = 5659                           (: 'else' '#' :)
          or $state[$p:lk] = 5915                           (: 'empty' '#' :)
          or $state[$p:lk] = 6171                           (: 'end' '#' :)
          or $state[$p:lk] = 6427                           (: 'eq' '#' :)
          or $state[$p:lk] = 6683                           (: 'every' '#' :)
          or $state[$p:lk] = 6939                           (: 'except' '#' :)
          or $state[$p:lk] = 7195                           (: 'following' '#' :)
          or $state[$p:lk] = 7451                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7707                           (: 'for' '#' :)
          or $state[$p:lk] = 7963                           (: 'ge' '#' :)
          or $state[$p:lk] = 8219                           (: 'group' '#' :)
          or $state[$p:lk] = 8475                           (: 'gt' '#' :)
          or $state[$p:lk] = 8731                           (: 'idiv' '#' :)
          or $state[$p:lk] = 8987                           (: 'import' '#' :)
          or $state[$p:lk] = 9243                           (: 'instance' '#' :)
          or $state[$p:lk] = 9499                           (: 'intersect' '#' :)
          or $state[$p:lk] = 9755                           (: 'is' '#' :)
          or $state[$p:lk] = 10011                          (: 'le' '#' :)
          or $state[$p:lk] = 10267                          (: 'let' '#' :)
          or $state[$p:lk] = 10523                          (: 'lt' '#' :)
          or $state[$p:lk] = 10779                          (: 'mod' '#' :)
          or $state[$p:lk] = 11035                          (: 'module' '#' :)
          or $state[$p:lk] = 11291                          (: 'namespace' '#' :)
          or $state[$p:lk] = 11547                          (: 'ne' '#' :)
          or $state[$p:lk] = 11803                          (: 'only' '#' :)
          or $state[$p:lk] = 12059                          (: 'or' '#' :)
          or $state[$p:lk] = 12315                          (: 'order' '#' :)
          or $state[$p:lk] = 12571                          (: 'ordered' '#' :)
          or $state[$p:lk] = 12827                          (: 'parent' '#' :)
          or $state[$p:lk] = 13083                          (: 'preceding' '#' :)
          or $state[$p:lk] = 13339                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 13595                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 13851                          (: 'return' '#' :)
          or $state[$p:lk] = 14107                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 14363                          (: 'self' '#' :)
          or $state[$p:lk] = 14619                          (: 'some' '#' :)
          or $state[$p:lk] = 14875                          (: 'stable' '#' :)
          or $state[$p:lk] = 15131                          (: 'start' '#' :)
          or $state[$p:lk] = 15387                          (: 'text' '#' :)
          or $state[$p:lk] = 15643                          (: 'to' '#' :)
          or $state[$p:lk] = 15899                          (: 'treat' '#' :)
          or $state[$p:lk] = 16155                          (: 'try' '#' :)
          or $state[$p:lk] = 16411                          (: 'union' '#' :)
          or $state[$p:lk] = 16667                          (: 'unordered' '#' :)
          or $state[$p:lk] = 16923                          (: 'validate' '#' :)
          or $state[$p:lk] = 17179                          (: 'where' '#' :)
          or $state[$p:lk] = 17435) then                    (: 'xquery' '#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionItemExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Constructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FilterExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FilterExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(148, $input, $state)        (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 31                               (: '(' :)
      and $state[$p:l1] != 63) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 63) then                 (: '[' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DynamicFunctionInvocation($input, $state)
            return $state
        return p:parse-FilterExpr-1($input, $state)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-FilterExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FilterExpr", $count, $begin, $end)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 19) then                            (: QName^Token :)
      let $state := p:lookahead2W(256, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ancestor' :)
      let $state := p:lookahead2W(512, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'ancestor-or-self' :)
      let $state := p:lookahead2W(768, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'and' :)
      let $state := p:lookahead2W(1024, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'ascending' :)
      let $state := p:lookahead2W(1280, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'attribute' :)
      let $state := p:lookahead2W(1536, 180, $input, $state) (: QName^Token | S^WS | EOF | '!=' | '#' | '(' |
                                                                ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                                '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                                '>>' | '[' | ']' | 'ancestor' | 'ancestor-or-self' |
                                                                'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'count' | 'declare' | 'default' | 'descendant' |
                                                                'descendant-or-self' | 'descending' | 'div' |
                                                                'document' | 'document-node' | 'element' | 'else' |
                                                                'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                                'except' | 'following' | 'following-sibling' | 'for' |
                                                                'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                                'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'return' | 'satisfies' | 'schema-attribute' |
                                                                'schema-element' | 'self' | 'some' | 'stable' |
                                                                'start' | 'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                                'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                                'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 1604) then                      (: 'attribute' 'and' :)
          let $state := p:lookahead3W(1792, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1606) then                 (: 'attribute' 'ascending' :)
          let $state := p:lookahead3W(2048, 128, $input, $state) (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                                    'empty' | 'for' | 'group' | 'let' | 'order' |
                                                                    'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 1612) then                 (: 'attribute' 'case' :)
          let $state := p:lookahead3W(2304, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1613) then                 (: 'attribute' 'cast' :)
          let $state := p:lookahead3W(2560, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 1614) then                 (: 'attribute' 'castable' :)
          let $state := p:lookahead3W(2816, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 1617) then                 (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(3072, 61, $input, $state) (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 1622) then                 (: 'attribute' 'count' :)
          let $state := p:lookahead3W(3328, 66, $input, $state) (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 1626) then                 (: 'attribute' 'default' :)
          let $state := p:lookahead3W(3584, 98, $input, $state) (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 1629) then                 (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(3840, 128, $input, $state) (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                                    'empty' | 'for' | 'group' | 'let' | 'order' |
                                                                    'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 1632) then                 (: 'attribute' 'div' :)
          let $state := p:lookahead3W(4096, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1636) then                 (: 'attribute' 'else' :)
          let $state := p:lookahead3W(4352, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1637) then                 (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(4608, 107, $input, $state) (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 1640) then                 (: 'attribute' 'end' :)
          let $state := p:lookahead3W(4864, 118, $input, $state) (: S^WS | '$' | ('(' ':') | 'at' | 'next' |
                                                                    'previous' | 'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 1641) then                 (: 'attribute' 'eq' :)
          let $state := p:lookahead3W(5120, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1643) then                 (: 'attribute' 'except' :)
          let $state := p:lookahead3W(5376, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1647) then                 (: 'attribute' 'for' :)
          let $state := p:lookahead3W(5632, 109, $input, $state) (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' |
                                                                    '{' :)
          return $state
        else if ($state[$p:lk] = 1649) then                 (: 'attribute' 'ge' :)
          let $state := p:lookahead3W(5888, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1651) then                 (: 'attribute' 'group' :)
          let $state := p:lookahead3W(6144, 79, $input, $state) (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 1653) then                 (: 'attribute' 'gt' :)
          let $state := p:lookahead3W(6400, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1654) then                 (: 'attribute' 'idiv' :)
          let $state := p:lookahead3W(6656, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1660) then                 (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(6912, 90, $input, $state) (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 1661) then                 (: 'attribute' 'intersect' :)
          let $state := p:lookahead3W(7168, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1662) then                 (: 'attribute' 'is' :)
          let $state := p:lookahead3W(7424, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1665) then                 (: 'attribute' 'le' :)
          let $state := p:lookahead3W(7680, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1667) then                 (: 'attribute' 'let' :)
          let $state := p:lookahead3W(7936, 66, $input, $state) (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 1668) then                 (: 'attribute' 'lt' :)
          let $state := p:lookahead3W(8192, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1670) then                 (: 'attribute' 'mod' :)
          let $state := p:lookahead3W(8448, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1674) then                 (: 'attribute' 'ne' :)
          let $state := p:lookahead3W(8704, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1681) then                 (: 'attribute' 'only' :)
          let $state := p:lookahead3W(8960, 83, $input, $state) (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 1683) then                 (: 'attribute' 'or' :)
          let $state := p:lookahead3W(9216, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1684) then                 (: 'attribute' 'order' :)
          let $state := p:lookahead3W(9472, 79, $input, $state) (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 1698) then                 (: 'attribute' 'return' :)
          let $state := p:lookahead3W(9728, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1699) then                 (: 'attribute' 'satisfies' :)
          let $state := p:lookahead3W(9984, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                    DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                                    '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                                    '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                                    'ancestor' | 'ancestor-or-self' | 'and' |
                                                                    'ascending' | 'attribute' | 'case' | 'cast' |
                                                                    'castable' | 'child' | 'collation' | 'comment' |
                                                                    'count' | 'declare' | 'default' | 'descendant' |
                                                                    'descendant-or-self' | 'descending' | 'div' |
                                                                    'document' | 'document-node' | 'element' | 'else' |
                                                                    'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                    'every' | 'except' | 'following' |
                                                                    'following-sibling' | 'for' | 'function' | 'ge' |
                                                                    'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                    'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                    'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                    'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                    'order' | 'ordered' | 'parent' | 'preceding' |
                                                                    'preceding-sibling' | 'processing-instruction' |
                                                                    'return' | 'satisfies' | 'schema-attribute' |
                                                                    'schema-element' | 'self' | 'some' | 'stable' |
                                                                    'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                    'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                    'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1706) then                 (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(10240, 91, $input, $state) (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 1707) then                 (: 'attribute' 'start' :)
          let $state := p:lookahead3W(10496, 118, $input, $state) (: S^WS | '$' | ('(' ':') | 'at' | 'next' |
                                                                     'previous' | 'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 1713) then                 (: 'attribute' 'to' :)
          let $state := p:lookahead3W(10752, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1714) then                 (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(11008, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 1718) then                 (: 'attribute' 'union' :)
          let $state := p:lookahead3W(11264, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 1724) then                 (: 'attribute' 'where' :)
          let $state := p:lookahead3W(11520, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'case' :)
      let $state := p:lookahead2W(11776, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'cast' :)
      let $state := p:lookahead2W(12032, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'castable' :)
      let $state := p:lookahead2W(12288, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'child' :)
      let $state := p:lookahead2W(12544, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:lookahead2W(12800, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:lookahead2W(13056, 157, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'count' :)
      let $state := p:lookahead2W(13312, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'declare' :)
      let $state := p:lookahead2W(13568, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'default' :)
      let $state := p:lookahead2W(13824, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant' :)
      let $state := p:lookahead2W(14080, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant-or-self' :)
      let $state := p:lookahead2W(14336, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descending' :)
      let $state := p:lookahead2W(14592, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'div' :)
      let $state := p:lookahead2W(14848, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'document' :)
      let $state := p:lookahead2W(15104, 157, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'document-node' :)
      let $state := p:lookahead2W(15360, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state := p:lookahead2W(15616, 179, $input, $state) (: QName^Token | S^WS | EOF | '!=' | '#' | '(' |
                                                                 ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                                 ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                                 '[' | ']' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                 'ascending' | 'attribute' | 'case' | 'cast' |
                                                                 'castable' | 'child' | 'collation' | 'comment' |
                                                                 'count' | 'declare' | 'default' | 'descendant' |
                                                                 'descendant-or-self' | 'descending' | 'div' |
                                                                 'document' | 'document-node' | 'element' | 'else' |
                                                                 'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                                 'except' | 'following' | 'following-sibling' | 'for' |
                                                                 'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                                 'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                 'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                 'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                 'order' | 'ordered' | 'parent' | 'preceding' |
                                                                 'preceding-sibling' | 'processing-instruction' |
                                                                 'return' | 'satisfies' | 'schema-attribute' |
                                                                 'schema-element' | 'self' | 'some' | 'stable' |
                                                                 'start' | 'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                                 'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                                 'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 15684) then                     (: 'element' 'and' :)
          let $state := p:lookahead3W(15872, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15686) then                (: 'element' 'ascending' :)
          let $state := p:lookahead3W(16128, 128, $input, $state) (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                                     'empty' | 'for' | 'group' | 'let' | 'order' |
                                                                     'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 15692) then                (: 'element' 'case' :)
          let $state := p:lookahead3W(16384, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15693) then                (: 'element' 'cast' :)
          let $state := p:lookahead3W(16640, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 15694) then                (: 'element' 'castable' :)
          let $state := p:lookahead3W(16896, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 15697) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(17152, 61, $input, $state) (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 15702) then                (: 'element' 'count' :)
          let $state := p:lookahead3W(17408, 66, $input, $state) (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 15706) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(17664, 98, $input, $state) (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 15709) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(17920, 128, $input, $state) (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                                     'empty' | 'for' | 'group' | 'let' | 'order' |
                                                                     'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 15712) then                (: 'element' 'div' :)
          let $state := p:lookahead3W(18176, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15716) then                (: 'element' 'else' :)
          let $state := p:lookahead3W(18432, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15717) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(18688, 107, $input, $state) (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 15720) then                (: 'element' 'end' :)
          let $state := p:lookahead3W(18944, 118, $input, $state) (: S^WS | '$' | ('(' ':') | 'at' | 'next' |
                                                                     'previous' | 'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 15721) then                (: 'element' 'eq' :)
          let $state := p:lookahead3W(19200, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15723) then                (: 'element' 'except' :)
          let $state := p:lookahead3W(19456, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15727) then                (: 'element' 'for' :)
          let $state := p:lookahead3W(19712, 109, $input, $state) (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' |
                                                                     '{' :)
          return $state
        else if ($state[$p:lk] = 15729) then                (: 'element' 'ge' :)
          let $state := p:lookahead3W(19968, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15731) then                (: 'element' 'group' :)
          let $state := p:lookahead3W(20224, 79, $input, $state) (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 15733) then                (: 'element' 'gt' :)
          let $state := p:lookahead3W(20480, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15734) then                (: 'element' 'idiv' :)
          let $state := p:lookahead3W(20736, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15740) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(20992, 90, $input, $state) (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 15741) then                (: 'element' 'intersect' :)
          let $state := p:lookahead3W(21248, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15742) then                (: 'element' 'is' :)
          let $state := p:lookahead3W(21504, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15745) then                (: 'element' 'le' :)
          let $state := p:lookahead3W(21760, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15747) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(22016, 66, $input, $state) (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 15748) then                (: 'element' 'lt' :)
          let $state := p:lookahead3W(22272, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15750) then                (: 'element' 'mod' :)
          let $state := p:lookahead3W(22528, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15754) then                (: 'element' 'ne' :)
          let $state := p:lookahead3W(22784, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15761) then                (: 'element' 'only' :)
          let $state := p:lookahead3W(23040, 83, $input, $state) (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 15763) then                (: 'element' 'or' :)
          let $state := p:lookahead3W(23296, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15764) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(23552, 79, $input, $state) (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 15778) then                (: 'element' 'return' :)
          let $state := p:lookahead3W(23808, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15779) then                (: 'element' 'satisfies' :)
          let $state := p:lookahead3W(24064, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15786) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(24320, 91, $input, $state) (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 15787) then                (: 'element' 'start' :)
          let $state := p:lookahead3W(24576, 118, $input, $state) (: S^WS | '$' | ('(' ':') | 'at' | 'next' |
                                                                     'previous' | 'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 15793) then                (: 'element' 'to' :)
          let $state := p:lookahead3W(24832, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15794) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(25088, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 15798) then                (: 'element' 'union' :)
          let $state := p:lookahead3W(25344, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 15804) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(25600, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'else' :)
      let $state := p:lookahead2W(25856, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'empty' :)
      let $state := p:lookahead2W(26112, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'empty-sequence' :)
      let $state := p:lookahead2W(26368, 147, $input, $state) (: S^WS | EOF | '!=' | '#' | ('(' ':') | ')' | '*' | '+' |
                                                                 ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                 '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'end' :)
      let $state := p:lookahead2W(26624, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'eq' :)
      let $state := p:lookahead2W(26880, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'every' :)
      let $state := p:lookahead2W(27136, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'except' :)
      let $state := p:lookahead2W(27392, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'following' :)
      let $state := p:lookahead2W(27648, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'following-sibling' :)
      let $state := p:lookahead2W(27904, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'for' :)
      let $state := p:lookahead2W(28160, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'function' :)
      let $state := p:lookahead2W(28416, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'ge' :)
      let $state := p:lookahead2W(28672, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'group' :)
      let $state := p:lookahead2W(28928, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'gt' :)
      let $state := p:lookahead2W(29184, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'idiv' :)
      let $state := p:lookahead2W(29440, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'if' :)
      let $state := p:lookahead2W(29696, 147, $input, $state) (: S^WS | EOF | '!=' | '#' | ('(' ':') | ')' | '*' | '+' |
                                                                 ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                 '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'import' :)
      let $state := p:lookahead2W(29952, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'instance' :)
      let $state := p:lookahead2W(30208, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'intersect' :)
      let $state := p:lookahead2W(30464, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'is' :)
      let $state := p:lookahead2W(30720, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'item' :)
      let $state := p:lookahead2W(30976, 147, $input, $state) (: S^WS | EOF | '!=' | '#' | ('(' ':') | ')' | '*' | '+' |
                                                                 ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                 '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'le' :)
      let $state := p:lookahead2W(31232, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'let' :)
      let $state := p:lookahead2W(31488, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'lt' :)
      let $state := p:lookahead2W(31744, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'mod' :)
      let $state := p:lookahead2W(32000, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'module' :)
      let $state := p:lookahead2W(32256, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'namespace' :)
      let $state := p:lookahead2W(32512, 158, $input, $state) (: NCName^Token | S^WS | EOF | '!=' | '#' | '(' |
                                                                 ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                                 ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                                 '[' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                                 'castable' | 'collation' | 'count' | 'default' |
                                                                 'descending' | 'div' | 'else' | 'empty' | 'end' |
                                                                 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                                 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                 'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                 'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 32580) then                     (: 'namespace' 'and' :)
          let $state := p:lookahead3W(32768, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32582) then                (: 'namespace' 'ascending' :)
          let $state := p:lookahead3W(33024, 128, $input, $state) (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                                     'empty' | 'for' | 'group' | 'let' | 'order' |
                                                                     'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 32588) then                (: 'namespace' 'case' :)
          let $state := p:lookahead3W(33280, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32589) then                (: 'namespace' 'cast' :)
          let $state := p:lookahead3W(33536, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 32590) then                (: 'namespace' 'castable' :)
          let $state := p:lookahead3W(33792, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 32593) then                (: 'namespace' 'collation' :)
          let $state := p:lookahead3W(34048, 61, $input, $state) (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 32598) then                (: 'namespace' 'count' :)
          let $state := p:lookahead3W(34304, 66, $input, $state) (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 32602) then                (: 'namespace' 'default' :)
          let $state := p:lookahead3W(34560, 98, $input, $state) (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 32605) then                (: 'namespace' 'descending' :)
          let $state := p:lookahead3W(34816, 128, $input, $state) (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                                     'empty' | 'for' | 'group' | 'let' | 'order' |
                                                                     'return' | 'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 32608) then                (: 'namespace' 'div' :)
          let $state := p:lookahead3W(35072, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32612) then                (: 'namespace' 'else' :)
          let $state := p:lookahead3W(35328, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32613) then                (: 'namespace' 'empty' :)
          let $state := p:lookahead3W(35584, 107, $input, $state) (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 32616) then                (: 'namespace' 'end' :)
          let $state := p:lookahead3W(35840, 118, $input, $state) (: S^WS | '$' | ('(' ':') | 'at' | 'next' |
                                                                     'previous' | 'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 32617) then                (: 'namespace' 'eq' :)
          let $state := p:lookahead3W(36096, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32619) then                (: 'namespace' 'except' :)
          let $state := p:lookahead3W(36352, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32623) then                (: 'namespace' 'for' :)
          let $state := p:lookahead3W(36608, 109, $input, $state) (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' |
                                                                     '{' :)
          return $state
        else if ($state[$p:lk] = 32625) then                (: 'namespace' 'ge' :)
          let $state := p:lookahead3W(36864, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32627) then                (: 'namespace' 'group' :)
          let $state := p:lookahead3W(37120, 79, $input, $state) (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 32629) then                (: 'namespace' 'gt' :)
          let $state := p:lookahead3W(37376, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32630) then                (: 'namespace' 'idiv' :)
          let $state := p:lookahead3W(37632, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32636) then                (: 'namespace' 'instance' :)
          let $state := p:lookahead3W(37888, 90, $input, $state) (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 32637) then                (: 'namespace' 'intersect' :)
          let $state := p:lookahead3W(38144, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32638) then                (: 'namespace' 'is' :)
          let $state := p:lookahead3W(38400, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32641) then                (: 'namespace' 'le' :)
          let $state := p:lookahead3W(38656, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32643) then                (: 'namespace' 'let' :)
          let $state := p:lookahead3W(38912, 66, $input, $state) (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 32644) then                (: 'namespace' 'lt' :)
          let $state := p:lookahead3W(39168, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32646) then                (: 'namespace' 'mod' :)
          let $state := p:lookahead3W(39424, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32650) then                (: 'namespace' 'ne' :)
          let $state := p:lookahead3W(39680, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32657) then                (: 'namespace' 'only' :)
          let $state := p:lookahead3W(39936, 83, $input, $state) (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 32659) then                (: 'namespace' 'or' :)
          let $state := p:lookahead3W(40192, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32660) then                (: 'namespace' 'order' :)
          let $state := p:lookahead3W(40448, 79, $input, $state) (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 32674) then                (: 'namespace' 'return' :)
          let $state := p:lookahead3W(40704, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32675) then                (: 'namespace' 'satisfies' :)
          let $state := p:lookahead3W(40960, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32682) then                (: 'namespace' 'stable' :)
          let $state := p:lookahead3W(41216, 91, $input, $state) (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 32683) then                (: 'namespace' 'start' :)
          let $state := p:lookahead3W(41472, 118, $input, $state) (: S^WS | '$' | ('(' ':') | 'at' | 'next' |
                                                                     'previous' | 'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 32689) then                (: 'namespace' 'to' :)
          let $state := p:lookahead3W(41728, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32690) then                (: 'namespace' 'treat' :)
          let $state := p:lookahead3W(41984, 77, $input, $state) (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 32694) then                (: 'namespace' 'union' :)
          let $state := p:lookahead3W(42240, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 32700) then                (: 'namespace' 'where' :)
          let $state := p:lookahead3W(42496, 177, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                     DoubleLiteral | StringLiteral | QName^Token |
                                                                     S^WS | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                                     '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                     '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                     'ascending' | 'attribute' | 'case' | 'cast' |
                                                                     'castable' | 'child' | 'collation' | 'comment' |
                                                                     'count' | 'declare' | 'default' | 'descendant' |
                                                                     'descendant-or-self' | 'descending' | 'div' |
                                                                     'document' | 'document-node' | 'element' | 'else' |
                                                                     'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                     'every' | 'except' | 'following' |
                                                                     'following-sibling' | 'for' | 'function' | 'ge' |
                                                                     'group' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                     'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                     'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                                     'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                     'order' | 'ordered' | 'parent' | 'preceding' |
                                                                     'preceding-sibling' | 'processing-instruction' |
                                                                     'return' | 'satisfies' | 'schema-attribute' |
                                                                     'schema-element' | 'self' | 'some' | 'stable' |
                                                                     'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                                     'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                     'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace-node' :)
      let $state := p:lookahead2W(42752, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'ne' :)
      let $state := p:lookahead2W(43008, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'node' :)
      let $state := p:lookahead2W(43264, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'only' :)
      let $state := p:lookahead2W(43520, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'or' :)
      let $state := p:lookahead2W(43776, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'order' :)
      let $state := p:lookahead2W(44032, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'ordered' :)
      let $state := p:lookahead2W(44288, 157, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'parent' :)
      let $state := p:lookahead2W(44544, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'preceding' :)
      let $state := p:lookahead2W(44800, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'preceding-sibling' :)
      let $state := p:lookahead2W(45056, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(45312, 158, $input, $state) (: NCName^Token | S^WS | EOF | '!=' | '#' | '(' |
                                                                 ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                                 ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                                 '[' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                                 'castable' | 'collation' | 'count' | 'default' |
                                                                 'descending' | 'div' | 'else' | 'empty' | 'end' |
                                                                 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                                 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                 'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                                 'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                                 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'return' :)
      let $state := p:lookahead2W(55552, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'satisfies' :)
      let $state := p:lookahead2W(55808, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'schema-attribute' :)
      let $state := p:lookahead2W(56064, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'schema-element' :)
      let $state := p:lookahead2W(56320, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'self' :)
      let $state := p:lookahead2W(56576, 156, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                                 '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                                 'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'some' :)
      let $state := p:lookahead2W(56832, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'stable' :)
      let $state := p:lookahead2W(57088, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'start' :)
      let $state := p:lookahead2W(57344, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'switch' :)
      let $state := p:lookahead2W(57600, 147, $input, $state) (: S^WS | EOF | '!=' | '#' | ('(' ':') | ')' | '*' | '+' |
                                                                 ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                 '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'text' :)
      let $state := p:lookahead2W(57856, 157, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'to' :)
      let $state := p:lookahead2W(58112, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'treat' :)
      let $state := p:lookahead2W(58368, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'try' :)
      let $state := p:lookahead2W(58624, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(58880, 147, $input, $state) (: S^WS | EOF | '!=' | '#' | ('(' ':') | ')' | '*' | '+' |
                                                                 ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                 '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'union' :)
      let $state := p:lookahead2W(59136, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'unordered' :)
      let $state := p:lookahead2W(59392, 157, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'validate' :)
      let $state := p:lookahead2W(59648, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'where' :)
      let $state := p:lookahead2W(59904, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'xquery' :)
      let $state := p:lookahead2W(60160, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                 '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                 '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                 'ascending' | 'case' | 'cast' | 'castable' |
                                                                 'collation' | 'count' | 'default' | 'descending' |
                                                                 'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                 'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                 'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7                              (: IntegerLiteral :)
          or $state[$p:lk] = 8                              (: DecimalLiteral :)
          or $state[$p:lk] = 9                              (: DoubleLiteral :)
          or $state[$p:lk] = 10                             (: StringLiteral :)
          or $state[$p:lk] = 29                             (: '$' :)
          or $state[$p:lk] = 31                             (: '(' :)
          or $state[$p:lk] = 40                             (: '.' :)
          or $state[$p:lk] = 49                             (: '<' :)
          or $state[$p:lk] = 50                             (: '<!--' :)
          or $state[$p:lk] = 54                             (: '<?' :)
          or $state[$p:lk] = 1555                           (: 'attribute' QName^Token :)
          or $state[$p:lk] = 15635                          (: 'element' QName^Token :)
          or $state[$p:lk] = 32532                          (: 'namespace' NCName^Token :)
          or $state[$p:lk] = 45332                          (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 283                            (: QName^Token '#' :)
          or $state[$p:lk] = 539                            (: 'ancestor' '#' :)
          or $state[$p:lk] = 795                            (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 1051                           (: 'and' '#' :)
          or $state[$p:lk] = 1307                           (: 'ascending' '#' :)
          or $state[$p:lk] = 1563                           (: 'attribute' '#' :)
          or $state[$p:lk] = 11803                          (: 'case' '#' :)
          or $state[$p:lk] = 12059                          (: 'cast' '#' :)
          or $state[$p:lk] = 12315                          (: 'castable' '#' :)
          or $state[$p:lk] = 12571                          (: 'child' '#' :)
          or $state[$p:lk] = 12827                          (: 'collation' '#' :)
          or $state[$p:lk] = 13083                          (: 'comment' '#' :)
          or $state[$p:lk] = 13339                          (: 'count' '#' :)
          or $state[$p:lk] = 13595                          (: 'declare' '#' :)
          or $state[$p:lk] = 13851                          (: 'default' '#' :)
          or $state[$p:lk] = 14107                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14363                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14619                          (: 'descending' '#' :)
          or $state[$p:lk] = 14875                          (: 'div' '#' :)
          or $state[$p:lk] = 15131                          (: 'document' '#' :)
          or $state[$p:lk] = 15387                          (: 'document-node' '#' :)
          or $state[$p:lk] = 15643                          (: 'element' '#' :)
          or $state[$p:lk] = 25883                          (: 'else' '#' :)
          or $state[$p:lk] = 26139                          (: 'empty' '#' :)
          or $state[$p:lk] = 26395                          (: 'empty-sequence' '#' :)
          or $state[$p:lk] = 26651                          (: 'end' '#' :)
          or $state[$p:lk] = 26907                          (: 'eq' '#' :)
          or $state[$p:lk] = 27163                          (: 'every' '#' :)
          or $state[$p:lk] = 27419                          (: 'except' '#' :)
          or $state[$p:lk] = 27675                          (: 'following' '#' :)
          or $state[$p:lk] = 27931                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 28187                          (: 'for' '#' :)
          or $state[$p:lk] = 28443                          (: 'function' '#' :)
          or $state[$p:lk] = 28699                          (: 'ge' '#' :)
          or $state[$p:lk] = 28955                          (: 'group' '#' :)
          or $state[$p:lk] = 29211                          (: 'gt' '#' :)
          or $state[$p:lk] = 29467                          (: 'idiv' '#' :)
          or $state[$p:lk] = 29723                          (: 'if' '#' :)
          or $state[$p:lk] = 29979                          (: 'import' '#' :)
          or $state[$p:lk] = 30235                          (: 'instance' '#' :)
          or $state[$p:lk] = 30491                          (: 'intersect' '#' :)
          or $state[$p:lk] = 30747                          (: 'is' '#' :)
          or $state[$p:lk] = 31003                          (: 'item' '#' :)
          or $state[$p:lk] = 31259                          (: 'le' '#' :)
          or $state[$p:lk] = 31515                          (: 'let' '#' :)
          or $state[$p:lk] = 31771                          (: 'lt' '#' :)
          or $state[$p:lk] = 32027                          (: 'mod' '#' :)
          or $state[$p:lk] = 32283                          (: 'module' '#' :)
          or $state[$p:lk] = 32539                          (: 'namespace' '#' :)
          or $state[$p:lk] = 42779                          (: 'namespace-node' '#' :)
          or $state[$p:lk] = 43035                          (: 'ne' '#' :)
          or $state[$p:lk] = 43291                          (: 'node' '#' :)
          or $state[$p:lk] = 43547                          (: 'only' '#' :)
          or $state[$p:lk] = 43803                          (: 'or' '#' :)
          or $state[$p:lk] = 44059                          (: 'order' '#' :)
          or $state[$p:lk] = 44315                          (: 'ordered' '#' :)
          or $state[$p:lk] = 44571                          (: 'parent' '#' :)
          or $state[$p:lk] = 44827                          (: 'preceding' '#' :)
          or $state[$p:lk] = 45083                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 45339                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 55579                          (: 'return' '#' :)
          or $state[$p:lk] = 55835                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 56091                          (: 'schema-attribute' '#' :)
          or $state[$p:lk] = 56347                          (: 'schema-element' '#' :)
          or $state[$p:lk] = 56603                          (: 'self' '#' :)
          or $state[$p:lk] = 56859                          (: 'some' '#' :)
          or $state[$p:lk] = 57115                          (: 'stable' '#' :)
          or $state[$p:lk] = 57371                          (: 'start' '#' :)
          or $state[$p:lk] = 57627                          (: 'switch' '#' :)
          or $state[$p:lk] = 57883                          (: 'text' '#' :)
          or $state[$p:lk] = 58139                          (: 'to' '#' :)
          or $state[$p:lk] = 58395                          (: 'treat' '#' :)
          or $state[$p:lk] = 58651                          (: 'try' '#' :)
          or $state[$p:lk] = 58907                          (: 'typeswitch' '#' :)
          or $state[$p:lk] = 59163                          (: 'union' '#' :)
          or $state[$p:lk] = 59419                          (: 'unordered' '#' :)
          or $state[$p:lk] = 59675                          (: 'validate' '#' :)
          or $state[$p:lk] = 59931                          (: 'where' '#' :)
          or $state[$p:lk] = 60187                          (: 'xquery' '#' :)
          or $state[$p:lk] = 287                            (: QName^Token '(' :)
          or $state[$p:lk] = 543                            (: 'ancestor' '(' :)
          or $state[$p:lk] = 799                            (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 1055                           (: 'and' '(' :)
          or $state[$p:lk] = 1311                           (: 'ascending' '(' :)
          or $state[$p:lk] = 11807                          (: 'case' '(' :)
          or $state[$p:lk] = 12063                          (: 'cast' '(' :)
          or $state[$p:lk] = 12319                          (: 'castable' '(' :)
          or $state[$p:lk] = 12575                          (: 'child' '(' :)
          or $state[$p:lk] = 12831                          (: 'collation' '(' :)
          or $state[$p:lk] = 13343                          (: 'count' '(' :)
          or $state[$p:lk] = 13599                          (: 'declare' '(' :)
          or $state[$p:lk] = 13855                          (: 'default' '(' :)
          or $state[$p:lk] = 14111                          (: 'descendant' '(' :)
          or $state[$p:lk] = 14367                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 14623                          (: 'descending' '(' :)
          or $state[$p:lk] = 14879                          (: 'div' '(' :)
          or $state[$p:lk] = 15135                          (: 'document' '(' :)
          or $state[$p:lk] = 25887                          (: 'else' '(' :)
          or $state[$p:lk] = 26143                          (: 'empty' '(' :)
          or $state[$p:lk] = 26655                          (: 'end' '(' :)
          or $state[$p:lk] = 26911                          (: 'eq' '(' :)
          or $state[$p:lk] = 27167                          (: 'every' '(' :)
          or $state[$p:lk] = 27423                          (: 'except' '(' :)
          or $state[$p:lk] = 27679                          (: 'following' '(' :)
          or $state[$p:lk] = 27935                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 28191                          (: 'for' '(' :)
          or $state[$p:lk] = 28447                          (: 'function' '(' :)
          or $state[$p:lk] = 28703                          (: 'ge' '(' :)
          or $state[$p:lk] = 28959                          (: 'group' '(' :)
          or $state[$p:lk] = 29215                          (: 'gt' '(' :)
          or $state[$p:lk] = 29471                          (: 'idiv' '(' :)
          or $state[$p:lk] = 29983                          (: 'import' '(' :)
          or $state[$p:lk] = 30239                          (: 'instance' '(' :)
          or $state[$p:lk] = 30495                          (: 'intersect' '(' :)
          or $state[$p:lk] = 30751                          (: 'is' '(' :)
          or $state[$p:lk] = 31263                          (: 'le' '(' :)
          or $state[$p:lk] = 31519                          (: 'let' '(' :)
          or $state[$p:lk] = 31775                          (: 'lt' '(' :)
          or $state[$p:lk] = 32031                          (: 'mod' '(' :)
          or $state[$p:lk] = 32287                          (: 'module' '(' :)
          or $state[$p:lk] = 32543                          (: 'namespace' '(' :)
          or $state[$p:lk] = 43039                          (: 'ne' '(' :)
          or $state[$p:lk] = 43551                          (: 'only' '(' :)
          or $state[$p:lk] = 43807                          (: 'or' '(' :)
          or $state[$p:lk] = 44063                          (: 'order' '(' :)
          or $state[$p:lk] = 44319                          (: 'ordered' '(' :)
          or $state[$p:lk] = 44575                          (: 'parent' '(' :)
          or $state[$p:lk] = 44831                          (: 'preceding' '(' :)
          or $state[$p:lk] = 45087                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 55583                          (: 'return' '(' :)
          or $state[$p:lk] = 55839                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 56607                          (: 'self' '(' :)
          or $state[$p:lk] = 56863                          (: 'some' '(' :)
          or $state[$p:lk] = 57119                          (: 'stable' '(' :)
          or $state[$p:lk] = 57375                          (: 'start' '(' :)
          or $state[$p:lk] = 58143                          (: 'to' '(' :)
          or $state[$p:lk] = 58399                          (: 'treat' '(' :)
          or $state[$p:lk] = 58655                          (: 'try' '(' :)
          or $state[$p:lk] = 59167                          (: 'union' '(' :)
          or $state[$p:lk] = 59423                          (: 'unordered' '(' :)
          or $state[$p:lk] = 59679                          (: 'validate' '(' :)
          or $state[$p:lk] = 59935                          (: 'where' '(' :)
          or $state[$p:lk] = 60191                          (: 'xquery' '(' :)
          or $state[$p:lk] = 1602                           (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 15682                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 1603                           (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 15683                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 1608                           (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 15688                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 1616                           (: 'attribute' 'child' :)
          or $state[$p:lk] = 15696                          (: 'element' 'child' :)
          or $state[$p:lk] = 1618                           (: 'attribute' 'comment' :)
          or $state[$p:lk] = 15698                          (: 'element' 'comment' :)
          or $state[$p:lk] = 1625                           (: 'attribute' 'declare' :)
          or $state[$p:lk] = 15705                          (: 'element' 'declare' :)
          or $state[$p:lk] = 1627                           (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 15707                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 1628                           (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 15708                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 1633                           (: 'attribute' 'document' :)
          or $state[$p:lk] = 15713                          (: 'element' 'document' :)
          or $state[$p:lk] = 1634                           (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 15714                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 1635                           (: 'attribute' 'element' :)
          or $state[$p:lk] = 15715                          (: 'element' 'element' :)
          or $state[$p:lk] = 1638                           (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 15718                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 1642                           (: 'attribute' 'every' :)
          or $state[$p:lk] = 15722                          (: 'element' 'every' :)
          or $state[$p:lk] = 1645                           (: 'attribute' 'following' :)
          or $state[$p:lk] = 15725                          (: 'element' 'following' :)
          or $state[$p:lk] = 1646                           (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 15726                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 1648                           (: 'attribute' 'function' :)
          or $state[$p:lk] = 15728                          (: 'element' 'function' :)
          or $state[$p:lk] = 1655                           (: 'attribute' 'if' :)
          or $state[$p:lk] = 15735                          (: 'element' 'if' :)
          or $state[$p:lk] = 1656                           (: 'attribute' 'import' :)
          or $state[$p:lk] = 15736                          (: 'element' 'import' :)
          or $state[$p:lk] = 1663                           (: 'attribute' 'item' :)
          or $state[$p:lk] = 15743                          (: 'element' 'item' :)
          or $state[$p:lk] = 1671                           (: 'attribute' 'module' :)
          or $state[$p:lk] = 15751                          (: 'element' 'module' :)
          or $state[$p:lk] = 1672                           (: 'attribute' 'namespace' :)
          or $state[$p:lk] = 15752                          (: 'element' 'namespace' :)
          or $state[$p:lk] = 1673                           (: 'attribute' 'namespace-node' :)
          or $state[$p:lk] = 15753                          (: 'element' 'namespace-node' :)
          or $state[$p:lk] = 1678                           (: 'attribute' 'node' :)
          or $state[$p:lk] = 15758                          (: 'element' 'node' :)
          or $state[$p:lk] = 1685                           (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 15765                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 1687                           (: 'attribute' 'parent' :)
          or $state[$p:lk] = 15767                          (: 'element' 'parent' :)
          or $state[$p:lk] = 1691                           (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 15771                          (: 'element' 'preceding' :)
          or $state[$p:lk] = 1692                           (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 15772                          (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 1696                           (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 15776                          (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 1701                           (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 15781                          (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 1702                           (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 15782                          (: 'element' 'schema-element' :)
          or $state[$p:lk] = 1703                           (: 'attribute' 'self' :)
          or $state[$p:lk] = 15783                          (: 'element' 'self' :)
          or $state[$p:lk] = 1705                           (: 'attribute' 'some' :)
          or $state[$p:lk] = 15785                          (: 'element' 'some' :)
          or $state[$p:lk] = 1710                           (: 'attribute' 'switch' :)
          or $state[$p:lk] = 15790                          (: 'element' 'switch' :)
          or $state[$p:lk] = 1711                           (: 'attribute' 'text' :)
          or $state[$p:lk] = 15791                          (: 'element' 'text' :)
          or $state[$p:lk] = 1715                           (: 'attribute' 'try' :)
          or $state[$p:lk] = 15795                          (: 'element' 'try' :)
          or $state[$p:lk] = 1717                           (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 15797                          (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 1719                           (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 15799                          (: 'element' 'unordered' :)
          or $state[$p:lk] = 1720                           (: 'attribute' 'validate' :)
          or $state[$p:lk] = 15800                          (: 'element' 'validate' :)
          or $state[$p:lk] = 1726                           (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 15806                          (: 'element' 'xquery' :)
          or $state[$p:lk] = 1728                           (: 'attribute' '{' :)
          or $state[$p:lk] = 13248                          (: 'comment' '{' :)
          or $state[$p:lk] = 15296                          (: 'document' '{' :)
          or $state[$p:lk] = 15808                          (: 'element' '{' :)
          or $state[$p:lk] = 32704                          (: 'namespace' '{' :)
          or $state[$p:lk] = 44480                          (: 'ordered' '{' :)
          or $state[$p:lk] = 45504                          (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 58048                          (: 'text' '{' :)
          or $state[$p:lk] = 59584                          (: 'unordered' '{' :)
          or $state[$p:lk] = 1984                           (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 16064                          (: 'element' 'and' '{' :)
          or $state[$p:lk] = 32960                          (: 'namespace' 'and' '{' :)
          or $state[$p:lk] = 45760                          (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 2240                           (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 16320                          (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 33216                          (: 'namespace' 'ascending' '{' :)
          or $state[$p:lk] = 46016                          (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 2496                           (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 16576                          (: 'element' 'case' '{' :)
          or $state[$p:lk] = 33472                          (: 'namespace' 'case' '{' :)
          or $state[$p:lk] = 46272                          (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 2752                           (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 16832                          (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 33728                          (: 'namespace' 'cast' '{' :)
          or $state[$p:lk] = 46528                          (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 3008                           (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 17088                          (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 33984                          (: 'namespace' 'castable' '{' :)
          or $state[$p:lk] = 46784                          (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 3264                           (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 17344                          (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 34240                          (: 'namespace' 'collation' '{' :)
          or $state[$p:lk] = 47040                          (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 3520                           (: 'attribute' 'count' '{' :)
          or $state[$p:lk] = 17600                          (: 'element' 'count' '{' :)
          or $state[$p:lk] = 34496                          (: 'namespace' 'count' '{' :)
          or $state[$p:lk] = 47296                          (: 'processing-instruction' 'count' '{' :)
          or $state[$p:lk] = 3776                           (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 17856                          (: 'element' 'default' '{' :)
          or $state[$p:lk] = 34752                          (: 'namespace' 'default' '{' :)
          or $state[$p:lk] = 47552                          (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 4032                           (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 18112                          (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 35008                          (: 'namespace' 'descending' '{' :)
          or $state[$p:lk] = 47808                          (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 4288                           (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 18368                          (: 'element' 'div' '{' :)
          or $state[$p:lk] = 35264                          (: 'namespace' 'div' '{' :)
          or $state[$p:lk] = 48064                          (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 4544                           (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 18624                          (: 'element' 'else' '{' :)
          or $state[$p:lk] = 35520                          (: 'namespace' 'else' '{' :)
          or $state[$p:lk] = 48320                          (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 4800                           (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 18880                          (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 35776                          (: 'namespace' 'empty' '{' :)
          or $state[$p:lk] = 48576                          (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 5056                           (: 'attribute' 'end' '{' :)
          or $state[$p:lk] = 19136                          (: 'element' 'end' '{' :)
          or $state[$p:lk] = 36032                          (: 'namespace' 'end' '{' :)
          or $state[$p:lk] = 48832                          (: 'processing-instruction' 'end' '{' :)
          or $state[$p:lk] = 5312                           (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 19392                          (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 36288                          (: 'namespace' 'eq' '{' :)
          or $state[$p:lk] = 49088                          (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 5568                           (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 19648                          (: 'element' 'except' '{' :)
          or $state[$p:lk] = 36544                          (: 'namespace' 'except' '{' :)
          or $state[$p:lk] = 49344                          (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 5824                           (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 19904                          (: 'element' 'for' '{' :)
          or $state[$p:lk] = 36800                          (: 'namespace' 'for' '{' :)
          or $state[$p:lk] = 49600                          (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 6080                           (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 20160                          (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 37056                          (: 'namespace' 'ge' '{' :)
          or $state[$p:lk] = 49856                          (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 6336                           (: 'attribute' 'group' '{' :)
          or $state[$p:lk] = 20416                          (: 'element' 'group' '{' :)
          or $state[$p:lk] = 37312                          (: 'namespace' 'group' '{' :)
          or $state[$p:lk] = 50112                          (: 'processing-instruction' 'group' '{' :)
          or $state[$p:lk] = 6592                           (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 20672                          (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 37568                          (: 'namespace' 'gt' '{' :)
          or $state[$p:lk] = 50368                          (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 6848                           (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 20928                          (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 37824                          (: 'namespace' 'idiv' '{' :)
          or $state[$p:lk] = 50624                          (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 7104                           (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 21184                          (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 38080                          (: 'namespace' 'instance' '{' :)
          or $state[$p:lk] = 50880                          (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 7360                           (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 21440                          (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 38336                          (: 'namespace' 'intersect' '{' :)
          or $state[$p:lk] = 51136                          (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 7616                           (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 21696                          (: 'element' 'is' '{' :)
          or $state[$p:lk] = 38592                          (: 'namespace' 'is' '{' :)
          or $state[$p:lk] = 51392                          (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 7872                           (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 21952                          (: 'element' 'le' '{' :)
          or $state[$p:lk] = 38848                          (: 'namespace' 'le' '{' :)
          or $state[$p:lk] = 51648                          (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 8128                           (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 22208                          (: 'element' 'let' '{' :)
          or $state[$p:lk] = 39104                          (: 'namespace' 'let' '{' :)
          or $state[$p:lk] = 51904                          (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 8384                           (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 22464                          (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 39360                          (: 'namespace' 'lt' '{' :)
          or $state[$p:lk] = 52160                          (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 8640                           (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 22720                          (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 39616                          (: 'namespace' 'mod' '{' :)
          or $state[$p:lk] = 52416                          (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 8896                           (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 22976                          (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 39872                          (: 'namespace' 'ne' '{' :)
          or $state[$p:lk] = 52672                          (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 9152                           (: 'attribute' 'only' '{' :)
          or $state[$p:lk] = 23232                          (: 'element' 'only' '{' :)
          or $state[$p:lk] = 40128                          (: 'namespace' 'only' '{' :)
          or $state[$p:lk] = 52928                          (: 'processing-instruction' 'only' '{' :)
          or $state[$p:lk] = 9408                           (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 23488                          (: 'element' 'or' '{' :)
          or $state[$p:lk] = 40384                          (: 'namespace' 'or' '{' :)
          or $state[$p:lk] = 53184                          (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 9664                           (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 23744                          (: 'element' 'order' '{' :)
          or $state[$p:lk] = 40640                          (: 'namespace' 'order' '{' :)
          or $state[$p:lk] = 53440                          (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 9920                           (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 24000                          (: 'element' 'return' '{' :)
          or $state[$p:lk] = 40896                          (: 'namespace' 'return' '{' :)
          or $state[$p:lk] = 53696                          (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 10176                          (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 24256                          (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 41152                          (: 'namespace' 'satisfies' '{' :)
          or $state[$p:lk] = 53952                          (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 10432                          (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 24512                          (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 41408                          (: 'namespace' 'stable' '{' :)
          or $state[$p:lk] = 54208                          (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 10688                          (: 'attribute' 'start' '{' :)
          or $state[$p:lk] = 24768                          (: 'element' 'start' '{' :)
          or $state[$p:lk] = 41664                          (: 'namespace' 'start' '{' :)
          or $state[$p:lk] = 54464                          (: 'processing-instruction' 'start' '{' :)
          or $state[$p:lk] = 10944                          (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 25024                          (: 'element' 'to' '{' :)
          or $state[$p:lk] = 41920                          (: 'namespace' 'to' '{' :)
          or $state[$p:lk] = 54720                          (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 11200                          (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 25280                          (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 42176                          (: 'namespace' 'treat' '{' :)
          or $state[$p:lk] = 54976                          (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 11456                          (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 25536                          (: 'element' 'union' '{' :)
          or $state[$p:lk] = 42432                          (: 'namespace' 'union' '{' :)
          or $state[$p:lk] = 55232                          (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 11712                          (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 25792                          (: 'element' 'where' '{' :)
          or $state[$p:lk] = 42688                          (: 'namespace' 'where' '{' :)
          or $state[$p:lk] = 55488) then                    (: 'processing-instruction' 'where' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FilterExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AxisStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StepExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 42                                 (: '/' :)
    and $state[$p:l1] != 43) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 42) then                   (: '/' :)
          let $state := p:consume(42, $input, $state)       (: '/' :)
          return $state
        else
          let $state := p:consume(43, $input, $state)       (: '//' :)
          return $state
      let $state := p:lookahead1W(173, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | ('(' ':') | '.' | '..' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelativePathExpr", $count, $begin, $end)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 42) then                       (: '/' :)
      let $state := p:consume(42, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(181, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               EOF | '!=' | '$' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '.' | '..' | ';' | '<' | '<!--' | '<<' |
                                                               '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' | ']' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 24                         (: EOF :)
              or $state[$p:l1] = 25                         (: '!=' :)
              or $state[$p:l1] = 34                         (: ')' :)
              or $state[$p:l1] = 35                         (: '*' :)
              or $state[$p:l1] = 36                         (: '+' :)
              or $state[$p:l1] = 37                         (: ',' :)
              or $state[$p:l1] = 38                         (: '-' :)
              or $state[$p:l1] = 48                         (: ';' :)
              or $state[$p:l1] = 52                         (: '<<' :)
              or $state[$p:l1] = 53                         (: '<=' :)
              or $state[$p:l1] = 55                         (: '=' :)
              or $state[$p:l1] = 56                         (: '>' :)
              or $state[$p:l1] = 57                         (: '>=' :)
              or $state[$p:l1] = 58                         (: '>>' :)
              or $state[$p:l1] = 64                         (: ']' :)
              or $state[$p:l1] = 194                        (: '|' :)
              or $state[$p:l1] = 195) then                  (: '}' :)
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 43) then                       (: '//' :)
      let $state := p:consume(43, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(173, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | ('(' ':') | '.' | '..' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PathExpr", $count, $begin, $end)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 128) then                      (: 'lax' :)
      let $state := p:consume(128, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(172, $input, $state)          (: 'strict' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidationMode", $count, $begin, $end)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(184, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 192) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 69) then                   (: 'as' :)
          let $state := p:consume(69, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(163, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidateExpr", $count, $begin, $end)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 184) then                           (: 'validate' :)
      let $state := p:lookahead2W(256, 160, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'lax' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'strict' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 325                            (: 'validate' 'as' :)
          or $state[$p:lk] = 384                            (: 'validate' 'lax' :)
          or $state[$p:lk] = 428                            (: 'validate' 'strict' :)
          or $state[$p:lk] = 448) then                      (: 'validate' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 32) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(174, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 36                               (: '+' :)
      and $state[$p:l1] != 38) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 38) then                 (: '-' :)
            let $state := p:consume(38, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(36, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpr", $count, $begin, $end)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(145, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'cast' :)
      let $state := p:consume(77, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(69, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpr", $count, $begin, $end)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(143, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'castable' :)
      let $state := p:consume(78, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(69, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastableExpr", $count, $begin, $end)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 178) then                      (: 'treat' :)
      let $state := p:consume(178, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(69, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(166, $input, $state)      (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TreatExpr", $count, $begin, $end)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 124) then                      (: 'instance' :)
      let $state := p:consume(124, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(144, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(166, $input, $state)      (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceofExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(139, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 107                              (: 'except' :)
      and $state[$p:l1] != 125) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 125) then                (: 'intersect' :)
            let $state := p:consume(125, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(107, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(174, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntersectExceptExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 182                                (: 'union' :)
    and $state[$p:l1] != 194) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 182) then                  (: 'union' :)
          let $state := p:consume(182, $input, $state)      (: 'union' :)
          return $state
        else
          let $state := p:consume(194, $input, $state)      (: '|' :)
          return $state
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 35                                 (: '*' :)
    and $state[$p:l1] != 96                                 (: 'div' :)
    and $state[$p:l1] != 118                                (: 'idiv' :)
    and $state[$p:l1] != 134) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: '*' :)
          let $state := p:consume(35, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 96) then                   (: 'div' :)
          let $state := p:consume(96, $input, $state)       (: 'div' :)
          return $state
        else if ($state[$p:l1] = 118) then                  (: 'idiv' :)
          let $state := p:consume(118, $input, $state)      (: 'idiv' :)
          return $state
        else
          let $state := p:consume(134, $input, $state)      (: 'mod' :)
          return $state
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 36                                 (: '+' :)
    and $state[$p:l1] != 38) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 36) then                   (: '+' :)
          let $state := p:consume(36, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(38, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpr", $count, $begin, $end)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 177) then                      (: 'to' :)
      let $state := p:consume(177, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RangeExpr", $count, $begin, $end)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-RangeExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25                             (: '!=' :)
          or $state[$p:l1] = 49                             (: '<' :)
          or $state[$p:l1] = 52                             (: '<<' :)
          or $state[$p:l1] = 53                             (: '<=' :)
          or $state[$p:l1] = 55                             (: '=' :)
          or $state[$p:l1] = 56                             (: '>' :)
          or $state[$p:l1] = 57                             (: '>=' :)
          or $state[$p:l1] = 58                             (: '>>' :)
          or $state[$p:l1] = 105                            (: 'eq' :)
          or $state[$p:l1] = 113                            (: 'ge' :)
          or $state[$p:l1] = 117                            (: 'gt' :)
          or $state[$p:l1] = 126                            (: 'is' :)
          or $state[$p:l1] = 129                            (: 'le' :)
          or $state[$p:l1] = 132                            (: 'lt' :)
          or $state[$p:l1] = 138) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 105                        (: 'eq' :)
              or $state[$p:l1] = 113                        (: 'ge' :)
              or $state[$p:l1] = 117                        (: 'gt' :)
              or $state[$p:l1] = 129                        (: 'le' :)
              or $state[$p:l1] = 132                        (: 'lt' :)
              or $state[$p:l1] = 138) then                  (: 'ne' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 52                         (: '<<' :)
              or $state[$p:l1] = 58                         (: '>>' :)
              or $state[$p:l1] = 126) then                  (: 'is' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeComp($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComparisonExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 68) then                           (: 'and' :)
      $state
    else
      let $state := p:consume(68, $input, $state)           (: 'and' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 147) then                          (: 'or' :)
      $state
    else
      let $state := p:consume(147, $input, $state)          (: 'or' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrExpr", $count, $begin, $end)
};

(:~
 : Parse CatchErrorVal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorVal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchErrorVal", $count, $begin, $end)
};

(:~
 : Parse CatchErrorDesc.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorDesc($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchErrorDesc", $count, $begin, $end)
};

(:~
 : Parse CatchErrorCode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorCode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchErrorCode", $count, $begin, $end)
};

(:~
 : Parse CatchVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchVars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CatchErrorCode($input, $state)
  let $state := p:lookahead1W(68, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: ',' :)
      let $state := p:consume(37, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CatchErrorDesc($input, $state)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ',' :)
          let $state := p:consume(37, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(20, $input, $state)   (: S^WS | '$' | ('(' ':') :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-CatchErrorVal($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchVars", $count, $begin, $end)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: Wildcard :)
      let $state := p:consume(6, $input, $state)            (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameTest", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(100, $input, $state)        (: S^WS | '(' | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 194) then                        (: '|' :)
        $state
      else
        let $state := p:consume(194, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(164, $input, $state)    (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchErrorList", $count, $begin, $end)
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(79, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(164, $input, $state)          (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CatchErrorList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CatchVars($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchClause", $count, $begin, $end)
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryTargetExpr", $count, $begin, $end)
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(179, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(192, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TryTargetExpr($input, $state)
  let $state := p:consume(195, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(129, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'ascending' | 'case' | 'catch' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 79) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryCatchExpr", $count, $begin, $end)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(119, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(176, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:consume(100, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IfExpr", $count, $begin, $end)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(76, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(169, $input, $state)          (: QName^Token | S^WS | '$' | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(69, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(166, $input, $state)          (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(162, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 76) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(181, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(90, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(162, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeswitchExpr", $count, $begin, $end)
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseOperand", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(76, $input, $state)             (: 'case' :)
    let $state := p:lookahead1W(174, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SwitchCaseOperand($input, $state)
    return
      if ($state[$p:l1] != 76) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:consume(162, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37) then                           (: ',' :)
      $state
    else
      let $state := p:consume(37, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SwitchCaseClause($input, $state)
    return
      if ($state[$p:l1] != 76) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(174, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:consume(90, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(162, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37) then                           (: ',' :)
      $state
    else
      let $state := p:consume(37, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 69) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:consume(121, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 169) then                      (: 'some' :)
      let $state := p:consume(169, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(106, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(121, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(163, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QuantifiedExpr", $count, $begin, $end)
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(162, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReturnClause", $count, $begin, $end)
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(86, $input, $state)               (: 'count' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CountClause", $count, $begin, $end)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70                             (: 'ascending' :)
          or $state[$p:l1] = 93) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: 'ascending' :)
          let $state := p:consume(70, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(93, $input, $state)       (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(126, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 101) then                      (: 'empty' :)
      let $state := p:consume(101, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(85, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 114) then                  (: 'greatest' :)
          let $state := p:consume(114, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(130, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:consume(81, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(16, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderModifier", $count, $begin, $end)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderModifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(124, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 37) then                         (: ',' :)
        $state
      else
        let $state := p:consume(37, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(174, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpecList", $count, $begin, $end)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 148) then                      (: 'order' :)
      let $state := p:consume(148, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(75, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(170, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(50, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(148, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(75, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderByClause", $count, $begin, $end)
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:consume(81, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(16, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(124, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 37) then                         (: ',' :)
        $state
      else
        let $state := p:consume(37, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpecList", $count, $begin, $end)
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(115, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(75, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupByClause", $count, $begin, $end)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(188, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhereClause", $count, $begin, $end)
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 111                            (: 'for' :)
          or $state[$p:l1] = 131) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'group' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'count' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CountClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderByClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IntermediateClause", $count, $begin, $end)
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(168, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(189, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(121, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowEndCondition($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SlidingWindowClause", $count, $begin, $end)
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 145) then                      (: 'only' :)
      let $state := p:consume(145, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(104, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(187, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowEndCondition", $count, $begin, $end)
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NextItem", $count, $begin, $end)
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PreviousItem", $count, $begin, $end)
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CurrentItem", $count, $begin, $end)
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '$' :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 158) then                      (: 'previous' :)
      let $state := p:consume(158, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 139) then                      (: 'next' :)
      let $state := p:consume(139, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(29, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NextItem($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowVars", $count, $begin, $end)
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(171, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(187, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowStartCondition", $count, $begin, $end)
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(180, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(189, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(121, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 104                            (: 'end' :)
          or $state[$p:l1] = 145) then                      (: 'only' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TumblingWindowClause", $count, $begin, $end)
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(111, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(94, $input, $state)           (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 180) then                      (: 'tumbling' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TumblingWindowClause($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SlidingWindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowClause", $count, $begin, $end)
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(47, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetBinding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37) then                           (: ',' :)
      $state
    else
      let $state := p:consume(37, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LetBinding($input, $state)
      return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(131, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetClause", $count, $begin, $end)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(71, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PositionalVar", $count, $begin, $end)
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(65, $input, $state)               (: 'allowing' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(101, $input, $state)              (: 'empty' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AllowingEmpty", $count, $begin, $end)
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: 'allowing' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(121, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForBinding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37) then                           (: ',' :)
      $state
    else
      let $state := p:consume(37, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForBinding($input, $state)
      return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(111, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForClause", $count, $begin, $end)
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 111) then                           (: 'for' :)
      let $state := p:lookahead2W(256, 99, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 285) then                      (: 'for' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 131) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LetClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InitialClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(122, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 162) then                         (: 'return' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ReturnClause($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FLWORExpr", $count, $begin, $end)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 106) then                           (: 'every' :)
      let $state := p:lookahead2W(256, 155, $input, $state) (: S^WS | EOF | '!=' | '#' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'for' :)
      let $state := p:lookahead2W(512, 159, $input, $state) (: S^WS | EOF | '!=' | '#' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'sliding' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'if' :)
      let $state := p:lookahead2W(768, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'let' :)
      let $state := p:lookahead2W(1024, 155, $input, $state) (: S^WS | EOF | '!=' | '#' | '$' | '(' | ('(' ':') | ')' |
                                                                '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'some' :)
      let $state := p:lookahead2W(1280, 155, $input, $state) (: S^WS | EOF | '!=' | '#' | '$' | '(' | ('(' ':') | ')' |
                                                                '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                                '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'switch' :)
      let $state := p:lookahead2W(1536, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'try' :)
      let $state := p:lookahead2W(1792, 157, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(2048, 151, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | ')' | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                                'ascending' | 'case' | 'cast' | 'castable' |
                                                                'collation' | 'count' | 'default' | 'descending' |
                                                                'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                                'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                                'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 541                            (: 'for' '$' :)
          or $state[$p:lk] = 1053                           (: 'let' '$' :)
          or $state[$p:lk] = 680                            (: 'for' 'sliding' :)
          or $state[$p:lk] = 692) then                      (: 'for' 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 285                            (: 'every' '$' :)
          or $state[$p:lk] = 1309) then                     (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 1567) then                     (: 'switch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 2079) then                     (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 799) then                      (: 'if' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 1984) then                     (: 'try' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TryCatchExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExprSingle", $count, $begin, $end)
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarValue", $count, $begin, $end)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 59) then                       (: '?' :)
      let $state := p:consume(59, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:consume(35, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(36, $input, $state)           (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OccurrenceIndicator", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(166, $input, $state)          (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedItemType", $count, $begin, $end)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AtomicType", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(68, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 37) then                         (: ',' :)
        $state
      else
        let $state := p:consume(37, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(166, $input, $state)    (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(112, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(170, $input, $state)          (: QName^Token | S^WS | '(' | ('(' ':') | ')' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(69, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(166, $input, $state)          (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedFunctionTest", $count, $begin, $end)
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(112, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(35, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyFunctionTest", $count, $begin, $end)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 112) then                           (: 'function' :)
      let $state := p:lookahead2W(256, 21, $input, $state)  (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] = 287) then                       (: 'function' '(' :)
          let $state := p:lookahead3W(512, 172, $input, $state) (: QName^Token | S^WS | '(' | ('(' ':') | ')' | '*' |
                                                                   'ancestor' | 'ancestor-or-self' | 'and' |
                                                                   'ascending' | 'attribute' | 'case' | 'cast' |
                                                                   'castable' | 'child' | 'collation' | 'comment' |
                                                                   'count' | 'declare' | 'default' | 'descendant' |
                                                                   'descendant-or-self' | 'descending' | 'div' |
                                                                   'document' | 'document-node' | 'element' | 'else' |
                                                                   'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                                   'except' | 'following' | 'following-sibling' |
                                                                   'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                   'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                                   'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                                   'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                                   'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                                   'preceding' | 'preceding-sibling' |
                                                                   'processing-instruction' | 'return' | 'satisfies' |
                                                                   'schema-attribute' | 'schema-element' | 'self' |
                                                                   'some' | 'stable' | 'start' | 'switch' | 'text' |
                                                                   'to' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                   'unordered' | 'validate' | 'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 547) then                      (: 'function' '(' '*' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyFunctionTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypedFunctionTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionTest", $count, $begin, $end)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(142, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyKindTest", $count, $begin, $end)
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(137, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceNodeTest", $count, $begin, $end)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(175, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TextTest", $count, $begin, $end)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(82, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CommentTest", $count, $begin, $end)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(160, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(135, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 10) then                   (: StringLiteral :)
          let $state := p:consume(10, $input, $state)       (: StringLiteral :)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PITest", $count, $begin, $end)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(165, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaAttributeTest", $count, $begin, $end)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeName", $count, $begin, $end)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:consume(35, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AttribNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(72, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(171, $input, $state)          (: QName^Token | S^WS | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ',' :)
          let $state := p:consume(37, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(163, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeTest", $count, $begin, $end)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(166, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaElementTest", $count, $begin, $end)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeName", $count, $begin, $end)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementName", $count, $begin, $end)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:consume(35, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(99, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(171, $input, $state)          (: QName^Token | S^WS | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ',' :)
          let $state := p:consume(37, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(163, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(69, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 59) then               (: '?' :)
              let $state := p:consume(59, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementTest", $count, $begin, $end)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(98, $input, $state)               (: 'document-node' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 99) then                   (: 'element' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(34, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DocumentTest", $count, $begin, $end)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NamespaceNodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyKindTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KindTest", $count, $begin, $end)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 72) then                            (: 'attribute' :)
      let $state := p:lookahead2W(256, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:lookahead2W(512, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'document-node' :)
      let $state := p:lookahead2W(768, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state := p:lookahead2W(1024, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'function' :)
      let $state := p:lookahead2W(1280, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'item' :)
      let $state := p:lookahead2W(1536, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace-node' :)
      let $state := p:lookahead2W(1792, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'node' :)
      let $state := p:lookahead2W(2048, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(2304, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'schema-attribute' :)
      let $state := p:lookahead2W(2560, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'schema-element' :)
      let $state := p:lookahead2W(2816, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'text' :)
      let $state := p:lookahead2W(3072, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                                'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                                'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                                'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'ne' | 'only' | 'or' | 'order' | 'return' |
                                                                'satisfies' | 'stable' | 'start' | 'to' | 'union' |
                                                                'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 287                            (: 'attribute' '(' :)
          or $state[$p:lk] = 543                            (: 'comment' '(' :)
          or $state[$p:lk] = 799                            (: 'document-node' '(' :)
          or $state[$p:lk] = 1055                           (: 'element' '(' :)
          or $state[$p:lk] = 1823                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 2079                           (: 'node' '(' :)
          or $state[$p:lk] = 2335                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 2591                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 2847                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 3103) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 1567) then                     (: 'item' '(' :)
      let $state := p:consume(127, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(34, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 1311) then                     (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedItemType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AtomicType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ItemType", $count, $begin, $end)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 102) then                           (: 'empty-sequence' :)
      let $state := p:lookahead2W(256, 153, $input, $state) (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 287) then                      (: 'empty-sequence' '(' :)
      let $state := p:consume(102, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(34, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(150, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'allowing' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35                         (: '*' :)
              or $state[$p:l1] = 36                         (: '+' :)
              or $state[$p:l1] = 59) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceType", $count, $begin, $end)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(69, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(166, $input, $state)          (: QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarName", $count, $begin, $end)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'variable' :)
  let $state := p:consume(185, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: ':=' :)
      let $state := p:consume(47, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(174, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 47) then                   (: ':=' :)
          let $state := p:consume(47, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(174, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(70, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 37) then                         (: ',' :)
        $state
      else
        let $state := p:consume(37, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(16, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(120, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:consume(135, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(60, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 136) then                      (: 'namespace' :)
      let $state := p:consume(136, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(130, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(55, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(16, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'at' :)
      let $state := p:consume(71, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(16, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleImport", $count, $begin, $end)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 136) then                      (: 'namespace' :)
      let $state := p:consume(136, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(130, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(55, $input, $state)           (: '=' :)
      return $state
    else
      let $state := p:consume(90, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:consume(99, $input, $state)           (: 'element' :)
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:consume(136, $input, $state)          (: 'namespace' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaPrefix", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(70, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 37) then                         (: ',' :)
        $state
      else
        let $state := p:consume(37, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(16, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(120, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:consume(164, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(95, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 10) then                      (: StringLiteral :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(16, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'at' :)
      let $state := p:consume(71, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(16, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaImport", $count, $begin, $end)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 120) then                           (: 'import' :)
      let $state := p:lookahead2W(256, 87, $input, $state)  (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 420) then                      (: 'import' 'schema' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaImport($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ModuleImport($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Import", $count, $begin, $end)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(136, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(130, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(55, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(16, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'decimal-separator' :)
      let $state := p:consume(88, $input, $state)           (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'grouping-separator' :)
      let $state := p:consume(116, $input, $state)          (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'infinity' :)
      let $state := p:consume(122, $input, $state)          (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'minus-sign' :)
      let $state := p:consume(133, $input, $state)          (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: 'NaN' :)
      let $state := p:consume(62, $input, $state)           (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'percent' :)
      let $state := p:consume(154, $input, $state)          (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'per-mille' :)
      let $state := p:consume(153, $input, $state)          (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'zero-digit' :)
      let $state := p:consume(191, $input, $state)          (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'digit' :)
      let $state := p:consume(95, $input, $state)           (: 'digit' :)
      return $state
    else
      let $state := p:consume(152, $input, $state)          (: 'pattern-separator' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DFPropertyName", $count, $begin, $end)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: QName^Token :)
      let $state := p:consume(19, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ancestor' :)
      let $state := p:consume(66, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(67, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'and' :)
      let $state := p:consume(68, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'ascending' :)
      let $state := p:consume(70, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'case' :)
      let $state := p:consume(76, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'cast' :)
      let $state := p:consume(77, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'castable' :)
      let $state := p:consume(78, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'child' :)
      let $state := p:consume(80, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:consume(81, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'count' :)
      let $state := p:consume(86, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'declare' :)
      let $state := p:consume(89, $input, $state)           (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'default' :)
      let $state := p:consume(90, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant' :)
      let $state := p:consume(91, $input, $state)           (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant-or-self' :)
      let $state := p:consume(92, $input, $state)           (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descending' :)
      let $state := p:consume(93, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'div' :)
      let $state := p:consume(96, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'document' :)
      let $state := p:consume(97, $input, $state)           (: 'document' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'else' :)
      let $state := p:consume(100, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'empty' :)
      let $state := p:consume(101, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'end' :)
      let $state := p:consume(104, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'eq' :)
      let $state := p:consume(105, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'every' :)
      let $state := p:consume(106, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'except' :)
      let $state := p:consume(107, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'following' :)
      let $state := p:consume(109, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'following-sibling' :)
      let $state := p:consume(110, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'for' :)
      let $state := p:consume(111, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'ge' :)
      let $state := p:consume(113, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'group' :)
      let $state := p:consume(115, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'gt' :)
      let $state := p:consume(117, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'idiv' :)
      let $state := p:consume(118, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'import' :)
      let $state := p:consume(120, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'instance' :)
      let $state := p:consume(124, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'intersect' :)
      let $state := p:consume(125, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'is' :)
      let $state := p:consume(126, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'le' :)
      let $state := p:consume(129, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'let' :)
      let $state := p:consume(131, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'lt' :)
      let $state := p:consume(132, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'mod' :)
      let $state := p:consume(134, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'module' :)
      let $state := p:consume(135, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'namespace' :)
      let $state := p:consume(136, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'ne' :)
      let $state := p:consume(138, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'only' :)
      let $state := p:consume(145, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'or' :)
      let $state := p:consume(147, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'order' :)
      let $state := p:consume(148, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'ordered' :)
      let $state := p:consume(149, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'parent' :)
      let $state := p:consume(151, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'preceding' :)
      let $state := p:consume(155, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'preceding-sibling' :)
      let $state := p:consume(156, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'return' :)
      let $state := p:consume(162, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'satisfies' :)
      let $state := p:consume(163, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'self' :)
      let $state := p:consume(167, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'some' :)
      let $state := p:consume(169, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'stable' :)
      let $state := p:consume(170, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'start' :)
      let $state := p:consume(171, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'to' :)
      let $state := p:consume(177, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'treat' :)
      let $state := p:consume(178, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'try' :)
      let $state := p:consume(179, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'union' :)
      let $state := p:consume(182, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'unordered' :)
      let $state := p:consume(183, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'validate' :)
      let $state := p:consume(184, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'where' :)
      let $state := p:consume(188, $input, $state)          (: 'where' :)
      return $state
    else
      let $state := p:consume(190, $input, $state)          (: 'xquery' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionName", $count, $begin, $end)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(161, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'attribute' :)
      let $state := p:consume(72, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:consume(82, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'document-node' :)
      let $state := p:consume(98, $input, $state)           (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state := p:consume(99, $input, $state)           (: 'element' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'empty-sequence' :)
      let $state := p:consume(102, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'if' :)
      let $state := p:consume(119, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'item' :)
      let $state := p:consume(127, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'node' :)
      let $state := p:consume(142, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'processing-instruction' :)
      let $state := p:consume(160, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'schema-attribute' :)
      let $state := p:consume(165, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'schema-element' :)
      let $state := p:consume(166, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'text' :)
      let $state := p:consume(175, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'function' :)
      let $state := p:consume(112, $input, $state)          (: 'function' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'typeswitch' :)
      let $state := p:consume(181, $input, $state)          (: 'typeswitch' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace-node' :)
      let $state := p:consume(137, $input, $state)          (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'switch' :)
      let $state := p:consume(174, $input, $state)          (: 'switch' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QName", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(127, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'grouping-separator' | 'infinity' |
                                                               'minus-sign' | 'pattern-separator' | 'per-mille' |
                                                               'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 48) then                          (: ';' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:consume(55, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(16, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(10, $input, $state)         (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 87) then                       (: 'decimal-format' :)
      let $state := p:consume(87, $input, $state)           (: 'decimal-format' :)
      let $state := p:lookahead1W(163, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
    else
      let $state := p:consume(90, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:consume(87, $input, $state)           (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DecimalFormatDecl", $count, $begin, $end)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 123) then                      (: 'inherit' :)
      let $state := p:consume(123, $input, $state)          (: 'inherit' :)
      return $state
    else
      let $state := p:consume(140, $input, $state)          (: 'no-inherit' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InheritMode", $count, $begin, $end)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 157) then                      (: 'preserve' :)
      let $state := p:consume(157, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(141, $input, $state)          (: 'no-preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PreserveMode", $count, $begin, $end)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(85, $input, $state)               (: 'copy-namespaces' :)
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(37, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InheritMode($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CopyNamespacesDecl", $count, $begin, $end)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(90, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(148, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(101, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: 'greatest' :)
      let $state := p:consume(114, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(130, $input, $state)          (: 'least' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyOrderDecl", $count, $begin, $end)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:consume(150, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(92, $input, $state)           (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 149) then                      (: 'ordered' :)
      let $state := p:consume(149, $input, $state)          (: 'ordered' :)
      return $state
    else
      let $state := p:consume(183, $input, $state)          (: 'unordered' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderingModeDecl", $count, $begin, $end)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:consume(83, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(93, $input, $state)           (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 173) then                      (: 'strip' :)
      let $state := p:consume(173, $input, $state)          (: 'strip' :)
      return $state
    else
      let $state := p:consume(157, $input, $state)          (: 'preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConstructionDecl", $count, $begin, $end)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:consume(73, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(16, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BaseURIDecl", $count, $begin, $end)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(90, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(81, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(16, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultCollationDecl", $count, $begin, $end)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(74, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(93, $input, $state)           (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 157) then                      (: 'preserve' :)
      let $state := p:consume(157, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(173, $input, $state)          (: 'strip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BoundarySpaceDecl", $count, $begin, $end)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 89) then                            (: 'declare' :)
      let $state := p:lookahead2W(256, 119, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' :)
      let $state :=
        if ($state[$p:lk] = 346) then                       (: 'declare' 'default' :)
          let $state := p:lookahead3W(512, 106, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                   'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 330) then                      (: 'declare' 'boundary-space' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 593) then                      (: 'declare' 'default' 'collation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 329) then                      (: 'declare' 'base-uri' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 339) then                      (: 'declare' 'construction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 406) then                      (: 'declare' 'ordering' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 660) then                      (: 'declare' 'default' 'order' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 341) then                      (: 'declare' 'copy-namespaces' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DecimalFormatDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Setter", $count, $begin, $end)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(90, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state := p:consume(99, $input, $state)           (: 'element' :)
      return $state
    else
      let $state := p:consume(112, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(136, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(16, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultNamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(175, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               EOF | '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 89) then                          (: 'declare' :)
        let $state := p:lookahead2W(256, 141, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | '*' | '+' |
                                                                 ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                                 '>' | '>=' | '>>' | '[' | 'and' | 'base-uri' |
                                                                 'boundary-space' | 'cast' | 'castable' |
                                                                 'construction' | 'context' | 'copy-namespaces' |
                                                                 'decimal-format' | 'default' | 'deterministic' |
                                                                 'div' | 'eq' | 'except' | 'function' | 'ge' | 'gt' |
                                                                 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                                 'lt' | 'mod' | 'namespace' | 'ne' |
                                                                 'nondeterministic' | 'option' | 'or' | 'ordering' |
                                                                 'private' | 'public' | 'to' | 'treat' | 'union' |
                                                                 'variable' | '|' :)
        return $state
      else if ($state[$p:l1] = 120) then                    (: 'import' :)
        let $state := p:lookahead2W(512, 134, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | '*' | '+' |
                                                                 ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                                 '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                                 'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                 'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                                 'module' | 'ne' | 'or' | 'schema' | 'to' | 'treat' |
                                                                 'union' | '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 329                              (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 330                              (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 339                              (: 'declare' 'construction' :)
      and $state[$p:lk] != 341                              (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 343                              (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 346                              (: 'declare' 'default' :)
      and $state[$p:lk] != 647                              (: 'import' 'module' :)
      and $state[$p:lk] != 392                              (: 'declare' 'namespace' :)
      and $state[$p:lk] != 406                              (: 'declare' 'ordering' :)
      and $state[$p:lk] != 676) then                        (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 89) then                      (: 'declare' :)
            let $state := p:lookahead2W(256, 120, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                     'construction' | 'copy-namespaces' |
                                                                     'decimal-format' | 'default' | 'namespace' |
                                                                     'ordering' :)
            let $state :=
              if ($state[$p:lk] = 346) then                 (: 'declare' 'default' :)
                let $state := p:lookahead3W(512, 114, $input, $state) (: S^WS | ('(' ':') | 'collation' |
                                                                         'decimal-format' | 'element' | 'function' |
                                                                         'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 611                      (: 'declare' 'default' 'element' :)
                or $state[$p:lk] = 624) then                (: 'declare' 'default' 'function' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 392) then                (: 'declare' 'namespace' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 120) then                (: 'import' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Import($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(27, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(175, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               EOF | '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 89) then                          (: 'declare' :)
        let $state := p:lookahead2W(256, 138, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | '*' | '+' |
                                                                 ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                                 '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                                 'context' | 'deterministic' | 'div' | 'eq' | 'except' |
                                                                 'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' |
                                                                 'nondeterministic' | 'option' | 'or' | 'private' |
                                                                 'public' | 'to' | 'treat' | 'union' | 'variable' | '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 340                              (: 'declare' 'context' :)
      and $state[$p:lk] != 350                              (: 'declare' 'deterministic' :)
      and $state[$p:lk] != 368                              (: 'declare' 'function' :)
      and $state[$p:lk] != 399                              (: 'declare' 'nondeterministic' :)
      and $state[$p:lk] != 402                              (: 'declare' 'option' :)
      and $state[$p:lk] != 415                              (: 'declare' 'private' :)
      and $state[$p:lk] != 417                              (: 'declare' 'public' :)
      and $state[$p:lk] != 441) then                        (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 89) then                      (: 'declare' :)
            let $state := p:lookahead2W(256, 121, $input, $state) (: S^WS | ('(' ':') | 'context' | 'deterministic' |
                                                                     'function' | 'nondeterministic' | 'option' |
                                                                     'private' | 'public' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 441) then                (: 'declare' 'variable' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 340) then                (: 'declare' 'context' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 402) then                (: 'declare' 'option' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-OptionDecl($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-FunctionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(27, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prolog", $count, $begin, $end)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(10, $input, $state)               (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "URILiteral", $count, $begin, $end)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 20) then                       (: NCName^Token :)
      let $state := p:consume(20, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'and' :)
      let $state := p:consume(68, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'ascending' :)
      let $state := p:consume(70, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'case' :)
      let $state := p:consume(76, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'cast' :)
      let $state := p:consume(77, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'castable' :)
      let $state := p:consume(78, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:consume(81, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'count' :)
      let $state := p:consume(86, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'default' :)
      let $state := p:consume(90, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descending' :)
      let $state := p:consume(93, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'div' :)
      let $state := p:consume(96, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'else' :)
      let $state := p:consume(100, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'empty' :)
      let $state := p:consume(101, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'end' :)
      let $state := p:consume(104, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'eq' :)
      let $state := p:consume(105, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'except' :)
      let $state := p:consume(107, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'for' :)
      let $state := p:consume(111, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'ge' :)
      let $state := p:consume(113, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'group' :)
      let $state := p:consume(115, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'gt' :)
      let $state := p:consume(117, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'idiv' :)
      let $state := p:consume(118, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'instance' :)
      let $state := p:consume(124, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'intersect' :)
      let $state := p:consume(125, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'is' :)
      let $state := p:consume(126, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'le' :)
      let $state := p:consume(129, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'let' :)
      let $state := p:consume(131, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'lt' :)
      let $state := p:consume(132, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'mod' :)
      let $state := p:consume(134, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'ne' :)
      let $state := p:consume(138, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'only' :)
      let $state := p:consume(145, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'or' :)
      let $state := p:consume(147, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'order' :)
      let $state := p:consume(148, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'return' :)
      let $state := p:consume(162, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'satisfies' :)
      let $state := p:consume(163, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'stable' :)
      let $state := p:consume(170, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'start' :)
      let $state := p:consume(171, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'to' :)
      let $state := p:consume(177, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'treat' :)
      let $state := p:consume(178, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'union' :)
      let $state := p:consume(182, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(188, $input, $state)          (: 'where' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NCName", $count, $begin, $end)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(135, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(136, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(130, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(55, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(16, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleDecl", $count, $begin, $end)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | EOF | ('(' ':') | 'declare' | 'import' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LibraryModule", $count, $begin, $end)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(48, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Separator", $count, $begin, $end)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(190, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 103) then                      (: 'encoding' :)
      let $state := p:consume(103, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(16, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(10, $input, $state)           (: StringLiteral :)
      return $state
    else
      let $state := p:consume(186, $input, $state)          (: 'version' :)
      let $state := p:lookahead1W(16, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(10, $input, $state)           (: StringLiteral :)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 103) then                  (: 'encoding' :)
          let $state := p:consume(103, $input, $state)      (: 'encoding' :)
          let $state := p:lookahead1W(16, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(10, $input, $state)       (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VersionDecl", $count, $begin, $end)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 190) then                           (: 'xquery' :)
      let $state := p:lookahead2W(256, 133, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' |
                                                               'encoding' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | 'version' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 359                            (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 442) then                      (: 'xquery' 'version' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 135) then                           (: 'module' :)
      let $state := p:lookahead2W(256, 131, $input, $state) (: S^WS | EOF | '!=' | '#' | '(' | ('(' ':') | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' |
                                                               'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 392) then                      (: 'module' 'namespace' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LibraryModule($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MainModule($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Module", $count, $begin, $end)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(174, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Module($input, $state)
  let $state := p:consume(24, $input, $state)               (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "XQuery", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 22) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 33) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:matchW($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3W($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:matchW($input, $state[$p:e2], $set)
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-XQuery($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : The input filename, or string, if surrounded by curly braces.
 :)
declare variable $input as xs:string external;

let $result :=
  if (matches($input, "^\{.*\}$")) then
    p:parse-XQuery(substring($input, 2, string-length($input) - 2))
  else
    p:parse-XQuery(unparsed-text($input, "utf-8"))
return
  if (empty($result/self::ERROR)) then
    $result
  else
    error(xs:QName("p:parse-XQuery"), concat("&#10;    ", replace($result, "&#10;", "&#10;    ")))

(: End :)
