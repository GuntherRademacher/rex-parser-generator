// This file was generated on Thu Dec 26, 2024 06:54 (UTC+01) by REx v6.1-SNAPSHOT which is Copyright (c) 1979-2024 by Gunther Rademacher <grd@gmx.net>
// REx command line: -q antlr.ebnf -backtrack -ll 2 -java -main -tree

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Arrays;

public class antlr
{
  public static void main(String args[]) throws Exception
  {
    if (args.length == 0)
    {
      System.out.println("Usage: java antlr [-i] INPUT...");
      System.out.println();
      System.out.println("  parse INPUT, which is either a filename or literal text enclosed in curly braces");
      System.out.println();
      System.out.println("  Option:");
      System.out.println("    -i     indented parse tree");
    }
    else
    {
      boolean indent = false;
      for (String arg : args)
      {
        if (arg.equals("-i"))
        {
          indent = true;
          continue;
        }
        Writer w = new OutputStreamWriter(System.out, "UTF-8");
        XmlSerializer s = new XmlSerializer(w, indent);
        String input = read(arg);
        antlr parser = new antlr(input, s);
        try
        {
          parser.parse_grammar();
        }
        catch (ParseException pe)
        {
          throw new RuntimeException("ParseException while processing " + arg + ":\n" + parser.getErrorMessage(pe));
        }
        finally
        {
          w.close();
        }
      }
    }
  }

  public static class ParseException extends RuntimeException
  {
    private static final long serialVersionUID = 1L;
    private int begin, end, offending, expected, state;

    public ParseException(int b, int e, int s, int o, int x)
    {
      begin = b;
      end = e;
      state = s;
      offending = o;
      expected = x;
    }

    @Override
    public String getMessage()
    {
      return offending < 0
           ? "lexical analysis failed"
           : "syntax error";
    }

    public void serialize(EventHandler eventHandler)
    {
    }

    public int getBegin() {return begin;}
    public int getEnd() {return end;}
    public int getState() {return state;}
    public int getOffending() {return offending;}
    public int getExpected() {return expected;}
    public boolean isAmbiguousInput() {return false;}
  }

  public interface EventHandler
  {
    public void reset(CharSequence string);
    public void startNonterminal(String name, int begin);
    public void endNonterminal(String name, int end);
    public void terminal(String name, int begin, int end);
    public void whitespace(int begin, int end);
  }

  public static class TopDownTreeBuilder implements EventHandler
  {
    private CharSequence input = null;
    private Nonterminal[] stack = new Nonterminal[64];
    private int top = -1;

    @Override
    public void reset(CharSequence input)
    {
      this.input = input;
      top = -1;
    }

    @Override
    public void startNonterminal(String name, int begin)
    {
      Nonterminal nonterminal = new Nonterminal(name, begin, begin, new Symbol[0]);
      if (top >= 0) addChild(nonterminal);
      if (++top >= stack.length) stack = Arrays.copyOf(stack, stack.length << 1);
      stack[top] = nonterminal;
    }

    @Override
    public void endNonterminal(String name, int end)
    {
      stack[top].end = end;
      if (top > 0) --top;
    }

    @Override
    public void terminal(String name, int begin, int end)
    {
      addChild(new Terminal(name, begin, end));
    }

    @Override
    public void whitespace(int begin, int end)
    {
    }

    private void addChild(Symbol s)
    {
      Nonterminal current = stack[top];
      current.children = Arrays.copyOf(current.children, current.children.length + 1);
      current.children[current.children.length - 1] = s;
    }

    public void serialize(EventHandler e)
    {
      e.reset(input);
      stack[0].send(e);
    }
  }

  public static abstract class Symbol
  {
    public String name;
    public int begin;
    public int end;

    protected Symbol(String name, int begin, int end)
    {
      this.name = name;
      this.begin = begin;
      this.end = end;
    }

    public abstract void send(EventHandler e);
  }

  public static class Terminal extends Symbol
  {
    public Terminal(String name, int begin, int end)
    {
      super(name, begin, end);
    }

    @Override
    public void send(EventHandler e)
    {
      e.terminal(name, begin, end);
    }
  }

  public static class Nonterminal extends Symbol
  {
    public Symbol[] children;

    public Nonterminal(String name, int begin, int end, Symbol[] children)
    {
      super(name, begin, end);
      this.children = children;
    }

    @Override
    public void send(EventHandler e)
    {
      e.startNonterminal(name, begin);
      int pos = begin;
      for (Symbol c : children)
      {
        if (pos < c.begin) e.whitespace(pos, c.begin);
        c.send(e);
        pos = c.end;
      }
      if (pos < end) e.whitespace(pos, end);
      e.endNonterminal(name, end);
    }
  }

  public static class XmlSerializer implements EventHandler
  {
    private CharSequence input;
    private String delayedTag;
    private Writer out;
    private boolean indent;
    private boolean hasChildElement;
    private int depth;

    public XmlSerializer(Writer w, boolean indent)
    {
      input = null;
      delayedTag = null;
      out = w;
      this.indent = indent;
    }

    @Override
    public void reset(CharSequence string)
    {
      writeOutput("<?xml version=\"1.0\" encoding=\"UTF-8\"?" + ">");
      input = string;
      delayedTag = null;
      hasChildElement = false;
      depth = 0;
    }

    @Override
    public void startNonterminal(String name, int begin)
    {
      if (delayedTag != null)
      {
        writeOutput("<");
        writeOutput(delayedTag);
        writeOutput(">");
      }
      delayedTag = name;
      if (indent)
      {
        writeOutput("\n");
        for (int i = 0; i < depth; ++i)
        {
          writeOutput("  ");
        }
      }
      hasChildElement = false;
      ++depth;
    }

    @Override
    public void endNonterminal(String name, int end)
    {
      --depth;
      if (delayedTag != null)
      {
        delayedTag = null;
        writeOutput("<");
        writeOutput(name);
        writeOutput("/>");
      }
      else
      {
        if (indent)
        {
          if (hasChildElement)
          {
            writeOutput("\n");
            for (int i = 0; i < depth; ++i)
            {
              writeOutput("  ");
            }
          }
        }
        writeOutput("</");
        writeOutput(name);
        writeOutput(">");
      }
      hasChildElement = true;
    }

    @Override
    public void terminal(String name, int begin, int end)
    {
      if (name.charAt(0) == '\'')
      {
        name = "TOKEN";
      }
      startNonterminal(name, begin);
      characters(begin, end);
      endNonterminal(name, end);
    }

    @Override
    public void whitespace(int begin, int end)
    {
      characters(begin, end);
    }

    private void characters(int begin, int end)
    {
      if (begin < end)
      {
        if (delayedTag != null)
        {
          writeOutput("<");
          writeOutput(delayedTag);
          writeOutput(">");
          delayedTag = null;
        }
        writeOutput(input.subSequence(begin, end)
                         .toString()
                         .replace("&", "&amp;")
                         .replace("<", "&lt;")
                         .replace(">", "&gt;"));
      }
    }

    public void writeOutput(String content)
    {
      try
      {
        out.write(content);
      }
      catch (IOException e)
      {
        throw new RuntimeException(e);
      }
    }
  }

  private static String read(String input) throws Exception
  {
    if (input.startsWith("{") && input.endsWith("}"))
    {
      return input.substring(1, input.length() - 1);
    }
    else
    {
      byte buffer[] = new byte[(int) new java.io.File(input).length()];
      java.io.FileInputStream stream = new java.io.FileInputStream(input);
      stream.read(buffer);
      stream.close();
      String content = new String(buffer, System.getProperty("file.encoding"));
      return content.length() > 0 && content.charAt(0) == '\uFEFF'
           ? content.substring(1)
           : content;
    }
  }

  public antlr(CharSequence string, EventHandler t)
  {
    initialize(string, t);
  }

  public void initialize(CharSequence source, EventHandler parsingEventHandler)
  {
    eventHandler = parsingEventHandler;
    input = source;
    size = source.length();
    reset(0, 0, 0);
  }

  public CharSequence getInput()
  {
    return input;
  }

  public int getTokenOffset()
  {
    return b0;
  }

  public int getTokenEnd()
  {
    return e0;
  }

  public final void reset(int l, int b, int e)
  {
            b0 = b; e0 = b;
    l1 = l; b1 = b; e1 = e;
    l2 = 0; b2 = 0; e2 = 0;
    end = e;
    ex = -1;
    memo.clear();
    eventHandler.reset(input);
  }

  public void reset()
  {
    reset(0, 0, 0);
  }

  public static String getOffendingToken(ParseException e)
  {
    return e.getOffending() < 0 ? null : TOKEN[e.getOffending()];
  }

  public static String[] getExpectedTokenSet(ParseException e)
  {
    String[] expected;
    if (e.getExpected() >= 0)
    {
      expected = new String[]{TOKEN[e.getExpected()]};
    }
    else
    {
      expected = getTokenSet(- e.getState());
    }
    return expected;
  }

  public String getErrorMessage(ParseException e)
  {
    String message = e.getMessage();
    String[] tokenSet = getExpectedTokenSet(e);
    String found = getOffendingToken(e);
    int size = e.getEnd() - e.getBegin();
    message += (found == null ? "" : ", found " + found)
            + "\nwhile expecting "
            + (tokenSet.length == 1 ? tokenSet[0] : java.util.Arrays.toString(tokenSet))
            + "\n"
            + (size == 0 || found != null ? "" : "after successfully scanning " + size + " characters beginning ");
    String prefix = input.subSequence(0, e.getBegin()).toString();
    int line = prefix.replaceAll("[^\n]", "").length() + 1;
    int column = prefix.length() - prefix.lastIndexOf('\n');
    return message
         + "at line " + line + ", column " + column + ":\n..."
         + input.subSequence(e.getBegin(), Math.min(input.length(), e.getBegin() + 64))
         + "...";
  }

  public void parse_grammar()
  {
    eventHandler.startNonterminal("grammar", e0);
    for (;;)
    {
      lookahead1W(48);              // WS | COMMENT^WS | EOF | DOC_COMMENT | OPTIONS | 'class' | 'header' | 'lexclass' |
                                    // '{'
      if (l1 != 48)                 // 'header'
      {
        break;
      }
      consume(48);                  // 'header'
      lookahead1W(20);              // WS | COMMENT^WS | STRING_LITERAL | '{'
      if (l1 == 25)                 // STRING_LITERAL
      {
        consume(25);                // STRING_LITERAL
      }
      lookahead1W(12);              // WS | COMMENT^WS | '{'
      whitespace();
      parse_ACTION();
    }
    if (l1 == 33)                   // OPTIONS
    {
      whitespace();
      parse_fileOptionsSpec();
    }
    for (;;)
    {
      lookahead1W(39);              // WS | COMMENT^WS | EOF | DOC_COMMENT | 'class' | 'lexclass' | '{'
      if (l1 == 31)                 // EOF
      {
        break;
      }
      whitespace();
      parse_classDef();
    }
    consume(31);                    // EOF
    eventHandler.endNonterminal("grammar", e0);
  }

  private void parse_classDef()
  {
    eventHandler.startNonterminal("classDef", e0);
    if (l1 == 55)                   // '{'
    {
      whitespace();
      parse_ACTION();
    }
    lookahead1W(29);                // WS | COMMENT^WS | DOC_COMMENT | 'class' | 'lexclass'
    if (l1 == 32)                   // DOC_COMMENT
    {
      consume(32);                  // DOC_COMMENT
    }
    lookahead1W(22);                // WS | COMMENT^WS | 'class' | 'lexclass'
    switch (l1)
    {
    case 45:                        // 'class'
      lookahead2W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      break;
    default:
      lk = l1;
    }
    if (lk != 49)                   // 'lexclass'
    {
      lk = memoized(0, e0);
      if (lk == 0)
      {
        int b0A = b0; int e0A = e0; int l1A = l1;
        int b1A = b1; int e1A = e1; int l2A = l2;
        int b2A = b2; int e2A = e2;
        try
        {
          try_lexerSpec();
          lk = -1;
        }
        catch (ParseException p1A)
        {
          try
          {
            b0 = b0A; e0 = e0A; l1 = l1A; if (l1 == 0) {end = e0A;} else {
            b1 = b1A; e1 = e1A; l2 = l2A; if (l2 == 0) {end = e1A;} else {
            b2 = b2A; e2 = e2A; end = e2A; }}
            try_treeParserSpec();
            lk = -2;
          }
          catch (ParseException p2A)
          {
            lk = -3;
          }
        }
        b0 = b0A; e0 = e0A; l1 = l1A; if (l1 == 0) {end = e0A;} else {
        b1 = b1A; e1 = e1A; l2 = l2A; if (l2 == 0) {end = e1A;} else {
        b2 = b2A; e2 = e2A; end = e2A; }}
        memoize(0, e0, lk);
      }
    }
    switch (lk)
    {
    case -2:
      whitespace();
      parse_treeParserSpec();
      break;
    case -3:
      whitespace();
      parse_parserSpec();
      break;
    default:
      whitespace();
      parse_lexerSpec();
    }
    lookahead1W(42);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | 'private' | 'protected' |
                                    // 'public'
    whitespace();
    parse_rules();
    eventHandler.endNonterminal("classDef", e0);
  }

  private void parse_fileOptionsSpec()
  {
    eventHandler.startNonterminal("fileOptionsSpec", e0);
    consume(33);                    // OPTIONS
    for (;;)
    {
      lookahead1W(28);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      whitespace();
      parse_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consume(14);                  // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      whitespace();
      parse_optionValue();
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consume(16);                  // SEMI
    }
    consume(23);                    // RCURLY
    eventHandler.endNonterminal("fileOptionsSpec", e0);
  }

  private void parse_parserOptionsSpec()
  {
    eventHandler.startNonterminal("parserOptionsSpec", e0);
    consume(33);                    // OPTIONS
    for (;;)
    {
      lookahead1W(28);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      whitespace();
      parse_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consume(14);                  // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      whitespace();
      parse_optionValue();
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consume(16);                  // SEMI
    }
    consume(23);                    // RCURLY
    eventHandler.endNonterminal("parserOptionsSpec", e0);
  }

  private void parse_treeParserOptionsSpec()
  {
    eventHandler.startNonterminal("treeParserOptionsSpec", e0);
    consume(33);                    // OPTIONS
    for (;;)
    {
      lookahead1W(28);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      whitespace();
      parse_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consume(14);                  // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      whitespace();
      parse_optionValue();
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consume(16);                  // SEMI
    }
    consume(23);                    // RCURLY
    eventHandler.endNonterminal("treeParserOptionsSpec", e0);
  }

  private void try_treeParserOptionsSpec()
  {
    consumeT(33);                   // OPTIONS
    for (;;)
    {
      lookahead1W(28);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      try_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consumeT(14);                 // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      try_optionValue();
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consumeT(16);                 // SEMI
    }
    consumeT(23);                   // RCURLY
  }

  private void parse_lexerOptionsSpec()
  {
    eventHandler.startNonterminal("lexerOptionsSpec", e0);
    consume(33);                    // OPTIONS
    for (;;)
    {
      lookahead1W(34);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF | 'charVocabulary'
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      switch (l1)
      {
      case 44:                      // 'charVocabulary'
        consume(44);                // 'charVocabulary'
        lookahead1W(2);             // WS | COMMENT^WS | ASSIGN
        consume(14);                // ASSIGN
        lookahead1W(5);             // WS | COMMENT^WS | CHAR_LITERAL
        whitespace();
        parse_charSet();
        consume(16);                // SEMI
        break;
      default:
        whitespace();
        parse_id();
        lookahead1W(2);             // WS | COMMENT^WS | ASSIGN
        consume(14);                // ASSIGN
        lookahead1W(37);            // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
        whitespace();
        parse_optionValue();
        lookahead1W(3);             // WS | COMMENT^WS | SEMI
        consume(16);                // SEMI
      }
    }
    consume(23);                    // RCURLY
    eventHandler.endNonterminal("lexerOptionsSpec", e0);
  }

  private void try_lexerOptionsSpec()
  {
    consumeT(33);                   // OPTIONS
    for (;;)
    {
      lookahead1W(34);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF | 'charVocabulary'
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      switch (l1)
      {
      case 44:                      // 'charVocabulary'
        consumeT(44);               // 'charVocabulary'
        lookahead1W(2);             // WS | COMMENT^WS | ASSIGN
        consumeT(14);               // ASSIGN
        lookahead1W(5);             // WS | COMMENT^WS | CHAR_LITERAL
        try_charSet();
        consumeT(16);               // SEMI
        break;
      default:
        try_id();
        lookahead1W(2);             // WS | COMMENT^WS | ASSIGN
        consumeT(14);               // ASSIGN
        lookahead1W(37);            // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
        try_optionValue();
        lookahead1W(3);             // WS | COMMENT^WS | SEMI
        consumeT(16);               // SEMI
      }
    }
    consumeT(23);                   // RCURLY
  }

  private void parse_subruleOptionsSpec()
  {
    eventHandler.startNonterminal("subruleOptionsSpec", e0);
    consume(33);                    // OPTIONS
    for (;;)
    {
      lookahead1W(28);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      whitespace();
      parse_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consume(14);                  // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      whitespace();
      parse_optionValue();
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consume(16);                  // SEMI
    }
    consume(23);                    // RCURLY
    eventHandler.endNonterminal("subruleOptionsSpec", e0);
  }

  private void try_subruleOptionsSpec()
  {
    consumeT(33);                   // OPTIONS
    for (;;)
    {
      lookahead1W(28);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      try_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consumeT(14);                 // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      try_optionValue();
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consumeT(16);                 // SEMI
    }
    consumeT(23);                   // RCURLY
  }

  private void parse_optionValue()
  {
    eventHandler.startNonterminal("optionValue", e0);
    switch (l1)
    {
    case 25:                        // STRING_LITERAL
      consume(25);                  // STRING_LITERAL
      break;
    case 24:                        // CHAR_LITERAL
      consume(24);                  // CHAR_LITERAL
      break;
    case 26:                        // INT
      consume(26);                  // INT
      break;
    default:
      parse_qualifiedID();
    }
    eventHandler.endNonterminal("optionValue", e0);
  }

  private void try_optionValue()
  {
    switch (l1)
    {
    case 25:                        // STRING_LITERAL
      consumeT(25);                 // STRING_LITERAL
      break;
    case 24:                        // CHAR_LITERAL
      consumeT(24);                 // CHAR_LITERAL
      break;
    case 26:                        // INT
      consumeT(26);                 // INT
      break;
    default:
      try_qualifiedID();
    }
  }

  private void parse_charSet()
  {
    eventHandler.startNonterminal("charSet", e0);
    parse_setBlockElement();
    for (;;)
    {
      lookahead1W(17);              // WS | COMMENT^WS | SEMI | OR
      if (l1 != 19)                 // OR
      {
        break;
      }
      consume(19);                  // OR
      lookahead1W(5);               // WS | COMMENT^WS | CHAR_LITERAL
      whitespace();
      parse_setBlockElement();
    }
    eventHandler.endNonterminal("charSet", e0);
  }

  private void try_charSet()
  {
    try_setBlockElement();
    for (;;)
    {
      lookahead1W(17);              // WS | COMMENT^WS | SEMI | OR
      if (l1 != 19)                 // OR
      {
        break;
      }
      consumeT(19);                 // OR
      lookahead1W(5);               // WS | COMMENT^WS | CHAR_LITERAL
      try_setBlockElement();
    }
  }

  private void parse_setBlockElement()
  {
    eventHandler.startNonterminal("setBlockElement", e0);
    consume(24);                    // CHAR_LITERAL
    lookahead1W(26);                // WS | COMMENT^WS | SEMI | OR | RANGE
    if (l1 == 21)                   // RANGE
    {
      consume(21);                  // RANGE
      lookahead1W(5);               // WS | COMMENT^WS | CHAR_LITERAL
      consume(24);                  // CHAR_LITERAL
    }
    eventHandler.endNonterminal("setBlockElement", e0);
  }

  private void try_setBlockElement()
  {
    consumeT(24);                   // CHAR_LITERAL
    lookahead1W(26);                // WS | COMMENT^WS | SEMI | OR | RANGE
    if (l1 == 21)                   // RANGE
    {
      consumeT(21);                 // RANGE
      lookahead1W(5);               // WS | COMMENT^WS | CHAR_LITERAL
      consumeT(24);                 // CHAR_LITERAL
    }
  }

  private void parse_tokensSpec()
  {
    eventHandler.startNonterminal("tokensSpec", e0);
    consume(34);                    // TOKENS
    for (;;)
    {
      lookahead1W(19);              // WS | COMMENT^WS | STRING_LITERAL | TOKEN_REF
      switch (l1)
      {
      case 29:                      // TOKEN_REF
        consume(29);                // TOKEN_REF
        lookahead1W(23);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | ASSIGN | SEMI
        if (l1 == 14)               // ASSIGN
        {
          consume(14);              // ASSIGN
          lookahead1W(6);           // WS | COMMENT^WS | STRING_LITERAL
          consume(25);              // STRING_LITERAL
        }
        lookahead1W(13);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | SEMI
        if (l1 == 4)                // OPEN_ELEMENT_OPTION
        {
          whitespace();
          parse_tokensSpecOptions();
        }
        break;
      default:
        consume(25);                // STRING_LITERAL
        lookahead1W(13);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | SEMI
        if (l1 == 4)                // OPEN_ELEMENT_OPTION
        {
          whitespace();
          parse_tokensSpecOptions();
        }
      }
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consume(16);                  // SEMI
      lookahead1W(27);              // WS | COMMENT^WS | RCURLY | STRING_LITERAL | TOKEN_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
    }
    consume(23);                    // RCURLY
    eventHandler.endNonterminal("tokensSpec", e0);
  }

  private void try_tokensSpec()
  {
    consumeT(34);                   // TOKENS
    for (;;)
    {
      lookahead1W(19);              // WS | COMMENT^WS | STRING_LITERAL | TOKEN_REF
      switch (l1)
      {
      case 29:                      // TOKEN_REF
        consumeT(29);               // TOKEN_REF
        lookahead1W(23);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | ASSIGN | SEMI
        if (l1 == 14)               // ASSIGN
        {
          consumeT(14);             // ASSIGN
          lookahead1W(6);           // WS | COMMENT^WS | STRING_LITERAL
          consumeT(25);             // STRING_LITERAL
        }
        lookahead1W(13);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | SEMI
        if (l1 == 4)                // OPEN_ELEMENT_OPTION
        {
          try_tokensSpecOptions();
        }
        break;
      default:
        consumeT(25);               // STRING_LITERAL
        lookahead1W(13);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | SEMI
        if (l1 == 4)                // OPEN_ELEMENT_OPTION
        {
          try_tokensSpecOptions();
        }
      }
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consumeT(16);                 // SEMI
      lookahead1W(27);              // WS | COMMENT^WS | RCURLY | STRING_LITERAL | TOKEN_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
    }
    consumeT(23);                   // RCURLY
  }

  private void parse_tokensSpecOptions()
  {
    eventHandler.startNonterminal("tokensSpecOptions", e0);
    consume(4);                     // OPEN_ELEMENT_OPTION
    lookahead1W(21);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF
    whitespace();
    parse_id();
    lookahead1W(2);                 // WS | COMMENT^WS | ASSIGN
    consume(14);                    // ASSIGN
    lookahead1W(37);                // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
    whitespace();
    parse_optionValue();
    for (;;)
    {
      lookahead1W(14);              // WS | COMMENT^WS | CLOSE_ELEMENT_OPTION | SEMI
      if (l1 != 16)                 // SEMI
      {
        break;
      }
      consume(16);                  // SEMI
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      whitespace();
      parse_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consume(14);                  // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      whitespace();
      parse_optionValue();
    }
    consume(5);                     // CLOSE_ELEMENT_OPTION
    eventHandler.endNonterminal("tokensSpecOptions", e0);
  }

  private void try_tokensSpecOptions()
  {
    consumeT(4);                    // OPEN_ELEMENT_OPTION
    lookahead1W(21);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF
    try_id();
    lookahead1W(2);                 // WS | COMMENT^WS | ASSIGN
    consumeT(14);                   // ASSIGN
    lookahead1W(37);                // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
    try_optionValue();
    for (;;)
    {
      lookahead1W(14);              // WS | COMMENT^WS | CLOSE_ELEMENT_OPTION | SEMI
      if (l1 != 16)                 // SEMI
      {
        break;
      }
      consumeT(16);                 // SEMI
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      try_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consumeT(14);                 // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      try_optionValue();
    }
    consumeT(5);                    // CLOSE_ELEMENT_OPTION
  }

  private void parse_superClass()
  {
    eventHandler.startNonterminal("superClass", e0);
    consume(9);                     // LPAREN
    lookahead1W(6);                 // WS | COMMENT^WS | STRING_LITERAL
    consume(25);                    // STRING_LITERAL
    lookahead1W(0);                 // WS | COMMENT^WS | RPAREN
    consume(10);                    // RPAREN
    eventHandler.endNonterminal("superClass", e0);
  }

  private void try_superClass()
  {
    consumeT(9);                    // LPAREN
    lookahead1W(6);                 // WS | COMMENT^WS | STRING_LITERAL
    consumeT(25);                   // STRING_LITERAL
    lookahead1W(0);                 // WS | COMMENT^WS | RPAREN
    consumeT(10);                   // RPAREN
  }

  private void parse_parserSpec()
  {
    eventHandler.startNonterminal("parserSpec", e0);
    consume(45);                    // 'class'
    lookahead1W(21);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF
    whitespace();
    parse_id();
    lookahead1W(18);                // WS | COMMENT^WS | SEMI | 'extends'
    switch (l1)
    {
    case 47:                        // 'extends'
      consume(47);                  // 'extends'
      lookahead1W(8);               // WS | COMMENT^WS | 'Parser'
      consume(39);                  // 'Parser'
      lookahead1W(15);              // WS | COMMENT^WS | LPAREN | SEMI
      if (l1 == 9)                  // LPAREN
      {
        whitespace();
        parse_superClass();
      }
      break;
    default:
      break;
    }
    lookahead1W(3);                 // WS | COMMENT^WS | SEMI
    consume(16);                    // SEMI
    lookahead1W(51);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | OPTIONS | TOKENS |
                                    // 'private' | 'protected' | 'public' | '{'
    if (l1 == 33)                   // OPTIONS
    {
      whitespace();
      parse_parserOptionsSpec();
    }
    lookahead1W(49);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | TOKENS | 'private' |
                                    // 'protected' | 'public' | '{'
    if (l1 == 34)                   // TOKENS
    {
      whitespace();
      parse_tokensSpec();
    }
    lookahead1W(46);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | 'private' | 'protected' |
                                    // 'public' | '{'
    if (l1 == 55)                   // '{'
    {
      whitespace();
      parse_ACTION();
    }
    eventHandler.endNonterminal("parserSpec", e0);
  }

  private void parse_lexerSpec()
  {
    eventHandler.startNonterminal("lexerSpec", e0);
    switch (l1)
    {
    case 49:                        // 'lexclass'
      consume(49);                  // 'lexclass'
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      whitespace();
      parse_id();
      break;
    default:
      consume(45);                  // 'class'
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      whitespace();
      parse_id();
      lookahead1W(11);              // WS | COMMENT^WS | 'extends'
      consume(47);                  // 'extends'
      lookahead1W(7);               // WS | COMMENT^WS | 'Lexer'
      consume(38);                  // 'Lexer'
      lookahead1W(15);              // WS | COMMENT^WS | LPAREN | SEMI
      if (l1 == 9)                  // LPAREN
      {
        whitespace();
        parse_superClass();
      }
    }
    lookahead1W(3);                 // WS | COMMENT^WS | SEMI
    consume(16);                    // SEMI
    lookahead1W(51);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | OPTIONS | TOKENS |
                                    // 'private' | 'protected' | 'public' | '{'
    if (l1 == 33)                   // OPTIONS
    {
      whitespace();
      parse_lexerOptionsSpec();
    }
    lookahead1W(49);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | TOKENS | 'private' |
                                    // 'protected' | 'public' | '{'
    if (l1 == 34)                   // TOKENS
    {
      whitespace();
      parse_tokensSpec();
    }
    lookahead1W(46);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | 'private' | 'protected' |
                                    // 'public' | '{'
    if (l1 == 55)                   // '{'
    {
      whitespace();
      parse_ACTION();
    }
    eventHandler.endNonterminal("lexerSpec", e0);
  }

  private void try_lexerSpec()
  {
    switch (l1)
    {
    case 49:                        // 'lexclass'
      consumeT(49);                 // 'lexclass'
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      try_id();
      break;
    default:
      consumeT(45);                 // 'class'
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      try_id();
      lookahead1W(11);              // WS | COMMENT^WS | 'extends'
      consumeT(47);                 // 'extends'
      lookahead1W(7);               // WS | COMMENT^WS | 'Lexer'
      consumeT(38);                 // 'Lexer'
      lookahead1W(15);              // WS | COMMENT^WS | LPAREN | SEMI
      if (l1 == 9)                  // LPAREN
      {
        try_superClass();
      }
    }
    lookahead1W(3);                 // WS | COMMENT^WS | SEMI
    consumeT(16);                   // SEMI
    lookahead1W(51);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | OPTIONS | TOKENS |
                                    // 'private' | 'protected' | 'public' | '{'
    if (l1 == 33)                   // OPTIONS
    {
      try_lexerOptionsSpec();
    }
    lookahead1W(49);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | TOKENS | 'private' |
                                    // 'protected' | 'public' | '{'
    if (l1 == 34)                   // TOKENS
    {
      try_tokensSpec();
    }
    lookahead1W(46);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | 'private' | 'protected' |
                                    // 'public' | '{'
    if (l1 == 55)                   // '{'
    {
      try_ACTION();
    }
  }

  private void parse_treeParserSpec()
  {
    eventHandler.startNonterminal("treeParserSpec", e0);
    consume(45);                    // 'class'
    lookahead1W(21);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF
    whitespace();
    parse_id();
    lookahead1W(11);                // WS | COMMENT^WS | 'extends'
    consume(47);                    // 'extends'
    lookahead1W(9);                 // WS | COMMENT^WS | 'TreeParser'
    consume(40);                    // 'TreeParser'
    lookahead1W(15);                // WS | COMMENT^WS | LPAREN | SEMI
    if (l1 == 9)                    // LPAREN
    {
      whitespace();
      parse_superClass();
    }
    lookahead1W(3);                 // WS | COMMENT^WS | SEMI
    consume(16);                    // SEMI
    lookahead1W(51);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | OPTIONS | TOKENS |
                                    // 'private' | 'protected' | 'public' | '{'
    if (l1 == 33)                   // OPTIONS
    {
      whitespace();
      parse_treeParserOptionsSpec();
    }
    lookahead1W(49);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | TOKENS | 'private' |
                                    // 'protected' | 'public' | '{'
    if (l1 == 34)                   // TOKENS
    {
      whitespace();
      parse_tokensSpec();
    }
    lookahead1W(46);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | 'private' | 'protected' |
                                    // 'public' | '{'
    if (l1 == 55)                   // '{'
    {
      whitespace();
      parse_ACTION();
    }
    eventHandler.endNonterminal("treeParserSpec", e0);
  }

  private void try_treeParserSpec()
  {
    consumeT(45);                   // 'class'
    lookahead1W(21);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF
    try_id();
    lookahead1W(11);                // WS | COMMENT^WS | 'extends'
    consumeT(47);                   // 'extends'
    lookahead1W(9);                 // WS | COMMENT^WS | 'TreeParser'
    consumeT(40);                   // 'TreeParser'
    lookahead1W(15);                // WS | COMMENT^WS | LPAREN | SEMI
    if (l1 == 9)                    // LPAREN
    {
      try_superClass();
    }
    lookahead1W(3);                 // WS | COMMENT^WS | SEMI
    consumeT(16);                   // SEMI
    lookahead1W(51);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | OPTIONS | TOKENS |
                                    // 'private' | 'protected' | 'public' | '{'
    if (l1 == 33)                   // OPTIONS
    {
      try_treeParserOptionsSpec();
    }
    lookahead1W(49);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | TOKENS | 'private' |
                                    // 'protected' | 'public' | '{'
    if (l1 == 34)                   // TOKENS
    {
      try_tokensSpec();
    }
    lookahead1W(46);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | DOC_COMMENT | 'private' | 'protected' |
                                    // 'public' | '{'
    if (l1 == 55)                   // '{'
    {
      try_ACTION();
    }
  }

  private void parse_rules()
  {
    eventHandler.startNonterminal("rules", e0);
    for (;;)
    {
      whitespace();
      parse_rule();
      switch (l1)
      {
      case 32:                      // DOC_COMMENT
        lookahead2W(47);            // WS | COMMENT^WS | TOKEN_REF | RULE_REF | 'class' | 'lexclass' | 'private' |
                                    // 'protected' | 'public'
        break;
      default:
        lk = l1;
      }
      if (lk == 31                  // EOF
       || lk == 45                  // 'class'
       || lk == 49                  // 'lexclass'
       || lk == 55                  // '{'
       || lk == 2912                // DOC_COMMENT 'class'
       || lk == 3168)               // DOC_COMMENT 'lexclass'
      {
        break;
      }
    }
    eventHandler.endNonterminal("rules", e0);
  }

  private void parse_rule()
  {
    eventHandler.startNonterminal("rule", e0);
    if (l1 == 32)                   // DOC_COMMENT
    {
      consume(32);                  // DOC_COMMENT
    }
    lookahead1W(38);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | 'private' | 'protected' | 'public'
    if (l1 != 29                    // TOKEN_REF
     && l1 != 30)                   // RULE_REF
    {
      switch (l1)
      {
      case 51:                      // 'protected'
        consume(51);                // 'protected'
        break;
      case 52:                      // 'public'
        consume(52);                // 'public'
        break;
      default:
        consume(50);                // 'private'
      }
    }
    lookahead1W(21);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF
    whitespace();
    parse_id();
    lookahead1W(45);                // WS | COMMENT^WS | COLON | BANG | OPTIONS | '[' | 'returns' | 'throws' | '{'
    if (l1 == 18)                   // BANG
    {
      consume(18);                  // BANG
    }
    lookahead1W(41);                // WS | COMMENT^WS | COLON | OPTIONS | '[' | 'returns' | 'throws' | '{'
    if (l1 == 41)                   // '['
    {
      whitespace();
      parse_ARG_ACTION();
    }
    lookahead1W(35);                // WS | COMMENT^WS | COLON | OPTIONS | 'returns' | 'throws' | '{'
    if (l1 == 53)                   // 'returns'
    {
      consume(53);                  // 'returns'
      lookahead1W(10);              // WS | COMMENT^WS | '['
      whitespace();
      parse_ARG_ACTION();
    }
    lookahead1W(32);                // WS | COMMENT^WS | COLON | OPTIONS | 'throws' | '{'
    if (l1 == 54)                   // 'throws'
    {
      whitespace();
      parse_throwsSpec();
    }
    if (l1 == 33)                   // OPTIONS
    {
      whitespace();
      parse_ruleOptionsSpec();
    }
    lookahead1W(16);                // WS | COMMENT^WS | COLON | '{'
    if (l1 == 55)                   // '{'
    {
      whitespace();
      parse_ACTION();
    }
    lookahead1W(1);                 // WS | COMMENT^WS | COLON
    consume(11);                    // COLON
    lookahead1W(58);                // WS | COMMENT^WS | TREE_BEGIN | LPAREN | SEMI | BANG | OR | WILDCARD | NOT_OP |
                                    // CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF | 'exception' | '{'
    whitespace();
    parse_block();
    consume(16);                    // SEMI
    lookahead1W(53);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | EOF | DOC_COMMENT | 'class' |
                                    // 'exception' | 'lexclass' | 'private' | 'protected' | 'public' | '{'
    if (l1 == 46)                   // 'exception'
    {
      whitespace();
      parse_exceptionGroup();
    }
    eventHandler.endNonterminal("rule", e0);
  }

  private void parse_ruleOptionsSpec()
  {
    eventHandler.startNonterminal("ruleOptionsSpec", e0);
    consume(33);                    // OPTIONS
    for (;;)
    {
      lookahead1W(28);              // WS | COMMENT^WS | RCURLY | TOKEN_REF | RULE_REF
      if (l1 == 23)                 // RCURLY
      {
        break;
      }
      whitespace();
      parse_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consume(14);                  // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      whitespace();
      parse_optionValue();
      lookahead1W(3);               // WS | COMMENT^WS | SEMI
      consume(16);                  // SEMI
    }
    consume(23);                    // RCURLY
    eventHandler.endNonterminal("ruleOptionsSpec", e0);
  }

  private void parse_throwsSpec()
  {
    eventHandler.startNonterminal("throwsSpec", e0);
    consume(54);                    // 'throws'
    lookahead1W(21);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF
    whitespace();
    parse_id();
    for (;;)
    {
      lookahead1W(30);              // WS | COMMENT^WS | COMMA | COLON | OPTIONS | '{'
      if (l1 != 6)                  // COMMA
      {
        break;
      }
      consume(6);                   // COMMA
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      whitespace();
      parse_id();
    }
    eventHandler.endNonterminal("throwsSpec", e0);
  }

  private void parse_block()
  {
    eventHandler.startNonterminal("block", e0);
    parse_alternative();
    for (;;)
    {
      if (l1 != 19)                 // OR
      {
        break;
      }
      consume(19);                  // OR
      lookahead1W(61);              // WS | COMMENT^WS | TREE_BEGIN | LPAREN | RPAREN | SEMI | BANG | OR | WILDCARD |
                                    // NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF | 'exception' | '{'
      whitespace();
      parse_alternative();
    }
    eventHandler.endNonterminal("block", e0);
  }

  private void parse_alternative()
  {
    eventHandler.startNonterminal("alternative", e0);
    if (l1 == 18)                   // BANG
    {
      consume(18);                  // BANG
    }
    for (;;)
    {
      lookahead1W(55);              // WS | COMMENT^WS | TREE_BEGIN | LPAREN | RPAREN | SEMI | OR | WILDCARD | NOT_OP |
                                    // CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF | 'exception' | '{'
      if (l1 == 10                  // RPAREN
       || l1 == 16                  // SEMI
       || l1 == 19                  // OR
       || l1 == 46)                 // 'exception'
      {
        break;
      }
      whitespace();
      parse_element();
    }
    if (l1 == 46)                   // 'exception'
    {
      whitespace();
      parse_exceptionSpecNoLabel();
    }
    eventHandler.endNonterminal("alternative", e0);
  }

  private void parse_exceptionGroup()
  {
    eventHandler.startNonterminal("exceptionGroup", e0);
    for (;;)
    {
      whitespace();
      parse_exceptionSpec();
      if (l1 != 46)                 // 'exception'
      {
        break;
      }
    }
    eventHandler.endNonterminal("exceptionGroup", e0);
  }

  private void parse_exceptionSpec()
  {
    eventHandler.startNonterminal("exceptionSpec", e0);
    consume(46);                    // 'exception'
    lookahead1W(59);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF | EOF | DOC_COMMENT | '[' | 'catch' |
                                    // 'class' | 'exception' | 'lexclass' | 'private' | 'protected' | 'public' | '{'
    if (l1 == 41)                   // '['
    {
      whitespace();
      parse_ARG_ACTION();
    }
    for (;;)
    {
      lookahead1W(54);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF | EOF | DOC_COMMENT | 'catch' | 'class' |
                                    // 'exception' | 'lexclass' | 'private' | 'protected' | 'public' | '{'
      if (l1 != 43)                 // 'catch'
      {
        break;
      }
      whitespace();
      parse_exceptionHandler();
    }
    eventHandler.endNonterminal("exceptionSpec", e0);
  }

  private void parse_exceptionSpecNoLabel()
  {
    eventHandler.startNonterminal("exceptionSpecNoLabel", e0);
    consume(46);                    // 'exception'
    for (;;)
    {
      lookahead1W(31);              // WS | COMMENT^WS | RPAREN | SEMI | OR | 'catch'
      if (l1 != 43)                 // 'catch'
      {
        break;
      }
      whitespace();
      parse_exceptionHandler();
    }
    eventHandler.endNonterminal("exceptionSpecNoLabel", e0);
  }

  private void parse_exceptionHandler()
  {
    eventHandler.startNonterminal("exceptionHandler", e0);
    consume(43);                    // 'catch'
    lookahead1W(10);                // WS | COMMENT^WS | '['
    whitespace();
    parse_ARG_ACTION();
    lookahead1W(12);                // WS | COMMENT^WS | '{'
    whitespace();
    parse_ACTION();
    eventHandler.endNonterminal("exceptionHandler", e0);
  }

  private void parse_element()
  {
    eventHandler.startNonterminal("element", e0);
    parse_elementNoOptionSpec();
    lookahead1W(60);                // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                    // 'exception' | '{'
    if (l1 == 4)                    // OPEN_ELEMENT_OPTION
    {
      whitespace();
      parse_elementOptionSpec();
    }
    eventHandler.endNonterminal("element", e0);
  }

  private void parse_elementOptionSpec()
  {
    eventHandler.startNonterminal("elementOptionSpec", e0);
    consume(4);                     // OPEN_ELEMENT_OPTION
    lookahead1W(21);                // WS | COMMENT^WS | TOKEN_REF | RULE_REF
    whitespace();
    parse_id();
    lookahead1W(2);                 // WS | COMMENT^WS | ASSIGN
    consume(14);                    // ASSIGN
    lookahead1W(37);                // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
    whitespace();
    parse_optionValue();
    for (;;)
    {
      lookahead1W(14);              // WS | COMMENT^WS | CLOSE_ELEMENT_OPTION | SEMI
      if (l1 != 16)                 // SEMI
      {
        break;
      }
      consume(16);                  // SEMI
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      whitespace();
      parse_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consume(14);                  // ASSIGN
      lookahead1W(37);              // WS | COMMENT^WS | CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF | RULE_REF
      whitespace();
      parse_optionValue();
    }
    consume(5);                     // CLOSE_ELEMENT_OPTION
    eventHandler.endNonterminal("elementOptionSpec", e0);
  }

  private void parse_elementNoOptionSpec()
  {
    eventHandler.startNonterminal("elementNoOptionSpec", e0);
    switch (l1)
    {
    case 29:                        // TOKEN_REF
      lookahead2W(77);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | COLON |
                                    // ASSIGN | SEMI | CARET | BANG | OR | WILDCARD | RANGE | NOT_OP | CHAR_LITERAL |
                                    // STRING_LITERAL | TOKEN_REF | RULE_REF | '[' | 'exception' | '{'
      break;
    case 30:                        // RULE_REF
      lookahead2W(73);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | COLON |
                                    // ASSIGN | SEMI | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | '[' | 'exception' | '{'
      break;
    default:
      lk = l1;
    }
    switch (lk)
    {
    case 925:                       // TOKEN_REF ASSIGN
    case 926:                       // RULE_REF ASSIGN
      parse_id();
      lookahead1W(2);               // WS | COMMENT^WS | ASSIGN
      consume(14);                  // ASSIGN
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      switch (l1)
      {
      case 29:                      // TOKEN_REF
        lookahead2W(66);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | COLON |
                                    // SEMI | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | '[' | 'exception' | '{'
        break;
      case 30:                      // RULE_REF
        lookahead2W(70);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | COLON |
                                    // SEMI | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | '[' | 'exception' | '{'
        break;
      default:
        lk = l1;
      }
      if (lk == 733                 // TOKEN_REF COLON
       || lk == 734)                // RULE_REF COLON
      {
        whitespace();
        parse_id();
        lookahead1W(1);             // WS | COMMENT^WS | COLON
        consume(11);                // COLON
      }
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      switch (l1)
      {
      case 30:                      // RULE_REF
        consume(30);                // RULE_REF
        lookahead1W(69);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | '[' | 'exception' | '{'
        if (l1 == 41)               // '['
        {
          whitespace();
          parse_ARG_ACTION();
        }
        lookahead1W(63);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | 'exception' | '{'
        if (l1 == 18)               // BANG
        {
          consume(18);              // BANG
        }
        break;
      default:
        consume(29);                // TOKEN_REF
        lookahead1W(65);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                    // '[' | 'exception' | '{'
        if (l1 == 41)               // '['
        {
          whitespace();
          parse_ARG_ACTION();
        }
      }
      break;
    case 55:                        // '{'
      parse_ACTION_OR_SEMPRED();
      break;
    case 8:                         // TREE_BEGIN
      parse_tree();
      break;
    default:
      switch (l1)
      {
      case 29:                      // TOKEN_REF
        lookahead2W(76);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | COLON |
                                    // SEMI | CARET | BANG | OR | WILDCARD | RANGE | NOT_OP | CHAR_LITERAL |
                                    // STRING_LITERAL | TOKEN_REF | RULE_REF | '[' | 'exception' | '{'
        break;
      case 30:                      // RULE_REF
        lookahead2W(70);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | COLON |
                                    // SEMI | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | '[' | 'exception' | '{'
        break;
      default:
        lk = l1;
      }
      if (lk == 733                 // TOKEN_REF COLON
       || lk == 734)                // RULE_REF COLON
      {
        whitespace();
        parse_id();
        lookahead1W(1);             // WS | COMMENT^WS | COLON
        consume(11);                // COLON
      }
      lookahead1W(44);              // WS | COMMENT^WS | LPAREN | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF
      switch (l1)
      {
      case 24:                      // CHAR_LITERAL
        lookahead2W(68);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | RANGE | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | 'exception' | '{'
        break;
      case 25:                      // STRING_LITERAL
        lookahead2W(71);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // CARET | BANG | OR | WILDCARD | RANGE | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | 'exception' | '{'
        break;
      case 29:                      // TOKEN_REF
        lookahead2W(74);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // CARET | BANG | OR | WILDCARD | RANGE | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | '[' | 'exception' | '{'
        break;
      default:
        lk = l1;
      }
      switch (lk)
      {
      case 30:                      // RULE_REF
        consume(30);                // RULE_REF
        lookahead1W(69);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | '[' | 'exception' | '{'
        if (l1 == 41)               // '['
        {
          whitespace();
          parse_ARG_ACTION();
        }
        lookahead1W(63);            // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | 'exception' | '{'
        if (l1 == 18)               // BANG
        {
          consume(18);              // BANG
        }
        break;
      case 1368:                    // CHAR_LITERAL RANGE
      case 1369:                    // STRING_LITERAL RANGE
      case 1373:                    // TOKEN_REF RANGE
        whitespace();
        parse_range();
        break;
      case 22:                      // NOT_OP
        consume(22);                // NOT_OP
        lookahead1W(25);            // WS | COMMENT^WS | LPAREN | CHAR_LITERAL | TOKEN_REF
        switch (l1)
        {
        case 9:                     // LPAREN
          whitespace();
          parse_ebnf();
          break;
        default:
          whitespace();
          parse_notTerminal();
        }
        break;
      case 9:                       // LPAREN
        whitespace();
        parse_ebnf();
        break;
      default:
        whitespace();
        parse_terminal();
      }
    }
    eventHandler.endNonterminal("elementNoOptionSpec", e0);
  }

  private void parse_tree()
  {
    eventHandler.startNonterminal("tree", e0);
    consume(8);                     // TREE_BEGIN
    lookahead1W(36);                // WS | COMMENT^WS | WILDCARD | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF
    whitespace();
    parse_rootNode();
    for (;;)
    {
      lookahead1W(50);              // WS | COMMENT^WS | TREE_BEGIN | LPAREN | WILDCARD | NOT_OP | CHAR_LITERAL |
                                    // STRING_LITERAL | TOKEN_REF | RULE_REF | '{'
      whitespace();
      parse_element();
      lookahead1W(52);              // WS | COMMENT^WS | TREE_BEGIN | LPAREN | RPAREN | WILDCARD | NOT_OP |
                                    // CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF | '{'
      if (l1 == 10)                 // RPAREN
      {
        break;
      }
    }
    consume(10);                    // RPAREN
    eventHandler.endNonterminal("tree", e0);
  }

  private void parse_rootNode()
  {
    eventHandler.startNonterminal("rootNode", e0);
    switch (l1)
    {
    case 29:                        // TOKEN_REF
      lookahead2W(57);              // WS | COMMENT^WS | TREE_BEGIN | LPAREN | COLON | CARET | BANG | WILDCARD |
                                    // NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF | '[' | '{'
      break;
    default:
      lk = l1;
    }
    if (lk == 30                    // RULE_REF
     || lk == 733)                  // TOKEN_REF COLON
    {
      whitespace();
      parse_id();
      lookahead1W(1);               // WS | COMMENT^WS | COLON
      consume(11);                  // COLON
    }
    lookahead1W(33);                // WS | COMMENT^WS | WILDCARD | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF
    whitespace();
    parse_terminal();
    eventHandler.endNonterminal("rootNode", e0);
  }

  private void parse_ebnf()
  {
    eventHandler.startNonterminal("ebnf", e0);
    consume(9);                     // LPAREN
    lookahead1W(62);                // WS | COMMENT^WS | TREE_BEGIN | LPAREN | RPAREN | BANG | OR | WILDCARD | NOT_OP |
                                    // CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF | OPTIONS | 'exception' |
                                    // '{'
    switch (l1)
    {
    case 55:                        // '{'
      lookahead2(43);               // COMMENT | CHAR_LITERAL | STRING_LITERAL | CR | LF | ACTION_CHAR | '{' | '}'
      break;
    default:
      lk = l1;
    }
    if (lk == 183                   // '{' COMMENT
     || lk == 1591                  // '{' CHAR_LITERAL
     || lk == 1655                  // '{' STRING_LITERAL
     || lk == 1783                  // '{' CR
     || lk == 1847                  // '{' LF
     || lk == 2295                  // '{' ACTION_CHAR
     || lk == 3575                  // '{' '{'
     || lk == 3639)                 // '{' '}'
    {
      lk = memoized(1, e0);
      if (lk == 0)
      {
        int b0A = b0; int e0A = e0; int l1A = l1;
        int b1A = b1; int e1A = e1; int l2A = l2;
        int b2A = b2; int e2A = e2;
        try
        {
          switch (l1)
          {
          case 33:                  // OPTIONS
            try_subruleOptionsSpec();
            lookahead1W(16);        // WS | COMMENT^WS | COLON | '{'
            if (l1 == 55)           // '{'
            {
              try_ACTION();
            }
            lookahead1W(1);         // WS | COMMENT^WS | COLON
            consumeT(11);           // COLON
            break;
          default:
            try_ACTION();
            lookahead1W(1);         // WS | COMMENT^WS | COLON
            consumeT(11);           // COLON
          }
          lk = -1;
        }
        catch (ParseException p1A)
        {
          lk = -2;
        }
        b0 = b0A; e0 = e0A; l1 = l1A; if (l1 == 0) {end = e0A;} else {
        b1 = b1A; e1 = e1A; l2 = l2A; if (l2 == 0) {end = e1A;} else {
        b2 = b2A; e2 = e2A; end = e2A; }}
        memoize(1, e0, lk);
      }
    }
    if (lk == -1
     || lk == 33)                   // OPTIONS
    {
      switch (l1)
      {
      case 33:                      // OPTIONS
        whitespace();
        parse_subruleOptionsSpec();
        lookahead1W(16);            // WS | COMMENT^WS | COLON | '{'
        if (l1 == 55)               // '{'
        {
          whitespace();
          parse_ACTION();
        }
        lookahead1W(1);             // WS | COMMENT^WS | COLON
        consume(11);                // COLON
        break;
      default:
        whitespace();
        parse_ACTION();
        lookahead1W(1);             // WS | COMMENT^WS | COLON
        consume(11);                // COLON
      }
    }
    lookahead1W(56);                // WS | COMMENT^WS | TREE_BEGIN | LPAREN | RPAREN | BANG | OR | WILDCARD | NOT_OP |
                                    // CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF | 'exception' | '{'
    whitespace();
    parse_block();
    consume(10);                    // RPAREN
    lookahead1W(75);                // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | QUESTION | TREE_BEGIN | LPAREN | RPAREN |
                                    // STAR | PLUS | IMPLIES | SEMI | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL |
                                    // STRING_LITERAL | TOKEN_REF | RULE_REF | 'exception' | '{'
    switch (l1)
    {
    case 15:                        // IMPLIES
      consume(15);                  // IMPLIES
      break;
    default:
      if (l1 == 7                   // QUESTION
       || l1 == 12                  // STAR
       || l1 == 13)                 // PLUS
      {
        switch (l1)
        {
        case 7:                     // QUESTION
          consume(7);               // QUESTION
          break;
        case 12:                    // STAR
          consume(12);              // STAR
          break;
        default:
          consume(13);              // PLUS
        }
      }
      lookahead1W(63);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | 'exception' | '{'
      if (l1 == 18)                 // BANG
      {
        consume(18);                // BANG
      }
    }
    eventHandler.endNonterminal("ebnf", e0);
  }

  private void parse_ast_type_spec()
  {
    eventHandler.startNonterminal("ast_type_spec", e0);
    if (l1 == 17                    // CARET
     || l1 == 18)                   // BANG
    {
      switch (l1)
      {
      case 17:                      // CARET
        consume(17);                // CARET
        break;
      default:
        consume(18);                // BANG
      }
    }
    eventHandler.endNonterminal("ast_type_spec", e0);
  }

  private void parse_range()
  {
    eventHandler.startNonterminal("range", e0);
    switch (l1)
    {
    case 24:                        // CHAR_LITERAL
      consume(24);                  // CHAR_LITERAL
      lookahead1W(4);               // WS | COMMENT^WS | RANGE
      consume(21);                  // RANGE
      lookahead1W(5);               // WS | COMMENT^WS | CHAR_LITERAL
      consume(24);                  // CHAR_LITERAL
      lookahead1W(63);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | 'exception' | '{'
      if (l1 == 18)                 // BANG
      {
        consume(18);                // BANG
      }
      break;
    default:
      switch (l1)
      {
      case 29:                      // TOKEN_REF
        consume(29);                // TOKEN_REF
        break;
      default:
        consume(25);                // STRING_LITERAL
      }
      lookahead1W(4);               // WS | COMMENT^WS | RANGE
      consume(21);                  // RANGE
      lookahead1W(19);              // WS | COMMENT^WS | STRING_LITERAL | TOKEN_REF
      switch (l1)
      {
      case 29:                      // TOKEN_REF
        consume(29);                // TOKEN_REF
        break;
      default:
        consume(25);                // STRING_LITERAL
      }
      lookahead1W(67);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // CARET | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | 'exception' | '{'
      whitespace();
      parse_ast_type_spec();
    }
    eventHandler.endNonterminal("range", e0);
  }

  private void parse_terminal()
  {
    eventHandler.startNonterminal("terminal", e0);
    switch (l1)
    {
    case 24:                        // CHAR_LITERAL
      consume(24);                  // CHAR_LITERAL
      lookahead1W(63);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | 'exception' | '{'
      if (l1 == 18)                 // BANG
      {
        consume(18);                // BANG
      }
      break;
    case 29:                        // TOKEN_REF
      consume(29);                  // TOKEN_REF
      lookahead1W(72);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // CARET | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | '[' | 'exception' | '{'
      whitespace();
      parse_ast_type_spec();
      lookahead1W(65);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                    // '[' | 'exception' | '{'
      if (l1 == 41)                 // '['
      {
        whitespace();
        parse_ARG_ACTION();
      }
      break;
    case 25:                        // STRING_LITERAL
      consume(25);                  // STRING_LITERAL
      lookahead1W(67);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // CARET | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | 'exception' | '{'
      whitespace();
      parse_ast_type_spec();
      break;
    default:
      consume(20);                  // WILDCARD
      lookahead1W(67);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // CARET | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | 'exception' | '{'
      whitespace();
      parse_ast_type_spec();
    }
    eventHandler.endNonterminal("terminal", e0);
  }

  private void parse_notTerminal()
  {
    eventHandler.startNonterminal("notTerminal", e0);
    switch (l1)
    {
    case 24:                        // CHAR_LITERAL
      consume(24);                  // CHAR_LITERAL
      lookahead1W(63);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF |
                                    // RULE_REF | 'exception' | '{'
      if (l1 == 18)                 // BANG
      {
        consume(18);                // BANG
      }
      break;
    default:
      consume(29);                  // TOKEN_REF
      lookahead1W(67);              // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // CARET | BANG | OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL |
                                    // TOKEN_REF | RULE_REF | 'exception' | '{'
      whitespace();
      parse_ast_type_spec();
    }
    eventHandler.endNonterminal("notTerminal", e0);
  }

  private void parse_qualifiedID()
  {
    eventHandler.startNonterminal("qualifiedID", e0);
    parse_id();
    for (;;)
    {
      lookahead1W(24);              // WS | COMMENT^WS | CLOSE_ELEMENT_OPTION | SEMI | WILDCARD
      if (l1 != 20)                 // WILDCARD
      {
        break;
      }
      consume(20);                  // WILDCARD
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      whitespace();
      parse_id();
    }
    eventHandler.endNonterminal("qualifiedID", e0);
  }

  private void try_qualifiedID()
  {
    try_id();
    for (;;)
    {
      lookahead1W(24);              // WS | COMMENT^WS | CLOSE_ELEMENT_OPTION | SEMI | WILDCARD
      if (l1 != 20)                 // WILDCARD
      {
        break;
      }
      consumeT(20);                 // WILDCARD
      lookahead1W(21);              // WS | COMMENT^WS | TOKEN_REF | RULE_REF
      try_id();
    }
  }

  private void parse_id()
  {
    eventHandler.startNonterminal("id", e0);
    switch (l1)
    {
    case 29:                        // TOKEN_REF
      consume(29);                  // TOKEN_REF
      break;
    default:
      consume(30);                  // RULE_REF
    }
    eventHandler.endNonterminal("id", e0);
  }

  private void try_id()
  {
    switch (l1)
    {
    case 29:                        // TOKEN_REF
      consumeT(29);                 // TOKEN_REF
      break;
    default:
      consumeT(30);                 // RULE_REF
    }
  }

  private void parse_ACTION()
  {
    eventHandler.startNonterminal("ACTION", e0);
    parse_NESTED_ACTION();
    eventHandler.endNonterminal("ACTION", e0);
  }

  private void try_ACTION()
  {
    try_NESTED_ACTION();
  }

  private void parse_NESTED_ACTION()
  {
    eventHandler.startNonterminal("NESTED_ACTION", e0);
    consume(55);                    // '{'
    for (;;)
    {
      lookahead1(43);               // COMMENT | CHAR_LITERAL | STRING_LITERAL | CR | LF | ACTION_CHAR | '{' | '}'
      if (l1 == 56)                 // '}'
      {
        break;
      }
      switch (l1)
      {
      case 27:                      // CR
        consume(27);                // CR
        break;
      case 28:                      // LF
        consume(28);                // LF
        break;
      case 55:                      // '{'
        parse_NESTED_ACTION();
        break;
      case 24:                      // CHAR_LITERAL
        consume(24);                // CHAR_LITERAL
        break;
      case 2:                       // COMMENT
        consume(2);                 // COMMENT
        break;
      case 25:                      // STRING_LITERAL
        consume(25);                // STRING_LITERAL
        break;
      default:
        consume(35);                // ACTION_CHAR
      }
    }
    consume(56);                    // '}'
    eventHandler.endNonterminal("NESTED_ACTION", e0);
  }

  private void try_NESTED_ACTION()
  {
    consumeT(55);                   // '{'
    for (;;)
    {
      lookahead1(43);               // COMMENT | CHAR_LITERAL | STRING_LITERAL | CR | LF | ACTION_CHAR | '{' | '}'
      if (l1 == 56)                 // '}'
      {
        break;
      }
      switch (l1)
      {
      case 27:                      // CR
        consumeT(27);               // CR
        break;
      case 28:                      // LF
        consumeT(28);               // LF
        break;
      case 55:                      // '{'
        try_NESTED_ACTION();
        break;
      case 24:                      // CHAR_LITERAL
        consumeT(24);               // CHAR_LITERAL
        break;
      case 2:                       // COMMENT
        consumeT(2);                // COMMENT
        break;
      case 25:                      // STRING_LITERAL
        consumeT(25);               // STRING_LITERAL
        break;
      default:
        consumeT(35);               // ACTION_CHAR
      }
    }
    consumeT(56);                   // '}'
  }

  private void parse_ARG_ACTION()
  {
    eventHandler.startNonterminal("ARG_ACTION", e0);
    parse_NESTED_ARG_ACTION();
    eventHandler.endNonterminal("ARG_ACTION", e0);
  }

  private void parse_NESTED_ARG_ACTION()
  {
    eventHandler.startNonterminal("NESTED_ARG_ACTION", e0);
    consume(41);                    // '['
    for (;;)
    {
      lookahead1(40);               // CHAR_LITERAL | STRING_LITERAL | CR | LF | ARG_ACTION_CHAR | '[' | ']'
      if (l1 == 42)                 // ']'
      {
        break;
      }
      switch (l1)
      {
      case 41:                      // '['
        parse_NESTED_ARG_ACTION();
        break;
      case 27:                      // CR
        consume(27);                // CR
        break;
      case 28:                      // LF
        consume(28);                // LF
        break;
      case 24:                      // CHAR_LITERAL
        consume(24);                // CHAR_LITERAL
        break;
      case 25:                      // STRING_LITERAL
        consume(25);                // STRING_LITERAL
        break;
      default:
        consume(36);                // ARG_ACTION_CHAR
      }
    }
    consume(42);                    // ']'
    eventHandler.endNonterminal("NESTED_ARG_ACTION", e0);
  }

  private void parse_ACTION_OR_SEMPRED()
  {
    eventHandler.startNonterminal("ACTION_OR_SEMPRED", e0);
    parse_ACTION();
    lookahead1W(64);                // WS | COMMENT^WS | OPEN_ELEMENT_OPTION | TREE_BEGIN | LPAREN | RPAREN | SEMI |
                                    // OR | WILDCARD | NOT_OP | CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                    // '?' | 'exception' | '{'
    if (l1 == 37)                   // '?'
    {
      consume(37);                  // '?'
    }
    eventHandler.endNonterminal("ACTION_OR_SEMPRED", e0);
  }

  private void consume(int t)
  {
    if (l1 == t)
    {
      whitespace();
      eventHandler.terminal(TOKEN[l1], b1, e1);
      b0 = b1; e0 = e1; l1 = l2; if (l1 != 0) {
      b1 = b2; e1 = e2; l2 = 0; }
    }
    else
    {
      error(b1, e1, 0, l1, t);
    }
  }

  private void consumeT(int t)
  {
    if (l1 == t)
    {
      b0 = b1; e0 = e1; l1 = l2; if (l1 != 0) {
      b1 = b2; e1 = e2; l2 = 0; }
    }
    else
    {
      error(b1, e1, 0, l1, t);
    }
  }

  private void whitespace()
  {
    if (e0 != b1)
    {
      eventHandler.whitespace(e0, b1);
      e0 = b1;
    }
  }

  private int matchW(int tokenSetId)
  {
    int code;
    for (;;)
    {
      code = match(tokenSetId);
      if (code != 1                 // WS
       && code != 3)                // COMMENT^WS
      {
        break;
      }
    }
    return code;
  }

  private void lookahead1W(int tokenSetId)
  {
    if (l1 == 0)
    {
      l1 = matchW(tokenSetId);
      b1 = begin;
      e1 = end;
    }
  }

  private void lookahead2W(int tokenSetId)
  {
    if (l2 == 0)
    {
      l2 = matchW(tokenSetId);
      b2 = begin;
      e2 = end;
    }
    lk = (l2 << 6) | l1;
  }

  private void lookahead1(int tokenSetId)
  {
    if (l1 == 0)
    {
      l1 = match(tokenSetId);
      b1 = begin;
      e1 = end;
    }
  }

  private void lookahead2(int tokenSetId)
  {
    if (l2 == 0)
    {
      l2 = match(tokenSetId);
      b2 = begin;
      e2 = end;
    }
    lk = (l2 << 6) | l1;
  }

  private int error(int b, int e, int s, int l, int t)
  {
    if (e >= ex)
    {
      bx = b;
      ex = e;
      sx = s;
      lx = l;
      tx = t;
    }
    throw new ParseException(bx, ex, sx, lx, tx);
  }

  private void memoize(int i, int e, int v)
  {
    memo.put((e << 1) + i, v);
  }

  private int memoized(int i, int e)
  {
    Integer v = memo.get((e << 1) + i);
    return v == null ? 0 : v;
  }

  private int lk, b0, e0;
  private int l1, b1, e1;
  private int l2, b2, e2;
  private int bx, ex, sx, lx, tx;
  private EventHandler eventHandler = null;
  private java.util.Map<Integer, Integer> memo = new java.util.HashMap<Integer, Integer>();
  private CharSequence input = null;
  private int size = 0;
  private int begin = 0;
  private int end = 0;

  private int match(int tokenSetId)
  {
    begin = end;
    int current = end;
    int result = INITIAL[tokenSetId];
    int state = 0;

    for (int code = result & 255; code != 0; )
    {
      int charclass;
      int c0 = current < size ? input.charAt(current) : 0;
      ++current;
      if (c0 < 0x80)
      {
        charclass = MAP0[c0];
      }
      else if (c0 < 0xd800)
      {
        int c1 = c0 >> 5;
        charclass = MAP1[(c0 & 31) + MAP1[(c1 & 31) + MAP1[c1 >> 5]]];
      }
      else
      {
        if (c0 < 0xdc00)
        {
          int c1 = current < size ? input.charAt(current) : 0;
          if (c1 >= 0xdc00 && c1 < 0xe000)
          {
            ++current;
            c0 = ((c0 & 0x3ff) << 10) + (c1 & 0x3ff) + 0x10000;
          }
        }

        int lo = 0, hi = 1;
        for (int m = 1; ; m = (hi + lo) >> 1)
        {
          if (MAP2[m] > c0) {hi = m - 1;}
          else if (MAP2[2 + m] < c0) {lo = m + 1;}
          else {charclass = MAP2[4 + m]; break;}
          if (lo > hi) {charclass = 0; break;}
        }
      }

      state = code;
      int i0 = (charclass << 8) + code - 1;
      code = TRANSITION[(i0 & 7) + TRANSITION[i0 >> 3]];

      if (code > 255)
      {
        result = code;
        code &= 255;
        end = current;
      }
    }

    result >>= 8;
    if (result == 0)
    {
      end = current - 1;
      int c1 = end < size ? input.charAt(end) : 0;
      if (c1 >= 0xdc00 && c1 < 0xe000)
      {
        --end;
      }
      return error(begin, end, state, -1, -1);
    }

    if (end > size) end = size;
    return (result & 63) - 1;
  }

  private static String[] getTokenSet(int tokenSetId)
  {
    java.util.ArrayList<String> expected = new java.util.ArrayList<>();
    int s = tokenSetId < 0 ? - tokenSetId : INITIAL[tokenSetId] & 255;
    for (int i = 0; i < 57; i += 32)
    {
      int j = i;
      int i0 = (i >> 5) * 245 + s - 1;
      int f = EXPECTED[(i0 & 3) + EXPECTED[i0 >> 2]];
      for ( ; f != 0; f >>>= 1, ++j)
      {
        if ((f & 1) != 0)
        {
          expected.add(TOKEN[j]);
        }
      }
    }
    return expected.toArray(new String[]{});
  }

  private static final int[] MAP0 =
  {
    /*   0 */ 62, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 5,
    /*  35 */ 6, 7, 7, 7, 8, 9, 10, 11, 12, 13, 7, 14, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 20, 21, 22, 23,
    /*  63 */ 24, 7, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 26, 26, 26, 28, 26, 26, 26, 29, 26, 30, 26, 26, 26,
    /*  90 */ 26, 31, 32, 33, 34, 35, 7, 36, 37, 38, 39, 40, 41, 42, 43, 44, 42, 45, 46, 42, 47, 48, 49, 42, 50, 51, 52,
    /* 117 */ 53, 54, 55, 56, 57, 42, 58, 59, 60, 61, 7
  };

  private static final int[] MAP1 =
  {
    /*   0 */ 54, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
    /*  26 */ 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
    /*  52 */ 58, 58, 90, 122, 216, 154, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185,
    /*  74 */ 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 62, 0, 0, 0, 0, 0, 0, 0,
    /*  98 */ 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 5, 6, 7, 7, 7, 8, 9, 10, 11,
    /* 133 */ 12, 13, 7, 14, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 20, 21, 22, 23, 24, 7, 36, 37, 38, 39, 40,
    /* 160 */ 41, 42, 43, 44, 42, 45, 46, 42, 47, 48, 49, 42, 50, 51, 52, 53, 54, 55, 56, 57, 42, 58, 59, 60, 61, 7, 7,
    /* 187 */ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 25, 25, 25, 25,
    /* 221 */ 25, 25, 26, 26, 26, 26, 26, 27, 26, 26, 26, 28, 26, 26, 26, 29, 26, 30, 26, 26, 26, 26, 31, 32, 33, 34,
    /* 247 */ 35
  };

  private static final int[] MAP2 =
  {
    /* 0 */ 57344, 65536, 65533, 1114111, 7, 7
  };

  private static final int[] INITIAL =
  {
    /*  0 */ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
    /* 29 */ 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
    /* 56 */ 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78
  };

  private static final int[] TRANSITION =
  {
    /*    0 */ 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782,
    /*   17 */ 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 2020, 2020,
    /*   34 */ 2020, 2020, 2020, 2016, 2020, 2020, 2020, 2022, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763,
    /*   51 */ 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3288, 2187, 3826, 3276, 3287, 3782, 2020, 2020, 2020, 2020,
    /*   68 */ 2020, 2040, 2020, 2020, 2020, 2021, 3871, 3782, 3782, 2357, 3131, 3781, 2048, 3780, 2763, 2155, 3782,
    /*   85 */ 3124, 3782, 3782, 3782, 3782, 3288, 2187, 3826, 3812, 3287, 3782, 2062, 2062, 2062, 2062, 2062, 2058,
    /*  102 */ 2062, 2062, 2062, 2064, 3871, 3782, 3782, 2357, 3131, 3781, 2048, 3780, 2763, 2155, 3782, 3124, 3782,
    /*  119 */ 3782, 3782, 3782, 3288, 2187, 3826, 3812, 3287, 3782, 3782, 3782, 3782, 3782, 3782, 2072, 3782, 3411,
    /*  136 */ 3405, 3408, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782,
    /*  153 */ 3782, 3782, 3782, 3782, 3276, 3287, 3782, 2050, 3782, 2094, 3129, 2403, 2089, 2400, 2116, 2120, 2122,
    /*  170 */ 2130, 3782, 3782, 2318, 2141, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782,
    /*  187 */ 3782, 3782, 3276, 3287, 3782, 3782, 3782, 3782, 3782, 3782, 2151, 2475, 2164, 2168, 2170, 3871, 3782,
    /*  204 */ 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782,
    /*  221 */ 3276, 3287, 3782, 3782, 3782, 3782, 3782, 3782, 2151, 3782, 3782, 3782, 3782, 3871, 3782, 3782, 2318,
    /*  238 */ 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287,
    /*  255 */ 3782, 2133, 3782, 3782, 3563, 2081, 2178, 2078, 2195, 2199, 2201, 3130, 3782, 3782, 2329, 2209, 3781,
    /*  272 */ 2030, 3844, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 3782,
    /*  289 */ 2346, 3782, 2713, 3782, 2219, 2707, 2236, 2240, 2242, 3871, 3782, 3782, 2250, 3131, 3781, 2030, 3780,
    /*  306 */ 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 2283, 3782, 3782,
    /*  323 */ 3829, 3782, 2151, 2108, 2292, 2296, 2298, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155,
    /*  340 */ 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 3782, 3782, 3782, 3782, 3782,
    /*  357 */ 2151, 3782, 3782, 3782, 2813, 3871, 2183, 2156, 2414, 3131, 2306, 2315, 2326, 2730, 3848, 3782, 2758,
    /*  374 */ 3782, 3782, 3782, 3782, 3782, 3782, 3282, 2337, 2345, 3782, 3782, 3782, 3782, 3782, 3782, 2151, 3782,
    /*  391 */ 3782, 3782, 3162, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782,
    /*  408 */ 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 3782, 3782, 3782, 3565, 3782, 2151, 3782, 3782, 3782,
    /*  425 */ 3782, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782,
    /*  442 */ 3782, 3782, 3782, 3276, 3287, 3782, 2767, 3782, 3782, 2354, 3623, 2365, 3620, 2382, 2386, 2394, 2411,
    /*  459 */ 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782,
    /*  476 */ 3782, 3276, 3287, 3782, 2454, 2454, 2454, 2422, 2455, 2432, 2447, 2424, 2454, 2439, 3871, 2104, 2224,
    /*  493 */ 2318, 3131, 3781, 2030, 2782, 2780, 3166, 3782, 3087, 3782, 3782, 3782, 3782, 2284, 2734, 2463, 3819,
    /*  510 */ 3828, 3782, 3782, 3782, 3782, 3782, 2969, 2151, 3782, 3782, 3782, 3782, 2483, 3667, 2495, 3143, 2508,
    /*  527 */ 2520, 2530, 3337, 2370, 3446, 3261, 3124, 3514, 3765, 2521, 3386, 3512, 2536, 3996, 3805, 2544, 3782,
    /*  544 */ 3782, 3782, 3782, 3782, 2969, 2151, 3782, 3782, 3782, 3782, 2483, 3667, 2495, 3143, 2553, 2520, 2530,
    /*  561 */ 3337, 2370, 3446, 3261, 3124, 3514, 3765, 2521, 3386, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3782,
    /*  578 */ 3782, 3782, 2969, 2151, 3782, 3782, 3782, 3782, 2483, 3667, 2495, 3143, 3131, 2520, 2530, 3119, 2370,
    /*  595 */ 3446, 3261, 3124, 3514, 3765, 2521, 3386, 3512, 2536, 3996, 3805, 2544, 3782, 2835, 3782, 2836, 2211,
    /*  612 */ 2833, 2564, 3782, 2835, 2827, 2568, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782,
    /*  629 */ 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 2580, 2556, 2576, 2592, 3782, 2151,
    /*  646 */ 2651, 2597, 2605, 2607, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782,
    /*  663 */ 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 3782, 2511, 2307, 3782, 3782, 2151, 3782, 2512,
    /*  680 */ 2615, 2617, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782,
    /*  697 */ 3782, 3782, 3782, 3782, 3276, 3287, 3782, 2966, 3782, 2837, 3782, 3782, 2151, 3782, 3782, 3782, 2625,
    /*  714 */ 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782,
    /*  731 */ 3782, 3782, 3276, 3287, 3782, 3782, 2143, 3782, 2650, 3782, 2151, 3782, 3782, 3782, 3782, 3871, 3782,
    /*  748 */ 3782, 2228, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782,
    /*  765 */ 3276, 3287, 3782, 3782, 3782, 3782, 3782, 3782, 2151, 3782, 3782, 2659, 2795, 3871, 3782, 3782, 2318,
    /*  782 */ 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287,
    /*  799 */ 3782, 3782, 3782, 2487, 2863, 2673, 2668, 3028, 3029, 3029, 3426, 2483, 3667, 3732, 3143, 3131, 2520,
    /*  816 */ 2530, 3119, 2370, 3446, 3261, 3124, 3514, 3765, 2521, 3386, 3512, 2536, 3996, 3805, 2544, 3782, 3782,
    /*  833 */ 3782, 2487, 2863, 2673, 2668, 3028, 3029, 3029, 3426, 2483, 3667, 3732, 3143, 3131, 2520, 2530, 2271,
    /*  850 */ 2370, 3446, 2545, 3124, 3514, 2545, 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3783, 3782, 2487,
    /*  867 */ 2863, 2673, 2668, 3028, 3029, 3029, 3426, 2483, 3667, 3732, 3143, 3131, 2520, 2530, 2271, 2370, 3446,
    /*  884 */ 2545, 3124, 3514, 2545, 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 2681, 2487, 2863, 2673,
    /*  901 */ 2668, 3028, 3029, 3029, 3426, 2483, 3667, 3732, 3143, 3131, 2520, 2530, 2271, 2370, 3446, 3104, 3124,
    /*  918 */ 3514, 2545, 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3722, 2487, 2863, 2673, 2668, 3028,
    /*  935 */ 3029, 3029, 3426, 2483, 3667, 3732, 3143, 3131, 2520, 2530, 2271, 2370, 3446, 2545, 3124, 3514, 2545,
    /*  952 */ 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3782, 2487, 2863, 2673, 2668, 3028, 3029, 3029,
    /*  969 */ 3426, 2483, 3667, 3732, 3143, 3131, 2520, 2530, 2271, 2370, 3446, 2545, 3124, 2690, 2545, 2521, 2533,
    /*  986 */ 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3082, 3782, 3782, 3782, 2701, 3782, 2725, 2745, 2742, 3871,
    /* 1003 */ 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782,
    /* 1020 */ 3782, 3276, 3287, 3782, 3782, 3782, 3782, 3782, 3782, 2151, 3782, 3782, 3782, 3782, 2753, 3782, 3782,
    /* 1037 */ 2318, 2775, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276,
    /* 1054 */ 3287, 3782, 3782, 3782, 3782, 3782, 3782, 2790, 3782, 3782, 3782, 3782, 3871, 3782, 3782, 2318, 3131,
    /* 1071 */ 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782,
    /* 1088 */ 3782, 3782, 3782, 3782, 3782, 2151, 3782, 2808, 3492, 2821, 3871, 3782, 3782, 2318, 3131, 3781, 2030,
    /* 1105 */ 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 3782, 3782,
    /* 1122 */ 3782, 3782, 3782, 2151, 3782, 3782, 3782, 3782, 2483, 3667, 3732, 3143, 3131, 2520, 2530, 2271, 2370,
    /* 1139 */ 3446, 2545, 3124, 3514, 2545, 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3782, 3669, 3670,
    /* 1156 */ 2522, 2845, 3054, 3055, 3055, 3102, 2857, 3688, 3732, 2876, 2900, 2921, 2934, 3119, 2370, 3446, 3261,
    /* 1173 */ 3124, 3302, 2943, 2951, 2960, 3512, 3217, 3996, 3805, 2977, 3782, 3782, 3782, 3669, 3670, 2522, 2845,
    /* 1190 */ 3054, 3055, 3055, 3102, 2483, 3667, 3732, 3143, 3872, 2988, 2530, 3119, 2370, 3446, 3261, 3124, 3514,
    /* 1207 */ 3765, 2521, 3386, 3512, 2536, 3945, 3805, 2544, 3782, 3782, 3782, 3367, 3368, 2257, 2996, 2264, 3257,
    /* 1224 */ 3055, 3102, 2483, 3667, 3732, 3143, 3131, 2520, 3004, 3119, 2631, 2926, 3157, 3124, 3514, 3765, 2374,
    /* 1241 */ 3386, 3051, 2536, 3996, 3805, 2544, 3782, 3782, 3782, 3669, 3670, 2522, 2845, 3054, 3055, 3055, 3102,
    /* 1258 */ 2483, 3667, 3732, 3143, 3131, 2520, 2530, 3119, 2370, 3884, 3261, 3124, 3514, 3322, 2521, 3386, 3512,
    /* 1275 */ 2536, 4000, 3805, 2544, 3782, 3782, 2099, 2469, 3670, 2522, 2845, 2637, 3012, 2642, 3014, 3022, 3203,
    /* 1292 */ 3037, 3143, 3487, 2520, 2530, 3189, 3063, 3446, 3075, 3124, 3707, 3765, 2521, 3386, 3756, 2980, 3973,
    /* 1309 */ 3805, 2544, 3782, 3782, 3782, 3669, 3670, 2522, 2845, 3054, 3055, 3055, 3102, 2483, 3667, 3732, 3143,
    /* 1326 */ 3872, 2520, 2530, 3119, 2370, 3446, 3261, 3124, 3514, 3765, 2521, 3386, 3512, 2536, 3996, 3805, 2544,
    /* 1343 */ 3782, 3782, 3782, 3669, 3670, 2522, 2845, 3054, 3055, 3055, 3102, 2483, 3667, 3732, 3143, 3131, 2520,
    /* 1360 */ 2530, 2271, 2370, 3446, 2545, 3124, 3514, 2545, 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782,
    /* 1377 */ 3782, 3669, 3670, 2522, 2845, 3100, 3055, 3055, 3102, 2483, 3244, 3732, 3143, 3131, 2520, 2530, 2271,
    /* 1394 */ 2370, 3446, 2545, 2868, 3514, 3400, 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3782, 3669,
    /* 1411 */ 3670, 2522, 2845, 3054, 3055, 3055, 3102, 2483, 3667, 3732, 3143, 3131, 3112, 2530, 2271, 3727, 3446,
    /* 1428 */ 3664, 3124, 2500, 2545, 2521, 2533, 3512, 3139, 3996, 3805, 2544, 3782, 3782, 3782, 3669, 3670, 2522,
    /* 1445 */ 2845, 3054, 3055, 3055, 3102, 2483, 3667, 3732, 3143, 3131, 2520, 3151, 2271, 2370, 3446, 2545, 3124,
    /* 1462 */ 3514, 2545, 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3782, 2274, 2275, 2952, 3174, 3182,
    /* 1479 */ 3761, 3055, 3102, 2483, 3365, 3702, 2913, 3131, 2520, 2530, 2271, 2370, 3197, 2545, 3432, 2849, 2545,
    /* 1496 */ 2521, 2533, 3512, 2536, 3996, 3805, 3214, 3782, 3782, 3782, 3669, 3670, 2522, 2845, 3054, 3055, 3055,
    /* 1513 */ 3102, 2483, 3667, 3732, 3143, 3872, 2520, 2530, 2271, 2370, 3446, 2545, 3225, 3514, 3241, 3252, 2888,
    /* 1530 */ 3512, 2536, 3996, 3269, 2544, 3782, 3782, 3782, 3669, 3206, 3296, 3313, 3318, 3635, 3055, 3102, 2483,
    /* 1547 */ 3667, 3527, 3143, 3131, 3330, 2530, 2271, 3342, 3446, 2545, 3742, 3514, 3685, 3442, 2533, 3512, 2536,
    /* 1564 */ 3992, 3805, 2544, 3782, 3782, 3782, 3669, 3670, 3541, 3350, 3358, 2939, 3055, 3102, 2483, 2892, 3732,
    /* 1581 */ 3376, 3131, 2520, 2530, 2271, 2370, 3446, 2545, 3124, 3514, 3602, 2521, 2533, 3512, 2536, 3996, 3805,
    /* 1598 */ 2544, 3782, 3782, 3782, 3669, 3670, 3898, 3394, 3054, 3055, 3055, 3102, 3419, 3667, 2883, 3143, 3454,
    /* 1615 */ 3468, 2530, 2271, 3092, 3446, 2693, 3124, 3556, 3305, 2521, 3480, 3512, 2536, 3996, 3798, 3500, 3782,
    /* 1632 */ 3782, 3782, 3669, 3670, 2522, 2845, 3054, 3055, 3055, 3102, 2483, 3667, 3732, 3143, 3131, 2520, 2530,
    /* 1649 */ 3044, 3522, 3978, 2545, 3535, 3472, 2545, 3383, 3904, 3549, 3573, 3996, 3805, 2544, 3782, 3782, 3782,
    /* 1666 */ 3669, 3670, 3581, 3596, 3631, 3055, 3055, 3102, 2483, 3667, 3732, 3143, 3643, 3657, 3678, 3696, 2370,
    /* 1683 */ 3715, 2545, 3124, 3514, 2545, 3067, 3737, 3649, 2536, 3996, 3805, 2544, 3782, 3782, 3782, 3669, 3670,
    /* 1700 */ 2522, 2845, 3054, 3055, 3055, 3102, 2483, 3667, 2907, 3143, 3750, 2520, 2530, 2271, 2370, 3773, 2545,
    /* 1717 */ 3124, 3514, 2545, 2521, 2533, 3512, 2536, 3996, 3791, 2544, 3782, 3782, 3782, 3669, 3670, 2522, 2845,
    /* 1734 */ 3054, 3055, 3055, 3102, 2483, 3667, 3732, 3143, 3131, 2520, 2530, 2271, 2370, 3837, 2545, 3124, 3514,
    /* 1751 */ 2545, 2521, 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3782, 3669, 3670, 2522, 2845, 3054, 3055,
    /* 1768 */ 3055, 3102, 2483, 3667, 3732, 3143, 3872, 2520, 2530, 2271, 2370, 3446, 2545, 2800, 3514, 2545, 2521,
    /* 1785 */ 2533, 3512, 2536, 3996, 3805, 2544, 3782, 3782, 3782, 3669, 3670, 2522, 2845, 3054, 3055, 3055, 3102,
    /* 1802 */ 3856, 3667, 3732, 3864, 3588, 2520, 3880, 2271, 2370, 3446, 2545, 3124, 3514, 2545, 2521, 2533, 3512,
    /* 1819 */ 2536, 3996, 3805, 2544, 3782, 3782, 3782, 3669, 3670, 2522, 2845, 3054, 3055, 3055, 3102, 2483, 3667,
    /* 1836 */ 3732, 3143, 3131, 2520, 2530, 2271, 2370, 3446, 2545, 3124, 3514, 2545, 2521, 2533, 3512, 2536, 3996,
    /* 1853 */ 3805, 3892, 3782, 3782, 2717, 3921, 2715, 3918, 3912, 3929, 3929, 3929, 3931, 3871, 3782, 3782, 2318,
    /* 1870 */ 3131, 3781, 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 2032, 2584, 3939, 3276, 3287,
    /* 1887 */ 3782, 3782, 3782, 3614, 3608, 3782, 2151, 2660, 3953, 3957, 3959, 3871, 3782, 3782, 2318, 3131, 3781,
    /* 1904 */ 2030, 3780, 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 3782,
    /* 1921 */ 3782, 3782, 3437, 3506, 3967, 3782, 3782, 3782, 3782, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780,
    /* 1938 */ 2763, 2155, 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 3782, 3782, 3782,
    /* 1955 */ 3782, 3782, 3986, 3460, 4008, 4012, 4014, 3871, 3782, 3782, 2318, 3131, 3781, 2030, 3780, 2763, 2155,
    /* 1972 */ 3782, 3124, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3276, 3287, 3782, 3782, 3782, 3782, 3782, 2682,
    /* 1989 */ 3782, 3233, 3230, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782,
    /* 2006 */ 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 3782, 9472, 512, 512, 9216, 512, 512, 512, 512,
    /* 2024 */ 512, 512, 512, 512, 0, 0, 129, 130, 0, 0, 0, 0, 0, 0, 0, 8960, 7424, 512, 512, 7424, 512, 512, 512, 512,
    /* 2048 */ 129, 768, 0, 0, 0, 0, 0, 0, 83, 0, 7168, 591, 591, 7168, 591, 591, 591, 591, 591, 591, 591, 591, 0, 0,
    /* 2072 */ 9472, 0, 0, 9216, 0, 4864, 0, 0, 82, 0, 82, 0, 0, 82, 82, 0, 0, 9555, 0, 0, 9299, 83, 0, 0, 0, 83, 83, 0,
    /* 2100 */ 0, 0, 87, 0, 0, 0, 0, 111, 0, 0, 0, 0, 2816, 0, 0, 2816, 83, 83, 83, 0, 83, 83, 83, 83, 83, 83, 83, 83,
    /* 2128 */ 0, 0, 0, 112, 6656, 0, 0, 0, 0, 0, 82, 0, 0, 112, 6739, 0, 0, 0, 0, 0, 0, 1536, 0, 9472, 0, 0, 9216, 0,
    /* 2156 */ 0, 0, 0, 129, 0, 0, 0, 0, 105, 105, 105, 0, 105, 105, 105, 105, 105, 105, 105, 105, 0, 0, 9554, 0, 0,
    /* 2181 */ 9298, 82, 0, 0, 0, 121, 0, 0, 0, 0, 221, 0, 0, 0, 82, 82, 82, 0, 82, 82, 82, 82, 82, 82, 82, 82, 0, 0,
    /* 2209 */ 6512, 83, 0, 0, 0, 0, 0, 0, 3072, 0, 9472, 0, 0, 9216, 2560, 0, 0, 0, 130, 0, 0, 0, 0, 4096, 110, 111, 0,
    /* 2236 */ 2560, 2560, 2560, 0, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 0, 0, 2304, 0, 0, 0, 0, 110, 111, 0,
    /* 2258 */ 0, 8032, 0, 8025, 8025, 8025, 90, 8025, 8025, 8025, 8025, 8037, 8044, 8025, 110, 0, 0, 0, 0, 0, 0, 8025,
    /* 2280 */ 91, 0, 0, 2816, 0, 0, 0, 0, 0, 0, 0, 226, 2816, 0, 0, 0, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816,
    /* 2304 */ 0, 0, 148, 0, 0, 0, 0, 0, 0, 0, 1280, 157, 130, 0, 0, 0, 0, 0, 0, 110, 111, 0, 0, 138, 0, 0, 0, 0, 0, 0,
    /* 2334 */ 110, 111, 6400, 240, 234, 0, 0, 241, 238, 0, 240, 241, 0, 0, 0, 0, 0, 0, 0, 2560, 5376, 0, 81, 0, 0, 0,
    /* 2360 */ 0, 0, 110, 1024, 0, 9472, 0, 0, 9216, 5376, 0, 0, 0, 172, 0, 0, 0, 8025, 0, 8025, 8150, 13657, 5376,
    /* 2383 */ 5376, 5376, 0, 5376, 5376, 5376, 5376, 5457, 5376, 5376, 5457, 5376, 5376, 5457, 5376, 5457, 5457, 0, 0,
    /* 2402 */ 83, 0, 83, 0, 0, 83, 83, 0, 0, 5632, 112, 83, 0, 0, 0, 0, 0, 138, 111, 0, 80, 80, 80, 80, 80, 92, 80, 80,
    /* 2430 */ 80, 80, 9472, 80, 92, 9316, 80, 80, 92, 80, 80, 80, 80, 80, 80, 0, 111, 92, 92, 80, 92, 80, 92, 92, 80,
    /* 2455 */ 80, 80, 80, 80, 80, 80, 80, 92, 226, 234, 230, 0, 0, 238, 0, 0, 87, 0, 0, 8025, 0, 0, 105, 0, 105, 0, 0,
    /* 2482 */ 105, 0, 112, 83, 0, 0, 0, 0, 7768, 0, 7768, 0, 0, 0, 7010, 8025, 0, 8025, 8025, 0, 8025, 8025, 8136,
    /* 2505 */ 8025, 8025, 0, 139, 83, 0, 0, 0, 0, 0, 0, 1280, 0, 0, 1280, 110, 0, 0, 0, 8025, 0, 8025, 8025, 8025, 0,
    /* 2530 */ 129, 130, 8025, 8025, 0, 8025, 8025, 8025, 0, 0, 0, 8025, 8025, 8025, 237, 8025, 8025, 8025, 8025, 0, 0,
    /* 2551 */ 0, 0, 140, 83, 0, 0, 0, 0, 0, 0, 4352, 4352, 4352, 9472, 3072, 0, 9216, 0, 3072, 0, 0, 3072, 3072, 0, 0,
    /* 2576 */ 0, 4352, 4352, 0, 0, 0, 0, 4352, 0, 0, 0, 0, 8704, 0, 0, 0, 4352, 0, 4352, 0, 0, 0, 0, 4352, 0, 4352,
    /* 2602 */ 4352, 0, 4352, 4352, 4352, 4352, 4352, 4352, 4352, 4352, 4352, 0, 0, 1280, 1280, 1280, 1280, 1280, 1280,
    /* 2621 */ 1280, 1280, 0, 0, 0, 3840, 0, 109, 0, 3840, 0, 0, 171, 172, 0, 175, 0, 8025, 8025, 8025, 8025, 8043,
    /* 2643 */ 8043, 8043, 8043, 8043, 8043, 8043, 8043, 1536, 0, 0, 0, 0, 0, 0, 0, 4352, 9728, 0, 0, 0, 0, 0, 0, 0,
    /* 2667 */ 5120, 9472, 0, 7768, 9216, 7768, 0, 7768, 7768, 0, 7768, 7768, 7768, 0, 85, 0, 0, 0, 0, 0, 0, 0, 8192,
    /* 2690 */ 8132, 0, 8025, 8025, 8025, 8025, 8025, 0, 9984, 0, 0, 10752, 10752, 0, 9216, 0, 10752, 0, 0, 2560, 0,
    /* 2711 */ 2560, 0, 0, 2560, 0, 0, 0, 0, 0, 0, 14336, 0, 0, 0, 0, 10752, 0, 10752, 0, 0, 0, 0, 173, 0, 0, 0, 0, 230,
    /* 2739 */ 0, 0, 0, 10752, 10752, 10752, 0, 10752, 10752, 0, 0, 10752, 10752, 0, 0, 113, 114, 0, 0, 0, 0, 0, 173,
    /* 2762 */ 173, 0, 0, 0, 172, 0, 0, 0, 0, 81, 0, 0, 0, 112, 114, 0, 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 0, 11008, 0,
    /* 2792 */ 0, 9216, 0, 0, 0, 0, 2048, 0, 0, 0, 0, 172, 172, 0, 0, 195, 0, 4608, 0, 0, 0, 0, 0, 0, 3328, 0, 0, 0,
    /* 2820 */ 110, 4608, 0, 4608, 0, 4608, 4608, 0, 0, 3072, 0, 0, 0, 3072, 0, 0, 3072, 0, 0, 0, 0, 0, 0, 0, 3840,
    /* 2845 */ 9472, 0, 8025, 9216, 8025, 0, 8025, 8025, 8025, 8025, 8137, 0, 0, 112, 83, 0, 116, 0, 0, 7768, 0, 7768,
    /* 2867 */ 7768, 0, 0, 0, 172, 172, 0, 11264, 0, 0, 8025, 8025, 8073, 0, 110, 111, 0, 0, 8063, 0, 8025, 8025, 0,
    /* 2890 */ 8025, 8153, 8025, 0, 0, 0, 122, 0, 0, 8025, 112, 83, 0, 0, 0, 0, 146, 0, 0, 8064, 0, 8025, 8025, 0, 8025,
    /* 2915 */ 8025, 8067, 0, 110, 111, 0, 110, 0, 0, 0, 8088, 0, 8025, 8025, 8025, 129, 8025, 8119, 0, 129, 130, 8094,
    /* 2937 */ 8025, 160, 8025, 8025, 8025, 8035, 8025, 8025, 8025, 8025, 206, 0, 207, 0, 209, 0, 0, 8025, 0, 8025,
    /* 2957 */ 8025, 8025, 91, 8151, 0, 8025, 8025, 8025, 112, 0, 0, 3840, 0, 0, 0, 0, 0, 7010, 0, 0, 237, 8025, 8180,
    /* 2980 */ 8025, 8025, 0, 0, 0, 8025, 8168, 8025, 110, 0, 0, 0, 8025, 0, 8025, 8092, 9472, 0, 8025, 9216, 8025, 0,
    /* 3002 */ 8025, 8037, 129, 130, 8025, 8025, 0, 8025, 8025, 8099, 8043, 8025, 8043, 8043, 8043, 8043, 8043, 8043, 0,
    /* 3021 */ 0, 0, 112, 83, 115, 0, 0, 0, 7768, 7768, 7768, 7768, 7768, 7768, 7768, 7768, 126, 0, 8025, 0, 8025, 8068,
    /* 3043 */ 133, 8025, 110, 0, 0, 0, 0, 167, 0, 0, 8158, 0, 8025, 8025, 8025, 8025, 8025, 8025, 8025, 8025, 169, 0,
    /* 3065 */ 0, 172, 0, 0, 0, 8025, 0, 8149, 8025, 8025, 8121, 8025, 8123, 8025, 189, 0, 190, 0, 0, 10752, 0, 0, 0, 0,
    /* 3089 */ 0, 172, 8448, 0, 0, 0, 172, 0, 0, 0, 8113, 103, 8025, 8025, 8025, 8025, 8025, 8025, 8025, 0, 0, 0, 191,
    /* 3112 */ 110, 0, 0, 0, 8025, 0, 8090, 8025, 110, 0, 0, 165, 0, 0, 0, 172, 172, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0,
    /* 3139 */ 8025, 8164, 0, 0, 0, 8025, 8025, 8025, 0, 110, 111, 0, 129, 130, 8025, 8025, 0, 8097, 8025, 8025, 8025,
    /* 3160 */ 8124, 189, 0, 0, 0, 3584, 0, 0, 0, 0, 768, 0, 0, 0, 9472, 0, 8025, 9216, 8025, 0, 8025, 8038, 91, 8025,
    /* 3184 */ 8025, 8025, 8025, 8038, 8038, 8025, 110, 0, 0, 165, 166, 0, 168, 0, 8025, 8025, 8117, 129, 8025, 8025, 0,
    /* 3205 */ 120, 0, 0, 0, 0, 8025, 0, 93, 0, 237, 8179, 8025, 8025, 8025, 0, 0, 0, 8167, 8025, 8025, 192, 0, 0, 172,
    /* 3229 */ 172, 0, 0, 0, 8192, 0, 0, 0, 0, 8192, 8192, 0, 8139, 8025, 8025, 8025, 0, 0, 0, 0, 0, 124, 8061, 0, 210,
    /* 3254 */ 0, 8025, 212, 8025, 8025, 8025, 8044, 8025, 8025, 8025, 8025, 189, 0, 0, 0, 233, 234, 12121, 0, 237, 238,
    /* 3275 */ 8025, 233, 234, 0, 0, 237, 238, 0, 233, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0, 0, 225, 93, 0, 8025, 93, 8025,
    /* 3301 */ 8025, 8025, 0, 8134, 8025, 8025, 8025, 8025, 0, 10240, 0, 0, 9472, 93, 8025, 9216, 8025, 93, 8025, 8025,
    /* 3321 */ 8042, 8025, 8025, 8025, 8025, 206, 0, 0, 208, 110, 0, 0, 0, 8025, 0, 8091, 8025, 110, 140, 112, 165, 0,
    /* 3343 */ 0, 0, 172, 0, 0, 176, 8025, 9472, 0, 8035, 9216, 8025, 0, 8035, 8035, 0, 8035, 8025, 8035, 8025, 8035,
    /* 3364 */ 8035, 8025, 119, 0, 0, 0, 0, 0, 8025, 90, 0, 94, 0, 8071, 8025, 8025, 0, 110, 111, 0, 0, 14080, 8025, 0,
    /* 3388 */ 8025, 8025, 8025, 112, 0, 0, 9472, 97, 8025, 9216, 8025, 97, 8025, 8025, 8025, 11353, 0, 0, 0, 0, 4864,
    /* 3409 */ 4864, 4864, 4864, 4864, 4864, 0, 0, 4864, 4864, 4864, 0, 112, 83, 0, 0, 117, 0, 7768, 7768, 7768, 7768,
    /* 3430 */ 7768, 7768, 0, 0, 193, 172, 172, 0, 0, 0, 6144, 6144, 0, 0, 0, 8147, 0, 8025, 8025, 8025, 129, 8025,
    /* 3452 */ 8025, 0, 112, 83, 0, 143, 0, 0, 0, 0, 5888, 0, 5888, 0, 0, 5888, 110, 0, 0, 151, 8025, 0, 8025, 8025,
    /* 3476 */ 8025, 11865, 8025, 0, 8025, 12544, 8025, 8025, 8025, 0, 219, 0, 83, 0, 0, 144, 0, 0, 0, 4608, 0, 0, 0,
    /* 3499 */ 4608, 237, 8025, 8025, 8181, 8025, 0, 0, 0, 6144, 0, 0, 0, 0, 0, 8025, 0, 8025, 8025, 8025, 8025, 8025,
    /* 3521 */ 0, 0, 170, 0, 172, 0, 0, 0, 8025, 0, 8025, 8025, 0, 8070, 0, 11776, 0, 172, 172, 0, 0, 0, 8025, 0, 8025,
    /* 3546 */ 8025, 8035, 0, 220, 221, 8025, 13824, 8025, 8025, 8160, 8025, 197, 8025, 8025, 8025, 8025, 8025, 0, 82,
    /* 3565 */ 0, 0, 0, 0, 0, 0, 1792, 0, 8163, 8025, 229, 12800, 0, 8025, 8025, 12889, 95, 0, 8025, 95, 8025, 8025,
    /* 3587 */ 8025, 0, 83, 142, 0, 0, 0, 0, 147, 9472, 95, 8025, 9216, 8025, 95, 8025, 8025, 8141, 8025, 0, 0, 0, 0,
    /* 3610 */ 5120, 0, 0, 0, 0, 5120, 0, 0, 0, 0, 0, 0, 5376, 0, 5376, 0, 0, 5376, 0, 0, 0, 0, 8040, 8025, 8040, 8025,
    /* 3636 */ 8025, 8025, 8025, 8025, 8025, 8042, 8025, 112, 83, 0, 0, 0, 145, 0, 0, 8025, 0, 8025, 8159, 8025, 8025,
    /* 3657 */ 110, 149, 150, 0, 8025, 153, 8025, 8025, 8122, 8025, 8025, 0, 0, 0, 0, 0, 0, 8025, 0, 0, 0, 129, 130,
    /* 3680 */ 8025, 8025, 0, 8025, 8098, 8025, 8140, 8025, 8025, 0, 0, 0, 0, 123, 0, 8025, 8100, 110, 0, 0, 0, 0, 0, 0,
    /* 3704 */ 8025, 0, 8067, 8025, 0, 8025, 8135, 8025, 8025, 8025, 202, 0, 8025, 8116, 8025, 129, 8025, 8025, 0, 86,
    /* 3724 */ 0, 0, 0, 0, 0, 0, 172, 174, 0, 0, 8025, 0, 8025, 8025, 0, 8025, 8025, 8154, 0, 0, 0, 172, 172, 194, 0, 0,
    /* 3750 */ 141, 83, 0, 0, 0, 0, 0, 0, 8025, 0, 13145, 8025, 8025, 8025, 8038, 8025, 8025, 8025, 8025, 206, 0, 0, 0,
    /* 3773 */ 178, 8025, 8025, 8025, 129, 8025, 8025, 0, 110, 0, 0, 0, 0, 0, 0, 0, 0, 84, 233, 234, 8025, 0, 237, 238,
    /* 3797 */ 8178, 233, 234, 8025, 10496, 237, 238, 8025, 233, 234, 8025, 0, 237, 238, 8025, 233, 225, 0, 0, 237, 221,
    /* 3818 */ 0, 233, 234, 0, 0, 237, 238, 0, 225, 0, 221, 0, 0, 0, 0, 0, 0, 0, 2816, 0, 8115, 8025, 8025, 129, 8025,
    /* 3843 */ 8025, 0, 110, 6400, 6400, 0, 0, 0, 0, 157, 0, 0, 0, 0, 112, 83, 0, 0, 0, 118, 7768, 0, 8025, 8072, 8025,
    /* 3868 */ 0, 110, 111, 0, 112, 83, 0, 0, 0, 0, 0, 0, 129, 130, 8025, 8095, 0, 8025, 8025, 8025, 129, 8025, 8025,
    /* 3891 */ 184, 237, 8025, 8025, 8025, 11609, 0, 0, 0, 8025, 97, 8025, 8025, 8025, 0, 8152, 8025, 8025, 0, 0, 12288,
    /* 3912 */ 9472, 14336, 0, 14336, 0, 14336, 14336, 0, 0, 14336, 0, 0, 0, 14336, 0, 0, 0, 14336, 14336, 14336, 14336,
    /* 3933 */ 14336, 14336, 14336, 14336, 0, 0, 8960, 0, 8704, 0, 0, 0, 0, 0, 8025, 8025, 0, 0, 8175, 8025, 5120, 0,
    /* 3955 */ 5120, 0, 5120, 5120, 5120, 5120, 5120, 5120, 5120, 5120, 0, 0, 9472, 0, 0, 14592, 0, 0, 0, 0, 8025, 8025,
    /* 3977 */ 236, 0, 8025, 8025, 8025, 129, 8118, 8025, 0, 9472, 0, 0, 9216, 5888, 0, 0, 0, 8025, 8171, 0, 0, 8025,
    /* 3999 */ 8025, 0, 0, 8025, 8025, 0, 0, 8025, 13401, 5888, 5888, 5888, 0, 5888, 5888, 5888, 5888, 5888, 5888, 5888,
    /* 4019 */ 5888, 0, 0
  };

  private static final int[] EXPECTED =
  {
    /*   0 */ 123, 127, 130, 133, 152, 137, 141, 145, 149, 156, 163, 167, 159, 171, 175, 179, 183, 190, 186, 194, 203,
    /*  21 */ 245, 208, 320, 212, 228, 221, 258, 204, 234, 197, 229, 226, 230, 239, 244, 235, 320, 230, 227, 222, 244,
    /*  42 */ 234, 234, 229, 231, 222, 244, 320, 230, 229, 243, 321, 222, 232, 230, 337, 337, 321, 321, 230, 233, 234,
    /*  63 */ 354, 249, 255, 262, 234, 251, 266, 273, 277, 281, 285, 289, 293, 301, 305, 296, 309, 297, 234, 313, 330,
    /*  84 */ 345, 269, 331, 215, 319, 198, 314, 344, 325, 329, 384, 335, 199, 315, 345, 378, 341, 385, 352, 315, 349,
    /* 105 */ 377, 358, 385, 367, 374, 378, 383, 217, 390, 379, 386, 391, 361, 398, 395, 370, 363, 365, 1034, 2058,
    /* 125 */ 16394, 65546, 2097162, 16777226, 33554442, 10, 10, 10, 10, 65562, 65578, 66058, 33554442, 1610612746, 10,
    /* 140 */ 81946, 1114154, 553648650, 2686986, 578813962, 1619001354, 10, 2122, 590858, 2058, 588251146, 1619001354,
    /* 152 */ 2058, 589834, 65546, 570425354, 1661992970, 1728053258, 1610612746, -2147483638, 1610612746, 1666188042,
    /* 162 */ 1610612746, 452984832, 2058, 1610612746, 452984836, 1666187786, 264202, 1610612746, 1610612746,
    /* 171 */ 1666189066, -536870902, -536870902, 1666778890, 1666975498, 1666583306, 1667040010, -536870902,
    /* 179 */ 1666778906, 1667041034, 1666975498, 1667041050, 1666778906, 1666778906, 1666780954, 1667172122,
    /* 187 */ 1667059482, 1669269274, 1667086234, 1669138202, 1667041050, 1667043098, 1669269274, 1669271322,
    /* 195 */ 1669287706, 2, 8, 0, 0, 0, 64, 128, 2097152, 16777216, 33554432, 0, 0, 1073741824, 0, 0, 8, 0, 67108864,
    /* 214 */ 1073741824, 4, 0, 2, 16384, 0, 256, 256, 1073741824, 1073741824, 1073741824, 1073741824, 4, 4, 1073741824,
    /* 229 */ 1073741824, 0, 1073741824, 1073741824, 1073741824, 0, 0, 0, 0, 8, 1073741824, 8, 16777216, 16777216,
    /* 243 */ 1073741824, 16777216, 0, 0, 0, 536870912, 32768, 8388608, 0, 0, 139265, 8388610, 0, 8388608, 0, 32768, 8,
    /* 260 */ 8, 16777216, 0, 8388608, 0, 139264, 2048, 12582914, 0, 4096, 2097152, 0, 1835008, 14680066, 0, 0, 1835008,
    /* 277 */ 8527873, 1552, 14680578, 1835009, 25165832, 0, 14680578, 10223617, 1974272, 8593411, 10223621, 8388608,
    /* 289 */ 10223623, 8388608, 10379265, 10381313, 8404992, 8404992, 8389120, 8404992, 8404992, 8405504, 8405504, 0,
    /* 301 */ 10381825, 8404992, 8404992, 8404994, 8404992, 8405024, 8405504, 8405504, 8404992, 8405504, 8405504,
    /* 312 */ 8405504, 64, 128, 256, 32768, 8192, 131072, 10240, 0, 0, 0, 1073741824, 0, 4194304, 4096, 2097152, 786432,
    /* 329 */ 1048576, 0, 0, 8192, 131072, 65536, 16384, 2048, 0, 0, 1073741824, 1073741824, 1048576, 0, 8192, 131072,
    /* 345 */ 1, 2, 2048, 4194304, 1, 1, 2, 2048, 0, 64, 128, 256, 512, 524288, 1048576, 8192, 131072, 4, 4, 2, 4096,
    /* 366 */ 4096, 2048, 0, 128, 256, 2, 2, 4096, 32768, 131072, 2, 4194304, 4096, 2097152, 262144, 524288, 131072,
    /* 383 */ 1048576, 131072, 65536, 4, 2, 16384, 256, 32768, 131072, 2, 4096, 524288, 524288, 4, 4, 16384, 256, 2,
    /* 401 */ 4096
  };

  private static final String[] TOKEN =
  {
    "%ERROR",
    "WS",
    "COMMENT",
    "COMMENT",
    "'<'",
    "'>'",
    "','",
    "'?'",
    "'#('",
    "'('",
    "')'",
    "':'",
    "'*'",
    "'+'",
    "'='",
    "'=>'",
    "';'",
    "'^'",
    "'!'",
    "'|'",
    "'.'",
    "'..'",
    "'~'",
    "'}'",
    "CHAR_LITERAL",
    "STRING_LITERAL",
    "INT",
    "CR",
    "LF",
    "TOKEN_REF",
    "RULE_REF",
    "EOF",
    "DOC_COMMENT",
    "OPTIONS",
    "TOKENS",
    "ACTION_CHAR",
    "ARG_ACTION_CHAR",
    "'?'",
    "'Lexer'",
    "'Parser'",
    "'TreeParser'",
    "'['",
    "']'",
    "'catch'",
    "'charVocabulary'",
    "'class'",
    "'exception'",
    "'extends'",
    "'header'",
    "'lexclass'",
    "'private'",
    "'protected'",
    "'public'",
    "'returns'",
    "'throws'",
    "'{'",
    "'}'"
  };
}

// End
