<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was generated on Thu Dec 26, 2024 07:40 (UTC+01) by REx v6.1-SNAPSHOT which is Copyright (c) 1979-2024 by Gunther Rademacher <grd@gmx.net> -->
<!-- REx command line: XQueryV10.lr.ebnf -xml -ff -rex -nolexer -lalr 1 -->
<g:grammar id="1" xmlns:g="http://www.w3.org/2001/03/XPath/grammar">
  <g:production id="2" name="Goal">
    <g:ref id="3" reduce-id="4" reduce-count="1" name="XQuery"/>
  </g:production>
  <g:production id="5" name="XQuery">
    <g:ref id="6" name="Module"/>
    <g:ref id="7" reduce-id="8" reduce-count="2" first="EOF" name="EOF"/>
  </g:production>
  <g:production id="9" name="Module">
    <g:ref id="10" name="Module_1"/>
    <g:ref id="11" reduce-id="12" reduce-count="2" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="Module_2"/>
  </g:production>
  <g:production id="13" name="Module_1">
    <g:choice id="14">
      <g:sequence id="15" reduce-id="16" reduce-count="0">
      </g:sequence>
      <g:ref id="17" reduce-id="18" reduce-count="1" name="VersionDecl"/>
    </g:choice>
  </g:production>
  <g:production id="19" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="Module_2">
    <g:choice id="20" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">
      <g:ref id="21" reduce-id="22" reduce-count="1" first="module" name="LibraryModule"/>
      <g:ref id="23" reduce-id="22" reduce-count="1" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="MainModule"/>
    </g:choice>
  </g:production>
  <g:production id="24" name="VersionDecl">
    <g:string id="25" first="xquery">xquery</g:string>
    <g:string id="26" first="version">version</g:string>
    <g:ref id="27" first="StringLiteral" name="StringLiteral"/>
    <g:ref id="28" name="VersionDecl_1"/>
    <g:ref id="29" reduce-id="30" reduce-count="5" first=";" name="Separator"/>
  </g:production>
  <g:production id="31" name="VersionDecl_1">
    <g:choice id="32">
      <g:sequence id="33" reduce-id="34" reduce-count="0">
      </g:sequence>
      <g:sequence id="35">
        <g:string id="36" first="encoding">encoding</g:string>
        <g:ref id="37" reduce-id="38" reduce-count="2" first="StringLiteral" name="StringLiteral"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="39" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="MainModule">
    <g:ref id="40" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="Prolog"/>
    <g:ref id="41" reduce-id="42" reduce-count="2" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="QueryBody"/>
  </g:production>
  <g:production id="43" first="module" name="LibraryModule">
    <g:ref id="44" first="module" name="ModuleDecl"/>
    <g:ref id="45" reduce-id="46" reduce-count="2" first="%EPSILON declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import" name="Prolog"/>
  </g:production>
  <g:production id="47" first="module" name="ModuleDecl">
    <g:string id="48" first="module">module</g:string>
    <g:string id="49" first="namespace">namespace</g:string>
    <g:ref id="50" first="NCName" name="NCName"/>
    <g:string id="51" first="=">=</g:string>
    <g:ref id="52" name="URILiteral"/>
    <g:ref id="53" reduce-id="54" reduce-count="6" first=";" name="Separator"/>
  </g:production>
  <g:production id="55" first="%EPSILON declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import" name="Prolog">
    <g:ref id="56" first="%EPSILON declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import" name="Prolog_1"/>
    <g:ref id="57" reduce-id="58" reduce-count="2" first="%EPSILON declare function declare option declare variable" name="Prolog_3"/>
  </g:production>
  <g:production id="59" first="%EPSILON declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare namespace declare ordering import" name="Prolog_1">
    <g:choice id="60" first="%EPSILON declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare namespace declare ordering import">
      <g:sequence id="61" reduce-id="62" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="63" first="declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare namespace declare ordering import">
        <g:ref id="64" first="declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare namespace declare ordering import" name="Prolog_1"/>
        <g:ref id="65" first="declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare namespace declare ordering import" name="Prolog_2"/>
        <g:ref id="66" reduce-id="67" reduce-count="3" first=";" name="Separator"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="68" first="declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare namespace declare ordering import" name="Prolog_2">
    <g:choice id="69" first="declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare namespace declare ordering import">
      <g:ref id="70" reduce-id="71" reduce-count="1" first="declare default" name="DefaultNamespaceDecl"/>
      <g:ref id="72" reduce-id="71" reduce-count="1" first="declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare ordering" name="Setter"/>
      <g:ref id="73" reduce-id="71" reduce-count="1" first="declare namespace" name="NamespaceDecl"/>
      <g:ref id="74" reduce-id="71" reduce-count="1" first="import" name="Import"/>
    </g:choice>
  </g:production>
  <g:production id="75" first="%EPSILON declare function declare option declare variable" name="Prolog_3">
    <g:choice id="76" first="%EPSILON declare function declare option declare variable">
      <g:sequence id="77" reduce-id="78" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="79" first="declare function declare option declare variable">
        <g:ref id="80" first="declare function declare option declare variable" name="Prolog_3"/>
        <g:ref id="81" first="declare function declare option declare variable" name="Prolog_4"/>
        <g:ref id="82" reduce-id="83" reduce-count="3" first=";" name="Separator"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="84" first="declare function declare option declare variable" name="Prolog_4">
    <g:choice id="85" first="declare function declare option declare variable">
      <g:ref id="86" reduce-id="87" reduce-count="1" first="declare variable" name="VarDecl"/>
      <g:ref id="88" reduce-id="87" reduce-count="1" first="declare function" name="FunctionDecl"/>
      <g:ref id="89" reduce-id="87" reduce-count="1" first="declare option" name="OptionDecl"/>
    </g:choice>
  </g:production>
  <g:production id="90" first="declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare ordering" name="Setter">
    <g:choice id="91" first="declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare ordering">
      <g:ref id="92" reduce-id="93" reduce-count="1" first="declare boundary-space" name="BoundarySpaceDecl"/>
      <g:ref id="94" reduce-id="93" reduce-count="1" first="declare default" name="DefaultCollationDecl"/>
      <g:ref id="95" reduce-id="93" reduce-count="1" first="declare base-uri" name="BaseURIDecl"/>
      <g:ref id="96" reduce-id="93" reduce-count="1" first="declare construction" name="ConstructionDecl"/>
      <g:ref id="97" reduce-id="93" reduce-count="1" first="declare ordering" name="OrderingModeDecl"/>
      <g:ref id="98" reduce-id="93" reduce-count="1" first="declare default" name="EmptyOrderDecl"/>
      <g:ref id="99" reduce-id="93" reduce-count="1" first="declare copy-namespaces" name="CopyNamespacesDecl"/>
    </g:choice>
  </g:production>
  <g:production id="100" first="import" name="Import">
    <g:choice id="101" first="import">
      <g:ref id="102" reduce-id="103" reduce-count="1" first="import" name="SchemaImport"/>
      <g:ref id="104" reduce-id="103" reduce-count="1" first="import" name="ModuleImport"/>
    </g:choice>
  </g:production>
  <g:production id="105" first=";" name="Separator">
    <g:string id="106" reduce-id="107" reduce-count="1" first=";">;</g:string>
  </g:production>
  <g:production id="108" first="declare namespace" name="NamespaceDecl">
    <g:string id="109" first="declare namespace">declare namespace</g:string>
    <g:ref id="110" first="NCName" name="NCName"/>
    <g:string id="111" first="=">=</g:string>
    <g:ref id="112" reduce-id="113" reduce-count="4" name="URILiteral"/>
  </g:production>
  <g:production id="114" first="declare boundary-space" name="BoundarySpaceDecl">
    <g:string id="115" first="declare boundary-space">declare boundary-space</g:string>
    <g:ref id="116" reduce-id="117" reduce-count="2" name="BoundarySpaceDecl_1"/>
  </g:production>
  <g:production id="118" name="BoundarySpaceDecl_1">
    <g:choice id="119">
      <g:string id="120" reduce-id="121" reduce-count="1" first="preserve">preserve</g:string>
      <g:string id="122" reduce-id="121" reduce-count="1" first="strip">strip</g:string>
    </g:choice>
  </g:production>
  <g:production id="123" first="declare default" name="DefaultNamespaceDecl">
    <g:string id="124" first="declare default">declare default</g:string>
    <g:ref id="125" name="DefaultNamespaceDecl_1"/>
    <g:string id="126" first="namespace">namespace</g:string>
    <g:ref id="127" reduce-id="128" reduce-count="4" name="URILiteral"/>
  </g:production>
  <g:production id="129" name="DefaultNamespaceDecl_1">
    <g:choice id="130">
      <g:string id="131" reduce-id="132" reduce-count="1" first="element">element</g:string>
      <g:string id="133" reduce-id="132" reduce-count="1" first="function">function</g:string>
    </g:choice>
  </g:production>
  <g:production id="134" first="declare option" name="OptionDecl">
    <g:string id="135" first="declare option">declare option</g:string>
    <g:ref id="136" first="QName" name="QName"/>
    <g:ref id="137" reduce-id="138" reduce-count="3" first="StringLiteral" name="StringLiteral"/>
  </g:production>
  <g:production id="139" first="declare ordering" name="OrderingModeDecl">
    <g:string id="140" first="declare ordering">declare ordering</g:string>
    <g:ref id="141" reduce-id="142" reduce-count="2" name="OrderingModeDecl_1"/>
  </g:production>
  <g:production id="143" name="OrderingModeDecl_1">
    <g:choice id="144">
      <g:string id="145" reduce-id="146" reduce-count="1" first="ordered">ordered</g:string>
      <g:string id="147" reduce-id="146" reduce-count="1" first="unordered">unordered</g:string>
    </g:choice>
  </g:production>
  <g:production id="148" first="declare default" name="EmptyOrderDecl">
    <g:string id="149" first="declare default">declare default</g:string>
    <g:string id="150" first="order">order</g:string>
    <g:string id="151" first="empty">empty</g:string>
    <g:ref id="152" reduce-id="153" reduce-count="4" name="EmptyOrderDecl_1"/>
  </g:production>
  <g:production id="154" name="EmptyOrderDecl_1">
    <g:choice id="155">
      <g:string id="156" reduce-id="157" reduce-count="1" first="greatest">greatest</g:string>
      <g:string id="158" reduce-id="157" reduce-count="1" first="least">least</g:string>
    </g:choice>
  </g:production>
  <g:production id="159" first="declare copy-namespaces" name="CopyNamespacesDecl">
    <g:string id="160" first="declare copy-namespaces">declare copy-namespaces</g:string>
    <g:ref id="161" name="PreserveMode"/>
    <g:string id="162" first=",">,</g:string>
    <g:ref id="163" reduce-id="164" reduce-count="4" name="InheritMode"/>
  </g:production>
  <g:production id="165" name="PreserveMode">
    <g:choice id="166">
      <g:string id="167" reduce-id="168" reduce-count="1" first="preserve">preserve</g:string>
      <g:string id="169" reduce-id="168" reduce-count="1" first="no-preserve">no-preserve</g:string>
    </g:choice>
  </g:production>
  <g:production id="170" name="InheritMode">
    <g:choice id="171">
      <g:string id="172" reduce-id="173" reduce-count="1" first="inherit">inherit</g:string>
      <g:string id="174" reduce-id="173" reduce-count="1" first="no-inherit">no-inherit</g:string>
    </g:choice>
  </g:production>
  <g:production id="175" first="declare default" name="DefaultCollationDecl">
    <g:string id="176" first="declare default">declare default</g:string>
    <g:string id="177" first="collation">collation</g:string>
    <g:ref id="178" reduce-id="179" reduce-count="3" name="URILiteral"/>
  </g:production>
  <g:production id="180" first="declare base-uri" name="BaseURIDecl">
    <g:string id="181" first="declare base-uri">declare base-uri</g:string>
    <g:ref id="182" reduce-id="183" reduce-count="2" name="URILiteral"/>
  </g:production>
  <g:production id="184" first="import" name="SchemaImport">
    <g:string id="185" first="import">import</g:string>
    <g:string id="186" first="schema">schema</g:string>
    <g:ref id="187" name="SchemaImport_1"/>
    <g:ref id="188" first="StringLiteral" name="URILiteral"/>
    <g:ref id="189" reduce-id="190" reduce-count="5" first="%EPSILON at" name="SchemaImport_2"/>
  </g:production>
  <g:production id="191" name="SchemaImport_1">
    <g:choice id="192">
      <g:sequence id="193" reduce-id="194" reduce-count="0">
      </g:sequence>
      <g:ref id="195" reduce-id="196" reduce-count="1" name="SchemaPrefix"/>
    </g:choice>
  </g:production>
  <g:production id="197" first="%EPSILON at" name="SchemaImport_2">
    <g:choice id="198" first="%EPSILON at">
      <g:sequence id="199" reduce-id="200" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="201" first="at">
        <g:string id="202" first="at">at</g:string>
        <g:ref id="203" name="URILiteral"/>
        <g:ref id="204" reduce-id="205" reduce-count="3" first="%EPSILON ," name="SchemaImport_3"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="206" first="%EPSILON ," name="SchemaImport_3">
    <g:choice id="207" first="%EPSILON ,">
      <g:sequence id="208" reduce-id="209" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="210" first=",">
        <g:ref id="211" first="," name="SchemaImport_3"/>
        <g:string id="212" first=",">,</g:string>
        <g:ref id="213" reduce-id="214" reduce-count="3" name="URILiteral"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="215" name="SchemaPrefix">
    <g:choice id="216">
      <g:sequence id="217">
        <g:string id="218" first="namespace">namespace</g:string>
        <g:ref id="219" first="NCName" name="NCName"/>
        <g:string id="220" reduce-id="221" reduce-count="3" first="=">=</g:string>
      </g:sequence>
      <g:sequence id="222">
        <g:string id="223" first="default">default</g:string>
        <g:string id="224" first="element">element</g:string>
        <g:string id="225" reduce-id="221" reduce-count="3" first="namespace">namespace</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="226" first="import" name="ModuleImport">
    <g:string id="227" first="import">import</g:string>
    <g:string id="228" first="module">module</g:string>
    <g:ref id="229" name="ModuleImport_1"/>
    <g:ref id="230" first="StringLiteral" name="URILiteral"/>
    <g:ref id="231" reduce-id="232" reduce-count="5" first="%EPSILON at" name="ModuleImport_2"/>
  </g:production>
  <g:production id="233" name="ModuleImport_1">
    <g:choice id="234">
      <g:sequence id="235" reduce-id="236" reduce-count="0">
      </g:sequence>
      <g:sequence id="237">
        <g:string id="238" first="namespace">namespace</g:string>
        <g:ref id="239" first="NCName" name="NCName"/>
        <g:string id="240" reduce-id="241" reduce-count="3" first="=">=</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="242" first="%EPSILON at" name="ModuleImport_2">
    <g:choice id="243" first="%EPSILON at">
      <g:sequence id="244" reduce-id="245" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="246" first="at">
        <g:string id="247" first="at">at</g:string>
        <g:ref id="248" name="URILiteral"/>
        <g:ref id="249" reduce-id="250" reduce-count="3" first="%EPSILON ," name="ModuleImport_3"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="251" first="%EPSILON ," name="ModuleImport_3">
    <g:choice id="252" first="%EPSILON ,">
      <g:sequence id="253" reduce-id="254" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="255" first=",">
        <g:ref id="256" first="," name="ModuleImport_3"/>
        <g:string id="257" first=",">,</g:string>
        <g:ref id="258" reduce-id="259" reduce-count="3" name="URILiteral"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="260" first="declare variable" name="VarDecl">
    <g:string id="261" first="declare variable">declare variable</g:string>
    <g:string id="262" first="$">$</g:string>
    <g:ref id="263" first="QName" name="QName"/>
    <g:ref id="264" name="VarDecl_1"/>
    <g:ref id="265" reduce-id="266" reduce-count="5" first=":= external" name="VarDecl_2"/>
  </g:production>
  <g:production id="267" name="VarDecl_1">
    <g:choice id="268">
      <g:sequence id="269" reduce-id="270" reduce-count="0">
      </g:sequence>
      <g:ref id="271" reduce-id="272" reduce-count="1" name="TypeDeclaration"/>
    </g:choice>
  </g:production>
  <g:production id="273" first=":= external" name="VarDecl_2">
    <g:choice id="274" first=":= external">
      <g:sequence id="275" first=":=">
        <g:string id="276" first=":=">:=</g:string>
        <g:ref id="277" reduce-id="278" reduce-count="2" name="ExprSingle"/>
      </g:sequence>
      <g:string id="279" reduce-id="280" reduce-count="1" first="external">external</g:string>
    </g:choice>
  </g:production>
  <g:production id="281" first="declare construction" name="ConstructionDecl">
    <g:string id="282" first="declare construction">declare construction</g:string>
    <g:ref id="283" reduce-id="284" reduce-count="2" name="ConstructionDecl_1"/>
  </g:production>
  <g:production id="285" name="ConstructionDecl_1">
    <g:choice id="286">
      <g:string id="287" reduce-id="288" reduce-count="1" first="strip">strip</g:string>
      <g:string id="289" reduce-id="288" reduce-count="1" first="preserve">preserve</g:string>
    </g:choice>
  </g:production>
  <g:production id="290" first="declare function" name="FunctionDecl">
    <g:string id="291" first="declare function">declare function</g:string>
    <g:ref id="292" first="QName" name="QName"/>
    <g:string id="293" first="(">(</g:string>
    <g:ref id="294" name="FunctionDecl_1"/>
    <g:string id="295" first=")">)</g:string>
    <g:ref id="296" name="FunctionDecl_2"/>
    <g:ref id="297" reduce-id="298" reduce-count="7" first="external {" name="FunctionDecl_3"/>
  </g:production>
  <g:production id="299" name="FunctionDecl_1">
    <g:choice id="300">
      <g:sequence id="301" reduce-id="302" reduce-count="0">
      </g:sequence>
      <g:ref id="303" reduce-id="304" reduce-count="1" name="ParamList"/>
    </g:choice>
  </g:production>
  <g:production id="305" name="FunctionDecl_2">
    <g:choice id="306">
      <g:sequence id="307" reduce-id="308" reduce-count="0">
      </g:sequence>
      <g:sequence id="309">
        <g:string id="310" first="as">as</g:string>
        <g:ref id="311" reduce-id="312" reduce-count="2" name="SequenceType"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="313" first="external {" name="FunctionDecl_3">
    <g:choice id="314" first="external {">
      <g:ref id="315" reduce-id="316" reduce-count="1" first="{" name="EnclosedExpr"/>
      <g:string id="317" reduce-id="316" reduce-count="1" first="external">external</g:string>
    </g:choice>
  </g:production>
  <g:production id="318" name="ParamList">
    <g:ref id="319" name="Param"/>
    <g:ref id="320" reduce-id="321" reduce-count="2" first="%EPSILON ," name="ParamList_1"/>
  </g:production>
  <g:production id="322" first="%EPSILON ," name="ParamList_1">
    <g:choice id="323" first="%EPSILON ,">
      <g:sequence id="324" reduce-id="325" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="326" first=",">
        <g:ref id="327" first="," name="ParamList_1"/>
        <g:string id="328" first=",">,</g:string>
        <g:ref id="329" reduce-id="330" reduce-count="3" name="Param"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="331" name="Param">
    <g:string id="332" first="$">$</g:string>
    <g:ref id="333" first="QName" name="QName"/>
    <g:ref id="334" reduce-id="335" reduce-count="3" name="Param_1"/>
  </g:production>
  <g:production id="336" name="Param_1">
    <g:choice id="337">
      <g:sequence id="338" reduce-id="339" reduce-count="0">
      </g:sequence>
      <g:ref id="340" reduce-id="341" reduce-count="1" name="TypeDeclaration"/>
    </g:choice>
  </g:production>
  <g:production id="342" first="{" name="EnclosedExpr">
    <g:string id="343" first="{">{</g:string>
    <g:ref id="344" name="Expr"/>
    <g:string id="345" reduce-id="346" reduce-count="3" first="}">}</g:string>
  </g:production>
  <g:production id="347" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="QueryBody">
    <g:ref id="348" reduce-id="349" reduce-count="1" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="Expr"/>
  </g:production>
  <g:production id="350" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="Expr">
    <g:ref id="351" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="ExprSingle"/>
    <g:ref id="352" reduce-id="353" reduce-count="2" first="%EPSILON ," name="Expr_1"/>
  </g:production>
  <g:production id="354" first="%EPSILON ," name="Expr_1">
    <g:choice id="355" first="%EPSILON ,">
      <g:sequence id="356" reduce-id="357" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="358" first=",">
        <g:ref id="359" first="," name="Expr_1"/>
        <g:string id="360" first=",">,</g:string>
        <g:ref id="361" reduce-id="362" reduce-count="3" name="ExprSingle"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="363" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="ExprSingle">
    <g:choice id="364" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">
      <g:ref id="365" reduce-id="366" reduce-count="1" first="for let" name="FLWORExpr"/>
      <g:ref id="367" reduce-id="366" reduce-count="1" first="every some" name="QuantifiedExpr"/>
      <g:ref id="368" reduce-id="366" reduce-count="1" first="typeswitch" name="TypeswitchExpr"/>
      <g:ref id="369" reduce-id="366" reduce-count="1" first="if" name="IfExpr"/>
      <g:ref id="370" reduce-id="366" reduce-count="1" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="OrExpr"/>
    </g:choice>
  </g:production>
  <g:production id="371" first="for let" name="FLWORExpr">
    <g:ref id="372" first="for let" name="FLWORExpr_1"/>
    <g:ref id="373" first="order return stable where" name="FLWORExpr_3"/>
    <g:ref id="374" first="order return stable" name="FLWORExpr_4"/>
    <g:string id="375" first="return">return</g:string>
    <g:ref id="376" reduce-id="377" reduce-count="5" name="ExprSingle"/>
  </g:production>
  <g:production id="378" first="for let" name="FLWORExpr_1">
    <g:choice id="379" first="for let">
      <g:ref id="380" reduce-id="381" reduce-count="1" first="for let" name="FLWORExpr_2"/>
      <g:sequence id="382" first="for let">
        <g:ref id="383" first="for let" name="FLWORExpr_1"/>
        <g:ref id="384" reduce-id="385" reduce-count="2" first="for let" name="FLWORExpr_2"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="386" first="for let" name="FLWORExpr_2">
    <g:choice id="387" first="for let">
      <g:ref id="388" reduce-id="389" reduce-count="1" first="for" name="ForClause"/>
      <g:ref id="390" reduce-id="389" reduce-count="1" first="let" name="LetClause"/>
    </g:choice>
  </g:production>
  <g:production id="391" first="%EPSILON where" name="FLWORExpr_3">
    <g:choice id="392" first="%EPSILON where">
      <g:sequence id="393" reduce-id="394" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="395" reduce-id="396" reduce-count="1" first="where" name="WhereClause"/>
    </g:choice>
  </g:production>
  <g:production id="397" first="%EPSILON order stable" name="FLWORExpr_4">
    <g:choice id="398" first="%EPSILON order stable">
      <g:sequence id="399" reduce-id="400" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="401" reduce-id="402" reduce-count="1" first="order stable" name="OrderByClause"/>
    </g:choice>
  </g:production>
  <g:production id="403" first="for" name="ForClause">
    <g:string id="404" first="for">for</g:string>
    <g:string id="405" first="$">$</g:string>
    <g:ref id="406" name="VarName"/>
    <g:ref id="407" first="as at in" name="ForClause_1"/>
    <g:ref id="408" first="at in" name="ForClause_2"/>
    <g:string id="409" first="in">in</g:string>
    <g:ref id="410" name="ExprSingle"/>
    <g:ref id="411" reduce-id="412" reduce-count="8" first="%EPSILON ," name="ForClause_3"/>
  </g:production>
  <g:production id="413" first="%EPSILON as" name="ForClause_1">
    <g:choice id="414" first="%EPSILON as">
      <g:sequence id="415" reduce-id="416" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="417" reduce-id="418" reduce-count="1" first="as" name="TypeDeclaration"/>
    </g:choice>
  </g:production>
  <g:production id="419" first="%EPSILON at" name="ForClause_2">
    <g:choice id="420" first="%EPSILON at">
      <g:sequence id="421" reduce-id="422" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="423" reduce-id="424" reduce-count="1" first="at" name="PositionalVar"/>
    </g:choice>
  </g:production>
  <g:production id="425" first="%EPSILON ," name="ForClause_3">
    <g:choice id="426" first="%EPSILON ,">
      <g:sequence id="427" reduce-id="428" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="429" first=",">
        <g:ref id="430" first="," name="ForClause_3"/>
        <g:string id="431" first=",">,</g:string>
        <g:string id="432" first="$">$</g:string>
        <g:ref id="433" name="VarName"/>
        <g:ref id="434" first="as at in" name="ForClause_4"/>
        <g:ref id="435" first="at in" name="ForClause_5"/>
        <g:string id="436" first="in">in</g:string>
        <g:ref id="437" reduce-id="438" reduce-count="8" name="ExprSingle"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="439" first="%EPSILON as" name="ForClause_4">
    <g:choice id="440" first="%EPSILON as">
      <g:sequence id="441" reduce-id="442" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="443" reduce-id="444" reduce-count="1" first="as" name="TypeDeclaration"/>
    </g:choice>
  </g:production>
  <g:production id="445" first="%EPSILON at" name="ForClause_5">
    <g:choice id="446" first="%EPSILON at">
      <g:sequence id="447" reduce-id="448" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="449" reduce-id="450" reduce-count="1" first="at" name="PositionalVar"/>
    </g:choice>
  </g:production>
  <g:production id="451" first="at" name="PositionalVar">
    <g:string id="452" first="at">at</g:string>
    <g:string id="453" first="$">$</g:string>
    <g:ref id="454" reduce-id="455" reduce-count="3" name="VarName"/>
  </g:production>
  <g:production id="456" first="let" name="LetClause">
    <g:string id="457" first="let">let</g:string>
    <g:string id="458" first="$">$</g:string>
    <g:ref id="459" name="VarName"/>
    <g:ref id="460" first=":= as" name="LetClause_1"/>
    <g:string id="461" first=":=">:=</g:string>
    <g:ref id="462" name="ExprSingle"/>
    <g:ref id="463" reduce-id="464" reduce-count="7" first="%EPSILON ," name="LetClause_2"/>
  </g:production>
  <g:production id="465" first="%EPSILON as" name="LetClause_1">
    <g:choice id="466" first="%EPSILON as">
      <g:sequence id="467" reduce-id="468" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="469" reduce-id="470" reduce-count="1" first="as" name="TypeDeclaration"/>
    </g:choice>
  </g:production>
  <g:production id="471" first="%EPSILON ," name="LetClause_2">
    <g:choice id="472" first="%EPSILON ,">
      <g:sequence id="473" reduce-id="474" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="475" first=",">
        <g:ref id="476" first="," name="LetClause_2"/>
        <g:string id="477" first=",">,</g:string>
        <g:string id="478" first="$">$</g:string>
        <g:ref id="479" name="VarName"/>
        <g:ref id="480" first=":= as" name="LetClause_3"/>
        <g:string id="481" first=":=">:=</g:string>
        <g:ref id="482" reduce-id="483" reduce-count="7" name="ExprSingle"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="484" first="%EPSILON as" name="LetClause_3">
    <g:choice id="485" first="%EPSILON as">
      <g:sequence id="486" reduce-id="487" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="488" reduce-id="489" reduce-count="1" first="as" name="TypeDeclaration"/>
    </g:choice>
  </g:production>
  <g:production id="490" first="where" name="WhereClause">
    <g:string id="491" first="where">where</g:string>
    <g:ref id="492" reduce-id="493" reduce-count="2" name="ExprSingle"/>
  </g:production>
  <g:production id="494" first="order stable" name="OrderByClause">
    <g:ref id="495" first="order stable" name="OrderByClause_1"/>
    <g:ref id="496" reduce-id="497" reduce-count="2" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="OrderSpecList"/>
  </g:production>
  <g:production id="498" first="order stable" name="OrderByClause_1">
    <g:choice id="499" first="order stable">
      <g:sequence id="500" first="order">
        <g:string id="501" first="order">order</g:string>
        <g:string id="502" reduce-id="503" reduce-count="2" first="by">by</g:string>
      </g:sequence>
      <g:sequence id="504" first="stable">
        <g:string id="505" first="stable">stable</g:string>
        <g:string id="506" first="order">order</g:string>
        <g:string id="507" reduce-id="508" reduce-count="3" first="by">by</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="509" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="OrderSpecList">
    <g:ref id="510" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="OrderSpec"/>
    <g:ref id="511" reduce-id="512" reduce-count="2" first="%EPSILON ," name="OrderSpecList_1"/>
  </g:production>
  <g:production id="513" first="%EPSILON ," name="OrderSpecList_1">
    <g:choice id="514" first="%EPSILON ,">
      <g:sequence id="515" reduce-id="516" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="517" first=",">
        <g:ref id="518" first="," name="OrderSpecList_1"/>
        <g:string id="519" first=",">,</g:string>
        <g:ref id="520" reduce-id="521" reduce-count="3" name="OrderSpec"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="522" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="OrderSpec">
    <g:ref id="523" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" name="ExprSingle"/>
    <g:ref id="524" reduce-id="525" reduce-count="2" first="%EPSILON ascending collation descending empty" name="OrderModifier"/>
  </g:production>
  <g:production id="526" first="%EPSILON ascending collation descending empty" name="OrderModifier">
    <g:ref id="527" first="%EPSILON ascending collation descending empty" name="OrderModifier_1"/>
    <g:ref id="528" first="%EPSILON collation empty" name="OrderModifier_2"/>
    <g:ref id="529" reduce-id="530" reduce-count="3" first="%EPSILON collation" name="OrderModifier_4"/>
  </g:production>
  <g:production id="531" first="%EPSILON ascending descending" name="OrderModifier_1">
    <g:choice id="532" first="%EPSILON ascending descending">
      <g:sequence id="533" reduce-id="534" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:string id="535" reduce-id="536" reduce-count="1" first="ascending">ascending</g:string>
      <g:string id="537" reduce-id="536" reduce-count="1" first="descending">descending</g:string>
    </g:choice>
  </g:production>
  <g:production id="538" first="%EPSILON empty" name="OrderModifier_2">
    <g:choice id="539" first="%EPSILON empty">
      <g:sequence id="540" reduce-id="541" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="542" first="empty">
        <g:string id="543" first="empty">empty</g:string>
        <g:ref id="544" reduce-id="545" reduce-count="2" name="OrderModifier_3"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="546" name="OrderModifier_3">
    <g:choice id="547">
      <g:string id="548" reduce-id="549" reduce-count="1" first="greatest">greatest</g:string>
      <g:string id="550" reduce-id="549" reduce-count="1" first="least">least</g:string>
    </g:choice>
  </g:production>
  <g:production id="551" first="%EPSILON collation" name="OrderModifier_4">
    <g:choice id="552" first="%EPSILON collation">
      <g:sequence id="553" reduce-id="554" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="555" first="collation">
        <g:string id="556" first="collation">collation</g:string>
        <g:ref id="557" reduce-id="558" reduce-count="2" name="URILiteral"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="559" first="every some" name="QuantifiedExpr">
    <g:ref id="560" first="every some" name="QuantifiedExpr_1"/>
    <g:string id="561" first="$">$</g:string>
    <g:ref id="562" name="VarName"/>
    <g:ref id="563" first="as in" name="QuantifiedExpr_2"/>
    <g:string id="564" first="in">in</g:string>
    <g:ref id="565" name="ExprSingle"/>
    <g:ref id="566" first=", satisfies" name="QuantifiedExpr_3"/>
    <g:string id="567" first="satisfies">satisfies</g:string>
    <g:ref id="568" reduce-id="569" reduce-count="9" name="ExprSingle"/>
  </g:production>
  <g:production id="570" first="every some" name="QuantifiedExpr_1">
    <g:choice id="571" first="every some">
      <g:string id="572" reduce-id="573" reduce-count="1" first="some">some</g:string>
      <g:string id="574" reduce-id="573" reduce-count="1" first="every">every</g:string>
    </g:choice>
  </g:production>
  <g:production id="575" first="%EPSILON as" name="QuantifiedExpr_2">
    <g:choice id="576" first="%EPSILON as">
      <g:sequence id="577" reduce-id="578" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="579" reduce-id="580" reduce-count="1" first="as" name="TypeDeclaration"/>
    </g:choice>
  </g:production>
  <g:production id="581" first="%EPSILON ," name="QuantifiedExpr_3">
    <g:choice id="582" first="%EPSILON ,">
      <g:sequence id="583" reduce-id="584" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="585" first=",">
        <g:ref id="586" first="," name="QuantifiedExpr_3"/>
        <g:string id="587" first=",">,</g:string>
        <g:string id="588" first="$">$</g:string>
        <g:ref id="589" name="VarName"/>
        <g:ref id="590" first="as in" name="QuantifiedExpr_4"/>
        <g:string id="591" first="in">in</g:string>
        <g:ref id="592" reduce-id="593" reduce-count="7" name="ExprSingle"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="594" first="%EPSILON as" name="QuantifiedExpr_4">
    <g:choice id="595" first="%EPSILON as">
      <g:sequence id="596" reduce-id="597" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="598" reduce-id="599" reduce-count="1" first="as" name="TypeDeclaration"/>
    </g:choice>
  </g:production>
  <g:production id="600" first="typeswitch" name="TypeswitchExpr">
    <g:string id="601" first="typeswitch">typeswitch</g:string>
    <g:string id="602" first="(">(</g:string>
    <g:ref id="603" name="Expr"/>
    <g:string id="604" first=")">)</g:string>
    <g:ref id="605" name="TypeswitchExpr_1"/>
    <g:string id="606" first="default">default</g:string>
    <g:ref id="607" name="TypeswitchExpr_2"/>
    <g:string id="608" first="return">return</g:string>
    <g:ref id="609" reduce-id="610" reduce-count="9" name="ExprSingle"/>
  </g:production>
  <g:production id="611" name="TypeswitchExpr_1">
    <g:choice id="612">
      <g:ref id="613" reduce-id="614" reduce-count="1" name="CaseClause"/>
      <g:sequence id="615">
        <g:ref id="616" name="TypeswitchExpr_1"/>
        <g:ref id="617" reduce-id="618" reduce-count="2" first="case" name="CaseClause"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="619" name="TypeswitchExpr_2">
    <g:choice id="620">
      <g:sequence id="621" reduce-id="622" reduce-count="0">
      </g:sequence>
      <g:sequence id="623">
        <g:string id="624" first="$">$</g:string>
        <g:ref id="625" reduce-id="626" reduce-count="2" name="VarName"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="627" first="case" name="CaseClause">
    <g:string id="628" first="case">case</g:string>
    <g:ref id="629" name="CaseClause_1"/>
    <g:ref id="630" first="QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text" name="SequenceType"/>
    <g:string id="631" first="return">return</g:string>
    <g:ref id="632" reduce-id="633" reduce-count="5" name="ExprSingle"/>
  </g:production>
  <g:production id="634" name="CaseClause_1">
    <g:choice id="635">
      <g:sequence id="636" reduce-id="637" reduce-count="0">
      </g:sequence>
      <g:sequence id="638">
        <g:string id="639" first="$">$</g:string>
        <g:ref id="640" name="VarName"/>
        <g:string id="641" reduce-id="642" reduce-count="3" first="as">as</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="643" first="if" name="IfExpr">
    <g:string id="644" first="if">if</g:string>
    <g:string id="645" first="(">(</g:string>
    <g:ref id="646" name="Expr"/>
    <g:string id="647" first=")">)</g:string>
    <g:string id="648" first="then">then</g:string>
    <g:ref id="649" name="ExprSingle"/>
    <g:string id="650" first="else">else</g:string>
    <g:ref id="651" reduce-id="652" reduce-count="8" name="ExprSingle"/>
  </g:production>
  <g:production id="653" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="OrExpr">
    <g:ref id="654" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="AndExpr"/>
    <g:ref id="655" reduce-id="656" reduce-count="2" first="%EPSILON or" name="OrExpr_1"/>
  </g:production>
  <g:production id="657" first="%EPSILON or" name="OrExpr_1">
    <g:choice id="658" first="%EPSILON or">
      <g:sequence id="659" reduce-id="660" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="661" first="or">
        <g:ref id="662" first="or" name="OrExpr_1"/>
        <g:string id="663" first="or">or</g:string>
        <g:ref id="664" reduce-id="665" reduce-count="3" name="AndExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="666" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="AndExpr">
    <g:ref id="667" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="ComparisonExpr"/>
    <g:ref id="668" reduce-id="669" reduce-count="2" first="%EPSILON and" name="AndExpr_1"/>
  </g:production>
  <g:production id="670" first="%EPSILON and" name="AndExpr_1">
    <g:choice id="671" first="%EPSILON and">
      <g:sequence id="672" reduce-id="673" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="674" first="and">
        <g:ref id="675" first="and" name="AndExpr_1"/>
        <g:string id="676" first="and">and</g:string>
        <g:ref id="677" reduce-id="678" reduce-count="3" name="ComparisonExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="679" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="ComparisonExpr">
    <g:ref id="680" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="RangeExpr"/>
    <g:ref id="681" reduce-id="682" reduce-count="2" first="!= %EPSILON &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; eq ge gt is le lt ne" name="ComparisonExpr_1"/>
  </g:production>
  <g:production id="683" first="!= %EPSILON &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; eq ge gt is le lt ne" name="ComparisonExpr_1">
    <g:choice id="684" first="!= %EPSILON &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; eq ge gt is le lt ne">
      <g:sequence id="685" reduce-id="686" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="687" first="!= &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; eq ge gt is le lt ne">
        <g:ref id="688" first="!= &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; eq ge gt is le lt ne" name="ComparisonExpr_2"/>
        <g:ref id="689" reduce-id="690" reduce-count="2" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="RangeExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="691" first="!= &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; eq ge gt is le lt ne" name="ComparisonExpr_2">
    <g:choice id="692" first="!= &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; eq ge gt is le lt ne">
      <g:ref id="693" reduce-id="694" reduce-count="1" first="eq ge gt le lt ne" name="ValueComp"/>
      <g:ref id="695" reduce-id="694" reduce-count="1" first="!= &lt; &lt;= = &gt; &gt;=" name="GeneralComp"/>
      <g:ref id="696" reduce-id="694" reduce-count="1" first="&lt;&lt; &gt;&gt; is" name="NodeComp"/>
    </g:choice>
  </g:production>
  <g:production id="697" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="RangeExpr">
    <g:ref id="698" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="AdditiveExpr"/>
    <g:ref id="699" reduce-id="700" reduce-count="2" first="%EPSILON to" name="RangeExpr_1"/>
  </g:production>
  <g:production id="701" first="%EPSILON to" name="RangeExpr_1">
    <g:choice id="702" first="%EPSILON to">
      <g:sequence id="703" reduce-id="704" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="705" first="to">
        <g:string id="706" first="to">to</g:string>
        <g:ref id="707" reduce-id="708" reduce-count="2" name="AdditiveExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="709" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="AdditiveExpr">
    <g:ref id="710" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="MultiplicativeExpr"/>
    <g:ref id="711" reduce-id="712" reduce-count="2" first="%EPSILON + -" name="AdditiveExpr_1"/>
  </g:production>
  <g:production id="713" first="%EPSILON + -" name="AdditiveExpr_1">
    <g:choice id="714" first="%EPSILON + -">
      <g:sequence id="715" reduce-id="716" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="717" first="+ -">
        <g:ref id="718" first="+ -" name="AdditiveExpr_1"/>
        <g:ref id="719" first="+ -" name="AdditiveExpr_2"/>
        <g:ref id="720" reduce-id="721" reduce-count="3" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="MultiplicativeExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="722" first="+ -" name="AdditiveExpr_2">
    <g:choice id="723" first="+ -">
      <g:string id="724" reduce-id="725" reduce-count="1" first="+">+</g:string>
      <g:string id="726" reduce-id="725" reduce-count="1" first="-">-</g:string>
    </g:choice>
  </g:production>
  <g:production id="727" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="MultiplicativeExpr">
    <g:ref id="728" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="UnionExpr"/>
    <g:ref id="729" reduce-id="730" reduce-count="2" first="%EPSILON * div idiv mod" name="MultiplicativeExpr_1"/>
  </g:production>
  <g:production id="731" first="%EPSILON * div idiv mod" name="MultiplicativeExpr_1">
    <g:choice id="732" first="%EPSILON * div idiv mod">
      <g:sequence id="733" reduce-id="734" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="735" first="* div idiv mod">
        <g:ref id="736" first="* div idiv mod" name="MultiplicativeExpr_1"/>
        <g:ref id="737" first="* div idiv mod" name="MultiplicativeExpr_2"/>
        <g:ref id="738" reduce-id="739" reduce-count="3" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="UnionExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="740" first="* div idiv mod" name="MultiplicativeExpr_2">
    <g:choice id="741" first="* div idiv mod">
      <g:string id="742" reduce-id="743" reduce-count="1" first="*">*</g:string>
      <g:string id="744" reduce-id="743" reduce-count="1" first="div">div</g:string>
      <g:string id="745" reduce-id="743" reduce-count="1" first="idiv">idiv</g:string>
      <g:string id="746" reduce-id="743" reduce-count="1" first="mod">mod</g:string>
    </g:choice>
  </g:production>
  <g:production id="747" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="UnionExpr">
    <g:ref id="748" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="IntersectExceptExpr"/>
    <g:ref id="749" reduce-id="750" reduce-count="2" first="%EPSILON union |" name="UnionExpr_1"/>
  </g:production>
  <g:production id="751" first="%EPSILON union |" name="UnionExpr_1">
    <g:choice id="752" first="%EPSILON union |">
      <g:sequence id="753" reduce-id="754" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="755" first="union |">
        <g:ref id="756" first="union |" name="UnionExpr_1"/>
        <g:ref id="757" first="union |" name="UnionExpr_2"/>
        <g:ref id="758" reduce-id="759" reduce-count="3" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="IntersectExceptExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="760" first="union |" name="UnionExpr_2">
    <g:choice id="761" first="union |">
      <g:string id="762" reduce-id="763" reduce-count="1" first="union">union</g:string>
      <g:string id="764" reduce-id="763" reduce-count="1" first="|">|</g:string>
    </g:choice>
  </g:production>
  <g:production id="765" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="IntersectExceptExpr">
    <g:ref id="766" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="InstanceofExpr"/>
    <g:ref id="767" reduce-id="768" reduce-count="2" first="%EPSILON except intersect" name="IntersectExceptExpr_1"/>
  </g:production>
  <g:production id="769" first="%EPSILON except intersect" name="IntersectExceptExpr_1">
    <g:choice id="770" first="%EPSILON except intersect">
      <g:sequence id="771" reduce-id="772" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="773" first="except intersect">
        <g:ref id="774" first="except intersect" name="IntersectExceptExpr_1"/>
        <g:ref id="775" first="except intersect" name="IntersectExceptExpr_2"/>
        <g:ref id="776" reduce-id="777" reduce-count="3" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="InstanceofExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="778" first="except intersect" name="IntersectExceptExpr_2">
    <g:choice id="779" first="except intersect">
      <g:string id="780" reduce-id="781" reduce-count="1" first="intersect">intersect</g:string>
      <g:string id="782" reduce-id="781" reduce-count="1" first="except">except</g:string>
    </g:choice>
  </g:production>
  <g:production id="783" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="InstanceofExpr">
    <g:ref id="784" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="TreatExpr"/>
    <g:ref id="785" reduce-id="786" reduce-count="2" first="%EPSILON instance" name="InstanceofExpr_1"/>
  </g:production>
  <g:production id="787" first="%EPSILON instance" name="InstanceofExpr_1">
    <g:choice id="788" first="%EPSILON instance">
      <g:sequence id="789" reduce-id="790" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="791" first="instance">
        <g:string id="792" first="instance">instance</g:string>
        <g:string id="793" first="of">of</g:string>
        <g:ref id="794" reduce-id="795" reduce-count="3" name="SequenceType"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="796" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="TreatExpr">
    <g:ref id="797" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="CastableExpr"/>
    <g:ref id="798" reduce-id="799" reduce-count="2" first="%EPSILON treat" name="TreatExpr_1"/>
  </g:production>
  <g:production id="800" first="%EPSILON treat" name="TreatExpr_1">
    <g:choice id="801" first="%EPSILON treat">
      <g:sequence id="802" reduce-id="803" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="804" first="treat">
        <g:string id="805" first="treat">treat</g:string>
        <g:string id="806" first="as">as</g:string>
        <g:ref id="807" reduce-id="808" reduce-count="3" name="SequenceType"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="809" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="CastableExpr">
    <g:ref id="810" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="CastExpr"/>
    <g:ref id="811" reduce-id="812" reduce-count="2" first="%EPSILON castable" name="CastableExpr_1"/>
  </g:production>
  <g:production id="813" first="%EPSILON castable" name="CastableExpr_1">
    <g:choice id="814" first="%EPSILON castable">
      <g:sequence id="815" reduce-id="816" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="817" first="castable">
        <g:string id="818" first="castable">castable</g:string>
        <g:string id="819" first="as">as</g:string>
        <g:ref id="820" reduce-id="821" reduce-count="3" name="SingleType"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="822" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="CastExpr">
    <g:ref id="823" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="UnaryExpr"/>
    <g:ref id="824" reduce-id="825" reduce-count="2" first="%EPSILON cast" name="CastExpr_1"/>
  </g:production>
  <g:production id="826" first="%EPSILON cast" name="CastExpr_1">
    <g:choice id="827" first="%EPSILON cast">
      <g:sequence id="828" reduce-id="829" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="830" first="cast">
        <g:string id="831" first="cast">cast</g:string>
        <g:string id="832" first="as">as</g:string>
        <g:ref id="833" reduce-id="834" reduce-count="3" name="SingleType"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="835" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="UnaryExpr">
    <g:ref id="836" first="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="UnaryExpr_1"/>
    <g:ref id="837" reduce-id="838" reduce-count="2" first="$ ( (# . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="ValueExpr"/>
  </g:production>
  <g:production id="839" first="%EPSILON + -" name="UnaryExpr_1">
    <g:choice id="840" first="%EPSILON + -">
      <g:sequence id="841" reduce-id="842" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="843" first="+ -">
        <g:ref id="844" first="+ -" name="UnaryExpr_1"/>
        <g:ref id="845" reduce-id="846" reduce-count="2" first="+ -" name="UnaryExpr_2"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="847" first="+ -" name="UnaryExpr_2">
    <g:choice id="848" first="+ -">
      <g:string id="849" reduce-id="850" reduce-count="1" first="-">-</g:string>
      <g:string id="851" reduce-id="850" reduce-count="1" first="+">+</g:string>
    </g:choice>
  </g:production>
  <g:production id="852" first="$ ( (# . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" name="ValueExpr">
    <g:choice id="853" first="$ ( (# . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">
      <g:ref id="854" reduce-id="855" reduce-count="1" first="validate" name="ValidateExpr"/>
      <g:ref id="856" reduce-id="855" reduce-count="1" first="$ ( . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered" name="PathExpr"/>
      <g:ref id="857" reduce-id="855" reduce-count="1" first="(#" name="ExtensionExpr"/>
    </g:choice>
  </g:production>
  <g:production id="858" first="!= &lt; &lt;= = &gt; &gt;=" name="GeneralComp">
    <g:choice id="859" first="!= &lt; &lt;= = &gt; &gt;=">
      <g:string id="860" reduce-id="861" reduce-count="1" first="=">=</g:string>
      <g:string id="862" reduce-id="861" reduce-count="1" first="!=">!=</g:string>
      <g:string id="863" reduce-id="861" reduce-count="1" first="&lt;">&lt;</g:string>
      <g:string id="864" reduce-id="861" reduce-count="1" first="&lt;=">&lt;=</g:string>
      <g:string id="865" reduce-id="861" reduce-count="1" first="&gt;">&gt;</g:string>
      <g:string id="866" reduce-id="861" reduce-count="1" first="&gt;=">&gt;=</g:string>
    </g:choice>
  </g:production>
  <g:production id="867" first="eq ge gt le lt ne" name="ValueComp">
    <g:choice id="868" first="eq ge gt le lt ne">
      <g:string id="869" reduce-id="870" reduce-count="1" first="eq">eq</g:string>
      <g:string id="871" reduce-id="870" reduce-count="1" first="ne">ne</g:string>
      <g:string id="872" reduce-id="870" reduce-count="1" first="lt">lt</g:string>
      <g:string id="873" reduce-id="870" reduce-count="1" first="le">le</g:string>
      <g:string id="874" reduce-id="870" reduce-count="1" first="gt">gt</g:string>
      <g:string id="875" reduce-id="870" reduce-count="1" first="ge">ge</g:string>
    </g:choice>
  </g:production>
  <g:production id="876" first="&lt;&lt; &gt;&gt; is" name="NodeComp">
    <g:choice id="877" first="&lt;&lt; &gt;&gt; is">
      <g:string id="878" reduce-id="879" reduce-count="1" first="is">is</g:string>
      <g:string id="880" reduce-id="879" reduce-count="1" first="&lt;&lt;">&lt;&lt;</g:string>
      <g:string id="881" reduce-id="879" reduce-count="1" first="&gt;&gt;">&gt;&gt;</g:string>
    </g:choice>
  </g:production>
  <g:production id="882" first="validate" name="ValidateExpr">
    <g:string id="883" first="validate">validate</g:string>
    <g:ref id="884" name="ValidateExpr_1"/>
    <g:string id="885" first="{">{</g:string>
    <g:ref id="886" name="Expr"/>
    <g:string id="887" reduce-id="888" reduce-count="5" first="}">}</g:string>
  </g:production>
  <g:production id="889" name="ValidateExpr_1">
    <g:choice id="890">
      <g:sequence id="891" reduce-id="892" reduce-count="0">
      </g:sequence>
      <g:ref id="893" reduce-id="894" reduce-count="1" name="ValidationMode"/>
    </g:choice>
  </g:production>
  <g:production id="895" name="ValidationMode">
    <g:choice id="896">
      <g:string id="897" reduce-id="898" reduce-count="1" first="lax">lax</g:string>
      <g:string id="899" reduce-id="898" reduce-count="1" first="strict">strict</g:string>
    </g:choice>
  </g:production>
  <g:production id="900" first="(#" name="ExtensionExpr">
    <g:ref id="901" first="(#" name="ExtensionExpr_1"/>
    <g:string id="902" first="{">{</g:string>
    <g:ref id="903" name="ExtensionExpr_2"/>
    <g:string id="904" reduce-id="905" reduce-count="4" first="}">}</g:string>
  </g:production>
  <g:production id="906" first="(#" name="ExtensionExpr_1">
    <g:choice id="907" first="(#">
      <g:ref id="908" reduce-id="909" reduce-count="1" first="(#" name="Pragma"/>
      <g:sequence id="910" first="(#">
        <g:ref id="911" first="(#" name="ExtensionExpr_1"/>
        <g:ref id="912" reduce-id="913" reduce-count="2" first="(#" name="Pragma"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="914" name="ExtensionExpr_2">
    <g:choice id="915">
      <g:sequence id="916" reduce-id="917" reduce-count="0">
      </g:sequence>
      <g:ref id="918" reduce-id="919" reduce-count="1" name="Expr"/>
    </g:choice>
  </g:production>
  <g:production id="920" first="(#" name="Pragma">
    <g:string id="921" first="(#">(#</g:string>
    <g:ref id="922" name="Pragma_1"/>
    <g:ref id="923" first="QName" name="QName"/>
    <g:ref id="924" name="Pragma_2"/>
    <g:string id="925" reduce-id="926" reduce-count="5" first="#)">#)</g:string>
  </g:production>
  <g:production id="927" name="Pragma_1">
    <g:choice id="928">
      <g:sequence id="929" reduce-id="930" reduce-count="0">
      </g:sequence>
      <g:ref id="931" reduce-id="932" reduce-count="1" first="S" name="S"/>
    </g:choice>
  </g:production>
  <g:production id="933" name="Pragma_2">
    <g:choice id="934">
      <g:sequence id="935" reduce-id="936" reduce-count="0">
      </g:sequence>
      <g:sequence id="937">
        <g:ref id="938" first="S" name="S"/>
        <g:ref id="939" reduce-id="940" reduce-count="2" first="PragmaContents" name="PragmaContents"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="941" first="$ ( . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered" name="PathExpr">
    <g:choice id="942" first="$ ( . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered">
      <g:sequence id="943" first="/">
        <g:string id="944" first="/">/</g:string>
        <g:ref id="945" reduce-id="946" reduce-count="2" name="RelativePathExpr"/>
      </g:sequence>
      <g:sequence id="947" first="//">
        <g:string id="948" first="//">//</g:string>
        <g:ref id="949" reduce-id="946" reduce-count="2" name="RelativePathExpr"/>
      </g:sequence>
      <g:ref id="950" reduce-id="951" reduce-count="1" first="$ ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered" name="RelativePathExpr"/>
    </g:choice>
  </g:production>
  <g:production id="952" first="$ ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered" name="RelativePathExpr">
    <g:ref id="953" first="$ ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered" name="StepExpr"/>
    <g:ref id="954" reduce-id="955" reduce-count="2" first="%EPSILON / //" name="RelativePathExpr_1"/>
  </g:production>
  <g:production id="956" first="%EPSILON / //" name="RelativePathExpr_1">
    <g:choice id="957" first="%EPSILON / //">
      <g:sequence id="958" reduce-id="959" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="960" first="/ //">
        <g:ref id="961" first="/ //" name="RelativePathExpr_1"/>
        <g:ref id="962" first="/ //" name="RelativePathExpr_2"/>
        <g:ref id="963" reduce-id="964" reduce-count="3" first="$ ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered" name="StepExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="965" first="/ //" name="RelativePathExpr_2">
    <g:choice id="966" first="/ //">
      <g:string id="967" reduce-id="968" reduce-count="1" first="/">/</g:string>
      <g:string id="969" reduce-id="968" reduce-count="1" first="//">//</g:string>
    </g:choice>
  </g:production>
  <g:production id="970" first="$ ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered" name="StepExpr">
    <g:choice id="971" first="$ ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered">
      <g:ref id="972" reduce-id="973" reduce-count="1" first="$ ( . &lt; &lt;!-- &lt;? DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral attribute comment document element ordered processing-instruction text unordered" name="FilterExpr"/>
      <g:ref id="974" reduce-id="973" reduce-count="1" first=".. @ QName Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document-node element following following-sibling node parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text" name="AxisStep"/>
    </g:choice>
  </g:production>
  <g:production id="975" first=".. @ QName Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document-node element following following-sibling node parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text" name="AxisStep">
    <g:ref id="976" first=".. @ QName Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document-node element following following-sibling node parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text" name="AxisStep_1"/>
    <g:ref id="977" reduce-id="978" reduce-count="2" first="%EPSILON [" name="PredicateList"/>
  </g:production>
  <g:production id="979" first=".. @ QName Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document-node element following following-sibling node parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text" name="AxisStep_1">
    <g:choice id="980" first=".. @ QName Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document-node element following following-sibling node parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text">
      <g:ref id="981" reduce-id="982" reduce-count="1" first=".. ancestor ancestor-or-self parent preceding preceding-sibling" name="ReverseStep"/>
      <g:ref id="983" reduce-id="982" reduce-count="1" first="@ QName Wildcard attribute child comment descendant descendant-or-self document-node element following following-sibling node processing-instruction schema-attribute schema-element self text" name="ForwardStep"/>
    </g:choice>
  </g:production>
  <g:production id="984" first="@ QName Wildcard attribute child comment descendant descendant-or-self document-node element following following-sibling node processing-instruction schema-attribute schema-element self text" name="ForwardStep">
    <g:choice id="985" first="@ QName Wildcard attribute child comment descendant descendant-or-self document-node element following following-sibling node processing-instruction schema-attribute schema-element self text">
      <g:sequence id="986" first="attribute child descendant descendant-or-self following following-sibling self">
        <g:ref id="987" first="attribute child descendant descendant-or-self following following-sibling self" name="ForwardAxis"/>
        <g:ref id="988" reduce-id="989" reduce-count="2" first="QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="NodeTest"/>
      </g:sequence>
      <g:ref id="990" reduce-id="991" reduce-count="1" first="@ QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="AbbrevForwardStep"/>
    </g:choice>
  </g:production>
  <g:production id="992" first="attribute child descendant descendant-or-self following following-sibling self" name="ForwardAxis">
    <g:choice id="993" first="attribute child descendant descendant-or-self following following-sibling self">
      <g:sequence id="994" first="child">
        <g:string id="995" first="child">child</g:string>
        <g:string id="996" reduce-id="997" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="998" first="descendant">
        <g:string id="999" first="descendant">descendant</g:string>
        <g:string id="1000" reduce-id="997" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1001" first="attribute">
        <g:string id="1002" first="attribute">attribute</g:string>
        <g:string id="1003" reduce-id="997" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1004" first="self">
        <g:string id="1005" first="self">self</g:string>
        <g:string id="1006" reduce-id="997" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1007" first="descendant-or-self">
        <g:string id="1008" first="descendant-or-self">descendant-or-self</g:string>
        <g:string id="1009" reduce-id="997" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1010" first="following-sibling">
        <g:string id="1011" first="following-sibling">following-sibling</g:string>
        <g:string id="1012" reduce-id="997" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1013" first="following">
        <g:string id="1014" first="following">following</g:string>
        <g:string id="1015" reduce-id="997" reduce-count="2" first="::">::</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1016" first="@ QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="AbbrevForwardStep">
    <g:choice id="1017" first="@ QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">
      <g:ref id="1018" reduce-id="1019" reduce-count="1" first="QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="NodeTest"/>
      <g:sequence id="1020" first="@">
        <g:string id="1021" first="@">@</g:string>
        <g:ref id="1022" reduce-id="1023" reduce-count="2" name="NodeTest"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1024" first=".. ancestor ancestor-or-self parent preceding preceding-sibling" name="ReverseStep">
    <g:choice id="1025" first=".. ancestor ancestor-or-self parent preceding preceding-sibling">
      <g:sequence id="1026" first="ancestor ancestor-or-self parent preceding preceding-sibling">
        <g:ref id="1027" first="ancestor ancestor-or-self parent preceding preceding-sibling" name="ReverseAxis"/>
        <g:ref id="1028" reduce-id="1029" reduce-count="2" first="QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="NodeTest"/>
      </g:sequence>
      <g:ref id="1030" reduce-id="1031" reduce-count="1" first=".." name="AbbrevReverseStep"/>
    </g:choice>
  </g:production>
  <g:production id="1032" first="ancestor ancestor-or-self parent preceding preceding-sibling" name="ReverseAxis">
    <g:choice id="1033" first="ancestor ancestor-or-self parent preceding preceding-sibling">
      <g:sequence id="1034" first="parent">
        <g:string id="1035" first="parent">parent</g:string>
        <g:string id="1036" reduce-id="1037" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1038" first="ancestor">
        <g:string id="1039" first="ancestor">ancestor</g:string>
        <g:string id="1040" reduce-id="1037" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1041" first="preceding-sibling">
        <g:string id="1042" first="preceding-sibling">preceding-sibling</g:string>
        <g:string id="1043" reduce-id="1037" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1044" first="preceding">
        <g:string id="1045" first="preceding">preceding</g:string>
        <g:string id="1046" reduce-id="1037" reduce-count="2" first="::">::</g:string>
      </g:sequence>
      <g:sequence id="1047" first="ancestor-or-self">
        <g:string id="1048" first="ancestor-or-self">ancestor-or-self</g:string>
        <g:string id="1049" reduce-id="1037" reduce-count="2" first="::">::</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1050" first=".." name="AbbrevReverseStep">
    <g:string id="1051" reduce-id="1052" reduce-count="1" first="..">..</g:string>
  </g:production>
  <g:production id="1053" first="QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="NodeTest">
    <g:choice id="1054" first="QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">
      <g:ref id="1055" reduce-id="1056" reduce-count="1" first="attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="KindTest"/>
      <g:ref id="1057" reduce-id="1056" reduce-count="1" first="QName Wildcard" name="NameTest"/>
    </g:choice>
  </g:production>
  <g:production id="1058" first="QName Wildcard" name="NameTest">
    <g:choice id="1059" first="QName Wildcard">
      <g:ref id="1060" reduce-id="1061" reduce-count="1" first="QName" name="QName"/>
      <g:ref id="1062" reduce-id="1061" reduce-count="1" first="Wildcard" name="Wildcard"/>
    </g:choice>
  </g:production>
  <g:production id="1063" first="$ ( . &lt; &lt;!-- &lt;? DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral attribute comment document element ordered processing-instruction text unordered" name="FilterExpr">
    <g:ref id="1064" first="$ ( . &lt; &lt;!-- &lt;? DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral attribute comment document element ordered processing-instruction text unordered" name="PrimaryExpr"/>
    <g:ref id="1065" reduce-id="1066" reduce-count="2" first="%EPSILON [" name="PredicateList"/>
  </g:production>
  <g:production id="1067" first="%EPSILON [" name="PredicateList">
    <g:choice id="1068" first="%EPSILON [">
      <g:sequence id="1069" reduce-id="1070" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="1071" first="[">
        <g:ref id="1072" first="[" name="PredicateList"/>
        <g:ref id="1073" reduce-id="1074" reduce-count="2" first="[" name="Predicate"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1075" first="[" name="Predicate">
    <g:string id="1076" first="[">[</g:string>
    <g:ref id="1077" name="Expr"/>
    <g:string id="1078" reduce-id="1079" reduce-count="3" first="]">]</g:string>
  </g:production>
  <g:production id="1080" first="$ ( . &lt; &lt;!-- &lt;? DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral attribute comment document element ordered processing-instruction text unordered" name="PrimaryExpr">
    <g:choice id="1081" first="$ ( . &lt; &lt;!-- &lt;? DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral attribute comment document element ordered processing-instruction text unordered">
      <g:ref id="1082" reduce-id="1083" reduce-count="1" first="DecimalLiteral DoubleLiteral IntegerLiteral StringLiteral" name="Literal"/>
      <g:ref id="1084" reduce-id="1083" reduce-count="1" first="$" name="VarRef"/>
      <g:ref id="1085" reduce-id="1083" reduce-count="1" first="(" name="ParenthesizedExpr"/>
      <g:ref id="1086" reduce-id="1083" reduce-count="1" first="." name="ContextItemExpr"/>
      <g:ref id="1087" reduce-id="1083" reduce-count="1" first="QName" name="FunctionCall"/>
      <g:ref id="1088" reduce-id="1083" reduce-count="1" first="ordered" name="OrderedExpr"/>
      <g:ref id="1089" reduce-id="1083" reduce-count="1" first="unordered" name="UnorderedExpr"/>
      <g:ref id="1090" reduce-id="1083" reduce-count="1" first="&lt; &lt;!-- &lt;? attribute comment document element processing-instruction text" name="Constructor"/>
    </g:choice>
  </g:production>
  <g:production id="1091" first="DecimalLiteral DoubleLiteral IntegerLiteral StringLiteral" name="Literal">
    <g:choice id="1092" first="DecimalLiteral DoubleLiteral IntegerLiteral StringLiteral">
      <g:ref id="1093" reduce-id="1094" reduce-count="1" first="DecimalLiteral DoubleLiteral IntegerLiteral" name="NumericLiteral"/>
      <g:ref id="1095" reduce-id="1094" reduce-count="1" first="StringLiteral" name="StringLiteral"/>
    </g:choice>
  </g:production>
  <g:production id="1096" first="DecimalLiteral DoubleLiteral IntegerLiteral" name="NumericLiteral">
    <g:choice id="1097" first="DecimalLiteral DoubleLiteral IntegerLiteral">
      <g:ref id="1098" reduce-id="1099" reduce-count="1" first="IntegerLiteral" name="IntegerLiteral"/>
      <g:ref id="1100" reduce-id="1099" reduce-count="1" first="DecimalLiteral" name="DecimalLiteral"/>
      <g:ref id="1101" reduce-id="1099" reduce-count="1" first="DoubleLiteral" name="DoubleLiteral"/>
    </g:choice>
  </g:production>
  <g:production id="1102" first="$" name="VarRef">
    <g:string id="1103" first="$">$</g:string>
    <g:ref id="1104" reduce-id="1105" reduce-count="2" name="VarName"/>
  </g:production>
  <g:production id="1106" name="VarName">
    <g:ref id="1107" reduce-id="1108" reduce-count="1" first="QName" name="QName"/>
  </g:production>
  <g:production id="1109" first="(" name="ParenthesizedExpr">
    <g:string id="1110" first="(">(</g:string>
    <g:ref id="1111" name="ParenthesizedExpr_1"/>
    <g:string id="1112" reduce-id="1113" reduce-count="3" first=")">)</g:string>
  </g:production>
  <g:production id="1114" name="ParenthesizedExpr_1">
    <g:choice id="1115">
      <g:sequence id="1116" reduce-id="1117" reduce-count="0">
      </g:sequence>
      <g:ref id="1118" reduce-id="1119" reduce-count="1" name="Expr"/>
    </g:choice>
  </g:production>
  <g:production id="1120" first="." name="ContextItemExpr">
    <g:string id="1121" reduce-id="1122" reduce-count="1" first=".">.</g:string>
  </g:production>
  <g:production id="1123" first="ordered" name="OrderedExpr">
    <g:string id="1124" first="ordered">ordered</g:string>
    <g:string id="1125" first="{">{</g:string>
    <g:ref id="1126" name="Expr"/>
    <g:string id="1127" reduce-id="1128" reduce-count="4" first="}">}</g:string>
  </g:production>
  <g:production id="1129" first="unordered" name="UnorderedExpr">
    <g:string id="1130" first="unordered">unordered</g:string>
    <g:string id="1131" first="{">{</g:string>
    <g:ref id="1132" name="Expr"/>
    <g:string id="1133" reduce-id="1134" reduce-count="4" first="}">}</g:string>
  </g:production>
  <g:production id="1135" first="QName" name="FunctionCall">
    <g:ref id="1136" first="QName" name="QName"/>
    <g:string id="1137" first="(">(</g:string>
    <g:ref id="1138" name="FunctionCall_1"/>
    <g:string id="1139" reduce-id="1140" reduce-count="4" first=")">)</g:string>
  </g:production>
  <g:production id="1141" name="FunctionCall_1">
    <g:choice id="1142">
      <g:sequence id="1143" reduce-id="1144" reduce-count="0">
      </g:sequence>
      <g:sequence id="1145">
        <g:ref id="1146" name="ExprSingle"/>
        <g:ref id="1147" reduce-id="1148" reduce-count="2" first="%EPSILON ," name="FunctionCall_2"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1149" first="%EPSILON ," name="FunctionCall_2">
    <g:choice id="1150" first="%EPSILON ,">
      <g:sequence id="1151" reduce-id="1152" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="1153" first=",">
        <g:ref id="1154" first="," name="FunctionCall_2"/>
        <g:string id="1155" first=",">,</g:string>
        <g:ref id="1156" reduce-id="1157" reduce-count="3" name="ExprSingle"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1158" first="&lt; &lt;!-- &lt;? attribute comment document element processing-instruction text" name="Constructor">
    <g:choice id="1159" first="&lt; &lt;!-- &lt;? attribute comment document element processing-instruction text">
      <g:ref id="1160" reduce-id="1161" reduce-count="1" first="&lt; &lt;!-- &lt;?" name="DirectConstructor"/>
      <g:ref id="1162" reduce-id="1161" reduce-count="1" first="attribute comment document element processing-instruction text" name="ComputedConstructor"/>
    </g:choice>
  </g:production>
  <g:production id="1163" first="&lt; &lt;!-- &lt;?" name="DirectConstructor">
    <g:choice id="1164" first="&lt; &lt;!-- &lt;?">
      <g:ref id="1165" reduce-id="1166" reduce-count="1" first="&lt;" name="DirElemConstructor"/>
      <g:ref id="1167" reduce-id="1166" reduce-count="1" first="&lt;!--" name="DirCommentConstructor"/>
      <g:ref id="1168" reduce-id="1166" reduce-count="1" first="&lt;?" name="DirPIConstructor"/>
    </g:choice>
  </g:production>
  <g:production id="1169" first="&lt;" name="DirElemConstructor">
    <g:string id="1170" first="&lt;">&lt;</g:string>
    <g:ref id="1171" first="QName" name="QName"/>
    <g:ref id="1172" name="DirAttributeList"/>
    <g:ref id="1173" reduce-id="1174" reduce-count="4" first="/&gt; &gt;" name="DirElemConstructor_1"/>
  </g:production>
  <g:production id="1175" first="/&gt; &gt;" name="DirElemConstructor_1">
    <g:choice id="1176" first="/&gt; &gt;">
      <g:string id="1177" reduce-id="1178" reduce-count="1" first="/&gt;">/&gt;</g:string>
      <g:sequence id="1179" first="&gt;">
        <g:string id="1180" first="&gt;">&gt;</g:string>
        <g:ref id="1181" name="DirElemConstructor_2"/>
        <g:string id="1182" first="&lt;/">&lt;/</g:string>
        <g:ref id="1183" first="QName" name="QName"/>
        <g:ref id="1184" name="DirElemConstructor_3"/>
        <g:string id="1185" reduce-id="1186" reduce-count="6" first="&gt;">&gt;</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1187" name="DirElemConstructor_2">
    <g:choice id="1188">
      <g:sequence id="1189" reduce-id="1190" reduce-count="0">
      </g:sequence>
      <g:sequence id="1191">
        <g:ref id="1192" name="DirElemConstructor_2"/>
        <g:ref id="1193" reduce-id="1194" reduce-count="2" first="&lt; &lt;!-- &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}" name="DirElemContent"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1195" name="DirElemConstructor_3">
    <g:choice id="1196">
      <g:sequence id="1197" reduce-id="1198" reduce-count="0">
      </g:sequence>
      <g:ref id="1199" reduce-id="1200" reduce-count="1" first="S" name="S"/>
    </g:choice>
  </g:production>
  <g:production id="1201" name="DirAttributeList">
    <g:choice id="1202">
      <g:sequence id="1203" reduce-id="1204" reduce-count="0">
      </g:sequence>
      <g:sequence id="1205">
        <g:ref id="1206" name="DirAttributeList"/>
        <g:ref id="1207" first="S" name="S"/>
        <g:ref id="1208" reduce-id="1209" reduce-count="3" name="DirAttributeList_1"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1210" name="DirAttributeList_1">
    <g:choice id="1211">
      <g:sequence id="1212" reduce-id="1213" reduce-count="0">
      </g:sequence>
      <g:sequence id="1214">
        <g:ref id="1215" first="QName" name="QName"/>
        <g:ref id="1216" name="DirAttributeList_2"/>
        <g:string id="1217" first="=">=</g:string>
        <g:ref id="1218" name="DirAttributeList_3"/>
        <g:ref id="1219" reduce-id="1220" reduce-count="5" first="&quot; '" name="DirAttributeValue"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1221" name="DirAttributeList_2">
    <g:choice id="1222">
      <g:sequence id="1223" reduce-id="1224" reduce-count="0">
      </g:sequence>
      <g:ref id="1225" reduce-id="1226" reduce-count="1" first="S" name="S"/>
    </g:choice>
  </g:production>
  <g:production id="1227" name="DirAttributeList_3">
    <g:choice id="1228">
      <g:sequence id="1229" reduce-id="1230" reduce-count="0">
      </g:sequence>
      <g:ref id="1231" reduce-id="1232" reduce-count="1" first="S" name="S"/>
    </g:choice>
  </g:production>
  <g:production id="1233" first="&quot; '" name="DirAttributeValue">
    <g:choice id="1234" first="&quot; '">
      <g:sequence id="1235" first="&quot;">
        <g:string id="1236" first="&quot;">&quot;</g:string>
        <g:ref id="1237" name="DirAttributeValue_1"/>
        <g:string id="1238" reduce-id="1239" reduce-count="3" first="&quot;">&quot;</g:string>
      </g:sequence>
      <g:sequence id="1240" first="'">
        <g:string id="1241" first="'">'</g:string>
        <g:ref id="1242" name="DirAttributeValue_3"/>
        <g:string id="1243" reduce-id="1239" reduce-count="3" first="'">'</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1244" name="DirAttributeValue_1">
    <g:choice id="1245">
      <g:sequence id="1246" reduce-id="1247" reduce-count="0">
      </g:sequence>
      <g:sequence id="1248">
        <g:ref id="1249" name="DirAttributeValue_1"/>
        <g:ref id="1250" reduce-id="1251" reduce-count="2" first="CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}" name="DirAttributeValue_2"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1252" first="CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}" name="DirAttributeValue_2">
    <g:choice id="1253" first="CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">
      <g:ref id="1254" reduce-id="1255" reduce-count="1" first="EscapeQuot" name="EscapeQuot"/>
      <g:ref id="1256" reduce-id="1255" reduce-count="1" first="CharRef PredefinedEntityRef QuotAttrContentChar { {{ }}" name="QuotAttrValueContent"/>
    </g:choice>
  </g:production>
  <g:production id="1257" name="DirAttributeValue_3">
    <g:choice id="1258">
      <g:sequence id="1259" reduce-id="1260" reduce-count="0">
      </g:sequence>
      <g:sequence id="1261">
        <g:ref id="1262" name="DirAttributeValue_3"/>
        <g:ref id="1263" reduce-id="1264" reduce-count="2" first="AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}" name="DirAttributeValue_4"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1265" first="AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}" name="DirAttributeValue_4">
    <g:choice id="1266" first="AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">
      <g:ref id="1267" reduce-id="1268" reduce-count="1" first="EscapeApos" name="EscapeApos"/>
      <g:ref id="1269" reduce-id="1268" reduce-count="1" first="AposAttrContentChar CharRef PredefinedEntityRef { {{ }}" name="AposAttrValueContent"/>
    </g:choice>
  </g:production>
  <g:production id="1270" first="CharRef PredefinedEntityRef QuotAttrContentChar { {{ }}" name="QuotAttrValueContent">
    <g:choice id="1271" first="CharRef PredefinedEntityRef QuotAttrContentChar { {{ }}">
      <g:ref id="1272" reduce-id="1273" reduce-count="1" first="QuotAttrContentChar" name="QuotAttrContentChar"/>
      <g:ref id="1274" reduce-id="1273" reduce-count="1" first="CharRef PredefinedEntityRef { {{ }}" name="CommonContent"/>
    </g:choice>
  </g:production>
  <g:production id="1275" first="AposAttrContentChar CharRef PredefinedEntityRef { {{ }}" name="AposAttrValueContent">
    <g:choice id="1276" first="AposAttrContentChar CharRef PredefinedEntityRef { {{ }}">
      <g:ref id="1277" reduce-id="1278" reduce-count="1" first="AposAttrContentChar" name="AposAttrContentChar"/>
      <g:ref id="1279" reduce-id="1278" reduce-count="1" first="CharRef PredefinedEntityRef { {{ }}" name="CommonContent"/>
    </g:choice>
  </g:production>
  <g:production id="1280" first="&lt; &lt;!-- &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}" name="DirElemContent">
    <g:choice id="1281" first="&lt; &lt;!-- &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">
      <g:ref id="1282" reduce-id="1283" reduce-count="1" first="&lt; &lt;!-- &lt;?" name="DirectConstructor"/>
      <g:ref id="1284" reduce-id="1283" reduce-count="1" first="CDataSection" name="CDataSection"/>
      <g:ref id="1285" reduce-id="1283" reduce-count="1" first="CharRef PredefinedEntityRef { {{ }}" name="CommonContent"/>
      <g:ref id="1286" reduce-id="1283" reduce-count="1" first="ElementContentChar" name="ElementContentChar"/>
    </g:choice>
  </g:production>
  <g:production id="1287" first="CharRef PredefinedEntityRef { {{ }}" name="CommonContent">
    <g:choice id="1288" first="CharRef PredefinedEntityRef { {{ }}">
      <g:ref id="1289" reduce-id="1290" reduce-count="1" first="PredefinedEntityRef" name="PredefinedEntityRef"/>
      <g:ref id="1291" reduce-id="1290" reduce-count="1" first="CharRef" name="CharRef"/>
      <g:string id="1292" reduce-id="1290" reduce-count="1" first="{{">{{</g:string>
      <g:string id="1293" reduce-id="1290" reduce-count="1" first="}}">}}</g:string>
      <g:ref id="1294" reduce-id="1290" reduce-count="1" first="{" name="EnclosedExpr"/>
    </g:choice>
  </g:production>
  <g:production id="1295" first="&lt;!--" name="DirCommentConstructor">
    <g:string id="1296" first="&lt;!--">&lt;!--</g:string>
    <g:ref id="1297" first="DirCommentContents" name="DirCommentContents"/>
    <g:string id="1298" reduce-id="1299" reduce-count="3" first="--&gt;">--&gt;</g:string>
  </g:production>
  <g:production id="1300" first="&lt;?" name="DirPIConstructor">
    <g:string id="1301" first="&lt;?">&lt;?</g:string>
    <g:ref id="1302" first="PITarget" name="PITarget"/>
    <g:ref id="1303" name="DirPIConstructor_1"/>
    <g:string id="1304" reduce-id="1305" reduce-count="4" first="?&gt;">?&gt;</g:string>
  </g:production>
  <g:production id="1306" name="DirPIConstructor_1">
    <g:choice id="1307">
      <g:sequence id="1308" reduce-id="1309" reduce-count="0">
      </g:sequence>
      <g:sequence id="1310">
        <g:ref id="1311" first="S" name="S"/>
        <g:ref id="1312" reduce-id="1313" reduce-count="2" first="DirPIContents" name="DirPIContents"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1314" first="attribute comment document element processing-instruction text" name="ComputedConstructor">
    <g:choice id="1315" first="attribute comment document element processing-instruction text">
      <g:ref id="1316" reduce-id="1317" reduce-count="1" first="document" name="CompDocConstructor"/>
      <g:ref id="1318" reduce-id="1317" reduce-count="1" first="element" name="CompElemConstructor"/>
      <g:ref id="1319" reduce-id="1317" reduce-count="1" first="attribute" name="CompAttrConstructor"/>
      <g:ref id="1320" reduce-id="1317" reduce-count="1" first="text" name="CompTextConstructor"/>
      <g:ref id="1321" reduce-id="1317" reduce-count="1" first="comment" name="CompCommentConstructor"/>
      <g:ref id="1322" reduce-id="1317" reduce-count="1" first="processing-instruction" name="CompPIConstructor"/>
    </g:choice>
  </g:production>
  <g:production id="1323" first="document" name="CompDocConstructor">
    <g:string id="1324" first="document">document</g:string>
    <g:string id="1325" first="{">{</g:string>
    <g:ref id="1326" name="Expr"/>
    <g:string id="1327" reduce-id="1328" reduce-count="4" first="}">}</g:string>
  </g:production>
  <g:production id="1329" first="element" name="CompElemConstructor">
    <g:string id="1330" first="element">element</g:string>
    <g:ref id="1331" name="CompElemConstructor_1"/>
    <g:string id="1332" first="{">{</g:string>
    <g:ref id="1333" name="CompElemConstructor_2"/>
    <g:string id="1334" reduce-id="1335" reduce-count="5" first="}">}</g:string>
  </g:production>
  <g:production id="1336" name="CompElemConstructor_1">
    <g:choice id="1337">
      <g:ref id="1338" reduce-id="1339" reduce-count="1" first="QName" name="QName"/>
      <g:sequence id="1340">
        <g:string id="1341" first="{">{</g:string>
        <g:ref id="1342" name="Expr"/>
        <g:string id="1343" reduce-id="1344" reduce-count="3" first="}">}</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1345" name="CompElemConstructor_2">
    <g:choice id="1346">
      <g:sequence id="1347" reduce-id="1348" reduce-count="0">
      </g:sequence>
      <g:ref id="1349" reduce-id="1350" reduce-count="1" name="ContentExpr"/>
    </g:choice>
  </g:production>
  <g:production id="1351" name="ContentExpr">
    <g:ref id="1352" reduce-id="1353" reduce-count="1" name="Expr"/>
  </g:production>
  <g:production id="1354" first="attribute" name="CompAttrConstructor">
    <g:string id="1355" first="attribute">attribute</g:string>
    <g:ref id="1356" name="CompAttrConstructor_1"/>
    <g:string id="1357" first="{">{</g:string>
    <g:ref id="1358" name="CompAttrConstructor_2"/>
    <g:string id="1359" reduce-id="1360" reduce-count="5" first="}">}</g:string>
  </g:production>
  <g:production id="1361" name="CompAttrConstructor_1">
    <g:choice id="1362">
      <g:ref id="1363" reduce-id="1364" reduce-count="1" first="QName" name="QName"/>
      <g:sequence id="1365">
        <g:string id="1366" first="{">{</g:string>
        <g:ref id="1367" name="Expr"/>
        <g:string id="1368" reduce-id="1369" reduce-count="3" first="}">}</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1370" name="CompAttrConstructor_2">
    <g:choice id="1371">
      <g:sequence id="1372" reduce-id="1373" reduce-count="0">
      </g:sequence>
      <g:ref id="1374" reduce-id="1375" reduce-count="1" name="Expr"/>
    </g:choice>
  </g:production>
  <g:production id="1376" first="text" name="CompTextConstructor">
    <g:string id="1377" first="text">text</g:string>
    <g:string id="1378" first="{">{</g:string>
    <g:ref id="1379" name="Expr"/>
    <g:string id="1380" reduce-id="1381" reduce-count="4" first="}">}</g:string>
  </g:production>
  <g:production id="1382" first="comment" name="CompCommentConstructor">
    <g:string id="1383" first="comment">comment</g:string>
    <g:string id="1384" first="{">{</g:string>
    <g:ref id="1385" name="Expr"/>
    <g:string id="1386" reduce-id="1387" reduce-count="4" first="}">}</g:string>
  </g:production>
  <g:production id="1388" first="processing-instruction" name="CompPIConstructor">
    <g:string id="1389" first="processing-instruction">processing-instruction</g:string>
    <g:ref id="1390" name="CompPIConstructor_1"/>
    <g:string id="1391" first="{">{</g:string>
    <g:ref id="1392" name="CompPIConstructor_2"/>
    <g:string id="1393" reduce-id="1394" reduce-count="5" first="}">}</g:string>
  </g:production>
  <g:production id="1395" name="CompPIConstructor_1">
    <g:choice id="1396">
      <g:ref id="1397" reduce-id="1398" reduce-count="1" first="NCName" name="NCName"/>
      <g:sequence id="1399">
        <g:string id="1400" first="{">{</g:string>
        <g:ref id="1401" name="Expr"/>
        <g:string id="1402" reduce-id="1403" reduce-count="3" first="}">}</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1404" name="CompPIConstructor_2">
    <g:choice id="1405">
      <g:sequence id="1406" reduce-id="1407" reduce-count="0">
      </g:sequence>
      <g:ref id="1408" reduce-id="1409" reduce-count="1" name="Expr"/>
    </g:choice>
  </g:production>
  <g:production id="1410" name="SingleType">
    <g:ref id="1411" name="AtomicType"/>
    <g:ref id="1412" reduce-id="1413" reduce-count="2" first="%EPSILON ?" name="SingleType_1"/>
  </g:production>
  <g:production id="1414" first="%EPSILON ?" name="SingleType_1">
    <g:choice id="1415" first="%EPSILON ?">
      <g:sequence id="1416" reduce-id="1417" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:string id="1418" reduce-id="1419" reduce-count="1" first="?">?</g:string>
    </g:choice>
  </g:production>
  <g:production id="1420" first="as" name="TypeDeclaration">
    <g:string id="1421" first="as">as</g:string>
    <g:ref id="1422" reduce-id="1423" reduce-count="2" name="SequenceType"/>
  </g:production>
  <g:production id="1424" first="QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text" name="SequenceType">
    <g:choice id="1425" first="QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text">
      <g:sequence id="1426" first="empty-sequence">
        <g:string id="1427" first="empty-sequence">empty-sequence</g:string>
        <g:string id="1428" first="(">(</g:string>
        <g:string id="1429" reduce-id="1430" reduce-count="3" first=")">)</g:string>
      </g:sequence>
      <g:sequence id="1431" first="QName attribute comment document-node element item node processing-instruction schema-attribute schema-element text">
        <g:ref id="1432" first="QName attribute comment document-node element item node processing-instruction schema-attribute schema-element text" name="ItemType"/>
        <g:ref id="1433" reduce-id="1434" reduce-count="2" first="%EPSILON ? PlusOccurreneIndicator StarOccurreneIndicator" name="SequenceType_1"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1435" first="%EPSILON ? PlusOccurreneIndicator StarOccurreneIndicator" name="SequenceType_1">
    <g:choice id="1436" first="%EPSILON ? PlusOccurreneIndicator StarOccurreneIndicator">
      <g:sequence id="1437" reduce-id="1438" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:ref id="1439" reduce-id="1440" reduce-count="1" first="? PlusOccurreneIndicator StarOccurreneIndicator" name="OccurrenceIndicator"/>
    </g:choice>
  </g:production>
  <g:production id="1441" first="? PlusOccurreneIndicator StarOccurreneIndicator" name="OccurrenceIndicator">
    <g:choice id="1442" first="? PlusOccurreneIndicator StarOccurreneIndicator">
      <g:string id="1443" reduce-id="1444" reduce-count="1" first="?">?</g:string>
      <g:ref id="1445" reduce-id="1444" reduce-count="1" first="StarOccurreneIndicator" name="StarOccurreneIndicator"/>
      <g:ref id="1446" reduce-id="1444" reduce-count="1" first="PlusOccurreneIndicator" name="PlusOccurreneIndicator"/>
    </g:choice>
  </g:production>
  <g:production id="1447" first="QName attribute comment document-node element item node processing-instruction schema-attribute schema-element text" name="ItemType">
    <g:choice id="1448" first="QName attribute comment document-node element item node processing-instruction schema-attribute schema-element text">
      <g:ref id="1449" reduce-id="1450" reduce-count="1" first="attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="KindTest"/>
      <g:sequence id="1451" first="item">
        <g:string id="1452" first="item">item</g:string>
        <g:string id="1453" first="(">(</g:string>
        <g:string id="1454" reduce-id="1455" reduce-count="3" first=")">)</g:string>
      </g:sequence>
      <g:ref id="1456" reduce-id="1450" reduce-count="1" first="QName" name="AtomicType"/>
    </g:choice>
  </g:production>
  <g:production id="1457" first="QName" name="AtomicType">
    <g:ref id="1458" reduce-id="1459" reduce-count="1" first="QName" name="QName"/>
  </g:production>
  <g:production id="1460" first="attribute comment document-node element node processing-instruction schema-attribute schema-element text" name="KindTest">
    <g:choice id="1461" first="attribute comment document-node element node processing-instruction schema-attribute schema-element text">
      <g:ref id="1462" reduce-id="1463" reduce-count="1" first="document-node" name="DocumentTest"/>
      <g:ref id="1464" reduce-id="1463" reduce-count="1" first="element" name="ElementTest"/>
      <g:ref id="1465" reduce-id="1463" reduce-count="1" first="attribute" name="AttributeTest"/>
      <g:ref id="1466" reduce-id="1463" reduce-count="1" first="schema-element" name="SchemaElementTest"/>
      <g:ref id="1467" reduce-id="1463" reduce-count="1" first="schema-attribute" name="SchemaAttributeTest"/>
      <g:ref id="1468" reduce-id="1463" reduce-count="1" first="processing-instruction" name="PITest"/>
      <g:ref id="1469" reduce-id="1463" reduce-count="1" first="comment" name="CommentTest"/>
      <g:ref id="1470" reduce-id="1463" reduce-count="1" first="text" name="TextTest"/>
      <g:ref id="1471" reduce-id="1463" reduce-count="1" first="node" name="AnyKindTest"/>
    </g:choice>
  </g:production>
  <g:production id="1472" first="node" name="AnyKindTest">
    <g:string id="1473" first="node">node</g:string>
    <g:string id="1474" first="(">(</g:string>
    <g:string id="1475" reduce-id="1476" reduce-count="3" first=")">)</g:string>
  </g:production>
  <g:production id="1477" first="document-node" name="DocumentTest">
    <g:string id="1478" first="document-node">document-node</g:string>
    <g:string id="1479" first="(">(</g:string>
    <g:ref id="1480" name="DocumentTest_1"/>
    <g:string id="1481" reduce-id="1482" reduce-count="4" first=")">)</g:string>
  </g:production>
  <g:production id="1483" name="DocumentTest_1">
    <g:choice id="1484">
      <g:sequence id="1485" reduce-id="1486" reduce-count="0">
      </g:sequence>
      <g:ref id="1487" reduce-id="1488" reduce-count="1" name="ElementTest"/>
      <g:ref id="1489" reduce-id="1488" reduce-count="1" name="SchemaElementTest"/>
    </g:choice>
  </g:production>
  <g:production id="1490" first="text" name="TextTest">
    <g:string id="1491" first="text">text</g:string>
    <g:string id="1492" first="(">(</g:string>
    <g:string id="1493" reduce-id="1494" reduce-count="3" first=")">)</g:string>
  </g:production>
  <g:production id="1495" first="comment" name="CommentTest">
    <g:string id="1496" first="comment">comment</g:string>
    <g:string id="1497" first="(">(</g:string>
    <g:string id="1498" reduce-id="1499" reduce-count="3" first=")">)</g:string>
  </g:production>
  <g:production id="1500" first="processing-instruction" name="PITest">
    <g:string id="1501" first="processing-instruction">processing-instruction</g:string>
    <g:string id="1502" first="(">(</g:string>
    <g:ref id="1503" name="PITest_1"/>
    <g:string id="1504" reduce-id="1505" reduce-count="4" first=")">)</g:string>
  </g:production>
  <g:production id="1506" name="PITest_1">
    <g:choice id="1507">
      <g:sequence id="1508" reduce-id="1509" reduce-count="0">
      </g:sequence>
      <g:ref id="1510" reduce-id="1511" reduce-count="1" first="NCName" name="NCName"/>
      <g:ref id="1512" reduce-id="1511" reduce-count="1" first="StringLiteral" name="StringLiteral"/>
    </g:choice>
  </g:production>
  <g:production id="1513" first="attribute" name="AttributeTest">
    <g:string id="1514" first="attribute">attribute</g:string>
    <g:string id="1515" first="(">(</g:string>
    <g:ref id="1516" name="AttributeTest_1"/>
    <g:string id="1517" reduce-id="1518" reduce-count="4" first=")">)</g:string>
  </g:production>
  <g:production id="1519" name="AttributeTest_1">
    <g:choice id="1520">
      <g:sequence id="1521" reduce-id="1522" reduce-count="0">
      </g:sequence>
      <g:sequence id="1523">
        <g:ref id="1524" name="AttribNameOrWildcard"/>
        <g:ref id="1525" reduce-id="1526" reduce-count="2" first="%EPSILON ," name="AttributeTest_2"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1527" first="%EPSILON ," name="AttributeTest_2">
    <g:choice id="1528" first="%EPSILON ,">
      <g:sequence id="1529" reduce-id="1530" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="1531" first=",">
        <g:string id="1532" first=",">,</g:string>
        <g:ref id="1533" reduce-id="1534" reduce-count="2" name="TypeName"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1535" name="AttribNameOrWildcard">
    <g:choice id="1536">
      <g:ref id="1537" reduce-id="1538" reduce-count="1" name="AttributeName"/>
      <g:string id="1539" reduce-id="1538" reduce-count="1" first="*">*</g:string>
    </g:choice>
  </g:production>
  <g:production id="1540" first="schema-attribute" name="SchemaAttributeTest">
    <g:string id="1541" first="schema-attribute">schema-attribute</g:string>
    <g:string id="1542" first="(">(</g:string>
    <g:ref id="1543" name="AttributeDeclaration"/>
    <g:string id="1544" reduce-id="1545" reduce-count="4" first=")">)</g:string>
  </g:production>
  <g:production id="1546" name="AttributeDeclaration">
    <g:ref id="1547" reduce-id="1548" reduce-count="1" name="AttributeName"/>
  </g:production>
  <g:production id="1549" first="element" name="ElementTest">
    <g:string id="1550" first="element">element</g:string>
    <g:string id="1551" first="(">(</g:string>
    <g:ref id="1552" name="ElementTest_1"/>
    <g:string id="1553" reduce-id="1554" reduce-count="4" first=")">)</g:string>
  </g:production>
  <g:production id="1555" name="ElementTest_1">
    <g:choice id="1556">
      <g:sequence id="1557" reduce-id="1558" reduce-count="0">
      </g:sequence>
      <g:sequence id="1559">
        <g:ref id="1560" name="ElementNameOrWildcard"/>
        <g:ref id="1561" reduce-id="1562" reduce-count="2" first="%EPSILON ," name="ElementTest_2"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1563" first="%EPSILON ," name="ElementTest_2">
    <g:choice id="1564" first="%EPSILON ,">
      <g:sequence id="1565" reduce-id="1566" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:sequence id="1567" first=",">
        <g:string id="1568" first=",">,</g:string>
        <g:ref id="1569" name="TypeName"/>
        <g:ref id="1570" reduce-id="1571" reduce-count="3" first="%EPSILON ?" name="ElementTest_3"/>
      </g:sequence>
    </g:choice>
  </g:production>
  <g:production id="1572" first="%EPSILON ?" name="ElementTest_3">
    <g:choice id="1573" first="%EPSILON ?">
      <g:sequence id="1574" reduce-id="1575" reduce-count="0" first="%EPSILON">
      </g:sequence>
      <g:string id="1576" reduce-id="1577" reduce-count="1" first="?">?</g:string>
    </g:choice>
  </g:production>
  <g:production id="1578" name="ElementNameOrWildcard">
    <g:choice id="1579">
      <g:ref id="1580" reduce-id="1581" reduce-count="1" name="ElementName"/>
      <g:string id="1582" reduce-id="1581" reduce-count="1" first="*">*</g:string>
    </g:choice>
  </g:production>
  <g:production id="1583" first="schema-element" name="SchemaElementTest">
    <g:string id="1584" first="schema-element">schema-element</g:string>
    <g:string id="1585" first="(">(</g:string>
    <g:ref id="1586" name="ElementDeclaration"/>
    <g:string id="1587" reduce-id="1588" reduce-count="4" first=")">)</g:string>
  </g:production>
  <g:production id="1589" name="ElementDeclaration">
    <g:ref id="1590" reduce-id="1591" reduce-count="1" name="ElementName"/>
  </g:production>
  <g:production id="1592" name="AttributeName">
    <g:ref id="1593" reduce-id="1594" reduce-count="1" first="QName" name="QName"/>
  </g:production>
  <g:production id="1595" name="ElementName">
    <g:ref id="1596" reduce-id="1597" reduce-count="1" first="QName" name="QName"/>
  </g:production>
  <g:production id="1598" name="TypeName">
    <g:ref id="1599" reduce-id="1600" reduce-count="1" first="QName" name="QName"/>
  </g:production>
  <g:production id="1601" first="StringLiteral" name="URILiteral">
    <g:ref id="1602" reduce-id="1603" reduce-count="1" first="StringLiteral" name="StringLiteral"/>
  </g:production>
  <parser>
    <state id="0">
      <item id="3" lookahead="%OTHER">Goal ::= <dot>.</dot> XQuery</item>
      <item id="6" lookahead="%OTHER">XQuery ::= <dot>.</dot> Module EOF</item>
      <item id="10" lookahead="%WS EOF">Module ::= <dot>.</dot> Module_1 Module_2</item>
      <item id="17" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Module_1 ::= <dot>.</dot> VersionDecl</item>
      <item id="25" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">VersionDecl ::= <dot>.</dot> 'xquery' 'version' StringLiteral VersionDecl_1 Separator</item>
      <item id="16" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Module_1 ::= <dot>.</dot></item>
      <goto on="XQuery" to="333"/>
      <goto on="Module" to="193"/>
      <goto on="Module_1" to="1"/>
      <goto on="VersionDecl" to="334"/>
      <shift on="xquery" to="194"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" symbol="Module_1"/>
      <accept on="Goal"/>
    </state>
    <state id="1">
      <item id="11" lookahead="%WS EOF">Module ::= Module_1 <dot>.</dot> Module_2</item>
      <item id="21" lookahead="%WS EOF">Module_2 ::= <dot>.</dot> LibraryModule</item>
      <item id="23" lookahead="%WS EOF">Module_2 ::= <dot>.</dot> MainModule</item>
      <item id="40" lookahead="%WS EOF">MainModule ::= <dot>.</dot> Prolog QueryBody</item>
      <item id="44" lookahead="%WS EOF">LibraryModule ::= <dot>.</dot> ModuleDecl Prolog</item>
      <item id="48" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">ModuleDecl ::= <dot>.</dot> 'module' 'namespace' NCName '=' URILiteral Separator</item>
      <item id="56" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog ::= <dot>.</dot> Prolog_1 Prolog_3</item>
      <item id="64" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_1 ::= <dot>.</dot> Prolog_1 Prolog_2 Separator</item>
      <item id="62" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_1 ::= <dot>.</dot></item>
      <goto on="Module_2" to="336"/>
      <goto on="MainModule" to="337"/>
      <goto on="LibraryModule" to="337"/>
      <goto on="ModuleDecl" to="2"/>
      <goto on="Prolog" to="3"/>
      <goto on="Prolog_1" to="4"/>
      <shift on="module" to="195"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" symbol="Prolog_1"/>
    </state>
    <state id="2">
      <item id="45" lookahead="%WS EOF">LibraryModule ::= ModuleDecl <dot>.</dot> Prolog</item>
      <item id="56" lookahead="%WS EOF">Prolog ::= <dot>.</dot> Prolog_1 Prolog_3</item>
      <item id="64" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">Prolog_1 ::= <dot>.</dot> Prolog_1 Prolog_2 Separator</item>
      <item id="62" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">Prolog_1 ::= <dot>.</dot></item>
      <goto on="Prolog" to="338"/>
      <goto on="Prolog_1" to="4"/>
      <reduce on="EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import" symbol="Prolog_1"/>
    </state>
    <state id="3">
      <item id="41" lookahead="%WS EOF">MainModule ::= Prolog <dot>.</dot> QueryBody</item>
      <item id="348" lookahead="%WS EOF">QueryBody ::= <dot>.</dot> Expr</item>
      <item id="351" lookahead="%WS EOF">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , EOF">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , EOF">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , EOF">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , EOF">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , EOF">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , EOF">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , EOF">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , EOF">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , EOF">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , EOF">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , EOF or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , EOF and or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="QueryBody" to="339"/>
      <goto on="Expr" to="340"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="4">
      <item id="57" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog ::= Prolog_1 <dot>.</dot> Prolog_3</item>
      <item id="65" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_1 ::= Prolog_1 <dot>.</dot> Prolog_2 Separator</item>
      <item id="70" lookahead="%WS ;">Prolog_2 ::= <dot>.</dot> DefaultNamespaceDecl</item>
      <item id="72" lookahead="%WS ;">Prolog_2 ::= <dot>.</dot> Setter</item>
      <item id="73" lookahead="%WS ;">Prolog_2 ::= <dot>.</dot> NamespaceDecl</item>
      <item id="74" lookahead="%WS ;">Prolog_2 ::= <dot>.</dot> Import</item>
      <item id="80" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare function declare option declare variable descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_3 ::= <dot>.</dot> Prolog_3 Prolog_4 Separator</item>
      <item id="92" lookahead="%WS ;">Setter ::= <dot>.</dot> BoundarySpaceDecl</item>
      <item id="94" lookahead="%WS ;">Setter ::= <dot>.</dot> DefaultCollationDecl</item>
      <item id="95" lookahead="%WS ;">Setter ::= <dot>.</dot> BaseURIDecl</item>
      <item id="96" lookahead="%WS ;">Setter ::= <dot>.</dot> ConstructionDecl</item>
      <item id="97" lookahead="%WS ;">Setter ::= <dot>.</dot> OrderingModeDecl</item>
      <item id="98" lookahead="%WS ;">Setter ::= <dot>.</dot> EmptyOrderDecl</item>
      <item id="99" lookahead="%WS ;">Setter ::= <dot>.</dot> CopyNamespacesDecl</item>
      <item id="102" lookahead="%WS ;">Import ::= <dot>.</dot> SchemaImport</item>
      <item id="104" lookahead="%WS ;">Import ::= <dot>.</dot> ModuleImport</item>
      <item id="109" lookahead="%WS ;">NamespaceDecl ::= <dot>.</dot> 'declare namespace' NCName '=' URILiteral</item>
      <item id="115" lookahead="%WS ;">BoundarySpaceDecl ::= <dot>.</dot> 'declare boundary-space' BoundarySpaceDecl_1</item>
      <item id="124" lookahead="%WS ;">DefaultNamespaceDecl ::= <dot>.</dot> 'declare default' DefaultNamespaceDecl_1 'namespace' URILiteral</item>
      <item id="140" lookahead="%WS ;">OrderingModeDecl ::= <dot>.</dot> 'declare ordering' OrderingModeDecl_1</item>
      <item id="149" lookahead="%WS ;">EmptyOrderDecl ::= <dot>.</dot> 'declare default' 'order' 'empty' EmptyOrderDecl_1</item>
      <item id="160" lookahead="%WS ;">CopyNamespacesDecl ::= <dot>.</dot> 'declare copy-namespaces' PreserveMode ',' InheritMode</item>
      <item id="176" lookahead="%WS ;">DefaultCollationDecl ::= <dot>.</dot> 'declare default' 'collation' URILiteral</item>
      <item id="181" lookahead="%WS ;">BaseURIDecl ::= <dot>.</dot> 'declare base-uri' URILiteral</item>
      <item id="185" lookahead="%WS ;">SchemaImport ::= <dot>.</dot> 'import' 'schema' SchemaImport_1 URILiteral SchemaImport_2</item>
      <item id="227" lookahead="%WS ;">ModuleImport ::= <dot>.</dot> 'import' 'module' ModuleImport_1 URILiteral ModuleImport_2</item>
      <item id="282" lookahead="%WS ;">ConstructionDecl ::= <dot>.</dot> 'declare construction' ConstructionDecl_1</item>
      <item id="78" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare function declare option declare variable descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_3 ::= <dot>.</dot></item>
      <goto on="Prolog_2" to="20"/>
      <goto on="Prolog_3" to="21"/>
      <goto on="Setter" to="345"/>
      <goto on="Import" to="345"/>
      <goto on="NamespaceDecl" to="345"/>
      <goto on="BoundarySpaceDecl" to="346"/>
      <goto on="DefaultNamespaceDecl" to="345"/>
      <goto on="OrderingModeDecl" to="346"/>
      <goto on="EmptyOrderDecl" to="346"/>
      <goto on="CopyNamespacesDecl" to="346"/>
      <goto on="DefaultCollationDecl" to="346"/>
      <goto on="BaseURIDecl" to="346"/>
      <goto on="SchemaImport" to="347"/>
      <goto on="ModuleImport" to="347"/>
      <goto on="ConstructionDecl" to="346"/>
      <shift on="declare namespace" to="202"/>
      <shift on="declare boundary-space" to="22"/>
      <shift on="declare default" to="23"/>
      <shift on="declare ordering" to="24"/>
      <shift on="declare copy-namespaces" to="25"/>
      <shift on="declare base-uri" to="26"/>
      <shift on="import" to="203"/>
      <shift on="declare construction" to="27"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare function declare option declare variable descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" symbol="Prolog_3"/>
    </state>
    <state id="5">
      <item id="352" lookahead="%WS ) EOF ] }">Expr ::= ExprSingle <dot>.</dot> Expr_1</item>
      <item id="359" lookahead="%WS ) , EOF ] }">Expr_1 ::= <dot>.</dot> Expr_1 ',' ExprSingle</item>
      <item id="357" lookahead="%WS ) , EOF ] }">Expr_1 ::= <dot>.</dot></item>
      <goto on="Expr_1" to="205"/>
      <reduce on=") , EOF ] }" symbol="Expr_1"/>
    </state>
    <state id="6">
      <item id="373" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= FLWORExpr_1 <dot>.</dot> FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="384" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= FLWORExpr_1 <dot>.</dot> FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="395" lookahead="%WS order return stable">FLWORExpr_3 ::= <dot>.</dot> WhereClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="491" lookahead="%WS order return stable">WhereClause ::= <dot>.</dot> 'where' ExprSingle</item>
      <item id="394" lookahead="%WS order return stable">FLWORExpr_3 ::= <dot>.</dot></item>
      <goto on="FLWORExpr_2" to="348"/>
      <goto on="FLWORExpr_3" to="29"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="WhereClause" to="349"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="where" to="30"/>
      <reduce on="order return stable" symbol="FLWORExpr_3"/>
    </state>
    <state id="7">
      <item id="655" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">OrExpr ::= AndExpr <dot>.</dot> OrExpr_1</item>
      <item id="662" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">OrExpr_1 ::= <dot>.</dot> OrExpr_1 'or' AndExpr</item>
      <item id="660" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">OrExpr_1 ::= <dot>.</dot></item>
      <goto on="OrExpr_1" to="206"/>
      <reduce on=") , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }" symbol="OrExpr_1"/>
    </state>
    <state id="8">
      <item id="668" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr ::= ComparisonExpr <dot>.</dot> AndExpr_1</item>
      <item id="675" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr_1 ::= <dot>.</dot> AndExpr_1 'and' ComparisonExpr</item>
      <item id="673" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr_1 ::= <dot>.</dot></item>
      <goto on="AndExpr_1" to="207"/>
      <reduce on=") , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }" symbol="AndExpr_1"/>
    </state>
    <state id="9">
      <item id="681" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr ::= RangeExpr <dot>.</dot> ComparisonExpr_1</item>
      <item id="688" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr_1 ::= <dot>.</dot> ComparisonExpr_2 RangeExpr</item>
      <item id="693" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ComparisonExpr_2 ::= <dot>.</dot> ValueComp</item>
      <item id="695" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ComparisonExpr_2 ::= <dot>.</dot> GeneralComp</item>
      <item id="696" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ComparisonExpr_2 ::= <dot>.</dot> NodeComp</item>
      <item id="860" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">GeneralComp ::= <dot>.</dot> '='</item>
      <item id="862" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">GeneralComp ::= <dot>.</dot> '!='</item>
      <item id="863" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">GeneralComp ::= <dot>.</dot> '&lt;'</item>
      <item id="864" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">GeneralComp ::= <dot>.</dot> '&lt;='</item>
      <item id="865" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">GeneralComp ::= <dot>.</dot> '&gt;'</item>
      <item id="866" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">GeneralComp ::= <dot>.</dot> '&gt;='</item>
      <item id="869" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ValueComp ::= <dot>.</dot> 'eq'</item>
      <item id="871" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ValueComp ::= <dot>.</dot> 'ne'</item>
      <item id="872" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ValueComp ::= <dot>.</dot> 'lt'</item>
      <item id="873" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ValueComp ::= <dot>.</dot> 'le'</item>
      <item id="874" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ValueComp ::= <dot>.</dot> 'gt'</item>
      <item id="875" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ValueComp ::= <dot>.</dot> 'ge'</item>
      <item id="878" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">NodeComp ::= <dot>.</dot> 'is'</item>
      <item id="880" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">NodeComp ::= <dot>.</dot> '&lt;&lt;'</item>
      <item id="881" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">NodeComp ::= <dot>.</dot> '&gt;&gt;'</item>
      <item id="686" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr_1 ::= <dot>.</dot></item>
      <goto on="ComparisonExpr_1" to="350"/>
      <goto on="ComparisonExpr_2" to="32"/>
      <goto on="GeneralComp" to="351"/>
      <goto on="ValueComp" to="351"/>
      <goto on="NodeComp" to="351"/>
      <shift on="=" to="352"/>
      <shift on="!=" to="352"/>
      <shift on="&lt;" to="352"/>
      <shift on="&lt;=" to="352"/>
      <shift on="&gt;" to="352"/>
      <shift on="&gt;=" to="352"/>
      <shift on="eq" to="353"/>
      <shift on="ne" to="353"/>
      <shift on="lt" to="353"/>
      <shift on="le" to="353"/>
      <shift on="gt" to="353"/>
      <shift on="ge" to="353"/>
      <shift on="is" to="354"/>
      <shift on="&lt;&lt;" to="354"/>
      <shift on="&gt;&gt;" to="354"/>
      <reduce on=") , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }" symbol="ComparisonExpr_1"/>
    </state>
    <state id="10">
      <item id="699" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr ::= AdditiveExpr <dot>.</dot> RangeExpr_1</item>
      <item id="706" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr_1 ::= <dot>.</dot> 'to' AdditiveExpr</item>
      <item id="704" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr_1 ::= <dot>.</dot></item>
      <goto on="RangeExpr_1" to="355"/>
      <shift on="to" to="33"/>
      <reduce on="!= ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }" symbol="RangeExpr_1"/>
    </state>
    <state id="11">
      <item id="711" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr ::= MultiplicativeExpr <dot>.</dot> AdditiveExpr_1</item>
      <item id="718" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr_1 ::= <dot>.</dot> AdditiveExpr_1 AdditiveExpr_2 MultiplicativeExpr</item>
      <item id="716" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr_1 ::= <dot>.</dot></item>
      <goto on="AdditiveExpr_1" to="34"/>
      <reduce on="!= ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }" symbol="AdditiveExpr_1"/>
    </state>
    <state id="12">
      <item id="729" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= UnionExpr <dot>.</dot> MultiplicativeExpr_1</item>
      <item id="736" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">MultiplicativeExpr_1 ::= <dot>.</dot> MultiplicativeExpr_1 MultiplicativeExpr_2 UnionExpr</item>
      <item id="734" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">MultiplicativeExpr_1 ::= <dot>.</dot></item>
      <goto on="MultiplicativeExpr_1" to="35"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }" symbol="MultiplicativeExpr_1"/>
    </state>
    <state id="13">
      <item id="749" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= IntersectExceptExpr <dot>.</dot> UnionExpr_1</item>
      <item id="756" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">UnionExpr_1 ::= <dot>.</dot> UnionExpr_1 UnionExpr_2 IntersectExceptExpr</item>
      <item id="754" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">UnionExpr_1 ::= <dot>.</dot></item>
      <goto on="UnionExpr_1" to="36"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }" symbol="UnionExpr_1"/>
    </state>
    <state id="14">
      <item id="767" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= InstanceofExpr <dot>.</dot> IntersectExceptExpr_1</item>
      <item id="774" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr_1 ::= <dot>.</dot> IntersectExceptExpr_1 IntersectExceptExpr_2 InstanceofExpr</item>
      <item id="772" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr_1 ::= <dot>.</dot></item>
      <goto on="IntersectExceptExpr_1" to="37"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }" symbol="IntersectExceptExpr_1"/>
    </state>
    <state id="15">
      <item id="785" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= TreatExpr <dot>.</dot> InstanceofExpr_1</item>
      <item id="792" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr_1 ::= <dot>.</dot> 'instance' 'of' SequenceType</item>
      <item id="790" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr_1 ::= <dot>.</dot></item>
      <goto on="InstanceofExpr_1" to="356"/>
      <shift on="instance" to="208"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }" symbol="InstanceofExpr_1"/>
    </state>
    <state id="16">
      <item id="798" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= CastableExpr <dot>.</dot> TreatExpr_1</item>
      <item id="805" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr_1 ::= <dot>.</dot> 'treat' 'as' SequenceType</item>
      <item id="803" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr_1 ::= <dot>.</dot></item>
      <goto on="TreatExpr_1" to="357"/>
      <shift on="treat" to="209"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }" symbol="TreatExpr_1"/>
    </state>
    <state id="17">
      <item id="811" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= CastExpr <dot>.</dot> CastableExpr_1</item>
      <item id="818" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr_1 ::= <dot>.</dot> 'castable' 'as' SingleType</item>
      <item id="816" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr_1 ::= <dot>.</dot></item>
      <goto on="CastableExpr_1" to="358"/>
      <shift on="castable" to="210"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="CastableExpr_1"/>
    </state>
    <state id="18">
      <item id="824" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= UnaryExpr <dot>.</dot> CastExpr_1</item>
      <item id="831" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr_1 ::= <dot>.</dot> 'cast' 'as' SingleType</item>
      <item id="829" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr_1 ::= <dot>.</dot></item>
      <goto on="CastExpr_1" to="359"/>
      <shift on="cast" to="211"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="CastExpr_1"/>
    </state>
    <state id="19">
      <item id="837" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= UnaryExpr_1 <dot>.</dot> ValueExpr</item>
      <item id="845" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= UnaryExpr_1 <dot>.</dot> UnaryExpr_2</item>
      <item id="849" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_2 ::= <dot>.</dot> '-'</item>
      <item id="851" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_2 ::= <dot>.</dot> '+'</item>
      <item id="854" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValueExpr ::= <dot>.</dot> ValidateExpr</item>
      <item id="856" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValueExpr ::= <dot>.</dot> PathExpr</item>
      <item id="857" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValueExpr ::= <dot>.</dot> ExtensionExpr</item>
      <item id="883" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValidateExpr ::= <dot>.</dot> 'validate' ValidateExpr_1 '{' Expr '}'</item>
      <item id="901" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ExtensionExpr ::= <dot>.</dot> ExtensionExpr_1 '{' ExtensionExpr_2 '}'</item>
      <item id="908" lookahead="%WS (# {">ExtensionExpr_1 ::= <dot>.</dot> Pragma</item>
      <item id="911" lookahead="%WS (# {">ExtensionExpr_1 ::= <dot>.</dot> ExtensionExpr_1 Pragma</item>
      <item id="921" lookahead="%WS (# {">Pragma ::= <dot>.</dot> '(#' Pragma_1 QName Pragma_2 '#)'</item>
      <item id="944" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PathExpr ::= <dot>.</dot> '/' RelativePathExpr</item>
      <item id="948" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PathExpr ::= <dot>.</dot> '//' RelativePathExpr</item>
      <item id="950" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PathExpr ::= <dot>.</dot> RelativePathExpr</item>
      <item id="953" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr ::= <dot>.</dot> StepExpr RelativePathExpr_1</item>
      <item id="972" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= <dot>.</dot> FilterExpr</item>
      <item id="974" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= <dot>.</dot> AxisStep</item>
      <item id="976" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep ::= <dot>.</dot> AxisStep_1 PredicateList</item>
      <item id="981" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= <dot>.</dot> ReverseStep</item>
      <item id="983" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= <dot>.</dot> ForwardStep</item>
      <item id="987" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= <dot>.</dot> ForwardAxis NodeTest</item>
      <item id="990" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= <dot>.</dot> AbbrevForwardStep</item>
      <item id="995" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'child' '::'</item>
      <item id="999" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'descendant' '::'</item>
      <item id="1002" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'attribute' '::'</item>
      <item id="1005" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'self' '::'</item>
      <item id="1008" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'descendant-or-self' '::'</item>
      <item id="1011" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'following-sibling' '::'</item>
      <item id="1014" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'following' '::'</item>
      <item id="1018" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= <dot>.</dot> NodeTest</item>
      <item id="1021" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= <dot>.</dot> '@' NodeTest</item>
      <item id="1027" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= <dot>.</dot> ReverseAxis NodeTest</item>
      <item id="1030" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= <dot>.</dot> AbbrevReverseStep</item>
      <item id="1035" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'parent' '::'</item>
      <item id="1039" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'ancestor' '::'</item>
      <item id="1042" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'preceding-sibling' '::'</item>
      <item id="1045" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'preceding' '::'</item>
      <item id="1048" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'ancestor-or-self' '::'</item>
      <item id="1051" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevReverseStep ::= <dot>.</dot> '..'</item>
      <item id="1055" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> KindTest</item>
      <item id="1057" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> NameTest</item>
      <item id="1060" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> QName</item>
      <item id="1062" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> Wildcard</item>
      <item id="1064" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FilterExpr ::= <dot>.</dot> PrimaryExpr PredicateList</item>
      <item id="1082" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> Literal</item>
      <item id="1084" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> VarRef</item>
      <item id="1085" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> ParenthesizedExpr</item>
      <item id="1086" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> ContextItemExpr</item>
      <item id="1087" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> FunctionCall</item>
      <item id="1088" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> OrderedExpr</item>
      <item id="1089" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> UnorderedExpr</item>
      <item id="1090" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> Constructor</item>
      <item id="1093" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= <dot>.</dot> NumericLiteral</item>
      <item id="1095" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= <dot>.</dot> StringLiteral</item>
      <item id="1098" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> IntegerLiteral</item>
      <item id="1100" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> DecimalLiteral</item>
      <item id="1101" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> DoubleLiteral</item>
      <item id="1103" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">VarRef ::= <dot>.</dot> '$' VarName</item>
      <item id="1110" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ParenthesizedExpr ::= <dot>.</dot> '(' ParenthesizedExpr_1 ')'</item>
      <item id="1121" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ContextItemExpr ::= <dot>.</dot> '.'</item>
      <item id="1124" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">OrderedExpr ::= <dot>.</dot> 'ordered' '{' Expr '}'</item>
      <item id="1130" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnorderedExpr ::= <dot>.</dot> 'unordered' '{' Expr '}'</item>
      <item id="1136" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FunctionCall ::= <dot>.</dot> QName '(' FunctionCall_1 ')'</item>
      <item id="1160" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= <dot>.</dot> DirectConstructor</item>
      <item id="1162" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= <dot>.</dot> ComputedConstructor</item>
      <item id="1165" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirElemConstructor</item>
      <item id="1167" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirCommentConstructor</item>
      <item id="1168" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirPIConstructor</item>
      <item id="1170" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirElemConstructor ::= <dot>.</dot> '&lt;' QName DirAttributeList DirElemConstructor_1</item>
      <item id="1296" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirCommentConstructor ::= <dot>.</dot> '&lt;!--' DirCommentContents '--&gt;'</item>
      <item id="1301" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirPIConstructor ::= <dot>.</dot> '&lt;?' PITarget DirPIConstructor_1 '?&gt;'</item>
      <item id="1316" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompDocConstructor</item>
      <item id="1318" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompElemConstructor</item>
      <item id="1319" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompAttrConstructor</item>
      <item id="1320" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompTextConstructor</item>
      <item id="1321" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompCommentConstructor</item>
      <item id="1322" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompPIConstructor</item>
      <item id="1324" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompDocConstructor ::= <dot>.</dot> 'document' '{' Expr '}'</item>
      <item id="1330" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= <dot>.</dot> 'element' CompElemConstructor_1 '{' CompElemConstructor_2 '}'</item>
      <item id="1355" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= <dot>.</dot> 'attribute' CompAttrConstructor_1 '{' CompAttrConstructor_2 '}'</item>
      <item id="1377" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompTextConstructor ::= <dot>.</dot> 'text' '{' Expr '}'</item>
      <item id="1383" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompCommentConstructor ::= <dot>.</dot> 'comment' '{' Expr '}'</item>
      <item id="1389" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= <dot>.</dot> 'processing-instruction' CompPIConstructor_1 '{' CompPIConstructor_2 '}'</item>
      <item id="1462" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="UnaryExpr_2" to="360"/>
      <goto on="ValueExpr" to="361"/>
      <goto on="ValidateExpr" to="362"/>
      <goto on="ExtensionExpr" to="362"/>
      <goto on="ExtensionExpr_1" to="38"/>
      <goto on="Pragma" to="363"/>
      <goto on="PathExpr" to="362"/>
      <goto on="RelativePathExpr" to="364"/>
      <goto on="StepExpr" to="39"/>
      <goto on="AxisStep" to="365"/>
      <goto on="AxisStep_1" to="40"/>
      <goto on="ForwardStep" to="366"/>
      <goto on="ForwardAxis" to="41"/>
      <goto on="AbbrevForwardStep" to="367"/>
      <goto on="ReverseStep" to="366"/>
      <goto on="ReverseAxis" to="42"/>
      <goto on="AbbrevReverseStep" to="368"/>
      <goto on="NodeTest" to="369"/>
      <goto on="NameTest" to="370"/>
      <goto on="FilterExpr" to="365"/>
      <goto on="PrimaryExpr" to="43"/>
      <goto on="Literal" to="371"/>
      <goto on="NumericLiteral" to="372"/>
      <goto on="VarRef" to="371"/>
      <goto on="ParenthesizedExpr" to="371"/>
      <goto on="ContextItemExpr" to="371"/>
      <goto on="OrderedExpr" to="371"/>
      <goto on="UnorderedExpr" to="371"/>
      <goto on="FunctionCall" to="371"/>
      <goto on="Constructor" to="371"/>
      <goto on="DirectConstructor" to="373"/>
      <goto on="DirElemConstructor" to="374"/>
      <goto on="DirCommentConstructor" to="374"/>
      <goto on="DirPIConstructor" to="374"/>
      <goto on="ComputedConstructor" to="373"/>
      <goto on="CompDocConstructor" to="375"/>
      <goto on="CompElemConstructor" to="375"/>
      <goto on="CompAttrConstructor" to="375"/>
      <goto on="CompTextConstructor" to="375"/>
      <goto on="CompCommentConstructor" to="375"/>
      <goto on="CompPIConstructor" to="375"/>
      <goto on="KindTest" to="370"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="StringLiteral" to="372"/>
      <shift on="element" to="44"/>
      <shift on="QName" to="212"/>
      <shift on="ordered" to="213"/>
      <shift on="unordered" to="214"/>
      <shift on="$" to="45"/>
      <shift on="(" to="46"/>
      <shift on="+" to="377"/>
      <shift on="-" to="377"/>
      <shift on="&lt;" to="215"/>
      <shift on="validate" to="47"/>
      <shift on="(#" to="48"/>
      <shift on="/" to="49"/>
      <shift on="//" to="50"/>
      <shift on="child" to="216"/>
      <shift on="descendant" to="217"/>
      <shift on="attribute" to="51"/>
      <shift on="self" to="218"/>
      <shift on="descendant-or-self" to="219"/>
      <shift on="following-sibling" to="220"/>
      <shift on="following" to="221"/>
      <shift on="@" to="52"/>
      <shift on="parent" to="222"/>
      <shift on="ancestor" to="223"/>
      <shift on="preceding-sibling" to="224"/>
      <shift on="preceding" to="225"/>
      <shift on="ancestor-or-self" to="226"/>
      <shift on=".." to="378"/>
      <shift on="Wildcard" to="379"/>
      <shift on="IntegerLiteral" to="380"/>
      <shift on="DecimalLiteral" to="380"/>
      <shift on="DoubleLiteral" to="380"/>
      <shift on="." to="381"/>
      <shift on="&lt;!--" to="227"/>
      <shift on="&lt;?" to="228"/>
      <shift on="document" to="229"/>
      <shift on="text" to="230"/>
      <shift on="comment" to="231"/>
      <shift on="processing-instruction" to="53"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="20">
      <item id="66" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_1 ::= Prolog_1 Prolog_2 <dot>.</dot> Separator</item>
      <item id="106" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Separator ::= <dot>.</dot> ';'</item>
      <goto on="Separator" to="382"/>
      <shift on=";" to="383"/>
    </state>
    <state id="21">
      <item id="81" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare function declare option declare variable descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_3 ::= Prolog_3 <dot>.</dot> Prolog_4 Separator</item>
      <item id="86" lookahead="%WS ;">Prolog_4 ::= <dot>.</dot> VarDecl</item>
      <item id="88" lookahead="%WS ;">Prolog_4 ::= <dot>.</dot> FunctionDecl</item>
      <item id="89" lookahead="%WS ;">Prolog_4 ::= <dot>.</dot> OptionDecl</item>
      <item id="135" lookahead="%WS ;">OptionDecl ::= <dot>.</dot> 'declare option' QName StringLiteral</item>
      <item id="261" lookahead="%WS ;">VarDecl ::= <dot>.</dot> 'declare variable' '$' QName VarDecl_1 VarDecl_2</item>
      <item id="291" lookahead="%WS ;">FunctionDecl ::= <dot>.</dot> 'declare function' QName '(' FunctionDecl_1 ')' FunctionDecl_2 FunctionDecl_3</item>
      <item id="58" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog ::= Prolog_1 Prolog_3 <dot>.</dot></item>
      <goto on="Prolog_4" to="58"/>
      <goto on="OptionDecl" to="384"/>
      <goto on="VarDecl" to="384"/>
      <goto on="FunctionDecl" to="384"/>
      <shift on="declare option" to="236"/>
      <shift on="declare variable" to="237"/>
      <shift on="declare function" to="238"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate" symbol="Prolog"/>
    </state>
    <state id="22">
      <item id="116" lookahead="%WS ;">BoundarySpaceDecl ::= 'declare boundary-space' <dot>.</dot> BoundarySpaceDecl_1</item>
      <item id="120" lookahead="%WS ;">BoundarySpaceDecl_1 ::= <dot>.</dot> 'preserve'</item>
      <item id="122" lookahead="%WS ;">BoundarySpaceDecl_1 ::= <dot>.</dot> 'strip'</item>
      <goto on="BoundarySpaceDecl_1" to="385"/>
      <shift on="preserve" to="386"/>
      <shift on="strip" to="386"/>
    </state>
    <state id="23">
      <item id="125" lookahead="%WS ;">DefaultNamespaceDecl ::= 'declare default' <dot>.</dot> DefaultNamespaceDecl_1 'namespace' URILiteral</item>
      <item id="131" lookahead="%WS namespace">DefaultNamespaceDecl_1 ::= <dot>.</dot> 'element'</item>
      <item id="133" lookahead="%WS namespace">DefaultNamespaceDecl_1 ::= <dot>.</dot> 'function'</item>
      <item id="150" lookahead="%WS ;">EmptyOrderDecl ::= 'declare default' <dot>.</dot> 'order' 'empty' EmptyOrderDecl_1</item>
      <item id="177" lookahead="%WS ;">DefaultCollationDecl ::= 'declare default' <dot>.</dot> 'collation' URILiteral</item>
      <goto on="DefaultNamespaceDecl_1" to="240"/>
      <shift on="element" to="387"/>
      <shift on="function" to="387"/>
      <shift on="order" to="241"/>
      <shift on="collation" to="59"/>
    </state>
    <state id="24">
      <item id="141" lookahead="%WS ;">OrderingModeDecl ::= 'declare ordering' <dot>.</dot> OrderingModeDecl_1</item>
      <item id="145" lookahead="%WS ;">OrderingModeDecl_1 ::= <dot>.</dot> 'ordered'</item>
      <item id="147" lookahead="%WS ;">OrderingModeDecl_1 ::= <dot>.</dot> 'unordered'</item>
      <goto on="OrderingModeDecl_1" to="388"/>
      <shift on="ordered" to="389"/>
      <shift on="unordered" to="389"/>
    </state>
    <state id="25">
      <item id="161" lookahead="%WS ;">CopyNamespacesDecl ::= 'declare copy-namespaces' <dot>.</dot> PreserveMode ',' InheritMode</item>
      <item id="167" lookahead="%WS ,">PreserveMode ::= <dot>.</dot> 'preserve'</item>
      <item id="169" lookahead="%WS ,">PreserveMode ::= <dot>.</dot> 'no-preserve'</item>
      <goto on="PreserveMode" to="242"/>
      <shift on="preserve" to="390"/>
      <shift on="no-preserve" to="390"/>
    </state>
    <state id="26">
      <item id="182" lookahead="%WS ;">BaseURIDecl ::= 'declare base-uri' <dot>.</dot> URILiteral</item>
      <item id="1602" lookahead="%WS ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="391"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="27">
      <item id="283" lookahead="%WS ;">ConstructionDecl ::= 'declare construction' <dot>.</dot> ConstructionDecl_1</item>
      <item id="287" lookahead="%WS ;">ConstructionDecl_1 ::= <dot>.</dot> 'strip'</item>
      <item id="289" lookahead="%WS ;">ConstructionDecl_1 ::= <dot>.</dot> 'preserve'</item>
      <goto on="ConstructionDecl_1" to="393"/>
      <shift on="preserve" to="394"/>
      <shift on="strip" to="394"/>
    </state>
    <state id="28">
      <item id="28" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">VersionDecl ::= 'xquery' 'version' StringLiteral <dot>.</dot> VersionDecl_1 Separator</item>
      <item id="36" lookahead="%WS ;">VersionDecl_1 ::= <dot>.</dot> 'encoding' StringLiteral</item>
      <item id="34" lookahead="%WS ;">VersionDecl_1 ::= <dot>.</dot></item>
      <goto on="VersionDecl_1" to="62"/>
      <shift on="encoding" to="244"/>
      <reduce on=";" symbol="VersionDecl_1"/>
    </state>
    <state id="29">
      <item id="374" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= FLWORExpr_1 FLWORExpr_3 <dot>.</dot> FLWORExpr_4 'return' ExprSingle</item>
      <item id="401" lookahead="%WS return">FLWORExpr_4 ::= <dot>.</dot> OrderByClause</item>
      <item id="495" lookahead="%WS return">OrderByClause ::= <dot>.</dot> OrderByClause_1 OrderSpecList</item>
      <item id="501" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">OrderByClause_1 ::= <dot>.</dot> 'order' 'by'</item>
      <item id="505" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">OrderByClause_1 ::= <dot>.</dot> 'stable' 'order' 'by'</item>
      <item id="400" lookahead="%WS return">FLWORExpr_4 ::= <dot>.</dot></item>
      <goto on="FLWORExpr_4" to="245"/>
      <goto on="OrderByClause" to="395"/>
      <goto on="OrderByClause_1" to="64"/>
      <shift on="order" to="246"/>
      <shift on="stable" to="247"/>
      <reduce on="return" symbol="FLWORExpr_4"/>
    </state>
    <state id="30">
      <item id="365" lookahead="%WS order return stable">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS order return stable">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS order return stable">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS order return stable">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS order return stable">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS order return stable">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="492" lookahead="%WS order return stable">WhereClause ::= 'where' <dot>.</dot> ExprSingle</item>
      <item id="560" lookahead="%WS order return stable">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS order return stable">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS order return stable">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS order return stable">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS or order return stable">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS and or order return stable">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or order return stable">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or order return stable to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or order return stable to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or order return stable to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or order return stable to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or order return stable to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or order return stable to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or order return stable to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or order return stable to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or order return stable to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="396"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="31">
      <item id="562" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 '$' <dot>.</dot> VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="1107" lookahead="%WS as in">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="65"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="32">
      <item id="689" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr_1 ::= ComparisonExpr_2 <dot>.</dot> RangeExpr</item>
      <item id="698" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable to where }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="%WS ) + , - ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable to where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="%WS ) * + , - ; EOF ] and ascending case collation default descending div else empty for idiv let mod or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="%WS ) * + , - ; EOF ] and ascending case collation default descending div else empty for idiv let mod or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="%WS ) * + , - ; EOF ] and ascending case collation default descending div else empty except for idiv intersect let mod or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="%WS ) * + , - ; EOF ] and ascending case collation default descending div else empty except for idiv instance intersect let mod or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="%WS ) * + , - ; EOF ] and ascending case collation default descending div else empty except for idiv instance intersect let mod or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="%WS ) * + , - ; EOF ] and ascending case castable collation default descending div else empty except for idiv instance intersect let mod or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="%WS ) * + , - ; EOF ] and ascending case cast castable collation default descending div else empty except for idiv instance intersect let mod or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="RangeExpr" to="398"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="33">
      <item id="707" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr_1 ::= 'to' <dot>.</dot> AdditiveExpr</item>
      <item id="710" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="AdditiveExpr" to="399"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="34">
      <item id="719" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr_1 ::= AdditiveExpr_1 <dot>.</dot> AdditiveExpr_2 MultiplicativeExpr</item>
      <item id="724" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">AdditiveExpr_2 ::= <dot>.</dot> '+'</item>
      <item id="726" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">AdditiveExpr_2 ::= <dot>.</dot> '-'</item>
      <item id="712" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr ::= MultiplicativeExpr AdditiveExpr_1 <dot>.</dot></item>
      <goto on="AdditiveExpr_2" to="68"/>
      <shift on="+" to="400"/>
      <shift on="-" to="400"/>
      <reduce on="!= ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }" symbol="AdditiveExpr"/>
    </state>
    <state id="35">
      <item id="737" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">MultiplicativeExpr_1 ::= MultiplicativeExpr_1 <dot>.</dot> MultiplicativeExpr_2 UnionExpr</item>
      <item id="742" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">MultiplicativeExpr_2 ::= <dot>.</dot> '*'</item>
      <item id="744" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">MultiplicativeExpr_2 ::= <dot>.</dot> 'div'</item>
      <item id="745" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">MultiplicativeExpr_2 ::= <dot>.</dot> 'idiv'</item>
      <item id="746" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">MultiplicativeExpr_2 ::= <dot>.</dot> 'mod'</item>
      <item id="730" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= UnionExpr MultiplicativeExpr_1 <dot>.</dot></item>
      <goto on="MultiplicativeExpr_2" to="69"/>
      <shift on="*" to="401"/>
      <shift on="div" to="401"/>
      <shift on="idiv" to="401"/>
      <shift on="mod" to="401"/>
      <reduce on="!= ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }" symbol="MultiplicativeExpr"/>
    </state>
    <state id="36">
      <item id="757" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">UnionExpr_1 ::= UnionExpr_1 <dot>.</dot> UnionExpr_2 IntersectExceptExpr</item>
      <item id="762" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnionExpr_2 ::= <dot>.</dot> 'union'</item>
      <item id="764" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnionExpr_2 ::= <dot>.</dot> '|'</item>
      <item id="750" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= IntersectExceptExpr UnionExpr_1 <dot>.</dot></item>
      <goto on="UnionExpr_2" to="70"/>
      <shift on="union" to="402"/>
      <shift on="|" to="402"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }" symbol="UnionExpr"/>
    </state>
    <state id="37">
      <item id="775" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr_1 ::= IntersectExceptExpr_1 <dot>.</dot> IntersectExceptExpr_2 InstanceofExpr</item>
      <item id="780" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">IntersectExceptExpr_2 ::= <dot>.</dot> 'intersect'</item>
      <item id="782" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">IntersectExceptExpr_2 ::= <dot>.</dot> 'except'</item>
      <item id="768" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= InstanceofExpr IntersectExceptExpr_1 <dot>.</dot></item>
      <goto on="IntersectExceptExpr_2" to="71"/>
      <shift on="intersect" to="403"/>
      <shift on="except" to="403"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }" symbol="IntersectExceptExpr"/>
    </state>
    <state id="38">
      <item id="902" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ExtensionExpr ::= ExtensionExpr_1 <dot>.</dot> '{' ExtensionExpr_2 '}'</item>
      <item id="912" lookahead="%WS (# {">ExtensionExpr_1 ::= ExtensionExpr_1 <dot>.</dot> Pragma</item>
      <item id="921" lookahead="%WS (# {">Pragma ::= <dot>.</dot> '(#' Pragma_1 QName Pragma_2 '#)'</item>
      <goto on="Pragma" to="404"/>
      <shift on="{" to="76"/>
      <shift on="(#" to="48"/>
    </state>
    <state id="39">
      <item id="954" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr ::= StepExpr <dot>.</dot> RelativePathExpr_1</item>
      <item id="961" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr_1 ::= <dot>.</dot> RelativePathExpr_1 RelativePathExpr_2 StepExpr</item>
      <item id="959" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr_1 ::= <dot>.</dot></item>
      <goto on="RelativePathExpr_1" to="77"/>
      <reduce on="!= ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="RelativePathExpr_1"/>
    </state>
    <state id="40">
      <item id="977" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep ::= AxisStep_1 <dot>.</dot> PredicateList</item>
      <item id="1072" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PredicateList ::= <dot>.</dot> PredicateList Predicate</item>
      <item id="1070" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PredicateList ::= <dot>.</dot></item>
      <goto on="PredicateList" to="78"/>
      <reduce on="!= ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="PredicateList"/>
    </state>
    <state id="41">
      <item id="988" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= ForwardAxis <dot>.</dot> NodeTest</item>
      <item id="1055" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> KindTest</item>
      <item id="1057" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> NameTest</item>
      <item id="1060" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> QName</item>
      <item id="1062" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> Wildcard</item>
      <item id="1462" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="NodeTest" to="405"/>
      <goto on="NameTest" to="370"/>
      <goto on="KindTest" to="370"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="element" to="248"/>
      <shift on="QName" to="379"/>
      <shift on="attribute" to="249"/>
      <shift on="Wildcard" to="379"/>
      <shift on="text" to="250"/>
      <shift on="comment" to="251"/>
      <shift on="processing-instruction" to="252"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="42">
      <item id="1028" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= ReverseAxis <dot>.</dot> NodeTest</item>
      <item id="1055" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> KindTest</item>
      <item id="1057" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> NameTest</item>
      <item id="1060" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> QName</item>
      <item id="1062" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> Wildcard</item>
      <item id="1462" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="NodeTest" to="406"/>
      <goto on="NameTest" to="370"/>
      <goto on="KindTest" to="370"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="element" to="248"/>
      <shift on="QName" to="379"/>
      <shift on="attribute" to="249"/>
      <shift on="Wildcard" to="379"/>
      <shift on="text" to="250"/>
      <shift on="comment" to="251"/>
      <shift on="processing-instruction" to="252"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="43">
      <item id="1065" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FilterExpr ::= PrimaryExpr <dot>.</dot> PredicateList</item>
      <item id="1072" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PredicateList ::= <dot>.</dot> PredicateList Predicate</item>
      <item id="1070" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PredicateList ::= <dot>.</dot></item>
      <goto on="PredicateList" to="79"/>
      <reduce on="!= ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="PredicateList"/>
    </state>
    <state id="44">
      <item id="1331" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= 'element' <dot>.</dot> CompElemConstructor_1 '{' CompElemConstructor_2 '}'</item>
      <item id="1338" lookahead="%WS {">CompElemConstructor_1 ::= <dot>.</dot> QName</item>
      <item id="1341" lookahead="%WS {">CompElemConstructor_1 ::= <dot>.</dot> '{' Expr '}'</item>
      <item id="1551" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ElementTest ::= 'element' <dot>.</dot> '(' ElementTest_1 ')'</item>
      <goto on="CompElemConstructor_1" to="253"/>
      <shift on="QName" to="407"/>
      <shift on="(" to="80"/>
      <shift on="{" to="81"/>
    </state>
    <state id="45">
      <item id="1104" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">VarRef ::= '$' <dot>.</dot> VarName</item>
      <item id="1107" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="408"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="46">
      <item id="351" lookahead="%WS )">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) ,">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) ,">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) ,">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) ,">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) ,">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , and or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1111" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ParenthesizedExpr ::= '(' <dot>.</dot> ParenthesizedExpr_1 ')'</item>
      <item id="1118" lookahead="%WS )">ParenthesizedExpr_1 ::= <dot>.</dot> Expr</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <item id="1117" lookahead="%WS )">ParenthesizedExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="409"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <goto on="ParenthesizedExpr_1" to="254"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
      <reduce on=")" symbol="ParenthesizedExpr_1"/>
    </state>
    <state id="47">
      <item id="884" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValidateExpr ::= 'validate' <dot>.</dot> ValidateExpr_1 '{' Expr '}'</item>
      <item id="893" lookahead="%WS {">ValidateExpr_1 ::= <dot>.</dot> ValidationMode</item>
      <item id="897" lookahead="%WS {">ValidationMode ::= <dot>.</dot> 'lax'</item>
      <item id="899" lookahead="%WS {">ValidationMode ::= <dot>.</dot> 'strict'</item>
      <item id="892" lookahead="%WS {">ValidateExpr_1 ::= <dot>.</dot></item>
      <goto on="ValidateExpr_1" to="255"/>
      <goto on="ValidationMode" to="410"/>
      <shift on="lax" to="411"/>
      <shift on="strict" to="411"/>
      <reduce on="{" symbol="ValidateExpr_1"/>
    </state>
    <state id="48">
      <item id="922" lookahead="%WS (# {">Pragma ::= '(#' <dot>.</dot> Pragma_1 QName Pragma_2 '#)'</item>
      <item id="931" lookahead="%WS QName">Pragma_1 ::= <dot>.</dot> S</item>
      <item id="930" lookahead="%WS QName">Pragma_1 ::= <dot>.</dot></item>
      <goto on="Pragma_1" to="256"/>
      <shift on="S" to="412"/>
      <reduce on="QName" symbol="Pragma_1"/>
    </state>
    <state id="49">
      <item id="945" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PathExpr ::= '/' <dot>.</dot> RelativePathExpr</item>
      <item id="953" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr ::= <dot>.</dot> StepExpr RelativePathExpr_1</item>
      <item id="972" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= <dot>.</dot> FilterExpr</item>
      <item id="974" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= <dot>.</dot> AxisStep</item>
      <item id="976" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep ::= <dot>.</dot> AxisStep_1 PredicateList</item>
      <item id="981" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= <dot>.</dot> ReverseStep</item>
      <item id="983" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= <dot>.</dot> ForwardStep</item>
      <item id="987" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= <dot>.</dot> ForwardAxis NodeTest</item>
      <item id="990" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= <dot>.</dot> AbbrevForwardStep</item>
      <item id="995" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'child' '::'</item>
      <item id="999" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'descendant' '::'</item>
      <item id="1002" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'attribute' '::'</item>
      <item id="1005" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'self' '::'</item>
      <item id="1008" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'descendant-or-self' '::'</item>
      <item id="1011" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'following-sibling' '::'</item>
      <item id="1014" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'following' '::'</item>
      <item id="1018" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= <dot>.</dot> NodeTest</item>
      <item id="1021" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= <dot>.</dot> '@' NodeTest</item>
      <item id="1027" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= <dot>.</dot> ReverseAxis NodeTest</item>
      <item id="1030" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= <dot>.</dot> AbbrevReverseStep</item>
      <item id="1035" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'parent' '::'</item>
      <item id="1039" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'ancestor' '::'</item>
      <item id="1042" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'preceding-sibling' '::'</item>
      <item id="1045" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'preceding' '::'</item>
      <item id="1048" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'ancestor-or-self' '::'</item>
      <item id="1051" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevReverseStep ::= <dot>.</dot> '..'</item>
      <item id="1055" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> KindTest</item>
      <item id="1057" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> NameTest</item>
      <item id="1060" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> QName</item>
      <item id="1062" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> Wildcard</item>
      <item id="1064" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FilterExpr ::= <dot>.</dot> PrimaryExpr PredicateList</item>
      <item id="1082" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> Literal</item>
      <item id="1084" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> VarRef</item>
      <item id="1085" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> ParenthesizedExpr</item>
      <item id="1086" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> ContextItemExpr</item>
      <item id="1087" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> FunctionCall</item>
      <item id="1088" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> OrderedExpr</item>
      <item id="1089" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> UnorderedExpr</item>
      <item id="1090" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> Constructor</item>
      <item id="1093" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= <dot>.</dot> NumericLiteral</item>
      <item id="1095" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= <dot>.</dot> StringLiteral</item>
      <item id="1098" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> IntegerLiteral</item>
      <item id="1100" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> DecimalLiteral</item>
      <item id="1101" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> DoubleLiteral</item>
      <item id="1103" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">VarRef ::= <dot>.</dot> '$' VarName</item>
      <item id="1110" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ParenthesizedExpr ::= <dot>.</dot> '(' ParenthesizedExpr_1 ')'</item>
      <item id="1121" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ContextItemExpr ::= <dot>.</dot> '.'</item>
      <item id="1124" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">OrderedExpr ::= <dot>.</dot> 'ordered' '{' Expr '}'</item>
      <item id="1130" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnorderedExpr ::= <dot>.</dot> 'unordered' '{' Expr '}'</item>
      <item id="1136" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FunctionCall ::= <dot>.</dot> QName '(' FunctionCall_1 ')'</item>
      <item id="1160" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= <dot>.</dot> DirectConstructor</item>
      <item id="1162" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= <dot>.</dot> ComputedConstructor</item>
      <item id="1165" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirElemConstructor</item>
      <item id="1167" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirCommentConstructor</item>
      <item id="1168" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirPIConstructor</item>
      <item id="1170" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirElemConstructor ::= <dot>.</dot> '&lt;' QName DirAttributeList DirElemConstructor_1</item>
      <item id="1296" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirCommentConstructor ::= <dot>.</dot> '&lt;!--' DirCommentContents '--&gt;'</item>
      <item id="1301" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirPIConstructor ::= <dot>.</dot> '&lt;?' PITarget DirPIConstructor_1 '?&gt;'</item>
      <item id="1316" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompDocConstructor</item>
      <item id="1318" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompElemConstructor</item>
      <item id="1319" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompAttrConstructor</item>
      <item id="1320" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompTextConstructor</item>
      <item id="1321" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompCommentConstructor</item>
      <item id="1322" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompPIConstructor</item>
      <item id="1324" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompDocConstructor ::= <dot>.</dot> 'document' '{' Expr '}'</item>
      <item id="1330" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= <dot>.</dot> 'element' CompElemConstructor_1 '{' CompElemConstructor_2 '}'</item>
      <item id="1355" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= <dot>.</dot> 'attribute' CompAttrConstructor_1 '{' CompAttrConstructor_2 '}'</item>
      <item id="1377" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompTextConstructor ::= <dot>.</dot> 'text' '{' Expr '}'</item>
      <item id="1383" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompCommentConstructor ::= <dot>.</dot> 'comment' '{' Expr '}'</item>
      <item id="1389" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= <dot>.</dot> 'processing-instruction' CompPIConstructor_1 '{' CompPIConstructor_2 '}'</item>
      <item id="1462" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="RelativePathExpr" to="413"/>
      <goto on="StepExpr" to="39"/>
      <goto on="AxisStep" to="365"/>
      <goto on="AxisStep_1" to="40"/>
      <goto on="ForwardStep" to="366"/>
      <goto on="ForwardAxis" to="41"/>
      <goto on="AbbrevForwardStep" to="367"/>
      <goto on="ReverseStep" to="366"/>
      <goto on="ReverseAxis" to="42"/>
      <goto on="AbbrevReverseStep" to="368"/>
      <goto on="NodeTest" to="369"/>
      <goto on="NameTest" to="370"/>
      <goto on="FilterExpr" to="365"/>
      <goto on="PrimaryExpr" to="43"/>
      <goto on="Literal" to="371"/>
      <goto on="NumericLiteral" to="372"/>
      <goto on="VarRef" to="371"/>
      <goto on="ParenthesizedExpr" to="371"/>
      <goto on="ContextItemExpr" to="371"/>
      <goto on="OrderedExpr" to="371"/>
      <goto on="UnorderedExpr" to="371"/>
      <goto on="FunctionCall" to="371"/>
      <goto on="Constructor" to="371"/>
      <goto on="DirectConstructor" to="373"/>
      <goto on="DirElemConstructor" to="374"/>
      <goto on="DirCommentConstructor" to="374"/>
      <goto on="DirPIConstructor" to="374"/>
      <goto on="ComputedConstructor" to="373"/>
      <goto on="CompDocConstructor" to="375"/>
      <goto on="CompElemConstructor" to="375"/>
      <goto on="CompAttrConstructor" to="375"/>
      <goto on="CompTextConstructor" to="375"/>
      <goto on="CompCommentConstructor" to="375"/>
      <goto on="CompPIConstructor" to="375"/>
      <goto on="KindTest" to="370"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="StringLiteral" to="372"/>
      <shift on="element" to="44"/>
      <shift on="QName" to="212"/>
      <shift on="ordered" to="213"/>
      <shift on="unordered" to="214"/>
      <shift on="$" to="45"/>
      <shift on="(" to="46"/>
      <shift on="&lt;" to="215"/>
      <shift on="child" to="216"/>
      <shift on="descendant" to="217"/>
      <shift on="attribute" to="51"/>
      <shift on="self" to="218"/>
      <shift on="descendant-or-self" to="219"/>
      <shift on="following-sibling" to="220"/>
      <shift on="following" to="221"/>
      <shift on="@" to="52"/>
      <shift on="parent" to="222"/>
      <shift on="ancestor" to="223"/>
      <shift on="preceding-sibling" to="224"/>
      <shift on="preceding" to="225"/>
      <shift on="ancestor-or-self" to="226"/>
      <shift on=".." to="378"/>
      <shift on="Wildcard" to="379"/>
      <shift on="IntegerLiteral" to="380"/>
      <shift on="DecimalLiteral" to="380"/>
      <shift on="DoubleLiteral" to="380"/>
      <shift on="." to="381"/>
      <shift on="&lt;!--" to="227"/>
      <shift on="&lt;?" to="228"/>
      <shift on="document" to="229"/>
      <shift on="text" to="230"/>
      <shift on="comment" to="231"/>
      <shift on="processing-instruction" to="53"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="50">
      <item id="949" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PathExpr ::= '//' <dot>.</dot> RelativePathExpr</item>
      <item id="953" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr ::= <dot>.</dot> StepExpr RelativePathExpr_1</item>
      <item id="972" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= <dot>.</dot> FilterExpr</item>
      <item id="974" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= <dot>.</dot> AxisStep</item>
      <item id="976" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep ::= <dot>.</dot> AxisStep_1 PredicateList</item>
      <item id="981" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= <dot>.</dot> ReverseStep</item>
      <item id="983" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= <dot>.</dot> ForwardStep</item>
      <item id="987" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= <dot>.</dot> ForwardAxis NodeTest</item>
      <item id="990" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= <dot>.</dot> AbbrevForwardStep</item>
      <item id="995" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'child' '::'</item>
      <item id="999" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'descendant' '::'</item>
      <item id="1002" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'attribute' '::'</item>
      <item id="1005" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'self' '::'</item>
      <item id="1008" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'descendant-or-self' '::'</item>
      <item id="1011" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'following-sibling' '::'</item>
      <item id="1014" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'following' '::'</item>
      <item id="1018" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= <dot>.</dot> NodeTest</item>
      <item id="1021" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= <dot>.</dot> '@' NodeTest</item>
      <item id="1027" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= <dot>.</dot> ReverseAxis NodeTest</item>
      <item id="1030" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= <dot>.</dot> AbbrevReverseStep</item>
      <item id="1035" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'parent' '::'</item>
      <item id="1039" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'ancestor' '::'</item>
      <item id="1042" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'preceding-sibling' '::'</item>
      <item id="1045" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'preceding' '::'</item>
      <item id="1048" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'ancestor-or-self' '::'</item>
      <item id="1051" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevReverseStep ::= <dot>.</dot> '..'</item>
      <item id="1055" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> KindTest</item>
      <item id="1057" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> NameTest</item>
      <item id="1060" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> QName</item>
      <item id="1062" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> Wildcard</item>
      <item id="1064" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FilterExpr ::= <dot>.</dot> PrimaryExpr PredicateList</item>
      <item id="1082" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> Literal</item>
      <item id="1084" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> VarRef</item>
      <item id="1085" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> ParenthesizedExpr</item>
      <item id="1086" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> ContextItemExpr</item>
      <item id="1087" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> FunctionCall</item>
      <item id="1088" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> OrderedExpr</item>
      <item id="1089" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> UnorderedExpr</item>
      <item id="1090" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> Constructor</item>
      <item id="1093" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= <dot>.</dot> NumericLiteral</item>
      <item id="1095" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= <dot>.</dot> StringLiteral</item>
      <item id="1098" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> IntegerLiteral</item>
      <item id="1100" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> DecimalLiteral</item>
      <item id="1101" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> DoubleLiteral</item>
      <item id="1103" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">VarRef ::= <dot>.</dot> '$' VarName</item>
      <item id="1110" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ParenthesizedExpr ::= <dot>.</dot> '(' ParenthesizedExpr_1 ')'</item>
      <item id="1121" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ContextItemExpr ::= <dot>.</dot> '.'</item>
      <item id="1124" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">OrderedExpr ::= <dot>.</dot> 'ordered' '{' Expr '}'</item>
      <item id="1130" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnorderedExpr ::= <dot>.</dot> 'unordered' '{' Expr '}'</item>
      <item id="1136" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FunctionCall ::= <dot>.</dot> QName '(' FunctionCall_1 ')'</item>
      <item id="1160" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= <dot>.</dot> DirectConstructor</item>
      <item id="1162" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= <dot>.</dot> ComputedConstructor</item>
      <item id="1165" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirElemConstructor</item>
      <item id="1167" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirCommentConstructor</item>
      <item id="1168" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirPIConstructor</item>
      <item id="1170" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirElemConstructor ::= <dot>.</dot> '&lt;' QName DirAttributeList DirElemConstructor_1</item>
      <item id="1296" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirCommentConstructor ::= <dot>.</dot> '&lt;!--' DirCommentContents '--&gt;'</item>
      <item id="1301" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirPIConstructor ::= <dot>.</dot> '&lt;?' PITarget DirPIConstructor_1 '?&gt;'</item>
      <item id="1316" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompDocConstructor</item>
      <item id="1318" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompElemConstructor</item>
      <item id="1319" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompAttrConstructor</item>
      <item id="1320" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompTextConstructor</item>
      <item id="1321" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompCommentConstructor</item>
      <item id="1322" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompPIConstructor</item>
      <item id="1324" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompDocConstructor ::= <dot>.</dot> 'document' '{' Expr '}'</item>
      <item id="1330" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= <dot>.</dot> 'element' CompElemConstructor_1 '{' CompElemConstructor_2 '}'</item>
      <item id="1355" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= <dot>.</dot> 'attribute' CompAttrConstructor_1 '{' CompAttrConstructor_2 '}'</item>
      <item id="1377" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompTextConstructor ::= <dot>.</dot> 'text' '{' Expr '}'</item>
      <item id="1383" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompCommentConstructor ::= <dot>.</dot> 'comment' '{' Expr '}'</item>
      <item id="1389" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= <dot>.</dot> 'processing-instruction' CompPIConstructor_1 '{' CompPIConstructor_2 '}'</item>
      <item id="1462" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="RelativePathExpr" to="413"/>
      <goto on="StepExpr" to="39"/>
      <goto on="AxisStep" to="365"/>
      <goto on="AxisStep_1" to="40"/>
      <goto on="ForwardStep" to="366"/>
      <goto on="ForwardAxis" to="41"/>
      <goto on="AbbrevForwardStep" to="367"/>
      <goto on="ReverseStep" to="366"/>
      <goto on="ReverseAxis" to="42"/>
      <goto on="AbbrevReverseStep" to="368"/>
      <goto on="NodeTest" to="369"/>
      <goto on="NameTest" to="370"/>
      <goto on="FilterExpr" to="365"/>
      <goto on="PrimaryExpr" to="43"/>
      <goto on="Literal" to="371"/>
      <goto on="NumericLiteral" to="372"/>
      <goto on="VarRef" to="371"/>
      <goto on="ParenthesizedExpr" to="371"/>
      <goto on="ContextItemExpr" to="371"/>
      <goto on="OrderedExpr" to="371"/>
      <goto on="UnorderedExpr" to="371"/>
      <goto on="FunctionCall" to="371"/>
      <goto on="Constructor" to="371"/>
      <goto on="DirectConstructor" to="373"/>
      <goto on="DirElemConstructor" to="374"/>
      <goto on="DirCommentConstructor" to="374"/>
      <goto on="DirPIConstructor" to="374"/>
      <goto on="ComputedConstructor" to="373"/>
      <goto on="CompDocConstructor" to="375"/>
      <goto on="CompElemConstructor" to="375"/>
      <goto on="CompAttrConstructor" to="375"/>
      <goto on="CompTextConstructor" to="375"/>
      <goto on="CompCommentConstructor" to="375"/>
      <goto on="CompPIConstructor" to="375"/>
      <goto on="KindTest" to="370"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="StringLiteral" to="372"/>
      <shift on="element" to="44"/>
      <shift on="QName" to="212"/>
      <shift on="ordered" to="213"/>
      <shift on="unordered" to="214"/>
      <shift on="$" to="45"/>
      <shift on="(" to="46"/>
      <shift on="&lt;" to="215"/>
      <shift on="child" to="216"/>
      <shift on="descendant" to="217"/>
      <shift on="attribute" to="51"/>
      <shift on="self" to="218"/>
      <shift on="descendant-or-self" to="219"/>
      <shift on="following-sibling" to="220"/>
      <shift on="following" to="221"/>
      <shift on="@" to="52"/>
      <shift on="parent" to="222"/>
      <shift on="ancestor" to="223"/>
      <shift on="preceding-sibling" to="224"/>
      <shift on="preceding" to="225"/>
      <shift on="ancestor-or-self" to="226"/>
      <shift on=".." to="378"/>
      <shift on="Wildcard" to="379"/>
      <shift on="IntegerLiteral" to="380"/>
      <shift on="DecimalLiteral" to="380"/>
      <shift on="DoubleLiteral" to="380"/>
      <shift on="." to="381"/>
      <shift on="&lt;!--" to="227"/>
      <shift on="&lt;?" to="228"/>
      <shift on="document" to="229"/>
      <shift on="text" to="230"/>
      <shift on="comment" to="231"/>
      <shift on="processing-instruction" to="53"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="51">
      <item id="1003" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= 'attribute' <dot>.</dot> '::'</item>
      <item id="1356" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= 'attribute' <dot>.</dot> CompAttrConstructor_1 '{' CompAttrConstructor_2 '}'</item>
      <item id="1363" lookahead="%WS {">CompAttrConstructor_1 ::= <dot>.</dot> QName</item>
      <item id="1366" lookahead="%WS {">CompAttrConstructor_1 ::= <dot>.</dot> '{' Expr '}'</item>
      <item id="1515" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AttributeTest ::= 'attribute' <dot>.</dot> '(' AttributeTest_1 ')'</item>
      <goto on="CompAttrConstructor_1" to="257"/>
      <shift on="QName" to="415"/>
      <shift on="(" to="86"/>
      <shift on="{" to="87"/>
      <shift on="::" to="414"/>
    </state>
    <state id="52">
      <item id="1022" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= '@' <dot>.</dot> NodeTest</item>
      <item id="1055" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> KindTest</item>
      <item id="1057" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> NameTest</item>
      <item id="1060" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> QName</item>
      <item id="1062" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> Wildcard</item>
      <item id="1462" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="NodeTest" to="416"/>
      <goto on="NameTest" to="370"/>
      <goto on="KindTest" to="370"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="element" to="248"/>
      <shift on="QName" to="379"/>
      <shift on="attribute" to="249"/>
      <shift on="Wildcard" to="379"/>
      <shift on="text" to="250"/>
      <shift on="comment" to="251"/>
      <shift on="processing-instruction" to="252"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="53">
      <item id="1390" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= 'processing-instruction' <dot>.</dot> CompPIConstructor_1 '{' CompPIConstructor_2 '}'</item>
      <item id="1397" lookahead="%WS {">CompPIConstructor_1 ::= <dot>.</dot> NCName</item>
      <item id="1400" lookahead="%WS {">CompPIConstructor_1 ::= <dot>.</dot> '{' Expr '}'</item>
      <item id="1502" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PITest ::= 'processing-instruction' <dot>.</dot> '(' PITest_1 ')'</item>
      <goto on="CompPIConstructor_1" to="261"/>
      <shift on="NCName" to="418"/>
      <shift on="(" to="92"/>
      <shift on="{" to="93"/>
    </state>
    <state id="54">
      <item id="406" lookahead="%WS for let order return stable where">ForClause ::= 'for' '$' <dot>.</dot> VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="1107" lookahead="%WS as at in">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="97"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="55">
      <item id="459" lookahead="%WS for let order return stable where">LetClause ::= 'let' '$' <dot>.</dot> VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="1107" lookahead="%WS := as">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="98"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="56">
      <item id="351" lookahead="%WS )">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) ,">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) ,">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) ,">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="603" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' '(' <dot>.</dot> Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) ,">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) ,">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , and or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="263"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="57">
      <item id="351" lookahead="%WS )">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) ,">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) ,">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) ,">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) ,">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="646" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= 'if' '(' <dot>.</dot> Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) ,">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , and or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="264"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="58">
      <item id="82" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare function declare option declare variable descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_3 ::= Prolog_3 Prolog_4 <dot>.</dot> Separator</item>
      <item id="106" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare function declare option declare variable descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Separator ::= <dot>.</dot> ';'</item>
      <goto on="Separator" to="419"/>
      <shift on=";" to="383"/>
    </state>
    <state id="59">
      <item id="178" lookahead="%WS ;">DefaultCollationDecl ::= 'declare default' 'collation' <dot>.</dot> URILiteral</item>
      <item id="1602" lookahead="%WS ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="420"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="60">
      <item id="229" lookahead="%WS ;">ModuleImport ::= 'import' 'module' <dot>.</dot> ModuleImport_1 URILiteral ModuleImport_2</item>
      <item id="238" lookahead="%WS StringLiteral">ModuleImport_1 ::= <dot>.</dot> 'namespace' NCName '='</item>
      <item id="236" lookahead="%WS StringLiteral">ModuleImport_1 ::= <dot>.</dot></item>
      <goto on="ModuleImport_1" to="103"/>
      <shift on="namespace" to="268"/>
      <reduce on="StringLiteral" symbol="ModuleImport_1"/>
    </state>
    <state id="61">
      <item id="187" lookahead="%WS ;">SchemaImport ::= 'import' 'schema' <dot>.</dot> SchemaImport_1 URILiteral SchemaImport_2</item>
      <item id="195" lookahead="%WS StringLiteral">SchemaImport_1 ::= <dot>.</dot> SchemaPrefix</item>
      <item id="218" lookahead="%WS StringLiteral">SchemaPrefix ::= <dot>.</dot> 'namespace' NCName '='</item>
      <item id="223" lookahead="%WS StringLiteral">SchemaPrefix ::= <dot>.</dot> 'default' 'element' 'namespace'</item>
      <item id="194" lookahead="%WS StringLiteral">SchemaImport_1 ::= <dot>.</dot></item>
      <goto on="SchemaImport_1" to="104"/>
      <goto on="SchemaPrefix" to="421"/>
      <shift on="namespace" to="269"/>
      <shift on="default" to="270"/>
      <reduce on="StringLiteral" symbol="SchemaImport_1"/>
    </state>
    <state id="62">
      <item id="29" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">VersionDecl ::= 'xquery' 'version' StringLiteral VersionDecl_1 <dot>.</dot> Separator</item>
      <item id="106" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Separator ::= <dot>.</dot> ';'</item>
      <goto on="Separator" to="422"/>
      <shift on=";" to="383"/>
    </state>
    <state id="63">
      <item id="361" lookahead="%WS ) , EOF ] }">Expr_1 ::= Expr_1 ',' <dot>.</dot> ExprSingle</item>
      <item id="365" lookahead="%WS ) , EOF ] }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) , EOF ] }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) , EOF ] }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) , EOF ] }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) , EOF ] }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) , EOF ] }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) , EOF ] }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) , EOF ] }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) , EOF ] }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) , EOF ] }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , EOF ] or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , EOF ] and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="424"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="64">
      <item id="365" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , ascending collation descending empty return">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="496" lookahead="%WS return">OrderByClause ::= OrderByClause_1 <dot>.</dot> OrderSpecList</item>
      <item id="510" lookahead="%WS return">OrderSpecList ::= <dot>.</dot> OrderSpec OrderSpecList_1</item>
      <item id="523" lookahead="%WS , return">OrderSpec ::= <dot>.</dot> ExprSingle OrderModifier</item>
      <item id="560" lookahead="%WS , ascending collation descending empty return">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , ascending collation descending empty return">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , ascending collation descending empty return">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , ascending collation descending empty return">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , ascending collation descending empty or return">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and ascending collation descending empty or return">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending empty eq ge gt is le lt ne or return">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending empty eq ge gt is le lt ne or return to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending empty eq ge gt is le lt ne or return to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq ge gt idiv is le lt mod ne or return to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq ge gt idiv is le lt mod ne or return to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq except ge gt idiv intersect is le lt mod ne or return to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq except ge gt idiv instance intersect is le lt mod ne or return to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq except ge gt idiv instance intersect is le lt mod ne or return to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending castable collation descending div empty eq except ge gt idiv instance intersect is le lt mod ne or return to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending cast castable collation descending div empty eq except ge gt idiv instance intersect is le lt mod ne or return to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="107"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="OrderSpecList" to="425"/>
      <goto on="OrderSpec" to="108"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="65">
      <item id="563" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 '$' VarName <dot>.</dot> QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="579" lookahead="%WS in">QuantifiedExpr_2 ::= <dot>.</dot> TypeDeclaration</item>
      <item id="1421" lookahead="%WS in">TypeDeclaration ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="578" lookahead="%WS in">QuantifiedExpr_2 ::= <dot>.</dot></item>
      <goto on="QuantifiedExpr_2" to="272"/>
      <goto on="TypeDeclaration" to="427"/>
      <shift on="as" to="109"/>
      <reduce on="in" symbol="QuantifiedExpr_2"/>
    </state>
    <state id="66">
      <item id="664" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">OrExpr_1 ::= OrExpr_1 'or' <dot>.</dot> AndExpr</item>
      <item id="667" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="AndExpr" to="428"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="67">
      <item id="677" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr_1 ::= AndExpr_1 'and' <dot>.</dot> ComparisonExpr</item>
      <item id="680" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ComparisonExpr" to="429"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="68">
      <item id="720" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr_1 ::= AdditiveExpr_1 AdditiveExpr_2 <dot>.</dot> MultiplicativeExpr</item>
      <item id="728" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="MultiplicativeExpr" to="430"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="69">
      <item id="738" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">MultiplicativeExpr_1 ::= MultiplicativeExpr_1 MultiplicativeExpr_2 <dot>.</dot> UnionExpr</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="UnionExpr" to="431"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="70">
      <item id="758" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">UnionExpr_1 ::= UnionExpr_1 UnionExpr_2 <dot>.</dot> IntersectExceptExpr</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="IntersectExceptExpr" to="432"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="71">
      <item id="776" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr_1 ::= IntersectExceptExpr_1 IntersectExceptExpr_2 <dot>.</dot> InstanceofExpr</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="InstanceofExpr" to="433"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="72">
      <item id="794" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr_1 ::= 'instance' 'of' <dot>.</dot> SequenceType</item>
      <item id="1427" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">SequenceType ::= <dot>.</dot> 'empty-sequence' '(' ')'</item>
      <item id="1432" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">SequenceType ::= <dot>.</dot> ItemType SequenceType_1</item>
      <item id="1449" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">ItemType ::= <dot>.</dot> KindTest</item>
      <item id="1452" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">ItemType ::= <dot>.</dot> 'item' '(' ')'</item>
      <item id="1456" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">ItemType ::= <dot>.</dot> AtomicType</item>
      <item id="1458" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">AtomicType ::= <dot>.</dot> QName</item>
      <item id="1462" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="SequenceType" to="434"/>
      <goto on="ItemType" to="110"/>
      <goto on="AtomicType" to="435"/>
      <goto on="KindTest" to="435"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="element" to="248"/>
      <shift on="QName" to="436"/>
      <shift on="attribute" to="249"/>
      <shift on="text" to="250"/>
      <shift on="comment" to="251"/>
      <shift on="processing-instruction" to="252"/>
      <shift on="empty-sequence" to="273"/>
      <shift on="item" to="274"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="73">
      <item id="807" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr_1 ::= 'treat' 'as' <dot>.</dot> SequenceType</item>
      <item id="1427" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">SequenceType ::= <dot>.</dot> 'empty-sequence' '(' ')'</item>
      <item id="1432" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">SequenceType ::= <dot>.</dot> ItemType SequenceType_1</item>
      <item id="1449" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">ItemType ::= <dot>.</dot> KindTest</item>
      <item id="1452" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">ItemType ::= <dot>.</dot> 'item' '(' ')'</item>
      <item id="1456" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">ItemType ::= <dot>.</dot> AtomicType</item>
      <item id="1458" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">AtomicType ::= <dot>.</dot> QName</item>
      <item id="1462" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="SequenceType" to="437"/>
      <goto on="ItemType" to="110"/>
      <goto on="AtomicType" to="435"/>
      <goto on="KindTest" to="435"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="element" to="248"/>
      <shift on="QName" to="436"/>
      <shift on="attribute" to="249"/>
      <shift on="text" to="250"/>
      <shift on="comment" to="251"/>
      <shift on="processing-instruction" to="252"/>
      <shift on="empty-sequence" to="273"/>
      <shift on="item" to="274"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="74">
      <item id="820" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr_1 ::= 'castable' 'as' <dot>.</dot> SingleType</item>
      <item id="1411" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SingleType ::= <dot>.</dot> AtomicType SingleType_1</item>
      <item id="1458" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AtomicType ::= <dot>.</dot> QName</item>
      <goto on="SingleType" to="438"/>
      <goto on="AtomicType" to="111"/>
      <shift on="QName" to="436"/>
    </state>
    <state id="75">
      <item id="833" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr_1 ::= 'cast' 'as' <dot>.</dot> SingleType</item>
      <item id="1411" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SingleType ::= <dot>.</dot> AtomicType SingleType_1</item>
      <item id="1458" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AtomicType ::= <dot>.</dot> QName</item>
      <goto on="SingleType" to="439"/>
      <goto on="AtomicType" to="111"/>
      <shift on="QName" to="436"/>
    </state>
    <state id="76">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="903" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ExtensionExpr ::= ExtensionExpr_1 '{' <dot>.</dot> ExtensionExpr_2 '}'</item>
      <item id="918" lookahead="%WS }">ExtensionExpr_2 ::= <dot>.</dot> Expr</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <item id="917" lookahead="%WS }">ExtensionExpr_2 ::= <dot>.</dot></item>
      <goto on="Expr" to="440"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <goto on="ExtensionExpr_2" to="275"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
      <reduce on="}" symbol="ExtensionExpr_2"/>
    </state>
    <state id="77">
      <item id="962" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr_1 ::= RelativePathExpr_1 <dot>.</dot> RelativePathExpr_2 StepExpr</item>
      <item id="967" lookahead="$ %WS ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered">RelativePathExpr_2 ::= <dot>.</dot> '/'</item>
      <item id="969" lookahead="$ %WS ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered">RelativePathExpr_2 ::= <dot>.</dot> '//'</item>
      <item id="955" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr ::= StepExpr RelativePathExpr_1 <dot>.</dot></item>
      <goto on="RelativePathExpr_2" to="112"/>
      <shift on="/" to="441"/>
      <shift on="//" to="441"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="RelativePathExpr"/>
    </state>
    <state id="78">
      <item id="1073" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PredicateList ::= PredicateList <dot>.</dot> Predicate</item>
      <item id="1076" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Predicate ::= <dot>.</dot> '[' Expr ']'</item>
      <item id="978" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep ::= AxisStep_1 PredicateList <dot>.</dot></item>
      <goto on="Predicate" to="442"/>
      <shift on="[" to="113"/>
      <reduce on="!= ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="AxisStep"/>
    </state>
    <state id="79">
      <item id="1073" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PredicateList ::= PredicateList <dot>.</dot> Predicate</item>
      <item id="1076" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Predicate ::= <dot>.</dot> '[' Expr ']'</item>
      <item id="1066" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FilterExpr ::= PrimaryExpr PredicateList <dot>.</dot></item>
      <goto on="Predicate" to="442"/>
      <shift on="[" to="113"/>
      <reduce on="!= ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="FilterExpr"/>
    </state>
    <state id="80">
      <item id="1552" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">ElementTest ::= 'element' '(' <dot>.</dot> ElementTest_1 ')'</item>
      <item id="1560" lookahead="%WS )">ElementTest_1 ::= <dot>.</dot> ElementNameOrWildcard ElementTest_2</item>
      <item id="1580" lookahead="%WS ) ,">ElementNameOrWildcard ::= <dot>.</dot> ElementName</item>
      <item id="1582" lookahead="%WS ) ,">ElementNameOrWildcard ::= <dot>.</dot> '*'</item>
      <item id="1596" lookahead="%WS ) ,">ElementName ::= <dot>.</dot> QName</item>
      <item id="1558" lookahead="%WS )">ElementTest_1 ::= <dot>.</dot></item>
      <goto on="ElementTest_1" to="276"/>
      <goto on="ElementNameOrWildcard" to="115"/>
      <goto on="ElementName" to="443"/>
      <shift on="QName" to="444"/>
      <shift on="*" to="443"/>
      <reduce on=")" symbol="ElementTest_1"/>
    </state>
    <state id="81">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1342" lookahead="%WS {">CompElemConstructor_1 ::= '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="277"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="82">
      <item id="365" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) ,">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) ,">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) ,">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) ,">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) ,">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , and or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1138" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FunctionCall ::= QName '(' <dot>.</dot> FunctionCall_1 ')'</item>
      <item id="1146" lookahead="%WS )">FunctionCall_1 ::= <dot>.</dot> ExprSingle FunctionCall_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <item id="1144" lookahead="%WS )">FunctionCall_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="116"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <goto on="FunctionCall_1" to="278"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
      <reduce on=")" symbol="FunctionCall_1"/>
    </state>
    <state id="83">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1126" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">OrderedExpr ::= 'ordered' '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="279"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="84">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1132" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnorderedExpr ::= 'unordered' '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="280"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="85">
      <item id="1172" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor ::= '&lt;' QName <dot>.</dot> DirAttributeList DirElemConstructor_1</item>
      <item id="1206" lookahead="%WS /&gt; &gt; S">DirAttributeList ::= <dot>.</dot> DirAttributeList S DirAttributeList_1</item>
      <item id="1204" lookahead="%WS /&gt; &gt; S">DirAttributeList ::= <dot>.</dot></item>
      <goto on="DirAttributeList" to="117"/>
      <reduce on="/&gt; &gt; S" symbol="DirAttributeList"/>
    </state>
    <state id="86">
      <item id="1516" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">AttributeTest ::= 'attribute' '(' <dot>.</dot> AttributeTest_1 ')'</item>
      <item id="1524" lookahead="%WS )">AttributeTest_1 ::= <dot>.</dot> AttribNameOrWildcard AttributeTest_2</item>
      <item id="1537" lookahead="%WS ) ,">AttribNameOrWildcard ::= <dot>.</dot> AttributeName</item>
      <item id="1539" lookahead="%WS ) ,">AttribNameOrWildcard ::= <dot>.</dot> '*'</item>
      <item id="1593" lookahead="%WS ) ,">AttributeName ::= <dot>.</dot> QName</item>
      <item id="1522" lookahead="%WS )">AttributeTest_1 ::= <dot>.</dot></item>
      <goto on="AttributeTest_1" to="281"/>
      <goto on="AttribNameOrWildcard" to="121"/>
      <goto on="AttributeName" to="446"/>
      <shift on="QName" to="447"/>
      <shift on="*" to="446"/>
      <reduce on=")" symbol="AttributeTest_1"/>
    </state>
    <state id="87">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1367" lookahead="%WS {">CompAttrConstructor_1 ::= '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="282"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="88">
      <item id="1303" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirPIConstructor ::= '&lt;?' PITarget <dot>.</dot> DirPIConstructor_1 '?&gt;'</item>
      <item id="1311" lookahead="%WS ?&gt;">DirPIConstructor_1 ::= <dot>.</dot> S DirPIContents</item>
      <item id="1309" lookahead="%WS ?&gt;">DirPIConstructor_1 ::= <dot>.</dot></item>
      <goto on="DirPIConstructor_1" to="283"/>
      <shift on="S" to="284"/>
      <reduce on="?&gt;" symbol="DirPIConstructor_1"/>
    </state>
    <state id="89">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1326" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompDocConstructor ::= 'document' '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="285"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="90">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1379" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompTextConstructor ::= 'text' '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="286"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="91">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1385" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompCommentConstructor ::= 'comment' '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="287"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="92">
      <item id="1503" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">PITest ::= 'processing-instruction' '(' <dot>.</dot> PITest_1 ')'</item>
      <item id="1510" lookahead="%WS )">PITest_1 ::= <dot>.</dot> NCName</item>
      <item id="1512" lookahead="%WS )">PITest_1 ::= <dot>.</dot> StringLiteral</item>
      <item id="1509" lookahead="%WS )">PITest_1 ::= <dot>.</dot></item>
      <goto on="PITest_1" to="288"/>
      <shift on="StringLiteral" to="451"/>
      <shift on="NCName" to="451"/>
      <reduce on=")" symbol="PITest_1"/>
    </state>
    <state id="93">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1401" lookahead="%WS {">CompPIConstructor_1 ::= '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="289"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="94">
      <item id="1480" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">DocumentTest ::= 'document-node' '(' <dot>.</dot> DocumentTest_1 ')'</item>
      <item id="1487" lookahead="%WS )">DocumentTest_1 ::= <dot>.</dot> ElementTest</item>
      <item id="1489" lookahead="%WS )">DocumentTest_1 ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1550" lookahead="%WS )">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="%WS )">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <item id="1486" lookahead="%WS )">DocumentTest_1 ::= <dot>.</dot></item>
      <goto on="DocumentTest_1" to="290"/>
      <goto on="ElementTest" to="453"/>
      <goto on="SchemaElementTest" to="453"/>
      <shift on="element" to="248"/>
      <shift on="schema-element" to="235"/>
      <reduce on=")" symbol="DocumentTest_1"/>
    </state>
    <state id="95">
      <item id="1543" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">SchemaAttributeTest ::= 'schema-attribute' '(' <dot>.</dot> AttributeDeclaration ')'</item>
      <item id="1547" lookahead="%WS )">AttributeDeclaration ::= <dot>.</dot> AttributeName</item>
      <item id="1593" lookahead="%WS )">AttributeName ::= <dot>.</dot> QName</item>
      <goto on="AttributeDeclaration" to="291"/>
      <goto on="AttributeName" to="454"/>
      <shift on="QName" to="447"/>
    </state>
    <state id="96">
      <item id="1586" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">SchemaElementTest ::= 'schema-element' '(' <dot>.</dot> ElementDeclaration ')'</item>
      <item id="1590" lookahead="%WS )">ElementDeclaration ::= <dot>.</dot> ElementName</item>
      <item id="1596" lookahead="%WS )">ElementName ::= <dot>.</dot> QName</item>
      <goto on="ElementDeclaration" to="292"/>
      <goto on="ElementName" to="455"/>
      <shift on="QName" to="444"/>
    </state>
    <state id="97">
      <item id="407" lookahead="%WS for let order return stable where">ForClause ::= 'for' '$' VarName <dot>.</dot> ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="417" lookahead="%WS at in">ForClause_1 ::= <dot>.</dot> TypeDeclaration</item>
      <item id="1421" lookahead="%WS at in">TypeDeclaration ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="416" lookahead="%WS at in">ForClause_1 ::= <dot>.</dot></item>
      <goto on="ForClause_1" to="123"/>
      <goto on="TypeDeclaration" to="456"/>
      <shift on="as" to="109"/>
      <reduce on="at in" symbol="ForClause_1"/>
    </state>
    <state id="98">
      <item id="460" lookahead="%WS for let order return stable where">LetClause ::= 'let' '$' VarName <dot>.</dot> LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="469" lookahead="%WS :=">LetClause_1 ::= <dot>.</dot> TypeDeclaration</item>
      <item id="1421" lookahead="%WS :=">TypeDeclaration ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="468" lookahead="%WS :=">LetClause_1 ::= <dot>.</dot></item>
      <goto on="LetClause_1" to="293"/>
      <goto on="TypeDeclaration" to="457"/>
      <shift on="as" to="109"/>
      <reduce on=":=" symbol="LetClause_1"/>
    </state>
    <state id="99">
      <item id="112" lookahead="%WS ;">NamespaceDecl ::= 'declare namespace' NCName '=' <dot>.</dot> URILiteral</item>
      <item id="1602" lookahead="%WS ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="459"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="100">
      <item id="127" lookahead="%WS ;">DefaultNamespaceDecl ::= 'declare default' DefaultNamespaceDecl_1 'namespace' <dot>.</dot> URILiteral</item>
      <item id="1602" lookahead="%WS ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="460"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="101">
      <item id="152" lookahead="%WS ;">EmptyOrderDecl ::= 'declare default' 'order' 'empty' <dot>.</dot> EmptyOrderDecl_1</item>
      <item id="156" lookahead="%WS ;">EmptyOrderDecl_1 ::= <dot>.</dot> 'greatest'</item>
      <item id="158" lookahead="%WS ;">EmptyOrderDecl_1 ::= <dot>.</dot> 'least'</item>
      <goto on="EmptyOrderDecl_1" to="461"/>
      <shift on="greatest" to="462"/>
      <shift on="least" to="462"/>
    </state>
    <state id="102">
      <item id="163" lookahead="%WS ;">CopyNamespacesDecl ::= 'declare copy-namespaces' PreserveMode ',' <dot>.</dot> InheritMode</item>
      <item id="172" lookahead="%WS ;">InheritMode ::= <dot>.</dot> 'inherit'</item>
      <item id="174" lookahead="%WS ;">InheritMode ::= <dot>.</dot> 'no-inherit'</item>
      <goto on="InheritMode" to="463"/>
      <shift on="inherit" to="464"/>
      <shift on="no-inherit" to="464"/>
    </state>
    <state id="103">
      <item id="230" lookahead="%WS ;">ModuleImport ::= 'import' 'module' ModuleImport_1 <dot>.</dot> URILiteral ModuleImport_2</item>
      <item id="1602" lookahead="%WS ; at">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="127"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="104">
      <item id="188" lookahead="%WS ;">SchemaImport ::= 'import' 'schema' SchemaImport_1 <dot>.</dot> URILiteral SchemaImport_2</item>
      <item id="1602" lookahead="%WS ; at">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="128"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="105">
      <item id="52" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">ModuleDecl ::= 'module' 'namespace' NCName '=' <dot>.</dot> URILiteral Separator</item>
      <item id="1602" lookahead="%WS ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="129"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="106">
      <item id="365" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="376" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' <dot>.</dot> ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="465"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="107">
      <item id="524" lookahead="%WS , return">OrderSpec ::= ExprSingle <dot>.</dot> OrderModifier</item>
      <item id="527" lookahead="%WS , return">OrderModifier ::= <dot>.</dot> OrderModifier_1 OrderModifier_2 OrderModifier_4</item>
      <item id="535" lookahead="%WS , collation empty return">OrderModifier_1 ::= <dot>.</dot> 'ascending'</item>
      <item id="537" lookahead="%WS , collation empty return">OrderModifier_1 ::= <dot>.</dot> 'descending'</item>
      <item id="534" lookahead="%WS , collation empty return">OrderModifier_1 ::= <dot>.</dot></item>
      <goto on="OrderModifier" to="466"/>
      <goto on="OrderModifier_1" to="130"/>
      <shift on="ascending" to="467"/>
      <shift on="descending" to="467"/>
      <reduce on=", collation empty return" symbol="OrderModifier_1"/>
    </state>
    <state id="108">
      <item id="511" lookahead="%WS return">OrderSpecList ::= OrderSpec <dot>.</dot> OrderSpecList_1</item>
      <item id="518" lookahead="%WS , return">OrderSpecList_1 ::= <dot>.</dot> OrderSpecList_1 ',' OrderSpec</item>
      <item id="516" lookahead="%WS , return">OrderSpecList_1 ::= <dot>.</dot></item>
      <goto on="OrderSpecList_1" to="298"/>
      <reduce on=", return" symbol="OrderSpecList_1"/>
    </state>
    <state id="109">
      <item id="1422" lookahead="%WS ) , := at external in">TypeDeclaration ::= 'as' <dot>.</dot> SequenceType</item>
      <item id="1427" lookahead="%WS ) , := at external in">SequenceType ::= <dot>.</dot> 'empty-sequence' '(' ')'</item>
      <item id="1432" lookahead="%WS ) , := at external in">SequenceType ::= <dot>.</dot> ItemType SequenceType_1</item>
      <item id="1449" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">ItemType ::= <dot>.</dot> KindTest</item>
      <item id="1452" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">ItemType ::= <dot>.</dot> 'item' '(' ')'</item>
      <item id="1456" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">ItemType ::= <dot>.</dot> AtomicType</item>
      <item id="1458" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">AtomicType ::= <dot>.</dot> QName</item>
      <item id="1462" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="%WS ) , := ? PlusOccurreneIndicator StarOccurreneIndicator at external in">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="SequenceType" to="469"/>
      <goto on="ItemType" to="110"/>
      <goto on="AtomicType" to="435"/>
      <goto on="KindTest" to="435"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="element" to="248"/>
      <shift on="QName" to="436"/>
      <shift on="attribute" to="249"/>
      <shift on="text" to="250"/>
      <shift on="comment" to="251"/>
      <shift on="processing-instruction" to="252"/>
      <shift on="empty-sequence" to="273"/>
      <shift on="item" to="274"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="110">
      <item id="1433" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">SequenceType ::= ItemType <dot>.</dot> SequenceType_1</item>
      <item id="1439" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">SequenceType_1 ::= <dot>.</dot> OccurrenceIndicator</item>
      <item id="1443" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">OccurrenceIndicator ::= <dot>.</dot> '?'</item>
      <item id="1445" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">OccurrenceIndicator ::= <dot>.</dot> StarOccurreneIndicator</item>
      <item id="1446" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">OccurrenceIndicator ::= <dot>.</dot> PlusOccurreneIndicator</item>
      <item id="1438" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">SequenceType_1 ::= <dot>.</dot></item>
      <goto on="SequenceType_1" to="470"/>
      <goto on="OccurrenceIndicator" to="471"/>
      <shift on="?" to="472"/>
      <shift on="StarOccurreneIndicator" to="472"/>
      <shift on="PlusOccurreneIndicator" to="472"/>
      <reduce on="!= ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }" symbol="SequenceType_1"/>
    </state>
    <state id="111">
      <item id="1412" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SingleType ::= AtomicType <dot>.</dot> SingleType_1</item>
      <item id="1418" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SingleType_1 ::= <dot>.</dot> '?'</item>
      <item id="1417" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SingleType_1 ::= <dot>.</dot></item>
      <goto on="SingleType_1" to="473"/>
      <shift on="?" to="474"/>
      <reduce on="!= ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="SingleType_1"/>
    </state>
    <state id="112">
      <item id="963" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr_1 ::= RelativePathExpr_1 RelativePathExpr_2 <dot>.</dot> StepExpr</item>
      <item id="972" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= <dot>.</dot> FilterExpr</item>
      <item id="974" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= <dot>.</dot> AxisStep</item>
      <item id="976" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep ::= <dot>.</dot> AxisStep_1 PredicateList</item>
      <item id="981" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= <dot>.</dot> ReverseStep</item>
      <item id="983" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= <dot>.</dot> ForwardStep</item>
      <item id="987" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= <dot>.</dot> ForwardAxis NodeTest</item>
      <item id="990" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= <dot>.</dot> AbbrevForwardStep</item>
      <item id="995" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'child' '::'</item>
      <item id="999" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'descendant' '::'</item>
      <item id="1002" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'attribute' '::'</item>
      <item id="1005" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'self' '::'</item>
      <item id="1008" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'descendant-or-self' '::'</item>
      <item id="1011" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'following-sibling' '::'</item>
      <item id="1014" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= <dot>.</dot> 'following' '::'</item>
      <item id="1018" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= <dot>.</dot> NodeTest</item>
      <item id="1021" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= <dot>.</dot> '@' NodeTest</item>
      <item id="1027" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= <dot>.</dot> ReverseAxis NodeTest</item>
      <item id="1030" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= <dot>.</dot> AbbrevReverseStep</item>
      <item id="1035" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'parent' '::'</item>
      <item id="1039" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'ancestor' '::'</item>
      <item id="1042" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'preceding-sibling' '::'</item>
      <item id="1045" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'preceding' '::'</item>
      <item id="1048" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= <dot>.</dot> 'ancestor-or-self' '::'</item>
      <item id="1051" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevReverseStep ::= <dot>.</dot> '..'</item>
      <item id="1055" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> KindTest</item>
      <item id="1057" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= <dot>.</dot> NameTest</item>
      <item id="1060" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> QName</item>
      <item id="1062" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= <dot>.</dot> Wildcard</item>
      <item id="1064" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FilterExpr ::= <dot>.</dot> PrimaryExpr PredicateList</item>
      <item id="1082" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> Literal</item>
      <item id="1084" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> VarRef</item>
      <item id="1085" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> ParenthesizedExpr</item>
      <item id="1086" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> ContextItemExpr</item>
      <item id="1087" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> FunctionCall</item>
      <item id="1088" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> OrderedExpr</item>
      <item id="1089" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> UnorderedExpr</item>
      <item id="1090" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= <dot>.</dot> Constructor</item>
      <item id="1093" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= <dot>.</dot> NumericLiteral</item>
      <item id="1095" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= <dot>.</dot> StringLiteral</item>
      <item id="1098" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> IntegerLiteral</item>
      <item id="1100" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> DecimalLiteral</item>
      <item id="1101" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= <dot>.</dot> DoubleLiteral</item>
      <item id="1103" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">VarRef ::= <dot>.</dot> '$' VarName</item>
      <item id="1110" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ParenthesizedExpr ::= <dot>.</dot> '(' ParenthesizedExpr_1 ')'</item>
      <item id="1121" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ContextItemExpr ::= <dot>.</dot> '.'</item>
      <item id="1124" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">OrderedExpr ::= <dot>.</dot> 'ordered' '{' Expr '}'</item>
      <item id="1130" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnorderedExpr ::= <dot>.</dot> 'unordered' '{' Expr '}'</item>
      <item id="1136" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FunctionCall ::= <dot>.</dot> QName '(' FunctionCall_1 ')'</item>
      <item id="1160" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= <dot>.</dot> DirectConstructor</item>
      <item id="1162" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= <dot>.</dot> ComputedConstructor</item>
      <item id="1165" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirElemConstructor</item>
      <item id="1167" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirCommentConstructor</item>
      <item id="1168" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirectConstructor ::= <dot>.</dot> DirPIConstructor</item>
      <item id="1170" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirElemConstructor ::= <dot>.</dot> '&lt;' QName DirAttributeList DirElemConstructor_1</item>
      <item id="1296" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirCommentConstructor ::= <dot>.</dot> '&lt;!--' DirCommentContents '--&gt;'</item>
      <item id="1301" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DirPIConstructor ::= <dot>.</dot> '&lt;?' PITarget DirPIConstructor_1 '?&gt;'</item>
      <item id="1316" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompDocConstructor</item>
      <item id="1318" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompElemConstructor</item>
      <item id="1319" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompAttrConstructor</item>
      <item id="1320" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompTextConstructor</item>
      <item id="1321" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompCommentConstructor</item>
      <item id="1322" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= <dot>.</dot> CompPIConstructor</item>
      <item id="1324" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompDocConstructor ::= <dot>.</dot> 'document' '{' Expr '}'</item>
      <item id="1330" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= <dot>.</dot> 'element' CompElemConstructor_1 '{' CompElemConstructor_2 '}'</item>
      <item id="1355" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= <dot>.</dot> 'attribute' CompAttrConstructor_1 '{' CompAttrConstructor_2 '}'</item>
      <item id="1377" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompTextConstructor ::= <dot>.</dot> 'text' '{' Expr '}'</item>
      <item id="1383" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompCommentConstructor ::= <dot>.</dot> 'comment' '{' Expr '}'</item>
      <item id="1389" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= <dot>.</dot> 'processing-instruction' CompPIConstructor_1 '{' CompPIConstructor_2 '}'</item>
      <item id="1462" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="StepExpr" to="476"/>
      <goto on="AxisStep" to="365"/>
      <goto on="AxisStep_1" to="40"/>
      <goto on="ForwardStep" to="366"/>
      <goto on="ForwardAxis" to="41"/>
      <goto on="AbbrevForwardStep" to="367"/>
      <goto on="ReverseStep" to="366"/>
      <goto on="ReverseAxis" to="42"/>
      <goto on="AbbrevReverseStep" to="368"/>
      <goto on="NodeTest" to="369"/>
      <goto on="NameTest" to="370"/>
      <goto on="FilterExpr" to="365"/>
      <goto on="PrimaryExpr" to="43"/>
      <goto on="Literal" to="371"/>
      <goto on="NumericLiteral" to="372"/>
      <goto on="VarRef" to="371"/>
      <goto on="ParenthesizedExpr" to="371"/>
      <goto on="ContextItemExpr" to="371"/>
      <goto on="OrderedExpr" to="371"/>
      <goto on="UnorderedExpr" to="371"/>
      <goto on="FunctionCall" to="371"/>
      <goto on="Constructor" to="371"/>
      <goto on="DirectConstructor" to="373"/>
      <goto on="DirElemConstructor" to="374"/>
      <goto on="DirCommentConstructor" to="374"/>
      <goto on="DirPIConstructor" to="374"/>
      <goto on="ComputedConstructor" to="373"/>
      <goto on="CompDocConstructor" to="375"/>
      <goto on="CompElemConstructor" to="375"/>
      <goto on="CompAttrConstructor" to="375"/>
      <goto on="CompTextConstructor" to="375"/>
      <goto on="CompCommentConstructor" to="375"/>
      <goto on="CompPIConstructor" to="375"/>
      <goto on="KindTest" to="370"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="StringLiteral" to="372"/>
      <shift on="element" to="44"/>
      <shift on="QName" to="212"/>
      <shift on="ordered" to="213"/>
      <shift on="unordered" to="214"/>
      <shift on="$" to="45"/>
      <shift on="(" to="46"/>
      <shift on="&lt;" to="215"/>
      <shift on="child" to="216"/>
      <shift on="descendant" to="217"/>
      <shift on="attribute" to="51"/>
      <shift on="self" to="218"/>
      <shift on="descendant-or-self" to="219"/>
      <shift on="following-sibling" to="220"/>
      <shift on="following" to="221"/>
      <shift on="@" to="52"/>
      <shift on="parent" to="222"/>
      <shift on="ancestor" to="223"/>
      <shift on="preceding-sibling" to="224"/>
      <shift on="preceding" to="225"/>
      <shift on="ancestor-or-self" to="226"/>
      <shift on=".." to="378"/>
      <shift on="Wildcard" to="379"/>
      <shift on="IntegerLiteral" to="380"/>
      <shift on="DecimalLiteral" to="380"/>
      <shift on="DoubleLiteral" to="380"/>
      <shift on="." to="381"/>
      <shift on="&lt;!--" to="227"/>
      <shift on="&lt;?" to="228"/>
      <shift on="document" to="229"/>
      <shift on="text" to="230"/>
      <shift on="comment" to="231"/>
      <shift on="processing-instruction" to="53"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="113">
      <item id="351" lookahead="%WS ]">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , ]">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , ]">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , ]">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , ]">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , ]">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , ]">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , ]">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , ]">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , ]">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , ]">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , ] or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , ] and or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ] and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1077" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Predicate ::= '[' <dot>.</dot> Expr ']'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="301"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="114">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1333" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= 'element' CompElemConstructor_1 '{' <dot>.</dot> CompElemConstructor_2 '}'</item>
      <item id="1349" lookahead="%WS }">CompElemConstructor_2 ::= <dot>.</dot> ContentExpr</item>
      <item id="1352" lookahead="%WS }">ContentExpr ::= <dot>.</dot> Expr</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <item id="1348" lookahead="%WS }">CompElemConstructor_2 ::= <dot>.</dot></item>
      <goto on="Expr" to="477"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <goto on="CompElemConstructor_2" to="302"/>
      <goto on="ContentExpr" to="478"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
      <reduce on="}" symbol="CompElemConstructor_2"/>
    </state>
    <state id="115">
      <item id="1561" lookahead="%WS )">ElementTest_1 ::= ElementNameOrWildcard <dot>.</dot> ElementTest_2</item>
      <item id="1568" lookahead="%WS )">ElementTest_2 ::= <dot>.</dot> ',' TypeName ElementTest_3</item>
      <item id="1566" lookahead="%WS )">ElementTest_2 ::= <dot>.</dot></item>
      <goto on="ElementTest_2" to="480"/>
      <shift on="," to="132"/>
      <reduce on=")" symbol="ElementTest_2"/>
    </state>
    <state id="116">
      <item id="1147" lookahead="%WS )">FunctionCall_1 ::= ExprSingle <dot>.</dot> FunctionCall_2</item>
      <item id="1154" lookahead="%WS ) ,">FunctionCall_2 ::= <dot>.</dot> FunctionCall_2 ',' ExprSingle</item>
      <item id="1152" lookahead="%WS ) ,">FunctionCall_2 ::= <dot>.</dot></item>
      <goto on="FunctionCall_2" to="303"/>
      <reduce on=") ," symbol="FunctionCall_2"/>
    </state>
    <state id="117">
      <item id="1173" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor ::= '&lt;' QName DirAttributeList <dot>.</dot> DirElemConstructor_1</item>
      <item id="1177" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= <dot>.</dot> '/&gt;'</item>
      <item id="1180" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= <dot>.</dot> '&gt;' DirElemConstructor_2 '&lt;/' QName DirElemConstructor_3 '&gt;'</item>
      <item id="1207" lookahead="%WS /&gt; &gt; S">DirAttributeList ::= DirAttributeList <dot>.</dot> S DirAttributeList_1</item>
      <goto on="DirElemConstructor_1" to="485"/>
      <shift on="&gt;" to="133"/>
      <shift on="S" to="134"/>
      <shift on="/&gt;" to="486"/>
    </state>
    <state id="118">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="886" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValidateExpr ::= 'validate' ValidateExpr_1 '{' <dot>.</dot> Expr '}'</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="304"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="119">
      <item id="924" lookahead="%WS (# {">Pragma ::= '(#' Pragma_1 QName <dot>.</dot> Pragma_2 '#)'</item>
      <item id="938" lookahead="#) %WS">Pragma_2 ::= <dot>.</dot> S PragmaContents</item>
      <item id="936" lookahead="#) %WS">Pragma_2 ::= <dot>.</dot></item>
      <goto on="Pragma_2" to="305"/>
      <shift on="S" to="306"/>
      <reduce on="#)" symbol="Pragma_2"/>
    </state>
    <state id="120">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1358" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= 'attribute' CompAttrConstructor_1 '{' <dot>.</dot> CompAttrConstructor_2 '}'</item>
      <item id="1374" lookahead="%WS }">CompAttrConstructor_2 ::= <dot>.</dot> Expr</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <item id="1373" lookahead="%WS }">CompAttrConstructor_2 ::= <dot>.</dot></item>
      <goto on="Expr" to="487"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <goto on="CompAttrConstructor_2" to="307"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
      <reduce on="}" symbol="CompAttrConstructor_2"/>
    </state>
    <state id="121">
      <item id="1525" lookahead="%WS )">AttributeTest_1 ::= AttribNameOrWildcard <dot>.</dot> AttributeTest_2</item>
      <item id="1532" lookahead="%WS )">AttributeTest_2 ::= <dot>.</dot> ',' TypeName</item>
      <item id="1530" lookahead="%WS )">AttributeTest_2 ::= <dot>.</dot></item>
      <goto on="AttributeTest_2" to="489"/>
      <shift on="," to="135"/>
      <reduce on=")" symbol="AttributeTest_2"/>
    </state>
    <state id="122">
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1392" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= 'processing-instruction' CompPIConstructor_1 '{' <dot>.</dot> CompPIConstructor_2 '}'</item>
      <item id="1408" lookahead="%WS }">CompPIConstructor_2 ::= <dot>.</dot> Expr</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <item id="1407" lookahead="%WS }">CompPIConstructor_2 ::= <dot>.</dot></item>
      <goto on="Expr" to="496"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <goto on="CompPIConstructor_2" to="308"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
      <reduce on="}" symbol="CompPIConstructor_2"/>
    </state>
    <state id="123">
      <item id="408" lookahead="%WS for let order return stable where">ForClause ::= 'for' '$' VarName ForClause_1 <dot>.</dot> ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="423" lookahead="%WS in">ForClause_2 ::= <dot>.</dot> PositionalVar</item>
      <item id="452" lookahead="%WS in">PositionalVar ::= <dot>.</dot> 'at' '$' VarName</item>
      <item id="422" lookahead="%WS in">ForClause_2 ::= <dot>.</dot></item>
      <goto on="ForClause_2" to="309"/>
      <goto on="PositionalVar" to="502"/>
      <shift on="at" to="310"/>
      <reduce on="in" symbol="ForClause_2"/>
    </state>
    <state id="124">
      <item id="605" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' '(' Expr ')' <dot>.</dot> TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="613" lookahead="%WS case default">TypeswitchExpr_1 ::= <dot>.</dot> CaseClause</item>
      <item id="616" lookahead="%WS case default">TypeswitchExpr_1 ::= <dot>.</dot> TypeswitchExpr_1 CaseClause</item>
      <item id="628" lookahead="%WS case default">CaseClause ::= <dot>.</dot> 'case' CaseClause_1 SequenceType 'return' ExprSingle</item>
      <goto on="TypeswitchExpr_1" to="137"/>
      <goto on="CaseClause" to="503"/>
      <shift on="case" to="138"/>
    </state>
    <state id="125">
      <item id="264" lookahead="%WS ;">VarDecl ::= 'declare variable' '$' QName <dot>.</dot> VarDecl_1 VarDecl_2</item>
      <item id="271" lookahead="%WS := external">VarDecl_1 ::= <dot>.</dot> TypeDeclaration</item>
      <item id="1421" lookahead="%WS := external">TypeDeclaration ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="270" lookahead="%WS := external">VarDecl_1 ::= <dot>.</dot></item>
      <goto on="VarDecl_1" to="140"/>
      <goto on="TypeDeclaration" to="504"/>
      <shift on="as" to="109"/>
      <reduce on=":= external" symbol="VarDecl_1"/>
    </state>
    <state id="126">
      <item id="294" lookahead="%WS ;">FunctionDecl ::= 'declare function' QName '(' <dot>.</dot> FunctionDecl_1 ')' FunctionDecl_2 FunctionDecl_3</item>
      <item id="303" lookahead="%WS )">FunctionDecl_1 ::= <dot>.</dot> ParamList</item>
      <item id="319" lookahead="%WS )">ParamList ::= <dot>.</dot> Param ParamList_1</item>
      <item id="332" lookahead="%WS ) ,">Param ::= <dot>.</dot> '$' QName Param_1</item>
      <item id="302" lookahead="%WS )">FunctionDecl_1 ::= <dot>.</dot></item>
      <goto on="FunctionDecl_1" to="311"/>
      <goto on="ParamList" to="505"/>
      <goto on="Param" to="141"/>
      <shift on="$" to="312"/>
      <reduce on=")" symbol="FunctionDecl_1"/>
    </state>
    <state id="127">
      <item id="231" lookahead="%WS ;">ModuleImport ::= 'import' 'module' ModuleImport_1 URILiteral <dot>.</dot> ModuleImport_2</item>
      <item id="247" lookahead="%WS ;">ModuleImport_2 ::= <dot>.</dot> 'at' URILiteral ModuleImport_3</item>
      <item id="245" lookahead="%WS ;">ModuleImport_2 ::= <dot>.</dot></item>
      <goto on="ModuleImport_2" to="506"/>
      <shift on="at" to="142"/>
      <reduce on=";" symbol="ModuleImport_2"/>
    </state>
    <state id="128">
      <item id="189" lookahead="%WS ;">SchemaImport ::= 'import' 'schema' SchemaImport_1 URILiteral <dot>.</dot> SchemaImport_2</item>
      <item id="202" lookahead="%WS ;">SchemaImport_2 ::= <dot>.</dot> 'at' URILiteral SchemaImport_3</item>
      <item id="200" lookahead="%WS ;">SchemaImport_2 ::= <dot>.</dot></item>
      <goto on="SchemaImport_2" to="508"/>
      <shift on="at" to="143"/>
      <reduce on=";" symbol="SchemaImport_2"/>
    </state>
    <state id="129">
      <item id="53" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">ModuleDecl ::= 'module' 'namespace' NCName '=' URILiteral <dot>.</dot> Separator</item>
      <item id="106" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">Separator ::= <dot>.</dot> ';'</item>
      <goto on="Separator" to="510"/>
      <shift on=";" to="383"/>
    </state>
    <state id="130">
      <item id="528" lookahead="%WS , return">OrderModifier ::= OrderModifier_1 <dot>.</dot> OrderModifier_2 OrderModifier_4</item>
      <item id="543" lookahead="%WS , collation return">OrderModifier_2 ::= <dot>.</dot> 'empty' OrderModifier_3</item>
      <item id="541" lookahead="%WS , collation return">OrderModifier_2 ::= <dot>.</dot></item>
      <goto on="OrderModifier_2" to="144"/>
      <shift on="empty" to="145"/>
      <reduce on=", collation return" symbol="OrderModifier_2"/>
    </state>
    <state id="131">
      <item id="365" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , satisfies">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , satisfies">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="565" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' <dot>.</dot> ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , satisfies">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , satisfies">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , satisfies">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or satisfies">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or satisfies">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or satisfies">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or satisfies to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or satisfies to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or satisfies to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or satisfies to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or satisfies to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or satisfies to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or satisfies to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or satisfies to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or satisfies to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="147"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="132">
      <item id="1569" lookahead="%WS )">ElementTest_2 ::= ',' <dot>.</dot> TypeName ElementTest_3</item>
      <item id="1599" lookahead="%WS ) ?">TypeName ::= <dot>.</dot> QName</item>
      <goto on="TypeName" to="148"/>
      <shift on="QName" to="515"/>
    </state>
    <state id="133">
      <item id="1181" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= '&gt;' <dot>.</dot> DirElemConstructor_2 '&lt;/' QName DirElemConstructor_3 '&gt;'</item>
      <item id="1192" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemConstructor_2 ::= <dot>.</dot> DirElemConstructor_2 DirElemContent</item>
      <item id="1190" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemConstructor_2 ::= <dot>.</dot></item>
      <goto on="DirElemConstructor_2" to="150"/>
      <reduce on="&lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}" symbol="DirElemConstructor_2"/>
    </state>
    <state id="134">
      <item id="1208" lookahead="%WS /&gt; &gt; S">DirAttributeList ::= DirAttributeList S <dot>.</dot> DirAttributeList_1</item>
      <item id="1215" lookahead="%WS /&gt; &gt; S">DirAttributeList_1 ::= <dot>.</dot> QName DirAttributeList_2 '=' DirAttributeList_3 DirAttributeValue</item>
      <item id="1213" lookahead="%WS /&gt; &gt; S">DirAttributeList_1 ::= <dot>.</dot></item>
      <goto on="DirAttributeList_1" to="516"/>
      <shift on="QName" to="151"/>
      <reduce on="/&gt; &gt; S" symbol="DirAttributeList_1"/>
    </state>
    <state id="135">
      <item id="1533" lookahead="%WS )">AttributeTest_2 ::= ',' <dot>.</dot> TypeName</item>
      <item id="1599" lookahead="%WS )">TypeName ::= <dot>.</dot> QName</item>
      <goto on="TypeName" to="521"/>
      <shift on="QName" to="515"/>
    </state>
    <state id="136">
      <item id="365" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , for let order return stable where">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="462" lookahead="%WS for let order return stable where">LetClause ::= 'let' '$' VarName LetClause_1 ':=' <dot>.</dot> ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , for let order return stable where">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , for let order return stable where">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , for let order return stable where">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , for let order return stable where">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , for let or order return stable where">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and for let or order return stable where">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable where">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable to where">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable to where">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq for ge gt idiv is le let lt mod ne or order return stable to where">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq for ge gt idiv is le let lt mod ne or order return stable to union where |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv intersect is le let lt mod ne or order return stable to union where |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to union where |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="154"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="137">
      <item id="606" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' '(' Expr ')' TypeswitchExpr_1 <dot>.</dot> 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="617" lookahead="%WS case default">TypeswitchExpr_1 ::= TypeswitchExpr_1 <dot>.</dot> CaseClause</item>
      <item id="628" lookahead="%WS case default">CaseClause ::= <dot>.</dot> 'case' CaseClause_1 SequenceType 'return' ExprSingle</item>
      <goto on="CaseClause" to="523"/>
      <shift on="default" to="155"/>
      <shift on="case" to="138"/>
    </state>
    <state id="138">
      <item id="629" lookahead="%WS case default">CaseClause ::= 'case' <dot>.</dot> CaseClause_1 SequenceType 'return' ExprSingle</item>
      <item id="639" lookahead="%WS QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text">CaseClause_1 ::= <dot>.</dot> '$' VarName 'as'</item>
      <item id="637" lookahead="%WS QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text">CaseClause_1 ::= <dot>.</dot></item>
      <goto on="CaseClause_1" to="156"/>
      <shift on="$" to="157"/>
      <reduce on="QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text" symbol="CaseClause_1"/>
    </state>
    <state id="139">
      <item id="365" lookahead="%WS else">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS else">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS else">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS else">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS else">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS else">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS else">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS else">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS else">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="649" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= 'if' '(' Expr ')' 'then' <dot>.</dot> ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS else">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS else or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS and else or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and else eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and else eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and else eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div else eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div else eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div else eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div else eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div else eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div else eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div else eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="313"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="140">
      <item id="265" lookahead="%WS ;">VarDecl ::= 'declare variable' '$' QName VarDecl_1 <dot>.</dot> VarDecl_2</item>
      <item id="276" lookahead="%WS ;">VarDecl_2 ::= <dot>.</dot> ':=' ExprSingle</item>
      <item id="279" lookahead="%WS ;">VarDecl_2 ::= <dot>.</dot> 'external'</item>
      <goto on="VarDecl_2" to="524"/>
      <shift on=":=" to="158"/>
      <shift on="external" to="525"/>
    </state>
    <state id="141">
      <item id="320" lookahead="%WS )">ParamList ::= Param <dot>.</dot> ParamList_1</item>
      <item id="327" lookahead="%WS ) ,">ParamList_1 ::= <dot>.</dot> ParamList_1 ',' Param</item>
      <item id="325" lookahead="%WS ) ,">ParamList_1 ::= <dot>.</dot></item>
      <goto on="ParamList_1" to="314"/>
      <reduce on=") ," symbol="ParamList_1"/>
    </state>
    <state id="142">
      <item id="248" lookahead="%WS ;">ModuleImport_2 ::= 'at' <dot>.</dot> URILiteral ModuleImport_3</item>
      <item id="1602" lookahead="%WS , ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="161"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="143">
      <item id="203" lookahead="%WS ;">SchemaImport_2 ::= 'at' <dot>.</dot> URILiteral SchemaImport_3</item>
      <item id="1602" lookahead="%WS , ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="162"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="144">
      <item id="529" lookahead="%WS , return">OrderModifier ::= OrderModifier_1 OrderModifier_2 <dot>.</dot> OrderModifier_4</item>
      <item id="556" lookahead="%WS , return">OrderModifier_4 ::= <dot>.</dot> 'collation' URILiteral</item>
      <item id="554" lookahead="%WS , return">OrderModifier_4 ::= <dot>.</dot></item>
      <goto on="OrderModifier_4" to="526"/>
      <shift on="collation" to="163"/>
      <reduce on=", return" symbol="OrderModifier_4"/>
    </state>
    <state id="145">
      <item id="544" lookahead="%WS , collation return">OrderModifier_2 ::= 'empty' <dot>.</dot> OrderModifier_3</item>
      <item id="548" lookahead="%WS , collation return">OrderModifier_3 ::= <dot>.</dot> 'greatest'</item>
      <item id="550" lookahead="%WS , collation return">OrderModifier_3 ::= <dot>.</dot> 'least'</item>
      <goto on="OrderModifier_3" to="527"/>
      <shift on="greatest" to="528"/>
      <shift on="least" to="528"/>
    </state>
    <state id="146">
      <item id="365" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , ascending collation descending empty return">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , ascending collation descending empty return">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="520" lookahead="%WS , return">OrderSpecList_1 ::= OrderSpecList_1 ',' <dot>.</dot> OrderSpec</item>
      <item id="523" lookahead="%WS , return">OrderSpec ::= <dot>.</dot> ExprSingle OrderModifier</item>
      <item id="560" lookahead="%WS , ascending collation descending empty return">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , ascending collation descending empty return">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , ascending collation descending empty return">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , ascending collation descending empty return">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , ascending collation descending empty or return">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and ascending collation descending empty or return">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending empty eq ge gt is le lt ne or return">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending empty eq ge gt is le lt ne or return to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending empty eq ge gt is le lt ne or return to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq ge gt idiv is le lt mod ne or return to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq ge gt idiv is le lt mod ne or return to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq except ge gt idiv intersect is le lt mod ne or return to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq except ge gt idiv instance intersect is le lt mod ne or return to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending collation descending div empty eq except ge gt idiv instance intersect is le lt mod ne or return to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending castable collation descending div empty eq except ge gt idiv instance intersect is le lt mod ne or return to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and ascending cast castable collation descending div empty eq except ge gt idiv instance intersect is le lt mod ne or return to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="107"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="OrderSpec" to="529"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="147">
      <item id="566" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle <dot>.</dot> QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="586" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= <dot>.</dot> QuantifiedExpr_3 ',' '$' VarName QuantifiedExpr_4 'in' ExprSingle</item>
      <item id="584" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= <dot>.</dot></item>
      <goto on="QuantifiedExpr_3" to="315"/>
      <reduce on=", satisfies" symbol="QuantifiedExpr_3"/>
    </state>
    <state id="148">
      <item id="1570" lookahead="%WS )">ElementTest_2 ::= ',' TypeName <dot>.</dot> ElementTest_3</item>
      <item id="1576" lookahead="%WS )">ElementTest_3 ::= <dot>.</dot> '?'</item>
      <item id="1575" lookahead="%WS )">ElementTest_3 ::= <dot>.</dot></item>
      <goto on="ElementTest_3" to="530"/>
      <shift on="?" to="531"/>
      <reduce on=")" symbol="ElementTest_3"/>
    </state>
    <state id="149">
      <item id="365" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) ,">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) ,">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) ,">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) ,">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) ,">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) ,">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , and or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="1156" lookahead="%WS ) ,">FunctionCall_2 ::= FunctionCall_2 ',' <dot>.</dot> ExprSingle</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="532"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="150">
      <item id="343" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">EnclosedExpr ::= <dot>.</dot> '{' Expr '}'</item>
      <item id="1165" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirectConstructor ::= <dot>.</dot> DirElemConstructor</item>
      <item id="1167" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirectConstructor ::= <dot>.</dot> DirCommentConstructor</item>
      <item id="1168" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirectConstructor ::= <dot>.</dot> DirPIConstructor</item>
      <item id="1170" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemConstructor ::= <dot>.</dot> '&lt;' QName DirAttributeList DirElemConstructor_1</item>
      <item id="1182" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= '&gt;' DirElemConstructor_2 <dot>.</dot> '&lt;/' QName DirElemConstructor_3 '&gt;'</item>
      <item id="1193" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemConstructor_2 ::= DirElemConstructor_2 <dot>.</dot> DirElemContent</item>
      <item id="1282" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemContent ::= <dot>.</dot> DirectConstructor</item>
      <item id="1284" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemContent ::= <dot>.</dot> CDataSection</item>
      <item id="1285" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemContent ::= <dot>.</dot> CommonContent</item>
      <item id="1286" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemContent ::= <dot>.</dot> ElementContentChar</item>
      <item id="1289" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> PredefinedEntityRef</item>
      <item id="1291" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> CharRef</item>
      <item id="1292" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> '{{'</item>
      <item id="1293" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> '}}'</item>
      <item id="1294" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> EnclosedExpr</item>
      <item id="1296" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirCommentConstructor ::= <dot>.</dot> '&lt;!--' DirCommentContents '--&gt;'</item>
      <item id="1301" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirPIConstructor ::= <dot>.</dot> '&lt;?' PITarget DirPIConstructor_1 '?&gt;'</item>
      <goto on="EnclosedExpr" to="533"/>
      <goto on="DirectConstructor" to="534"/>
      <goto on="DirElemConstructor" to="374"/>
      <goto on="DirElemContent" to="535"/>
      <goto on="CommonContent" to="534"/>
      <goto on="DirCommentConstructor" to="374"/>
      <goto on="DirPIConstructor" to="374"/>
      <shift on="{" to="164"/>
      <shift on="&lt;" to="215"/>
      <shift on="&lt;/" to="316"/>
      <shift on="CDataSection" to="534"/>
      <shift on="ElementContentChar" to="534"/>
      <shift on="PredefinedEntityRef" to="533"/>
      <shift on="CharRef" to="533"/>
      <shift on="{{" to="533"/>
      <shift on="}}" to="533"/>
      <shift on="&lt;!--" to="227"/>
      <shift on="&lt;?" to="228"/>
    </state>
    <state id="151">
      <item id="1216" lookahead="%WS /&gt; &gt; S">DirAttributeList_1 ::= QName <dot>.</dot> DirAttributeList_2 '=' DirAttributeList_3 DirAttributeValue</item>
      <item id="1225" lookahead="%WS =">DirAttributeList_2 ::= <dot>.</dot> S</item>
      <item id="1224" lookahead="%WS =">DirAttributeList_2 ::= <dot>.</dot></item>
      <goto on="DirAttributeList_2" to="317"/>
      <shift on="S" to="536"/>
      <reduce on="=" symbol="DirAttributeList_2"/>
    </state>
    <state id="152">
      <item id="365" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , for let order return stable where">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="410" lookahead="%WS for let order return stable where">ForClause ::= 'for' '$' VarName ForClause_1 ForClause_2 'in' <dot>.</dot> ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , for let order return stable where">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , for let order return stable where">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , for let order return stable where">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , for let order return stable where">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , for let or order return stable where">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and for let or order return stable where">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable where">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable to where">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable to where">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq for ge gt idiv is le let lt mod ne or order return stable to where">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq for ge gt idiv is le let lt mod ne or order return stable to union where |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv intersect is le let lt mod ne or order return stable to union where |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to union where |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="165"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="153">
      <item id="454" lookahead="%WS in">PositionalVar ::= 'at' '$' <dot>.</dot> VarName</item>
      <item id="1107" lookahead="%WS in">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="537"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="154">
      <item id="463" lookahead="%WS for let order return stable where">LetClause ::= 'let' '$' VarName LetClause_1 ':=' ExprSingle <dot>.</dot> LetClause_2</item>
      <item id="476" lookahead="%WS , for let order return stable where">LetClause_2 ::= <dot>.</dot> LetClause_2 ',' '$' VarName LetClause_3 ':=' ExprSingle</item>
      <item id="474" lookahead="%WS , for let order return stable where">LetClause_2 ::= <dot>.</dot></item>
      <goto on="LetClause_2" to="318"/>
      <reduce on=", for let order return stable where" symbol="LetClause_2"/>
    </state>
    <state id="155">
      <item id="607" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' <dot>.</dot> TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="624" lookahead="%WS return">TypeswitchExpr_2 ::= <dot>.</dot> '$' VarName</item>
      <item id="622" lookahead="%WS return">TypeswitchExpr_2 ::= <dot>.</dot></item>
      <goto on="TypeswitchExpr_2" to="319"/>
      <shift on="$" to="166"/>
      <reduce on="return" symbol="TypeswitchExpr_2"/>
    </state>
    <state id="156">
      <item id="630" lookahead="%WS case default">CaseClause ::= 'case' CaseClause_1 <dot>.</dot> SequenceType 'return' ExprSingle</item>
      <item id="1427" lookahead="%WS return">SequenceType ::= <dot>.</dot> 'empty-sequence' '(' ')'</item>
      <item id="1432" lookahead="%WS return">SequenceType ::= <dot>.</dot> ItemType SequenceType_1</item>
      <item id="1449" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">ItemType ::= <dot>.</dot> KindTest</item>
      <item id="1452" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">ItemType ::= <dot>.</dot> 'item' '(' ')'</item>
      <item id="1456" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">ItemType ::= <dot>.</dot> AtomicType</item>
      <item id="1458" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">AtomicType ::= <dot>.</dot> QName</item>
      <item id="1462" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator return">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="SequenceType" to="320"/>
      <goto on="ItemType" to="110"/>
      <goto on="AtomicType" to="435"/>
      <goto on="KindTest" to="435"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="element" to="248"/>
      <shift on="QName" to="436"/>
      <shift on="attribute" to="249"/>
      <shift on="text" to="250"/>
      <shift on="comment" to="251"/>
      <shift on="processing-instruction" to="252"/>
      <shift on="empty-sequence" to="273"/>
      <shift on="item" to="274"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="157">
      <item id="640" lookahead="%WS QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text">CaseClause_1 ::= '$' <dot>.</dot> VarName 'as'</item>
      <item id="1107" lookahead="%WS as">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="321"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="158">
      <item id="277" lookahead="%WS ;">VarDecl_2 ::= ':=' <dot>.</dot> ExprSingle</item>
      <item id="365" lookahead="%WS ;">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ;">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ;">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ;">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ;">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ;">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ;">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ;">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ;">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ;">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ; or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ; and or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="538"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="159">
      <item id="296" lookahead="%WS ;">FunctionDecl ::= 'declare function' QName '(' FunctionDecl_1 ')' <dot>.</dot> FunctionDecl_2 FunctionDecl_3</item>
      <item id="310" lookahead="%WS external {">FunctionDecl_2 ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="308" lookahead="%WS external {">FunctionDecl_2 ::= <dot>.</dot></item>
      <goto on="FunctionDecl_2" to="168"/>
      <shift on="as" to="169"/>
      <reduce on="external {" symbol="FunctionDecl_2"/>
    </state>
    <state id="160">
      <item id="334" lookahead="%WS ) ,">Param ::= '$' QName <dot>.</dot> Param_1</item>
      <item id="340" lookahead="%WS ) ,">Param_1 ::= <dot>.</dot> TypeDeclaration</item>
      <item id="1421" lookahead="%WS ) ,">TypeDeclaration ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="339" lookahead="%WS ) ,">Param_1 ::= <dot>.</dot></item>
      <goto on="Param_1" to="539"/>
      <goto on="TypeDeclaration" to="540"/>
      <shift on="as" to="109"/>
      <reduce on=") ," symbol="Param_1"/>
    </state>
    <state id="161">
      <item id="249" lookahead="%WS ;">ModuleImport_2 ::= 'at' URILiteral <dot>.</dot> ModuleImport_3</item>
      <item id="256" lookahead="%WS , ;">ModuleImport_3 ::= <dot>.</dot> ModuleImport_3 ',' URILiteral</item>
      <item id="254" lookahead="%WS , ;">ModuleImport_3 ::= <dot>.</dot></item>
      <goto on="ModuleImport_3" to="322"/>
      <reduce on=", ;" symbol="ModuleImport_3"/>
    </state>
    <state id="162">
      <item id="204" lookahead="%WS ;">SchemaImport_2 ::= 'at' URILiteral <dot>.</dot> SchemaImport_3</item>
      <item id="211" lookahead="%WS , ;">SchemaImport_3 ::= <dot>.</dot> SchemaImport_3 ',' URILiteral</item>
      <item id="209" lookahead="%WS , ;">SchemaImport_3 ::= <dot>.</dot></item>
      <goto on="SchemaImport_3" to="323"/>
      <reduce on=", ;" symbol="SchemaImport_3"/>
    </state>
    <state id="163">
      <item id="557" lookahead="%WS , return">OrderModifier_4 ::= 'collation' <dot>.</dot> URILiteral</item>
      <item id="1602" lookahead="%WS , return">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="541"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="164">
      <item id="344" lookahead="&quot; %WS ' ; &lt; &lt;!-- &lt;/ &lt;? AposAttrContentChar CDataSection CharRef ElementContentChar EscapeApos EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">EnclosedExpr ::= '{' <dot>.</dot> Expr '}'</item>
      <item id="351" lookahead="%WS }">Expr ::= <dot>.</dot> ExprSingle Expr_1</item>
      <item id="365" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or to }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or to union | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or to union | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to union | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or to treat union | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="Expr" to="325"/>
      <goto on="ExprSingle" to="5"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="165">
      <item id="411" lookahead="%WS for let order return stable where">ForClause ::= 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle <dot>.</dot> ForClause_3</item>
      <item id="430" lookahead="%WS , for let order return stable where">ForClause_3 ::= <dot>.</dot> ForClause_3 ',' '$' VarName ForClause_4 ForClause_5 'in' ExprSingle</item>
      <item id="428" lookahead="%WS , for let order return stable where">ForClause_3 ::= <dot>.</dot></item>
      <goto on="ForClause_3" to="326"/>
      <reduce on=", for let order return stable where" symbol="ForClause_3"/>
    </state>
    <state id="166">
      <item id="625" lookahead="%WS return">TypeswitchExpr_2 ::= '$' <dot>.</dot> VarName</item>
      <item id="1107" lookahead="%WS return">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="542"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="167">
      <item id="365" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="651" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= 'if' '(' Expr ')' 'then' ExprSingle 'else' <dot>.</dot> ExprSingle</item>
      <item id="654" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="544"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="168">
      <item id="297" lookahead="%WS ;">FunctionDecl ::= 'declare function' QName '(' FunctionDecl_1 ')' FunctionDecl_2 <dot>.</dot> FunctionDecl_3</item>
      <item id="315" lookahead="%WS ;">FunctionDecl_3 ::= <dot>.</dot> EnclosedExpr</item>
      <item id="317" lookahead="%WS ;">FunctionDecl_3 ::= <dot>.</dot> 'external'</item>
      <item id="343" lookahead="%WS ;">EnclosedExpr ::= <dot>.</dot> '{' Expr '}'</item>
      <goto on="FunctionDecl_3" to="545"/>
      <goto on="EnclosedExpr" to="546"/>
      <shift on="external" to="546"/>
      <shift on="{" to="164"/>
    </state>
    <state id="169">
      <item id="311" lookahead="%WS external {">FunctionDecl_2 ::= 'as' <dot>.</dot> SequenceType</item>
      <item id="1427" lookahead="%WS external {">SequenceType ::= <dot>.</dot> 'empty-sequence' '(' ')'</item>
      <item id="1432" lookahead="%WS external {">SequenceType ::= <dot>.</dot> ItemType SequenceType_1</item>
      <item id="1449" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">ItemType ::= <dot>.</dot> KindTest</item>
      <item id="1452" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">ItemType ::= <dot>.</dot> 'item' '(' ')'</item>
      <item id="1456" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">ItemType ::= <dot>.</dot> AtomicType</item>
      <item id="1458" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">AtomicType ::= <dot>.</dot> QName</item>
      <item id="1462" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> DocumentTest</item>
      <item id="1464" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> ElementTest</item>
      <item id="1465" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> AttributeTest</item>
      <item id="1466" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> SchemaElementTest</item>
      <item id="1467" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> SchemaAttributeTest</item>
      <item id="1468" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> PITest</item>
      <item id="1469" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> CommentTest</item>
      <item id="1470" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> TextTest</item>
      <item id="1471" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">KindTest ::= <dot>.</dot> AnyKindTest</item>
      <item id="1473" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">AnyKindTest ::= <dot>.</dot> 'node' '(' ')'</item>
      <item id="1478" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">DocumentTest ::= <dot>.</dot> 'document-node' '(' DocumentTest_1 ')'</item>
      <item id="1491" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">TextTest ::= <dot>.</dot> 'text' '(' ')'</item>
      <item id="1496" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">CommentTest ::= <dot>.</dot> 'comment' '(' ')'</item>
      <item id="1501" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">PITest ::= <dot>.</dot> 'processing-instruction' '(' PITest_1 ')'</item>
      <item id="1514" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">AttributeTest ::= <dot>.</dot> 'attribute' '(' AttributeTest_1 ')'</item>
      <item id="1541" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">SchemaAttributeTest ::= <dot>.</dot> 'schema-attribute' '(' AttributeDeclaration ')'</item>
      <item id="1550" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">ElementTest ::= <dot>.</dot> 'element' '(' ElementTest_1 ')'</item>
      <item id="1584" lookahead="%WS ? PlusOccurreneIndicator StarOccurreneIndicator external {">SchemaElementTest ::= <dot>.</dot> 'schema-element' '(' ElementDeclaration ')'</item>
      <goto on="SequenceType" to="547"/>
      <goto on="ItemType" to="110"/>
      <goto on="AtomicType" to="435"/>
      <goto on="KindTest" to="435"/>
      <goto on="AnyKindTest" to="376"/>
      <goto on="DocumentTest" to="376"/>
      <goto on="TextTest" to="376"/>
      <goto on="CommentTest" to="376"/>
      <goto on="PITest" to="376"/>
      <goto on="AttributeTest" to="376"/>
      <goto on="SchemaAttributeTest" to="376"/>
      <goto on="ElementTest" to="376"/>
      <goto on="SchemaElementTest" to="376"/>
      <shift on="element" to="248"/>
      <shift on="QName" to="436"/>
      <shift on="attribute" to="249"/>
      <shift on="text" to="250"/>
      <shift on="comment" to="251"/>
      <shift on="processing-instruction" to="252"/>
      <shift on="empty-sequence" to="273"/>
      <shift on="item" to="274"/>
      <shift on="node" to="232"/>
      <shift on="document-node" to="233"/>
      <shift on="schema-attribute" to="234"/>
      <shift on="schema-element" to="235"/>
    </state>
    <state id="170">
      <item id="329" lookahead="%WS ) ,">ParamList_1 ::= ParamList_1 ',' <dot>.</dot> Param</item>
      <item id="332" lookahead="%WS ) ,">Param ::= <dot>.</dot> '$' QName Param_1</item>
      <goto on="Param" to="548"/>
      <shift on="$" to="312"/>
    </state>
    <state id="171">
      <item id="365" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="568" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' <dot>.</dot> ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="549"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="172">
      <item id="1184" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= '&gt;' DirElemConstructor_2 '&lt;/' QName <dot>.</dot> DirElemConstructor_3 '&gt;'</item>
      <item id="1199" lookahead="%WS &gt;">DirElemConstructor_3 ::= <dot>.</dot> S</item>
      <item id="1198" lookahead="%WS &gt;">DirElemConstructor_3 ::= <dot>.</dot></item>
      <goto on="DirElemConstructor_3" to="328"/>
      <shift on="S" to="551"/>
      <reduce on="&gt;" symbol="DirElemConstructor_3"/>
    </state>
    <state id="173">
      <item id="1218" lookahead="%WS /&gt; &gt; S">DirAttributeList_1 ::= QName DirAttributeList_2 '=' <dot>.</dot> DirAttributeList_3 DirAttributeValue</item>
      <item id="1231" lookahead="&quot; %WS '">DirAttributeList_3 ::= <dot>.</dot> S</item>
      <item id="1230" lookahead="&quot; %WS '">DirAttributeList_3 ::= <dot>.</dot></item>
      <goto on="DirAttributeList_3" to="179"/>
      <shift on="S" to="552"/>
      <reduce on="&quot; '" symbol="DirAttributeList_3"/>
    </state>
    <state id="174">
      <item id="365" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="609" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' <dot>.</dot> ExprSingle</item>
      <item id="644" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="553"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="175">
      <item id="365" lookahead="%WS case default">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS case default">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS case default">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS case default">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS case default">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS case default">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS case default">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS case default">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="632" lookahead="%WS case default">CaseClause ::= 'case' CaseClause_1 SequenceType 'return' <dot>.</dot> ExprSingle</item>
      <item id="644" lookahead="%WS case default">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS case default">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS case default or">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS and case default or">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case default eq ge gt is le lt ne or">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case default eq ge gt is le lt ne or to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case default eq ge gt is le lt ne or to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case default div eq ge gt idiv is le lt mod ne or to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case default div eq ge gt idiv is le lt mod ne or to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case default div eq except ge gt idiv intersect is le lt mod ne or to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case default div eq except ge gt idiv instance intersect is le lt mod ne or to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case default div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case castable default div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and case cast castable default div eq except ge gt idiv instance intersect is le lt mod ne or to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="554"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="176">
      <item id="258" lookahead="%WS , ;">ModuleImport_3 ::= ModuleImport_3 ',' <dot>.</dot> URILiteral</item>
      <item id="1602" lookahead="%WS , ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="555"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="177">
      <item id="213" lookahead="%WS , ;">SchemaImport_3 ::= SchemaImport_3 ',' <dot>.</dot> URILiteral</item>
      <item id="1602" lookahead="%WS , ;">URILiteral ::= <dot>.</dot> StringLiteral</item>
      <goto on="URILiteral" to="556"/>
      <shift on="StringLiteral" to="392"/>
    </state>
    <state id="178">
      <item id="589" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= QuantifiedExpr_3 ',' '$' <dot>.</dot> VarName QuantifiedExpr_4 'in' ExprSingle</item>
      <item id="1107" lookahead="%WS as in">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="181"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="179">
      <item id="1219" lookahead="%WS /&gt; &gt; S">DirAttributeList_1 ::= QName DirAttributeList_2 '=' DirAttributeList_3 <dot>.</dot> DirAttributeValue</item>
      <item id="1236" lookahead="%WS /&gt; &gt; S">DirAttributeValue ::= <dot>.</dot> '&quot;' DirAttributeValue_1 '&quot;'</item>
      <item id="1241" lookahead="%WS /&gt; &gt; S">DirAttributeValue ::= <dot>.</dot> &quot;'&quot; DirAttributeValue_3 &quot;'&quot;</item>
      <goto on="DirAttributeValue" to="558"/>
      <shift on="&quot;" to="182"/>
      <shift on="'" to="183"/>
    </state>
    <state id="180">
      <item id="479" lookahead="%WS , for let order return stable where">LetClause_2 ::= LetClause_2 ',' '$' <dot>.</dot> VarName LetClause_3 ':=' ExprSingle</item>
      <item id="1107" lookahead="%WS := as">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="185"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="181">
      <item id="590" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= QuantifiedExpr_3 ',' '$' VarName <dot>.</dot> QuantifiedExpr_4 'in' ExprSingle</item>
      <item id="598" lookahead="%WS in">QuantifiedExpr_4 ::= <dot>.</dot> TypeDeclaration</item>
      <item id="1421" lookahead="%WS in">TypeDeclaration ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="597" lookahead="%WS in">QuantifiedExpr_4 ::= <dot>.</dot></item>
      <goto on="QuantifiedExpr_4" to="330"/>
      <goto on="TypeDeclaration" to="559"/>
      <shift on="as" to="109"/>
      <reduce on="in" symbol="QuantifiedExpr_4"/>
    </state>
    <state id="182">
      <item id="1237" lookahead="%WS /&gt; &gt; S">DirAttributeValue ::= '&quot;' <dot>.</dot> DirAttributeValue_1 '&quot;'</item>
      <item id="1249" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">DirAttributeValue_1 ::= <dot>.</dot> DirAttributeValue_1 DirAttributeValue_2</item>
      <item id="1247" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">DirAttributeValue_1 ::= <dot>.</dot></item>
      <goto on="DirAttributeValue_1" to="186"/>
      <reduce on="&quot; CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}" symbol="DirAttributeValue_1"/>
    </state>
    <state id="183">
      <item id="1242" lookahead="%WS /&gt; &gt; S">DirAttributeValue ::= &quot;'&quot; <dot>.</dot> DirAttributeValue_3 &quot;'&quot;</item>
      <item id="1262" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">DirAttributeValue_3 ::= <dot>.</dot> DirAttributeValue_3 DirAttributeValue_4</item>
      <item id="1260" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">DirAttributeValue_3 ::= <dot>.</dot></item>
      <goto on="DirAttributeValue_3" to="187"/>
      <reduce on="' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}" symbol="DirAttributeValue_3"/>
    </state>
    <state id="184">
      <item id="433" lookahead="%WS , for let order return stable where">ForClause_3 ::= ForClause_3 ',' '$' <dot>.</dot> VarName ForClause_4 ForClause_5 'in' ExprSingle</item>
      <item id="1107" lookahead="%WS as at in">VarName ::= <dot>.</dot> QName</item>
      <goto on="VarName" to="188"/>
      <shift on="QName" to="397"/>
    </state>
    <state id="185">
      <item id="480" lookahead="%WS , for let order return stable where">LetClause_2 ::= LetClause_2 ',' '$' VarName <dot>.</dot> LetClause_3 ':=' ExprSingle</item>
      <item id="488" lookahead="%WS :=">LetClause_3 ::= <dot>.</dot> TypeDeclaration</item>
      <item id="1421" lookahead="%WS :=">TypeDeclaration ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="487" lookahead="%WS :=">LetClause_3 ::= <dot>.</dot></item>
      <goto on="LetClause_3" to="331"/>
      <goto on="TypeDeclaration" to="560"/>
      <shift on="as" to="109"/>
      <reduce on=":=" symbol="LetClause_3"/>
    </state>
    <state id="186">
      <item id="343" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">EnclosedExpr ::= <dot>.</dot> '{' Expr '}'</item>
      <item id="1238" lookahead="%WS /&gt; &gt; S">DirAttributeValue ::= '&quot;' DirAttributeValue_1 <dot>.</dot> '&quot;'</item>
      <item id="1250" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">DirAttributeValue_1 ::= DirAttributeValue_1 <dot>.</dot> DirAttributeValue_2</item>
      <item id="1254" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">DirAttributeValue_2 ::= <dot>.</dot> EscapeQuot</item>
      <item id="1256" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">DirAttributeValue_2 ::= <dot>.</dot> QuotAttrValueContent</item>
      <item id="1272" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">QuotAttrValueContent ::= <dot>.</dot> QuotAttrContentChar</item>
      <item id="1274" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">QuotAttrValueContent ::= <dot>.</dot> CommonContent</item>
      <item id="1289" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">CommonContent ::= <dot>.</dot> PredefinedEntityRef</item>
      <item id="1291" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">CommonContent ::= <dot>.</dot> CharRef</item>
      <item id="1292" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">CommonContent ::= <dot>.</dot> '{{'</item>
      <item id="1293" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">CommonContent ::= <dot>.</dot> '}}'</item>
      <item id="1294" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">CommonContent ::= <dot>.</dot> EnclosedExpr</item>
      <goto on="EnclosedExpr" to="533"/>
      <goto on="DirAttributeValue_2" to="561"/>
      <goto on="QuotAttrValueContent" to="562"/>
      <goto on="CommonContent" to="563"/>
      <shift on="{" to="164"/>
      <shift on="&quot;" to="564"/>
      <shift on="EscapeQuot" to="562"/>
      <shift on="QuotAttrContentChar" to="563"/>
      <shift on="PredefinedEntityRef" to="533"/>
      <shift on="CharRef" to="533"/>
      <shift on="{{" to="533"/>
      <shift on="}}" to="533"/>
    </state>
    <state id="187">
      <item id="343" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">EnclosedExpr ::= <dot>.</dot> '{' Expr '}'</item>
      <item id="1243" lookahead="%WS /&gt; &gt; S">DirAttributeValue ::= &quot;'&quot; DirAttributeValue_3 <dot>.</dot> &quot;'&quot;</item>
      <item id="1263" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">DirAttributeValue_3 ::= DirAttributeValue_3 <dot>.</dot> DirAttributeValue_4</item>
      <item id="1267" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">DirAttributeValue_4 ::= <dot>.</dot> EscapeApos</item>
      <item id="1269" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">DirAttributeValue_4 ::= <dot>.</dot> AposAttrValueContent</item>
      <item id="1277" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">AposAttrValueContent ::= <dot>.</dot> AposAttrContentChar</item>
      <item id="1279" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">AposAttrValueContent ::= <dot>.</dot> CommonContent</item>
      <item id="1289" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> PredefinedEntityRef</item>
      <item id="1291" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> CharRef</item>
      <item id="1292" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> '{{'</item>
      <item id="1293" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> '}}'</item>
      <item id="1294" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">CommonContent ::= <dot>.</dot> EnclosedExpr</item>
      <goto on="EnclosedExpr" to="533"/>
      <goto on="DirAttributeValue_4" to="565"/>
      <goto on="AposAttrValueContent" to="566"/>
      <goto on="CommonContent" to="567"/>
      <shift on="{" to="164"/>
      <shift on="'" to="564"/>
      <shift on="EscapeApos" to="566"/>
      <shift on="AposAttrContentChar" to="567"/>
      <shift on="PredefinedEntityRef" to="533"/>
      <shift on="CharRef" to="533"/>
      <shift on="{{" to="533"/>
      <shift on="}}" to="533"/>
    </state>
    <state id="188">
      <item id="434" lookahead="%WS , for let order return stable where">ForClause_3 ::= ForClause_3 ',' '$' VarName <dot>.</dot> ForClause_4 ForClause_5 'in' ExprSingle</item>
      <item id="443" lookahead="%WS at in">ForClause_4 ::= <dot>.</dot> TypeDeclaration</item>
      <item id="1421" lookahead="%WS at in">TypeDeclaration ::= <dot>.</dot> 'as' SequenceType</item>
      <item id="442" lookahead="%WS at in">ForClause_4 ::= <dot>.</dot></item>
      <goto on="ForClause_4" to="190"/>
      <goto on="TypeDeclaration" to="568"/>
      <shift on="as" to="109"/>
      <reduce on="at in" symbol="ForClause_4"/>
    </state>
    <state id="189">
      <item id="365" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , satisfies">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , satisfies">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , satisfies">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="592" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= QuantifiedExpr_3 ',' '$' VarName QuantifiedExpr_4 'in' <dot>.</dot> ExprSingle</item>
      <item id="601" lookahead="%WS , satisfies">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , satisfies">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , satisfies">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , or satisfies">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and or satisfies">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or satisfies">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or satisfies to">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq ge gt is le lt ne or satisfies to">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or satisfies to">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq ge gt idiv is le lt mod ne or satisfies to union |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv intersect is le lt mod ne or satisfies to union |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or satisfies to union |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except ge gt idiv instance intersect is le lt mod ne or satisfies to treat union |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except ge gt idiv instance intersect is le lt mod ne or satisfies to treat union |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except ge gt idiv instance intersect is le lt mod ne or satisfies to treat union |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="569"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="190">
      <item id="435" lookahead="%WS , for let order return stable where">ForClause_3 ::= ForClause_3 ',' '$' VarName ForClause_4 <dot>.</dot> ForClause_5 'in' ExprSingle</item>
      <item id="449" lookahead="%WS in">ForClause_5 ::= <dot>.</dot> PositionalVar</item>
      <item id="452" lookahead="%WS in">PositionalVar ::= <dot>.</dot> 'at' '$' VarName</item>
      <item id="448" lookahead="%WS in">ForClause_5 ::= <dot>.</dot></item>
      <goto on="ForClause_5" to="332"/>
      <goto on="PositionalVar" to="570"/>
      <shift on="at" to="310"/>
      <reduce on="in" symbol="ForClause_5"/>
    </state>
    <state id="191">
      <item id="365" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , for let order return stable where">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="482" lookahead="%WS , for let order return stable where">LetClause_2 ::= LetClause_2 ',' '$' VarName LetClause_3 ':=' <dot>.</dot> ExprSingle</item>
      <item id="560" lookahead="%WS , for let order return stable where">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , for let order return stable where">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , for let order return stable where">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , for let order return stable where">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , for let or order return stable where">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and for let or order return stable where">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable where">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable to where">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable to where">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq for ge gt idiv is le let lt mod ne or order return stable to where">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq for ge gt idiv is le let lt mod ne or order return stable to union where |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv intersect is le let lt mod ne or order return stable to union where |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to union where |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="571"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="192">
      <item id="365" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> FLWORExpr</item>
      <item id="367" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> QuantifiedExpr</item>
      <item id="368" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> TypeswitchExpr</item>
      <item id="369" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> IfExpr</item>
      <item id="370" lookahead="%WS , for let order return stable where">ExprSingle ::= <dot>.</dot> OrExpr</item>
      <item id="372" lookahead="%WS , for let order return stable where">FLWORExpr ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle</item>
      <item id="380" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_2</item>
      <item id="383" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= <dot>.</dot> FLWORExpr_1 FLWORExpr_2</item>
      <item id="388" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> ForClause</item>
      <item id="390" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= <dot>.</dot> LetClause</item>
      <item id="404" lookahead="%WS for let order return stable where">ForClause ::= <dot>.</dot> 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <item id="437" lookahead="%WS , for let order return stable where">ForClause_3 ::= ForClause_3 ',' '$' VarName ForClause_4 ForClause_5 'in' <dot>.</dot> ExprSingle</item>
      <item id="457" lookahead="%WS for let order return stable where">LetClause ::= <dot>.</dot> 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <item id="560" lookahead="%WS , for let order return stable where">QuantifiedExpr ::= <dot>.</dot> QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <item id="572" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'some'</item>
      <item id="574" lookahead="$ %WS">QuantifiedExpr_1 ::= <dot>.</dot> 'every'</item>
      <item id="601" lookahead="%WS , for let order return stable where">TypeswitchExpr ::= <dot>.</dot> 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <item id="644" lookahead="%WS , for let order return stable where">IfExpr ::= <dot>.</dot> 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <item id="654" lookahead="%WS , for let order return stable where">OrExpr ::= <dot>.</dot> AndExpr OrExpr_1</item>
      <item id="667" lookahead="%WS , for let or order return stable where">AndExpr ::= <dot>.</dot> ComparisonExpr AndExpr_1</item>
      <item id="680" lookahead="%WS , and for let or order return stable where">ComparisonExpr ::= <dot>.</dot> RangeExpr ComparisonExpr_1</item>
      <item id="698" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable where">RangeExpr ::= <dot>.</dot> AdditiveExpr RangeExpr_1</item>
      <item id="710" lookahead="!= %WS , &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable to where">AdditiveExpr ::= <dot>.</dot> MultiplicativeExpr AdditiveExpr_1</item>
      <item id="728" lookahead="!= %WS + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and eq for ge gt is le let lt ne or order return stable to where">MultiplicativeExpr ::= <dot>.</dot> UnionExpr MultiplicativeExpr_1</item>
      <item id="748" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq for ge gt idiv is le let lt mod ne or order return stable to where">UnionExpr ::= <dot>.</dot> IntersectExceptExpr UnionExpr_1</item>
      <item id="766" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq for ge gt idiv is le let lt mod ne or order return stable to union where |">IntersectExceptExpr ::= <dot>.</dot> InstanceofExpr IntersectExceptExpr_1</item>
      <item id="784" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv intersect is le let lt mod ne or order return stable to union where |">InstanceofExpr ::= <dot>.</dot> TreatExpr InstanceofExpr_1</item>
      <item id="797" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to union where |">TreatExpr ::= <dot>.</dot> CastableExpr TreatExpr_1</item>
      <item id="810" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">CastableExpr ::= <dot>.</dot> CastExpr CastableExpr_1</item>
      <item id="823" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and castable div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">CastExpr ::= <dot>.</dot> UnaryExpr CastExpr_1</item>
      <item id="836" lookahead="!= %WS * + , - &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; and cast castable div eq except for ge gt idiv instance intersect is le let lt mod ne or order return stable to treat union where |">UnaryExpr ::= <dot>.</dot> UnaryExpr_1 ValueExpr</item>
      <item id="844" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot> UnaryExpr_1 UnaryExpr_2</item>
      <item id="842" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= <dot>.</dot></item>
      <goto on="ExprSingle" to="572"/>
      <goto on="FLWORExpr" to="341"/>
      <goto on="FLWORExpr_1" to="6"/>
      <goto on="FLWORExpr_2" to="342"/>
      <goto on="ForClause" to="343"/>
      <goto on="LetClause" to="343"/>
      <goto on="QuantifiedExpr" to="341"/>
      <goto on="QuantifiedExpr_1" to="197"/>
      <goto on="TypeswitchExpr" to="341"/>
      <goto on="IfExpr" to="341"/>
      <goto on="OrExpr" to="341"/>
      <goto on="AndExpr" to="7"/>
      <goto on="ComparisonExpr" to="8"/>
      <goto on="RangeExpr" to="9"/>
      <goto on="AdditiveExpr" to="10"/>
      <goto on="MultiplicativeExpr" to="11"/>
      <goto on="UnionExpr" to="12"/>
      <goto on="IntersectExceptExpr" to="13"/>
      <goto on="InstanceofExpr" to="14"/>
      <goto on="TreatExpr" to="15"/>
      <goto on="CastableExpr" to="16"/>
      <goto on="CastExpr" to="17"/>
      <goto on="UnaryExpr" to="18"/>
      <goto on="UnaryExpr_1" to="19"/>
      <shift on="for" to="198"/>
      <shift on="let" to="199"/>
      <shift on="some" to="344"/>
      <shift on="every" to="344"/>
      <shift on="typeswitch" to="200"/>
      <shift on="if" to="201"/>
      <reduce on="$ ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate" symbol="UnaryExpr_1"/>
    </state>
    <state id="193">
      <item id="7" lookahead="%OTHER">XQuery ::= Module <dot>.</dot> EOF</item>
      <shift on="EOF" to="335"/>
    </state>
    <state id="194">
      <item id="26" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">VersionDecl ::= 'xquery' <dot>.</dot> 'version' StringLiteral VersionDecl_1 Separator</item>
      <shift on="version" to="196"/>
    </state>
    <state id="195">
      <item id="49" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">ModuleDecl ::= 'module' <dot>.</dot> 'namespace' NCName '=' URILiteral Separator</item>
      <shift on="namespace" to="204"/>
    </state>
    <state id="196">
      <item id="27" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">VersionDecl ::= 'xquery' 'version' <dot>.</dot> StringLiteral VersionDecl_1 Separator</item>
      <shift on="StringLiteral" to="28"/>
    </state>
    <state id="197">
      <item id="561" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 <dot>.</dot> '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <shift on="$" to="31"/>
    </state>
    <state id="198">
      <item id="405" lookahead="%WS for let order return stable where">ForClause ::= 'for' <dot>.</dot> '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3</item>
      <shift on="$" to="54"/>
    </state>
    <state id="199">
      <item id="458" lookahead="%WS for let order return stable where">LetClause ::= 'let' <dot>.</dot> '$' VarName LetClause_1 ':=' ExprSingle LetClause_2</item>
      <shift on="$" to="55"/>
    </state>
    <state id="200">
      <item id="602" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' <dot>.</dot> '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <shift on="(" to="56"/>
    </state>
    <state id="201">
      <item id="645" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= 'if' <dot>.</dot> '(' Expr ')' 'then' ExprSingle 'else' ExprSingle</item>
      <shift on="(" to="57"/>
    </state>
    <state id="202">
      <item id="110" lookahead="%WS ;">NamespaceDecl ::= 'declare namespace' <dot>.</dot> NCName '=' URILiteral</item>
      <shift on="NCName" to="239"/>
    </state>
    <state id="203">
      <item id="186" lookahead="%WS ;">SchemaImport ::= 'import' <dot>.</dot> 'schema' SchemaImport_1 URILiteral SchemaImport_2</item>
      <item id="228" lookahead="%WS ;">ModuleImport ::= 'import' <dot>.</dot> 'module' ModuleImport_1 URILiteral ModuleImport_2</item>
      <shift on="module" to="60"/>
      <shift on="schema" to="61"/>
    </state>
    <state id="204">
      <item id="50" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">ModuleDecl ::= 'module' 'namespace' <dot>.</dot> NCName '=' URILiteral Separator</item>
      <shift on="NCName" to="243"/>
    </state>
    <state id="205">
      <item id="360" lookahead="%WS ) , EOF ] }">Expr_1 ::= Expr_1 <dot>.</dot> ',' ExprSingle</item>
      <item id="353" lookahead="%WS ) EOF ] }">Expr ::= ExprSingle Expr_1 <dot>.</dot></item>
      <shift on="," to="63"/>
      <reduce on=") EOF ] }" symbol="Expr"/>
    </state>
    <state id="206">
      <item id="663" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">OrExpr_1 ::= OrExpr_1 <dot>.</dot> 'or' AndExpr</item>
      <item id="656" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">OrExpr ::= AndExpr OrExpr_1 <dot>.</dot></item>
      <shift on="or" to="66"/>
      <reduce on=") , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }" symbol="OrExpr"/>
    </state>
    <state id="207">
      <item id="676" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr_1 ::= AndExpr_1 <dot>.</dot> 'and' ComparisonExpr</item>
      <item id="669" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr ::= ComparisonExpr AndExpr_1 <dot>.</dot></item>
      <shift on="and" to="67"/>
      <reduce on=") , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }" symbol="AndExpr"/>
    </state>
    <state id="208">
      <item id="793" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr_1 ::= 'instance' <dot>.</dot> 'of' SequenceType</item>
      <shift on="of" to="72"/>
    </state>
    <state id="209">
      <item id="806" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr_1 ::= 'treat' <dot>.</dot> 'as' SequenceType</item>
      <shift on="as" to="73"/>
    </state>
    <state id="210">
      <item id="819" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr_1 ::= 'castable' <dot>.</dot> 'as' SingleType</item>
      <shift on="as" to="74"/>
    </state>
    <state id="211">
      <item id="832" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr_1 ::= 'cast' <dot>.</dot> 'as' SingleType</item>
      <shift on="as" to="75"/>
    </state>
    <state id="212">
      <item id="1137" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FunctionCall ::= QName <dot>.</dot> '(' FunctionCall_1 ')'</item>
      <item id="1061" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= QName <dot>.</dot> | Wildcard <dot>.</dot></item>
      <shift on="(" to="82"/>
      <reduce on="!= ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }" symbol="NameTest"/>
    </state>
    <state id="213">
      <item id="1125" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">OrderedExpr ::= 'ordered' <dot>.</dot> '{' Expr '}'</item>
      <shift on="{" to="83"/>
    </state>
    <state id="214">
      <item id="1131" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnorderedExpr ::= 'unordered' <dot>.</dot> '{' Expr '}'</item>
      <shift on="{" to="84"/>
    </state>
    <state id="215">
      <item id="1171" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor ::= '&lt;' <dot>.</dot> QName DirAttributeList DirElemConstructor_1</item>
      <shift on="QName" to="85"/>
    </state>
    <state id="216">
      <item id="996" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= 'child' <dot>.</dot> '::'</item>
      <shift on="::" to="414"/>
    </state>
    <state id="217">
      <item id="1000" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= 'descendant' <dot>.</dot> '::'</item>
      <shift on="::" to="414"/>
    </state>
    <state id="218">
      <item id="1006" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= 'self' <dot>.</dot> '::'</item>
      <shift on="::" to="414"/>
    </state>
    <state id="219">
      <item id="1009" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= 'descendant-or-self' <dot>.</dot> '::'</item>
      <shift on="::" to="414"/>
    </state>
    <state id="220">
      <item id="1012" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= 'following-sibling' <dot>.</dot> '::'</item>
      <shift on="::" to="414"/>
    </state>
    <state id="221">
      <item id="1015" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= 'following' <dot>.</dot> '::'</item>
      <shift on="::" to="414"/>
    </state>
    <state id="222">
      <item id="1036" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= 'parent' <dot>.</dot> '::'</item>
      <shift on="::" to="417"/>
    </state>
    <state id="223">
      <item id="1040" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= 'ancestor' <dot>.</dot> '::'</item>
      <shift on="::" to="417"/>
    </state>
    <state id="224">
      <item id="1043" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= 'preceding-sibling' <dot>.</dot> '::'</item>
      <shift on="::" to="417"/>
    </state>
    <state id="225">
      <item id="1046" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= 'preceding' <dot>.</dot> '::'</item>
      <shift on="::" to="417"/>
    </state>
    <state id="226">
      <item id="1049" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= 'ancestor-or-self' <dot>.</dot> '::'</item>
      <shift on="::" to="417"/>
    </state>
    <state id="227">
      <item id="1297" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirCommentConstructor ::= '&lt;!--' <dot>.</dot> DirCommentContents '--&gt;'</item>
      <shift on="DirCommentContents" to="258"/>
    </state>
    <state id="228">
      <item id="1302" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirPIConstructor ::= '&lt;?' <dot>.</dot> PITarget DirPIConstructor_1 '?&gt;'</item>
      <shift on="PITarget" to="88"/>
    </state>
    <state id="229">
      <item id="1325" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompDocConstructor ::= 'document' <dot>.</dot> '{' Expr '}'</item>
      <shift on="{" to="89"/>
    </state>
    <state id="230">
      <item id="1378" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompTextConstructor ::= 'text' <dot>.</dot> '{' Expr '}'</item>
      <item id="1492" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">TextTest ::= 'text' <dot>.</dot> '(' ')'</item>
      <shift on="(" to="259"/>
      <shift on="{" to="90"/>
    </state>
    <state id="231">
      <item id="1384" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompCommentConstructor ::= 'comment' <dot>.</dot> '{' Expr '}'</item>
      <item id="1497" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CommentTest ::= 'comment' <dot>.</dot> '(' ')'</item>
      <shift on="(" to="260"/>
      <shift on="{" to="91"/>
    </state>
    <state id="232">
      <item id="1474" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">AnyKindTest ::= 'node' <dot>.</dot> '(' ')'</item>
      <shift on="(" to="262"/>
    </state>
    <state id="233">
      <item id="1479" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">DocumentTest ::= 'document-node' <dot>.</dot> '(' DocumentTest_1 ')'</item>
      <shift on="(" to="94"/>
    </state>
    <state id="234">
      <item id="1542" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">SchemaAttributeTest ::= 'schema-attribute' <dot>.</dot> '(' AttributeDeclaration ')'</item>
      <shift on="(" to="95"/>
    </state>
    <state id="235">
      <item id="1585" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">SchemaElementTest ::= 'schema-element' <dot>.</dot> '(' ElementDeclaration ')'</item>
      <shift on="(" to="96"/>
    </state>
    <state id="236">
      <item id="136" lookahead="%WS ;">OptionDecl ::= 'declare option' <dot>.</dot> QName StringLiteral</item>
      <shift on="QName" to="265"/>
    </state>
    <state id="237">
      <item id="262" lookahead="%WS ;">VarDecl ::= 'declare variable' <dot>.</dot> '$' QName VarDecl_1 VarDecl_2</item>
      <shift on="$" to="266"/>
    </state>
    <state id="238">
      <item id="292" lookahead="%WS ;">FunctionDecl ::= 'declare function' <dot>.</dot> QName '(' FunctionDecl_1 ')' FunctionDecl_2 FunctionDecl_3</item>
      <shift on="QName" to="267"/>
    </state>
    <state id="239">
      <item id="111" lookahead="%WS ;">NamespaceDecl ::= 'declare namespace' NCName <dot>.</dot> '=' URILiteral</item>
      <shift on="=" to="99"/>
    </state>
    <state id="240">
      <item id="126" lookahead="%WS ;">DefaultNamespaceDecl ::= 'declare default' DefaultNamespaceDecl_1 <dot>.</dot> 'namespace' URILiteral</item>
      <shift on="namespace" to="100"/>
    </state>
    <state id="241">
      <item id="151" lookahead="%WS ;">EmptyOrderDecl ::= 'declare default' 'order' <dot>.</dot> 'empty' EmptyOrderDecl_1</item>
      <shift on="empty" to="101"/>
    </state>
    <state id="242">
      <item id="162" lookahead="%WS ;">CopyNamespacesDecl ::= 'declare copy-namespaces' PreserveMode <dot>.</dot> ',' InheritMode</item>
      <shift on="," to="102"/>
    </state>
    <state id="243">
      <item id="51" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">ModuleDecl ::= 'module' 'namespace' NCName <dot>.</dot> '=' URILiteral Separator</item>
      <shift on="=" to="105"/>
    </state>
    <state id="244">
      <item id="37" lookahead="%WS ;">VersionDecl_1 ::= 'encoding' <dot>.</dot> StringLiteral</item>
      <shift on="StringLiteral" to="423"/>
    </state>
    <state id="245">
      <item id="375" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 <dot>.</dot> 'return' ExprSingle</item>
      <shift on="return" to="106"/>
    </state>
    <state id="246">
      <item id="502" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">OrderByClause_1 ::= 'order' <dot>.</dot> 'by'</item>
      <shift on="by" to="426"/>
    </state>
    <state id="247">
      <item id="506" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">OrderByClause_1 ::= 'stable' <dot>.</dot> 'order' 'by'</item>
      <shift on="order" to="271"/>
    </state>
    <state id="248">
      <item id="1551" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">ElementTest ::= 'element' <dot>.</dot> '(' ElementTest_1 ')'</item>
      <shift on="(" to="80"/>
    </state>
    <state id="249">
      <item id="1515" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">AttributeTest ::= 'attribute' <dot>.</dot> '(' AttributeTest_1 ')'</item>
      <shift on="(" to="86"/>
    </state>
    <state id="250">
      <item id="1492" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">TextTest ::= 'text' <dot>.</dot> '(' ')'</item>
      <shift on="(" to="259"/>
    </state>
    <state id="251">
      <item id="1497" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">CommentTest ::= 'comment' <dot>.</dot> '(' ')'</item>
      <shift on="(" to="260"/>
    </state>
    <state id="252">
      <item id="1502" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">PITest ::= 'processing-instruction' <dot>.</dot> '(' PITest_1 ')'</item>
      <shift on="(" to="92"/>
    </state>
    <state id="253">
      <item id="1332" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= 'element' CompElemConstructor_1 <dot>.</dot> '{' CompElemConstructor_2 '}'</item>
      <shift on="{" to="114"/>
    </state>
    <state id="254">
      <item id="1112" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ParenthesizedExpr ::= '(' ParenthesizedExpr_1 <dot>.</dot> ')'</item>
      <shift on=")" to="445"/>
    </state>
    <state id="255">
      <item id="885" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValidateExpr ::= 'validate' ValidateExpr_1 <dot>.</dot> '{' Expr '}'</item>
      <shift on="{" to="118"/>
    </state>
    <state id="256">
      <item id="923" lookahead="%WS (# {">Pragma ::= '(#' Pragma_1 <dot>.</dot> QName Pragma_2 '#)'</item>
      <shift on="QName" to="119"/>
    </state>
    <state id="257">
      <item id="1357" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= 'attribute' CompAttrConstructor_1 <dot>.</dot> '{' CompAttrConstructor_2 '}'</item>
      <shift on="{" to="120"/>
    </state>
    <state id="258">
      <item id="1298" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirCommentConstructor ::= '&lt;!--' DirCommentContents <dot>.</dot> '--&gt;'</item>
      <shift on="--&gt;" to="448"/>
    </state>
    <state id="259">
      <item id="1493" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">TextTest ::= 'text' '(' <dot>.</dot> ')'</item>
      <shift on=")" to="449"/>
    </state>
    <state id="260">
      <item id="1498" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">CommentTest ::= 'comment' '(' <dot>.</dot> ')'</item>
      <shift on=")" to="450"/>
    </state>
    <state id="261">
      <item id="1391" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= 'processing-instruction' CompPIConstructor_1 <dot>.</dot> '{' CompPIConstructor_2 '}'</item>
      <shift on="{" to="122"/>
    </state>
    <state id="262">
      <item id="1475" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">AnyKindTest ::= 'node' '(' <dot>.</dot> ')'</item>
      <shift on=")" to="452"/>
    </state>
    <state id="263">
      <item id="604" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' '(' Expr <dot>.</dot> ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle</item>
      <shift on=")" to="124"/>
    </state>
    <state id="264">
      <item id="647" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= 'if' '(' Expr <dot>.</dot> ')' 'then' ExprSingle 'else' ExprSingle</item>
      <shift on=")" to="294"/>
    </state>
    <state id="265">
      <item id="137" lookahead="%WS ;">OptionDecl ::= 'declare option' QName <dot>.</dot> StringLiteral</item>
      <shift on="StringLiteral" to="458"/>
    </state>
    <state id="266">
      <item id="263" lookahead="%WS ;">VarDecl ::= 'declare variable' '$' <dot>.</dot> QName VarDecl_1 VarDecl_2</item>
      <shift on="QName" to="125"/>
    </state>
    <state id="267">
      <item id="293" lookahead="%WS ;">FunctionDecl ::= 'declare function' QName <dot>.</dot> '(' FunctionDecl_1 ')' FunctionDecl_2 FunctionDecl_3</item>
      <shift on="(" to="126"/>
    </state>
    <state id="268">
      <item id="239" lookahead="%WS StringLiteral">ModuleImport_1 ::= 'namespace' <dot>.</dot> NCName '='</item>
      <shift on="NCName" to="295"/>
    </state>
    <state id="269">
      <item id="219" lookahead="%WS StringLiteral">SchemaPrefix ::= 'namespace' <dot>.</dot> NCName '='</item>
      <shift on="NCName" to="296"/>
    </state>
    <state id="270">
      <item id="224" lookahead="%WS StringLiteral">SchemaPrefix ::= 'default' <dot>.</dot> 'element' 'namespace'</item>
      <shift on="element" to="297"/>
    </state>
    <state id="271">
      <item id="507" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">OrderByClause_1 ::= 'stable' 'order' <dot>.</dot> 'by'</item>
      <shift on="by" to="468"/>
    </state>
    <state id="272">
      <item id="564" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 <dot>.</dot> 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle</item>
      <shift on="in" to="131"/>
    </state>
    <state id="273">
      <item id="1428" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">SequenceType ::= 'empty-sequence' <dot>.</dot> '(' ')'</item>
      <shift on="(" to="299"/>
    </state>
    <state id="274">
      <item id="1453" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">ItemType ::= 'item' <dot>.</dot> '(' ')'</item>
      <shift on="(" to="300"/>
    </state>
    <state id="275">
      <item id="904" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ExtensionExpr ::= ExtensionExpr_1 '{' ExtensionExpr_2 <dot>.</dot> '}'</item>
      <shift on="}" to="475"/>
    </state>
    <state id="276">
      <item id="1553" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">ElementTest ::= 'element' '(' ElementTest_1 <dot>.</dot> ')'</item>
      <shift on=")" to="479"/>
    </state>
    <state id="277">
      <item id="1343" lookahead="%WS {">CompElemConstructor_1 ::= '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="481"/>
    </state>
    <state id="278">
      <item id="1139" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FunctionCall ::= QName '(' FunctionCall_1 <dot>.</dot> ')'</item>
      <shift on=")" to="482"/>
    </state>
    <state id="279">
      <item id="1127" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">OrderedExpr ::= 'ordered' '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="483"/>
    </state>
    <state id="280">
      <item id="1133" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnorderedExpr ::= 'unordered' '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="484"/>
    </state>
    <state id="281">
      <item id="1517" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">AttributeTest ::= 'attribute' '(' AttributeTest_1 <dot>.</dot> ')'</item>
      <shift on=")" to="488"/>
    </state>
    <state id="282">
      <item id="1368" lookahead="%WS {">CompAttrConstructor_1 ::= '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="490"/>
    </state>
    <state id="283">
      <item id="1304" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirPIConstructor ::= '&lt;?' PITarget DirPIConstructor_1 <dot>.</dot> '?&gt;'</item>
      <shift on="?&gt;" to="491"/>
    </state>
    <state id="284">
      <item id="1312" lookahead="%WS ?&gt;">DirPIConstructor_1 ::= S <dot>.</dot> DirPIContents</item>
      <shift on="DirPIContents" to="492"/>
    </state>
    <state id="285">
      <item id="1327" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompDocConstructor ::= 'document' '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="493"/>
    </state>
    <state id="286">
      <item id="1380" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompTextConstructor ::= 'text' '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="494"/>
    </state>
    <state id="287">
      <item id="1386" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompCommentConstructor ::= 'comment' '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="495"/>
    </state>
    <state id="288">
      <item id="1504" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">PITest ::= 'processing-instruction' '(' PITest_1 <dot>.</dot> ')'</item>
      <shift on=")" to="497"/>
    </state>
    <state id="289">
      <item id="1402" lookahead="%WS {">CompPIConstructor_1 ::= '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="498"/>
    </state>
    <state id="290">
      <item id="1481" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">DocumentTest ::= 'document-node' '(' DocumentTest_1 <dot>.</dot> ')'</item>
      <shift on=")" to="499"/>
    </state>
    <state id="291">
      <item id="1544" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">SchemaAttributeTest ::= 'schema-attribute' '(' AttributeDeclaration <dot>.</dot> ')'</item>
      <shift on=")" to="500"/>
    </state>
    <state id="292">
      <item id="1587" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">SchemaElementTest ::= 'schema-element' '(' ElementDeclaration <dot>.</dot> ')'</item>
      <shift on=")" to="501"/>
    </state>
    <state id="293">
      <item id="461" lookahead="%WS for let order return stable where">LetClause ::= 'let' '$' VarName LetClause_1 <dot>.</dot> ':=' ExprSingle LetClause_2</item>
      <shift on=":=" to="136"/>
    </state>
    <state id="294">
      <item id="648" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= 'if' '(' Expr ')' <dot>.</dot> 'then' ExprSingle 'else' ExprSingle</item>
      <shift on="then" to="139"/>
    </state>
    <state id="295">
      <item id="240" lookahead="%WS StringLiteral">ModuleImport_1 ::= 'namespace' NCName <dot>.</dot> '='</item>
      <shift on="=" to="507"/>
    </state>
    <state id="296">
      <item id="220" lookahead="%WS StringLiteral">SchemaPrefix ::= 'namespace' NCName <dot>.</dot> '='</item>
      <shift on="=" to="509"/>
    </state>
    <state id="297">
      <item id="225" lookahead="%WS StringLiteral">SchemaPrefix ::= 'default' 'element' <dot>.</dot> 'namespace'</item>
      <shift on="namespace" to="509"/>
    </state>
    <state id="298">
      <item id="519" lookahead="%WS , return">OrderSpecList_1 ::= OrderSpecList_1 <dot>.</dot> ',' OrderSpec</item>
      <item id="512" lookahead="%WS return">OrderSpecList ::= OrderSpec OrderSpecList_1 <dot>.</dot></item>
      <shift on="," to="146"/>
      <reduce on="return" symbol="OrderSpecList"/>
    </state>
    <state id="299">
      <item id="1429" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">SequenceType ::= 'empty-sequence' '(' <dot>.</dot> ')'</item>
      <shift on=")" to="511"/>
    </state>
    <state id="300">
      <item id="1454" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">ItemType ::= 'item' '(' <dot>.</dot> ')'</item>
      <shift on=")" to="512"/>
    </state>
    <state id="301">
      <item id="1078" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Predicate ::= '[' Expr <dot>.</dot> ']'</item>
      <shift on="]" to="513"/>
    </state>
    <state id="302">
      <item id="1334" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= 'element' CompElemConstructor_1 '{' CompElemConstructor_2 <dot>.</dot> '}'</item>
      <shift on="}" to="514"/>
    </state>
    <state id="303">
      <item id="1155" lookahead="%WS ) ,">FunctionCall_2 ::= FunctionCall_2 <dot>.</dot> ',' ExprSingle</item>
      <item id="1148" lookahead="%WS )">FunctionCall_1 ::= ExprSingle FunctionCall_2 <dot>.</dot></item>
      <shift on="," to="149"/>
      <reduce on=")" symbol="FunctionCall_1"/>
    </state>
    <state id="304">
      <item id="887" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValidateExpr ::= 'validate' ValidateExpr_1 '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="517"/>
    </state>
    <state id="305">
      <item id="925" lookahead="%WS (# {">Pragma ::= '(#' Pragma_1 QName Pragma_2 <dot>.</dot> '#)'</item>
      <shift on="#)" to="518"/>
    </state>
    <state id="306">
      <item id="939" lookahead="#) %WS">Pragma_2 ::= S <dot>.</dot> PragmaContents</item>
      <shift on="PragmaContents" to="519"/>
    </state>
    <state id="307">
      <item id="1359" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= 'attribute' CompAttrConstructor_1 '{' CompAttrConstructor_2 <dot>.</dot> '}'</item>
      <shift on="}" to="520"/>
    </state>
    <state id="308">
      <item id="1393" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= 'processing-instruction' CompPIConstructor_1 '{' CompPIConstructor_2 <dot>.</dot> '}'</item>
      <shift on="}" to="522"/>
    </state>
    <state id="309">
      <item id="409" lookahead="%WS for let order return stable where">ForClause ::= 'for' '$' VarName ForClause_1 ForClause_2 <dot>.</dot> 'in' ExprSingle ForClause_3</item>
      <shift on="in" to="152"/>
    </state>
    <state id="310">
      <item id="453" lookahead="%WS in">PositionalVar ::= 'at' <dot>.</dot> '$' VarName</item>
      <shift on="$" to="153"/>
    </state>
    <state id="311">
      <item id="295" lookahead="%WS ;">FunctionDecl ::= 'declare function' QName '(' FunctionDecl_1 <dot>.</dot> ')' FunctionDecl_2 FunctionDecl_3</item>
      <shift on=")" to="159"/>
    </state>
    <state id="312">
      <item id="333" lookahead="%WS ) ,">Param ::= '$' <dot>.</dot> QName Param_1</item>
      <shift on="QName" to="160"/>
    </state>
    <state id="313">
      <item id="650" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= 'if' '(' Expr ')' 'then' ExprSingle <dot>.</dot> 'else' ExprSingle</item>
      <shift on="else" to="167"/>
    </state>
    <state id="314">
      <item id="328" lookahead="%WS ) ,">ParamList_1 ::= ParamList_1 <dot>.</dot> ',' Param</item>
      <item id="321" lookahead="%WS )">ParamList ::= Param ParamList_1 <dot>.</dot></item>
      <shift on="," to="170"/>
      <reduce on=")" symbol="ParamList"/>
    </state>
    <state id="315">
      <item id="567" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 <dot>.</dot> 'satisfies' ExprSingle</item>
      <item id="587" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= QuantifiedExpr_3 <dot>.</dot> ',' '$' VarName QuantifiedExpr_4 'in' ExprSingle</item>
      <shift on="," to="324"/>
      <shift on="satisfies" to="171"/>
    </state>
    <state id="316">
      <item id="1183" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= '&gt;' DirElemConstructor_2 '&lt;/' <dot>.</dot> QName DirElemConstructor_3 '&gt;'</item>
      <shift on="QName" to="172"/>
    </state>
    <state id="317">
      <item id="1217" lookahead="%WS /&gt; &gt; S">DirAttributeList_1 ::= QName DirAttributeList_2 <dot>.</dot> '=' DirAttributeList_3 DirAttributeValue</item>
      <shift on="=" to="173"/>
    </state>
    <state id="318">
      <item id="477" lookahead="%WS , for let order return stable where">LetClause_2 ::= LetClause_2 <dot>.</dot> ',' '$' VarName LetClause_3 ':=' ExprSingle</item>
      <item id="464" lookahead="%WS for let order return stable where">LetClause ::= 'let' '$' VarName LetClause_1 ':=' ExprSingle LetClause_2 <dot>.</dot></item>
      <shift on="," to="327"/>
      <reduce on="for let order return stable where" symbol="LetClause"/>
    </state>
    <state id="319">
      <item id="608" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 <dot>.</dot> 'return' ExprSingle</item>
      <shift on="return" to="174"/>
    </state>
    <state id="320">
      <item id="631" lookahead="%WS case default">CaseClause ::= 'case' CaseClause_1 SequenceType <dot>.</dot> 'return' ExprSingle</item>
      <shift on="return" to="175"/>
    </state>
    <state id="321">
      <item id="641" lookahead="%WS QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text">CaseClause_1 ::= '$' VarName <dot>.</dot> 'as'</item>
      <shift on="as" to="543"/>
    </state>
    <state id="322">
      <item id="257" lookahead="%WS , ;">ModuleImport_3 ::= ModuleImport_3 <dot>.</dot> ',' URILiteral</item>
      <item id="250" lookahead="%WS ;">ModuleImport_2 ::= 'at' URILiteral ModuleImport_3 <dot>.</dot></item>
      <shift on="," to="176"/>
      <reduce on=";" symbol="ModuleImport_2"/>
    </state>
    <state id="323">
      <item id="212" lookahead="%WS , ;">SchemaImport_3 ::= SchemaImport_3 <dot>.</dot> ',' URILiteral</item>
      <item id="205" lookahead="%WS ;">SchemaImport_2 ::= 'at' URILiteral SchemaImport_3 <dot>.</dot></item>
      <shift on="," to="177"/>
      <reduce on=";" symbol="SchemaImport_2"/>
    </state>
    <state id="324">
      <item id="588" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= QuantifiedExpr_3 ',' <dot>.</dot> '$' VarName QuantifiedExpr_4 'in' ExprSingle</item>
      <shift on="$" to="178"/>
    </state>
    <state id="325">
      <item id="345" lookahead="&quot; %WS ' ; &lt; &lt;!-- &lt;/ &lt;? AposAttrContentChar CDataSection CharRef ElementContentChar EscapeApos EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">EnclosedExpr ::= '{' Expr <dot>.</dot> '}'</item>
      <shift on="}" to="550"/>
    </state>
    <state id="326">
      <item id="431" lookahead="%WS , for let order return stable where">ForClause_3 ::= ForClause_3 <dot>.</dot> ',' '$' VarName ForClause_4 ForClause_5 'in' ExprSingle</item>
      <item id="412" lookahead="%WS for let order return stable where">ForClause ::= 'for' '$' VarName ForClause_1 ForClause_2 'in' ExprSingle ForClause_3 <dot>.</dot></item>
      <shift on="," to="329"/>
      <reduce on="for let order return stable where" symbol="ForClause"/>
    </state>
    <state id="327">
      <item id="478" lookahead="%WS , for let order return stable where">LetClause_2 ::= LetClause_2 ',' <dot>.</dot> '$' VarName LetClause_3 ':=' ExprSingle</item>
      <shift on="$" to="180"/>
    </state>
    <state id="328">
      <item id="1185" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= '&gt;' DirElemConstructor_2 '&lt;/' QName DirElemConstructor_3 <dot>.</dot> '&gt;'</item>
      <shift on="&gt;" to="557"/>
    </state>
    <state id="329">
      <item id="432" lookahead="%WS , for let order return stable where">ForClause_3 ::= ForClause_3 ',' <dot>.</dot> '$' VarName ForClause_4 ForClause_5 'in' ExprSingle</item>
      <shift on="$" to="184"/>
    </state>
    <state id="330">
      <item id="591" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= QuantifiedExpr_3 ',' '$' VarName QuantifiedExpr_4 <dot>.</dot> 'in' ExprSingle</item>
      <shift on="in" to="189"/>
    </state>
    <state id="331">
      <item id="481" lookahead="%WS , for let order return stable where">LetClause_2 ::= LetClause_2 ',' '$' VarName LetClause_3 <dot>.</dot> ':=' ExprSingle</item>
      <shift on=":=" to="191"/>
    </state>
    <state id="332">
      <item id="436" lookahead="%WS , for let order return stable where">ForClause_3 ::= ForClause_3 ',' '$' VarName ForClause_4 ForClause_5 <dot>.</dot> 'in' ExprSingle</item>
      <shift on="in" to="192"/>
    </state>
    <state id="333">
      <item id="4" lookahead="%OTHER">Goal ::= XQuery <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Goal"/>
    </state>
    <state id="334">
      <item id="18" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Module_1 ::= VersionDecl <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Module_1"/>
    </state>
    <state id="335">
      <item id="8" lookahead="%OTHER">XQuery ::= Module EOF <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="XQuery"/>
    </state>
    <state id="336">
      <item id="12" lookahead="%WS EOF">Module ::= Module_1 Module_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Module"/>
    </state>
    <state id="337">
      <item id="22" lookahead="%WS EOF">Module_2 ::= LibraryModule <dot>.</dot> | MainModule <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Module_2"/>
    </state>
    <state id="338">
      <item id="46" lookahead="%WS EOF">LibraryModule ::= ModuleDecl Prolog <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="LibraryModule"/>
    </state>
    <state id="339">
      <item id="42" lookahead="%WS EOF">MainModule ::= Prolog QueryBody <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="MainModule"/>
    </state>
    <state id="340">
      <item id="349" lookahead="%WS EOF">QueryBody ::= Expr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="QueryBody"/>
    </state>
    <state id="341">
      <item id="366" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">ExprSingle ::= FLWORExpr <dot>.</dot> | QuantifiedExpr <dot>.</dot> | TypeswitchExpr <dot>.</dot> | IfExpr <dot>.</dot> | OrExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ExprSingle"/>
    </state>
    <state id="342">
      <item id="381" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= FLWORExpr_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FLWORExpr_1"/>
    </state>
    <state id="343">
      <item id="389" lookahead="%WS for let order return stable where">FLWORExpr_2 ::= ForClause <dot>.</dot> | LetClause <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FLWORExpr_2"/>
    </state>
    <state id="344">
      <item id="573" lookahead="$ %WS">QuantifiedExpr_1 ::= 'some' <dot>.</dot> | 'every' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="QuantifiedExpr_1"/>
    </state>
    <state id="345">
      <item id="71" lookahead="%WS ;">Prolog_2 ::= DefaultNamespaceDecl <dot>.</dot> | Setter <dot>.</dot> | NamespaceDecl <dot>.</dot> | Import <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Prolog_2"/>
    </state>
    <state id="346">
      <item id="93" lookahead="%WS ;">Setter ::= BoundarySpaceDecl <dot>.</dot> | DefaultCollationDecl <dot>.</dot> | BaseURIDecl <dot>.</dot> | ConstructionDecl <dot>.</dot> | OrderingModeDecl <dot>.</dot> | EmptyOrderDecl <dot>.</dot> | CopyNamespacesDecl <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Setter"/>
    </state>
    <state id="347">
      <item id="103" lookahead="%WS ;">Import ::= SchemaImport <dot>.</dot> | ModuleImport <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Import"/>
    </state>
    <state id="348">
      <item id="385" lookahead="%WS for let order return stable where">FLWORExpr_1 ::= FLWORExpr_1 FLWORExpr_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FLWORExpr_1"/>
    </state>
    <state id="349">
      <item id="396" lookahead="%WS order return stable">FLWORExpr_3 ::= WhereClause <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FLWORExpr_3"/>
    </state>
    <state id="350">
      <item id="682" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr ::= RangeExpr ComparisonExpr_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ComparisonExpr"/>
    </state>
    <state id="351">
      <item id="694" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ComparisonExpr_2 ::= ValueComp <dot>.</dot> | GeneralComp <dot>.</dot> | NodeComp <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ComparisonExpr_2"/>
    </state>
    <state id="352">
      <item id="861" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">GeneralComp ::= '=' <dot>.</dot> | '!=' <dot>.</dot> | '&lt;' <dot>.</dot> | '&lt;=' <dot>.</dot> | '&gt;' <dot>.</dot> | '&gt;=' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="GeneralComp"/>
    </state>
    <state id="353">
      <item id="870" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">ValueComp ::= 'eq' <dot>.</dot> | 'ne' <dot>.</dot> | 'lt' <dot>.</dot> | 'le' <dot>.</dot> | 'gt' <dot>.</dot> | 'ge' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ValueComp"/>
    </state>
    <state id="354">
      <item id="879" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">NodeComp ::= 'is' <dot>.</dot> | '&lt;&lt;' <dot>.</dot> | '&gt;&gt;' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="NodeComp"/>
    </state>
    <state id="355">
      <item id="700" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr ::= AdditiveExpr RangeExpr_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="RangeExpr"/>
    </state>
    <state id="356">
      <item id="786" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr ::= TreatExpr InstanceofExpr_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="InstanceofExpr"/>
    </state>
    <state id="357">
      <item id="799" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr ::= CastableExpr TreatExpr_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TreatExpr"/>
    </state>
    <state id="358">
      <item id="812" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr ::= CastExpr CastableExpr_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CastableExpr"/>
    </state>
    <state id="359">
      <item id="825" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr ::= UnaryExpr CastExpr_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CastExpr"/>
    </state>
    <state id="360">
      <item id="846" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_1 ::= UnaryExpr_1 UnaryExpr_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="UnaryExpr_1"/>
    </state>
    <state id="361">
      <item id="838" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnaryExpr ::= UnaryExpr_1 ValueExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="UnaryExpr"/>
    </state>
    <state id="362">
      <item id="855" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValueExpr ::= ValidateExpr <dot>.</dot> | PathExpr <dot>.</dot> | ExtensionExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ValueExpr"/>
    </state>
    <state id="363">
      <item id="909" lookahead="%WS (# {">ExtensionExpr_1 ::= Pragma <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ExtensionExpr_1"/>
    </state>
    <state id="364">
      <item id="951" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PathExpr ::= RelativePathExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="PathExpr"/>
    </state>
    <state id="365">
      <item id="973" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">StepExpr ::= FilterExpr <dot>.</dot> | AxisStep <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="StepExpr"/>
    </state>
    <state id="366">
      <item id="982" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AxisStep_1 ::= ReverseStep <dot>.</dot> | ForwardStep <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AxisStep_1"/>
    </state>
    <state id="367">
      <item id="991" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= AbbrevForwardStep <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ForwardStep"/>
    </state>
    <state id="368">
      <item id="1031" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= AbbrevReverseStep <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ReverseStep"/>
    </state>
    <state id="369">
      <item id="1019" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= NodeTest <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AbbrevForwardStep"/>
    </state>
    <state id="370">
      <item id="1056" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NodeTest ::= KindTest <dot>.</dot> | NameTest <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="NodeTest"/>
    </state>
    <state id="371">
      <item id="1083" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PrimaryExpr ::= Literal <dot>.</dot> | VarRef <dot>.</dot> | ParenthesizedExpr <dot>.</dot> | ContextItemExpr <dot>.</dot> | FunctionCall <dot>.</dot> | OrderedExpr <dot>.</dot> | UnorderedExpr <dot>.</dot> | Constructor <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="PrimaryExpr"/>
    </state>
    <state id="372">
      <item id="1094" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Literal ::= NumericLiteral <dot>.</dot> | StringLiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Literal"/>
    </state>
    <state id="373">
      <item id="1161" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Constructor ::= DirectConstructor <dot>.</dot> | ComputedConstructor <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Constructor"/>
    </state>
    <state id="374">
      <item id="1166" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirectConstructor ::= DirElemConstructor <dot>.</dot> | DirCommentConstructor <dot>.</dot> | DirPIConstructor <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirectConstructor"/>
    </state>
    <state id="375">
      <item id="1317" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ComputedConstructor ::= CompDocConstructor <dot>.</dot> | CompElemConstructor <dot>.</dot> | CompAttrConstructor <dot>.</dot> | CompTextConstructor <dot>.</dot> | CompCommentConstructor <dot>.</dot> | CompPIConstructor <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ComputedConstructor"/>
    </state>
    <state id="376">
      <item id="1463" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">KindTest ::= DocumentTest <dot>.</dot> | ElementTest <dot>.</dot> | AttributeTest <dot>.</dot> | SchemaElementTest <dot>.</dot> | SchemaAttributeTest <dot>.</dot> | PITest <dot>.</dot> | CommentTest <dot>.</dot> | TextTest <dot>.</dot> | AnyKindTest <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="KindTest"/>
    </state>
    <state id="377">
      <item id="850" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnaryExpr_2 ::= '-' <dot>.</dot> | '+' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="UnaryExpr_2"/>
    </state>
    <state id="378">
      <item id="1052" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevReverseStep ::= '..' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AbbrevReverseStep"/>
    </state>
    <state id="379">
      <item id="1061" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NameTest ::= QName <dot>.</dot> | Wildcard <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="NameTest"/>
    </state>
    <state id="380">
      <item id="1099" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">NumericLiteral ::= IntegerLiteral <dot>.</dot> | DecimalLiteral <dot>.</dot> | DoubleLiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="NumericLiteral"/>
    </state>
    <state id="381">
      <item id="1122" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ContextItemExpr ::= '.' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ContextItemExpr"/>
    </state>
    <state id="382">
      <item id="67" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_1 ::= Prolog_1 Prolog_2 Separator <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Prolog_1"/>
    </state>
    <state id="383">
      <item id="107" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Separator ::= ';' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Separator"/>
    </state>
    <state id="384">
      <item id="87" lookahead="%WS ;">Prolog_4 ::= VarDecl <dot>.</dot> | FunctionDecl <dot>.</dot> | OptionDecl <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Prolog_4"/>
    </state>
    <state id="385">
      <item id="117" lookahead="%WS ;">BoundarySpaceDecl ::= 'declare boundary-space' BoundarySpaceDecl_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="BoundarySpaceDecl"/>
    </state>
    <state id="386">
      <item id="121" lookahead="%WS ;">BoundarySpaceDecl_1 ::= 'preserve' <dot>.</dot> | 'strip' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="BoundarySpaceDecl_1"/>
    </state>
    <state id="387">
      <item id="132" lookahead="%WS namespace">DefaultNamespaceDecl_1 ::= 'element' <dot>.</dot> | 'function' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DefaultNamespaceDecl_1"/>
    </state>
    <state id="388">
      <item id="142" lookahead="%WS ;">OrderingModeDecl ::= 'declare ordering' OrderingModeDecl_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderingModeDecl"/>
    </state>
    <state id="389">
      <item id="146" lookahead="%WS ;">OrderingModeDecl_1 ::= 'ordered' <dot>.</dot> | 'unordered' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderingModeDecl_1"/>
    </state>
    <state id="390">
      <item id="168" lookahead="%WS ,">PreserveMode ::= 'preserve' <dot>.</dot> | 'no-preserve' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="PreserveMode"/>
    </state>
    <state id="391">
      <item id="183" lookahead="%WS ;">BaseURIDecl ::= 'declare base-uri' URILiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="BaseURIDecl"/>
    </state>
    <state id="392">
      <item id="1603" lookahead="%WS , ; at return">URILiteral ::= StringLiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="URILiteral"/>
    </state>
    <state id="393">
      <item id="284" lookahead="%WS ;">ConstructionDecl ::= 'declare construction' ConstructionDecl_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ConstructionDecl"/>
    </state>
    <state id="394">
      <item id="288" lookahead="%WS ;">ConstructionDecl_1 ::= 'strip' <dot>.</dot> | 'preserve' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ConstructionDecl_1"/>
    </state>
    <state id="395">
      <item id="402" lookahead="%WS return">FLWORExpr_4 ::= OrderByClause <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FLWORExpr_4"/>
    </state>
    <state id="396">
      <item id="493" lookahead="%WS order return stable">WhereClause ::= 'where' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="WhereClause"/>
    </state>
    <state id="397">
      <item id="1108" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and as ascending at case cast castable collation default descending div else empty eq except for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">VarName ::= QName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="VarName"/>
    </state>
    <state id="398">
      <item id="690" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">ComparisonExpr_1 ::= ComparisonExpr_2 RangeExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ComparisonExpr_1"/>
    </state>
    <state id="399">
      <item id="708" lookahead="!= %WS ) , ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable where }">RangeExpr_1 ::= 'to' AdditiveExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="RangeExpr_1"/>
    </state>
    <state id="400">
      <item id="725" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">AdditiveExpr_2 ::= '+' <dot>.</dot> | '-' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AdditiveExpr_2"/>
    </state>
    <state id="401">
      <item id="743" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">MultiplicativeExpr_2 ::= '*' <dot>.</dot> | 'div' <dot>.</dot> | 'idiv' <dot>.</dot> | 'mod' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="MultiplicativeExpr_2"/>
    </state>
    <state id="402">
      <item id="763" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">UnionExpr_2 ::= 'union' <dot>.</dot> | '|' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="UnionExpr_2"/>
    </state>
    <state id="403">
      <item id="781" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered validate">IntersectExceptExpr_2 ::= 'intersect' <dot>.</dot> | 'except' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="IntersectExceptExpr_2"/>
    </state>
    <state id="404">
      <item id="913" lookahead="%WS (# {">ExtensionExpr_1 ::= ExtensionExpr_1 Pragma <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ExtensionExpr_1"/>
    </state>
    <state id="405">
      <item id="989" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ForwardStep ::= ForwardAxis NodeTest <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ForwardStep"/>
    </state>
    <state id="406">
      <item id="1029" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ReverseStep ::= ReverseAxis NodeTest <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ReverseStep"/>
    </state>
    <state id="407">
      <item id="1339" lookahead="%WS {">CompElemConstructor_1 ::= QName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompElemConstructor_1"/>
    </state>
    <state id="408">
      <item id="1105" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">VarRef ::= '$' VarName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="VarRef"/>
    </state>
    <state id="409">
      <item id="1119" lookahead="%WS )">ParenthesizedExpr_1 ::= Expr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ParenthesizedExpr_1"/>
    </state>
    <state id="410">
      <item id="894" lookahead="%WS {">ValidateExpr_1 ::= ValidationMode <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ValidateExpr_1"/>
    </state>
    <state id="411">
      <item id="898" lookahead="%WS {">ValidationMode ::= 'lax' <dot>.</dot> | 'strict' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ValidationMode"/>
    </state>
    <state id="412">
      <item id="932" lookahead="%WS QName">Pragma_1 ::= S <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Pragma_1"/>
    </state>
    <state id="413">
      <item id="946" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PathExpr ::= '/' RelativePathExpr <dot>.</dot> | '//' RelativePathExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="PathExpr"/>
    </state>
    <state id="414">
      <item id="997" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ForwardAxis ::= 'child' '::' <dot>.</dot> | 'descendant' '::' <dot>.</dot> | 'attribute' '::' <dot>.</dot> | 'self' '::' <dot>.</dot> | 'descendant-or-self' '::' <dot>.</dot> | 'following-sibling' '::' <dot>.</dot> | 'following' '::' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ForwardAxis"/>
    </state>
    <state id="415">
      <item id="1364" lookahead="%WS {">CompAttrConstructor_1 ::= QName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompAttrConstructor_1"/>
    </state>
    <state id="416">
      <item id="1023" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">AbbrevForwardStep ::= '@' NodeTest <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AbbrevForwardStep"/>
    </state>
    <state id="417">
      <item id="1037" lookahead="%WS QName Wildcard attribute comment document-node element node processing-instruction schema-attribute schema-element text">ReverseAxis ::= 'parent' '::' <dot>.</dot> | 'ancestor' '::' <dot>.</dot> | 'preceding-sibling' '::' <dot>.</dot> | 'preceding' '::' <dot>.</dot> | 'ancestor-or-self' '::' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ReverseAxis"/>
    </state>
    <state id="418">
      <item id="1398" lookahead="%WS {">CompPIConstructor_1 ::= NCName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompPIConstructor_1"/>
    </state>
    <state id="419">
      <item id="83" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral EOF IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare function declare option declare variable descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">Prolog_3 ::= Prolog_3 Prolog_4 Separator <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Prolog_3"/>
    </state>
    <state id="420">
      <item id="179" lookahead="%WS ;">DefaultCollationDecl ::= 'declare default' 'collation' URILiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DefaultCollationDecl"/>
    </state>
    <state id="421">
      <item id="196" lookahead="%WS StringLiteral">SchemaImport_1 ::= SchemaPrefix <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SchemaImport_1"/>
    </state>
    <state id="422">
      <item id="30" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable descendant descendant-or-self document document-node element every following following-sibling for if import let module node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">VersionDecl ::= 'xquery' 'version' StringLiteral VersionDecl_1 Separator <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="VersionDecl"/>
    </state>
    <state id="423">
      <item id="38" lookahead="%WS ;">VersionDecl_1 ::= 'encoding' StringLiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="VersionDecl_1"/>
    </state>
    <state id="424">
      <item id="362" lookahead="%WS ) , EOF ] }">Expr_1 ::= Expr_1 ',' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Expr_1"/>
    </state>
    <state id="425">
      <item id="497" lookahead="%WS return">OrderByClause ::= OrderByClause_1 OrderSpecList <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderByClause"/>
    </state>
    <state id="426">
      <item id="503" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">OrderByClause_1 ::= 'order' 'by' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderByClause_1"/>
    </state>
    <state id="427">
      <item id="580" lookahead="%WS in">QuantifiedExpr_2 ::= TypeDeclaration <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="QuantifiedExpr_2"/>
    </state>
    <state id="428">
      <item id="665" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let or order return satisfies stable where }">OrExpr_1 ::= OrExpr_1 'or' AndExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrExpr_1"/>
    </state>
    <state id="429">
      <item id="678" lookahead="%WS ) , ; EOF ] and ascending case collation default descending else empty for let or order return satisfies stable where }">AndExpr_1 ::= AndExpr_1 'and' ComparisonExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AndExpr_1"/>
    </state>
    <state id="430">
      <item id="721" lookahead="!= %WS ) + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending else empty eq for ge gt is le let lt ne or order return satisfies stable to where }">AdditiveExpr_1 ::= AdditiveExpr_1 AdditiveExpr_2 MultiplicativeExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AdditiveExpr_1"/>
    </state>
    <state id="431">
      <item id="739" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to where }">MultiplicativeExpr_1 ::= MultiplicativeExpr_1 MultiplicativeExpr_2 UnionExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="MultiplicativeExpr_1"/>
    </state>
    <state id="432">
      <item id="759" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq for ge gt idiv is le let lt mod ne or order return satisfies stable to union where | }">UnionExpr_1 ::= UnionExpr_1 UnionExpr_2 IntersectExceptExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="UnionExpr_1"/>
    </state>
    <state id="433">
      <item id="777" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">IntersectExceptExpr_1 ::= IntersectExceptExpr_1 IntersectExceptExpr_2 InstanceofExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="IntersectExceptExpr_1"/>
    </state>
    <state id="434">
      <item id="795" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv intersect is le let lt mod ne or order return satisfies stable to union where | }">InstanceofExpr_1 ::= 'instance' 'of' SequenceType <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="InstanceofExpr_1"/>
    </state>
    <state id="435">
      <item id="1450" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">ItemType ::= KindTest <dot>.</dot> | AtomicType <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ItemType"/>
    </state>
    <state id="436">
      <item id="1459" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending at case castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">AtomicType ::= QName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AtomicType"/>
    </state>
    <state id="437">
      <item id="808" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to union where | }">TreatExpr_1 ::= 'treat' 'as' SequenceType <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TreatExpr_1"/>
    </state>
    <state id="438">
      <item id="821" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastableExpr_1 ::= 'castable' 'as' SingleType <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CastableExpr_1"/>
    </state>
    <state id="439">
      <item id="834" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CastExpr_1 ::= 'cast' 'as' SingleType <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CastExpr_1"/>
    </state>
    <state id="440">
      <item id="919" lookahead="%WS }">ExtensionExpr_2 ::= Expr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ExtensionExpr_2"/>
    </state>
    <state id="441">
      <item id="968" lookahead="$ %WS ( . .. &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element following following-sibling node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self text unordered">RelativePathExpr_2 ::= '/' <dot>.</dot> | '//' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="RelativePathExpr_2"/>
    </state>
    <state id="442">
      <item id="1074" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">PredicateList ::= PredicateList Predicate <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="PredicateList"/>
    </state>
    <state id="443">
      <item id="1581" lookahead="%WS ) ,">ElementNameOrWildcard ::= ElementName <dot>.</dot> | '*' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ElementNameOrWildcard"/>
    </state>
    <state id="444">
      <item id="1597" lookahead="%WS ) ,">ElementName ::= QName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ElementName"/>
    </state>
    <state id="445">
      <item id="1113" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ParenthesizedExpr ::= '(' ParenthesizedExpr_1 ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ParenthesizedExpr"/>
    </state>
    <state id="446">
      <item id="1538" lookahead="%WS ) ,">AttribNameOrWildcard ::= AttributeName <dot>.</dot> | '*' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AttribNameOrWildcard"/>
    </state>
    <state id="447">
      <item id="1594" lookahead="%WS ) ,">AttributeName ::= QName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AttributeName"/>
    </state>
    <state id="448">
      <item id="1299" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirCommentConstructor ::= '&lt;!--' DirCommentContents '--&gt;' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirCommentConstructor"/>
    </state>
    <state id="449">
      <item id="1494" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">TextTest ::= 'text' '(' ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TextTest"/>
    </state>
    <state id="450">
      <item id="1499" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">CommentTest ::= 'comment' '(' ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CommentTest"/>
    </state>
    <state id="451">
      <item id="1511" lookahead="%WS )">PITest_1 ::= NCName <dot>.</dot> | StringLiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="PITest_1"/>
    </state>
    <state id="452">
      <item id="1476" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">AnyKindTest ::= 'node' '(' ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AnyKindTest"/>
    </state>
    <state id="453">
      <item id="1488" lookahead="%WS )">DocumentTest_1 ::= ElementTest <dot>.</dot> | SchemaElementTest <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DocumentTest_1"/>
    </state>
    <state id="454">
      <item id="1548" lookahead="%WS )">AttributeDeclaration ::= AttributeName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AttributeDeclaration"/>
    </state>
    <state id="455">
      <item id="1591" lookahead="%WS )">ElementDeclaration ::= ElementName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ElementDeclaration"/>
    </state>
    <state id="456">
      <item id="418" lookahead="%WS at in">ForClause_1 ::= TypeDeclaration <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ForClause_1"/>
    </state>
    <state id="457">
      <item id="470" lookahead="%WS :=">LetClause_1 ::= TypeDeclaration <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="LetClause_1"/>
    </state>
    <state id="458">
      <item id="138" lookahead="%WS ;">OptionDecl ::= 'declare option' QName StringLiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OptionDecl"/>
    </state>
    <state id="459">
      <item id="113" lookahead="%WS ;">NamespaceDecl ::= 'declare namespace' NCName '=' URILiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="NamespaceDecl"/>
    </state>
    <state id="460">
      <item id="128" lookahead="%WS ;">DefaultNamespaceDecl ::= 'declare default' DefaultNamespaceDecl_1 'namespace' URILiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DefaultNamespaceDecl"/>
    </state>
    <state id="461">
      <item id="153" lookahead="%WS ;">EmptyOrderDecl ::= 'declare default' 'order' 'empty' EmptyOrderDecl_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="EmptyOrderDecl"/>
    </state>
    <state id="462">
      <item id="157" lookahead="%WS ;">EmptyOrderDecl_1 ::= 'greatest' <dot>.</dot> | 'least' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="EmptyOrderDecl_1"/>
    </state>
    <state id="463">
      <item id="164" lookahead="%WS ;">CopyNamespacesDecl ::= 'declare copy-namespaces' PreserveMode ',' InheritMode <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CopyNamespacesDecl"/>
    </state>
    <state id="464">
      <item id="173" lookahead="%WS ;">InheritMode ::= 'inherit' <dot>.</dot> | 'no-inherit' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="InheritMode"/>
    </state>
    <state id="465">
      <item id="377" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">FLWORExpr ::= FLWORExpr_1 FLWORExpr_3 FLWORExpr_4 'return' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FLWORExpr"/>
    </state>
    <state id="466">
      <item id="525" lookahead="%WS , return">OrderSpec ::= ExprSingle OrderModifier <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderSpec"/>
    </state>
    <state id="467">
      <item id="536" lookahead="%WS , collation empty return">OrderModifier_1 ::= 'ascending' <dot>.</dot> | 'descending' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderModifier_1"/>
    </state>
    <state id="468">
      <item id="508" lookahead="$ %WS ( (# + - . .. / // &lt; &lt;!-- &lt;? @ DecimalLiteral DoubleLiteral IntegerLiteral QName StringLiteral Wildcard ancestor ancestor-or-self attribute child comment descendant descendant-or-self document document-node element every following following-sibling for if let node ordered parent preceding preceding-sibling processing-instruction schema-attribute schema-element self some text typeswitch unordered validate">OrderByClause_1 ::= 'stable' 'order' 'by' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderByClause_1"/>
    </state>
    <state id="469">
      <item id="1423" lookahead="%WS ) , := at external in">TypeDeclaration ::= 'as' SequenceType <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TypeDeclaration"/>
    </state>
    <state id="470">
      <item id="1434" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">SequenceType ::= ItemType SequenceType_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SequenceType"/>
    </state>
    <state id="471">
      <item id="1440" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">SequenceType_1 ::= OccurrenceIndicator <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SequenceType_1"/>
    </state>
    <state id="472">
      <item id="1444" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">OccurrenceIndicator ::= '?' <dot>.</dot> | StarOccurreneIndicator <dot>.</dot> | PlusOccurreneIndicator <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OccurrenceIndicator"/>
    </state>
    <state id="473">
      <item id="1413" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SingleType ::= AtomicType SingleType_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SingleType"/>
    </state>
    <state id="474">
      <item id="1419" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">SingleType_1 ::= '?' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SingleType_1"/>
    </state>
    <state id="475">
      <item id="905" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ExtensionExpr ::= ExtensionExpr_1 '{' ExtensionExpr_2 '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ExtensionExpr"/>
    </state>
    <state id="476">
      <item id="964" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">RelativePathExpr_1 ::= RelativePathExpr_1 RelativePathExpr_2 StepExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="RelativePathExpr_1"/>
    </state>
    <state id="477">
      <item id="1353" lookahead="%WS }">ContentExpr ::= Expr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ContentExpr"/>
    </state>
    <state id="478">
      <item id="1350" lookahead="%WS }">CompElemConstructor_2 ::= ContentExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompElemConstructor_2"/>
    </state>
    <state id="479">
      <item id="1554" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">ElementTest ::= 'element' '(' ElementTest_1 ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ElementTest"/>
    </state>
    <state id="480">
      <item id="1562" lookahead="%WS )">ElementTest_1 ::= ElementNameOrWildcard ElementTest_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ElementTest_1"/>
    </state>
    <state id="481">
      <item id="1344" lookahead="%WS {">CompElemConstructor_1 ::= '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompElemConstructor_1"/>
    </state>
    <state id="482">
      <item id="1140" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">FunctionCall ::= QName '(' FunctionCall_1 ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FunctionCall"/>
    </state>
    <state id="483">
      <item id="1128" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">OrderedExpr ::= 'ordered' '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderedExpr"/>
    </state>
    <state id="484">
      <item id="1134" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">UnorderedExpr ::= 'unordered' '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="UnorderedExpr"/>
    </state>
    <state id="485">
      <item id="1174" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor ::= '&lt;' QName DirAttributeList DirElemConstructor_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirElemConstructor"/>
    </state>
    <state id="486">
      <item id="1178" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= '/&gt;' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirElemConstructor_1"/>
    </state>
    <state id="487">
      <item id="1375" lookahead="%WS }">CompAttrConstructor_2 ::= Expr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompAttrConstructor_2"/>
    </state>
    <state id="488">
      <item id="1518" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">AttributeTest ::= 'attribute' '(' AttributeTest_1 ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AttributeTest"/>
    </state>
    <state id="489">
      <item id="1526" lookahead="%WS )">AttributeTest_1 ::= AttribNameOrWildcard AttributeTest_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AttributeTest_1"/>
    </state>
    <state id="490">
      <item id="1369" lookahead="%WS {">CompAttrConstructor_1 ::= '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompAttrConstructor_1"/>
    </state>
    <state id="491">
      <item id="1305" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirPIConstructor ::= '&lt;?' PITarget DirPIConstructor_1 '?&gt;' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirPIConstructor"/>
    </state>
    <state id="492">
      <item id="1313" lookahead="%WS ?&gt;">DirPIConstructor_1 ::= S DirPIContents <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirPIConstructor_1"/>
    </state>
    <state id="493">
      <item id="1328" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompDocConstructor ::= 'document' '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompDocConstructor"/>
    </state>
    <state id="494">
      <item id="1381" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompTextConstructor ::= 'text' '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompTextConstructor"/>
    </state>
    <state id="495">
      <item id="1387" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompCommentConstructor ::= 'comment' '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompCommentConstructor"/>
    </state>
    <state id="496">
      <item id="1409" lookahead="%WS }">CompPIConstructor_2 ::= Expr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompPIConstructor_2"/>
    </state>
    <state id="497">
      <item id="1505" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">PITest ::= 'processing-instruction' '(' PITest_1 ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="PITest"/>
    </state>
    <state id="498">
      <item id="1403" lookahead="%WS {">CompPIConstructor_1 ::= '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompPIConstructor_1"/>
    </state>
    <state id="499">
      <item id="1482" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">DocumentTest ::= 'document-node' '(' DocumentTest_1 ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DocumentTest"/>
    </state>
    <state id="500">
      <item id="1545" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">SchemaAttributeTest ::= 'schema-attribute' '(' AttributeDeclaration ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SchemaAttributeTest"/>
    </state>
    <state id="501">
      <item id="1588" lookahead="!= %WS ) * + , - / // := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator [ ] and ascending at case cast castable collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to treat union where { | }">SchemaElementTest ::= 'schema-element' '(' ElementDeclaration ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SchemaElementTest"/>
    </state>
    <state id="502">
      <item id="424" lookahead="%WS in">ForClause_2 ::= PositionalVar <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ForClause_2"/>
    </state>
    <state id="503">
      <item id="614" lookahead="%WS case default">TypeswitchExpr_1 ::= CaseClause <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TypeswitchExpr_1"/>
    </state>
    <state id="504">
      <item id="272" lookahead="%WS := external">VarDecl_1 ::= TypeDeclaration <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="VarDecl_1"/>
    </state>
    <state id="505">
      <item id="304" lookahead="%WS )">FunctionDecl_1 ::= ParamList <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FunctionDecl_1"/>
    </state>
    <state id="506">
      <item id="232" lookahead="%WS ;">ModuleImport ::= 'import' 'module' ModuleImport_1 URILiteral ModuleImport_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ModuleImport"/>
    </state>
    <state id="507">
      <item id="241" lookahead="%WS StringLiteral">ModuleImport_1 ::= 'namespace' NCName '=' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ModuleImport_1"/>
    </state>
    <state id="508">
      <item id="190" lookahead="%WS ;">SchemaImport ::= 'import' 'schema' SchemaImport_1 URILiteral SchemaImport_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SchemaImport"/>
    </state>
    <state id="509">
      <item id="221" lookahead="%WS StringLiteral">SchemaPrefix ::= 'namespace' NCName '=' <dot>.</dot> | 'default' 'element' 'namespace' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SchemaPrefix"/>
    </state>
    <state id="510">
      <item id="54" lookahead="%WS EOF declare base-uri declare boundary-space declare construction declare copy-namespaces declare default declare function declare namespace declare option declare ordering declare variable import">ModuleDecl ::= 'module' 'namespace' NCName '=' URILiteral Separator <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ModuleDecl"/>
    </state>
    <state id="511">
      <item id="1430" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">SequenceType ::= 'empty-sequence' '(' ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SequenceType"/>
    </state>
    <state id="512">
      <item id="1455" lookahead="!= %WS ) * + , - := ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; ? EOF PlusOccurreneIndicator StarOccurreneIndicator ] and ascending at case collation default descending div else empty eq except external for ge gt idiv in instance intersect is le let lt mod ne or order return satisfies stable to union where { | }">ItemType ::= 'item' '(' ')' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ItemType"/>
    </state>
    <state id="513">
      <item id="1079" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">Predicate ::= '[' Expr ']' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Predicate"/>
    </state>
    <state id="514">
      <item id="1335" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompElemConstructor ::= 'element' CompElemConstructor_1 '{' CompElemConstructor_2 '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompElemConstructor"/>
    </state>
    <state id="515">
      <item id="1600" lookahead="%WS ) ?">TypeName ::= QName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TypeName"/>
    </state>
    <state id="516">
      <item id="1209" lookahead="%WS /&gt; &gt; S">DirAttributeList ::= DirAttributeList S DirAttributeList_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeList"/>
    </state>
    <state id="517">
      <item id="888" lookahead="!= %WS ) * + , - ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">ValidateExpr ::= 'validate' ValidateExpr_1 '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ValidateExpr"/>
    </state>
    <state id="518">
      <item id="926" lookahead="%WS (# {">Pragma ::= '(#' Pragma_1 QName Pragma_2 '#)' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Pragma"/>
    </state>
    <state id="519">
      <item id="940" lookahead="#) %WS">Pragma_2 ::= S PragmaContents <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Pragma_2"/>
    </state>
    <state id="520">
      <item id="1360" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompAttrConstructor ::= 'attribute' CompAttrConstructor_1 '{' CompAttrConstructor_2 '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompAttrConstructor"/>
    </state>
    <state id="521">
      <item id="1534" lookahead="%WS )">AttributeTest_2 ::= ',' TypeName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AttributeTest_2"/>
    </state>
    <state id="522">
      <item id="1394" lookahead="!= %WS ) * + , - / // ; &lt; &lt;&lt; &lt;= = &gt; &gt;= &gt;&gt; EOF [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where | }">CompPIConstructor ::= 'processing-instruction' CompPIConstructor_1 '{' CompPIConstructor_2 '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CompPIConstructor"/>
    </state>
    <state id="523">
      <item id="618" lookahead="%WS case default">TypeswitchExpr_1 ::= TypeswitchExpr_1 CaseClause <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TypeswitchExpr_1"/>
    </state>
    <state id="524">
      <item id="266" lookahead="%WS ;">VarDecl ::= 'declare variable' '$' QName VarDecl_1 VarDecl_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="VarDecl"/>
    </state>
    <state id="525">
      <item id="280" lookahead="%WS ;">VarDecl_2 ::= 'external' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="VarDecl_2"/>
    </state>
    <state id="526">
      <item id="530" lookahead="%WS , return">OrderModifier ::= OrderModifier_1 OrderModifier_2 OrderModifier_4 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderModifier"/>
    </state>
    <state id="527">
      <item id="545" lookahead="%WS , collation return">OrderModifier_2 ::= 'empty' OrderModifier_3 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderModifier_2"/>
    </state>
    <state id="528">
      <item id="549" lookahead="%WS , collation return">OrderModifier_3 ::= 'greatest' <dot>.</dot> | 'least' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderModifier_3"/>
    </state>
    <state id="529">
      <item id="521" lookahead="%WS , return">OrderSpecList_1 ::= OrderSpecList_1 ',' OrderSpec <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderSpecList_1"/>
    </state>
    <state id="530">
      <item id="1571" lookahead="%WS )">ElementTest_2 ::= ',' TypeName ElementTest_3 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ElementTest_2"/>
    </state>
    <state id="531">
      <item id="1577" lookahead="%WS )">ElementTest_3 ::= '?' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ElementTest_3"/>
    </state>
    <state id="532">
      <item id="1157" lookahead="%WS ) ,">FunctionCall_2 ::= FunctionCall_2 ',' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FunctionCall_2"/>
    </state>
    <state id="533">
      <item id="1290" lookahead="&quot; %WS ' &lt; &lt;!-- &lt;/ &lt;? AposAttrContentChar CDataSection CharRef ElementContentChar EscapeApos EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">CommonContent ::= PredefinedEntityRef <dot>.</dot> | CharRef <dot>.</dot> | '{{' <dot>.</dot> | '}}' <dot>.</dot> | EnclosedExpr <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CommonContent"/>
    </state>
    <state id="534">
      <item id="1283" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemContent ::= DirectConstructor <dot>.</dot> | CDataSection <dot>.</dot> | CommonContent <dot>.</dot> | ElementContentChar <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirElemContent"/>
    </state>
    <state id="535">
      <item id="1194" lookahead="%WS &lt; &lt;!-- &lt;/ &lt;? CDataSection CharRef ElementContentChar PredefinedEntityRef { {{ }}">DirElemConstructor_2 ::= DirElemConstructor_2 DirElemContent <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirElemConstructor_2"/>
    </state>
    <state id="536">
      <item id="1226" lookahead="%WS =">DirAttributeList_2 ::= S <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeList_2"/>
    </state>
    <state id="537">
      <item id="455" lookahead="%WS in">PositionalVar ::= 'at' '$' VarName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="PositionalVar"/>
    </state>
    <state id="538">
      <item id="278" lookahead="%WS ;">VarDecl_2 ::= ':=' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="VarDecl_2"/>
    </state>
    <state id="539">
      <item id="335" lookahead="%WS ) ,">Param ::= '$' QName Param_1 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Param"/>
    </state>
    <state id="540">
      <item id="341" lookahead="%WS ) ,">Param_1 ::= TypeDeclaration <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="Param_1"/>
    </state>
    <state id="541">
      <item id="558" lookahead="%WS , return">OrderModifier_4 ::= 'collation' URILiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="OrderModifier_4"/>
    </state>
    <state id="542">
      <item id="626" lookahead="%WS return">TypeswitchExpr_2 ::= '$' VarName <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TypeswitchExpr_2"/>
    </state>
    <state id="543">
      <item id="642" lookahead="%WS QName attribute comment document-node element empty-sequence item node processing-instruction schema-attribute schema-element text">CaseClause_1 ::= '$' VarName 'as' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CaseClause_1"/>
    </state>
    <state id="544">
      <item id="652" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">IfExpr ::= 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="IfExpr"/>
    </state>
    <state id="545">
      <item id="298" lookahead="%WS ;">FunctionDecl ::= 'declare function' QName '(' FunctionDecl_1 ')' FunctionDecl_2 FunctionDecl_3 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FunctionDecl"/>
    </state>
    <state id="546">
      <item id="316" lookahead="%WS ;">FunctionDecl_3 ::= EnclosedExpr <dot>.</dot> | 'external' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FunctionDecl_3"/>
    </state>
    <state id="547">
      <item id="312" lookahead="%WS external {">FunctionDecl_2 ::= 'as' SequenceType <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="FunctionDecl_2"/>
    </state>
    <state id="548">
      <item id="330" lookahead="%WS ) ,">ParamList_1 ::= ParamList_1 ',' Param <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ParamList_1"/>
    </state>
    <state id="549">
      <item id="569" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">QuantifiedExpr ::= QuantifiedExpr_1 '$' VarName QuantifiedExpr_2 'in' ExprSingle QuantifiedExpr_3 'satisfies' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="QuantifiedExpr"/>
    </state>
    <state id="550">
      <item id="346" lookahead="&quot; %WS ' ; &lt; &lt;!-- &lt;/ &lt;? AposAttrContentChar CDataSection CharRef ElementContentChar EscapeApos EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">EnclosedExpr ::= '{' Expr '}' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="EnclosedExpr"/>
    </state>
    <state id="551">
      <item id="1200" lookahead="%WS &gt;">DirElemConstructor_3 ::= S <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirElemConstructor_3"/>
    </state>
    <state id="552">
      <item id="1232" lookahead="&quot; %WS '">DirAttributeList_3 ::= S <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeList_3"/>
    </state>
    <state id="553">
      <item id="610" lookahead="%WS ) , ; EOF ] ascending case collation default descending else empty for let order return satisfies stable where }">TypeswitchExpr ::= 'typeswitch' '(' Expr ')' TypeswitchExpr_1 'default' TypeswitchExpr_2 'return' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="TypeswitchExpr"/>
    </state>
    <state id="554">
      <item id="633" lookahead="%WS case default">CaseClause ::= 'case' CaseClause_1 SequenceType 'return' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="CaseClause"/>
    </state>
    <state id="555">
      <item id="259" lookahead="%WS , ;">ModuleImport_3 ::= ModuleImport_3 ',' URILiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ModuleImport_3"/>
    </state>
    <state id="556">
      <item id="214" lookahead="%WS , ;">SchemaImport_3 ::= SchemaImport_3 ',' URILiteral <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="SchemaImport_3"/>
    </state>
    <state id="557">
      <item id="1186" lookahead="!= %WS ) * + , - / // ; &lt; &lt;!-- &lt;/ &lt;&lt; &lt;= &lt;? = &gt; &gt;= &gt;&gt; CDataSection CharRef EOF ElementContentChar PredefinedEntityRef [ ] and ascending case cast castable collation default descending div else empty eq except for ge gt idiv instance intersect is le let lt mod ne or order return satisfies stable to treat union where { {{ | } }}">DirElemConstructor_1 ::= '&gt;' DirElemConstructor_2 '&lt;/' QName DirElemConstructor_3 '&gt;' <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirElemConstructor_1"/>
    </state>
    <state id="558">
      <item id="1220" lookahead="%WS /&gt; &gt; S">DirAttributeList_1 ::= QName DirAttributeList_2 '=' DirAttributeList_3 DirAttributeValue <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeList_1"/>
    </state>
    <state id="559">
      <item id="599" lookahead="%WS in">QuantifiedExpr_4 ::= TypeDeclaration <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="QuantifiedExpr_4"/>
    </state>
    <state id="560">
      <item id="489" lookahead="%WS :=">LetClause_3 ::= TypeDeclaration <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="LetClause_3"/>
    </state>
    <state id="561">
      <item id="1251" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">DirAttributeValue_1 ::= DirAttributeValue_1 DirAttributeValue_2 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeValue_1"/>
    </state>
    <state id="562">
      <item id="1255" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">DirAttributeValue_2 ::= EscapeQuot <dot>.</dot> | QuotAttrValueContent <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeValue_2"/>
    </state>
    <state id="563">
      <item id="1273" lookahead="&quot; %WS CharRef EscapeQuot PredefinedEntityRef QuotAttrContentChar { {{ }}">QuotAttrValueContent ::= QuotAttrContentChar <dot>.</dot> | CommonContent <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="QuotAttrValueContent"/>
    </state>
    <state id="564">
      <item id="1239" lookahead="%WS /&gt; &gt; S">DirAttributeValue ::= '&quot;' DirAttributeValue_1 '&quot;' <dot>.</dot> | &quot;'&quot; DirAttributeValue_3 &quot;'&quot; <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeValue"/>
    </state>
    <state id="565">
      <item id="1264" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">DirAttributeValue_3 ::= DirAttributeValue_3 DirAttributeValue_4 <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeValue_3"/>
    </state>
    <state id="566">
      <item id="1268" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">DirAttributeValue_4 ::= EscapeApos <dot>.</dot> | AposAttrValueContent <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="DirAttributeValue_4"/>
    </state>
    <state id="567">
      <item id="1278" lookahead="%WS ' AposAttrContentChar CharRef EscapeApos PredefinedEntityRef { {{ }}">AposAttrValueContent ::= AposAttrContentChar <dot>.</dot> | CommonContent <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="AposAttrValueContent"/>
    </state>
    <state id="568">
      <item id="444" lookahead="%WS at in">ForClause_4 ::= TypeDeclaration <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ForClause_4"/>
    </state>
    <state id="569">
      <item id="593" lookahead="%WS , satisfies">QuantifiedExpr_3 ::= QuantifiedExpr_3 ',' '$' VarName QuantifiedExpr_4 'in' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="QuantifiedExpr_3"/>
    </state>
    <state id="570">
      <item id="450" lookahead="%WS in">ForClause_5 ::= PositionalVar <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ForClause_5"/>
    </state>
    <state id="571">
      <item id="483" lookahead="%WS , for let order return stable where">LetClause_2 ::= LetClause_2 ',' '$' VarName LetClause_3 ':=' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="LetClause_2"/>
    </state>
    <state id="572">
      <item id="438" lookahead="%WS , for let order return stable where">ForClause_3 ::= ForClause_3 ',' '$' VarName ForClause_4 ForClause_5 'in' ExprSingle <dot>.</dot></item>
      <reduce on="%EPSILON" symbol="ForClause_3"/>
    </state>
  </parser>
  <triples>
  </triples>
</g:grammar>
