xquery version "1.0" encoding "UTF-8";

(: This file was generated on Thu Dec 26, 2024 06:57 (UTC+01) by REx v6.1-SNAPSHOT which is Copyright (c) 1979-2024 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q relax-ng-compact.ebnf -xquery -tree -main -backtrack -ll 2 :)

declare namespace p="relax-ng-compact";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 11;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 12;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  52, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 5, 6, 4, 4, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 4, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 4, 4, 17, 18, 19, 4, 20, 21, 21, 21, 21,
  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 23, 24, 4, 21, 4, 25, 26, 27,
  28, 29, 30, 31, 32, 33, 21, 34, 35, 36, 37, 38, 39, 21, 40, 41, 42, 43, 44, 45, 46, 47, 21, 48, 49, 50, 51, 4
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 979, 993, 1001, 1279, 1279, 1012, 1031,
  1039, 1047, 1055, 1287, 1287, 1287, 1287, 1287, 1287, 1288, 1287, 1279, 1279, 1280, 1279, 1279, 1279, 1280, 1279,
  1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1281, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1287, 1287, 1287, 1279, 1279, 1279, 1279, 1279, 1279, 1360, 1280, 1278, 1277, 1279, 1279, 1279, 1279,
  1279, 1280, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1283, 1020, 1279, 1279, 1279, 1279, 1208, 1023, 1279,
  1279, 1279, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1286, 1287, 1022, 1285, 1287, 985, 1287, 1287, 1287, 1287, 1287, 1278, 1279, 1279, 1284, 1123, 1133, 984, 1287,
  979, 985, 1123, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1362, 1279, 1280, 1142, 979, 1160, 1221, 979, 985,
  979, 979, 979, 979, 979, 979, 979, 979, 981, 1287, 1287, 1287, 985, 1287, 1287, 1287, 1385, 1256, 1279, 1279, 1276,
  1279, 1279, 1279, 1279, 1280, 1280, 1395, 1277, 1279, 1283, 1287, 1278, 1077, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1279, 1278, 1077, 1279, 1279, 1279, 1279, 1086, 1287, 1279, 1279, 1279, 1279, 1279, 1279, 1103, 1112, 1279,
  1279, 1279, 1104, 1281, 1285, 1420, 1279, 1279, 1279, 1279, 1279, 1279, 1179, 979, 981, 1222, 1279, 1165, 979, 1287,
  1287, 1420, 1103, 1361, 1279, 1279, 1277, 1206, 1217, 1151, 1168, 1288, 1232, 1165, 979, 1285, 1287, 1243, 1266, 1361,
  1279, 1279, 1277, 1069, 1217, 1171, 1168, 1287, 1254, 1289, 979, 1264, 1287, 1420, 1255, 1276, 1279, 1279, 1277, 1274,
  1179, 1326, 1095, 1287, 1287, 1190, 979, 1287, 1287, 1420, 1103, 1361, 1279, 1279, 1277, 1358, 1179, 1223, 1168, 1289,
  1232, 1115, 979, 1287, 1287, 1198, 1298, 1314, 1310, 1209, 1298, 1003, 1115, 1224, 1221, 1288, 1287, 1288, 979, 1287,
  1287, 1420, 1077, 1277, 1279, 1279, 1277, 1078, 1115, 1327, 1221, 1290, 1287, 1115, 979, 1287, 1287, 1198, 1077, 1277,
  1279, 1279, 1277, 1078, 1115, 1327, 1221, 1290, 1409, 1115, 979, 1287, 1287, 1198, 1077, 1277, 1279, 1279, 1277, 1279,
  1115, 1152, 1221, 1288, 1287, 1115, 979, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1287, 1287, 1287, 1287, 1287, 1279, 1279, 1279, 1279, 1281, 1287, 1279, 1279, 1279, 1279, 1280, 1287,
  1278, 1279, 1279, 1279, 1279, 1280, 1322, 984, 1125, 980, 979, 985, 1287, 1287, 1287, 1287, 1235, 1335, 1021, 1278,
  1345, 1355, 1322, 1185, 1370, 981, 979, 985, 1287, 1287, 1287, 1287, 1409, 1302, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1287, 1287, 1284, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1274, 1068, 1284, 1287, 1287, 1287, 1287, 1393, 1286, 1393, 1208, 1018, 1347, 1207, 1234, 1287, 1287, 1287,
  1287, 1409, 1287, 1337, 1408, 1312, 1284, 1287, 1287, 1287, 1287, 1404, 1286, 1406, 1279, 1279, 1279, 1279, 1279,
  1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1283, 1279, 1279, 1279, 1279,
  1279, 1279, 1279, 1279, 1279, 1279, 1279, 1285, 1279, 1279, 1281, 1281, 1279, 1279, 1279, 1279, 1281, 1281, 1279,
  1396, 1279, 1279, 1279, 1281, 1279, 1279, 1279, 1279, 1279, 1279, 1077, 1004, 1246, 1282, 1104, 1283, 1279, 1282,
  1246, 1282, 1062, 1287, 1287, 1287, 1278, 1134, 1150, 1287, 1278, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1282, 1195, 1278, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1417, 1020, 1279, 1279, 1279,
  1279, 1282, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 979, 982, 1383, 1287, 1287,
  1287, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1279, 1283, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 985, 979, 985, 972, 1375, 1279,
  1278, 1279, 1279, 1279, 1285, 978, 979, 1327, 983, 1326, 978, 979, 981, 978, 1383, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1278, 1279, 1279, 1279, 1280, 1406, 1278, 1279, 1279, 1279, 1280, 1287, 978, 979, 1148, 979, 979, 1091,
  1380, 1287, 1279, 1279, 1279, 1284, 1284, 1287, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 1, 4, 5, 6, 4, 4,
  7, 8, 9, 10, 11, 12, 13, 14, 15, 4, 4, 4, 4, 4, 15, 4, 15, 15, 15, 15, 15, 15, 15, 15, 4, 4, 4, 4, 4, 4, 15, 15, 16,
  4, 4, 17, 18, 19, 4, 20, 21, 21, 21, 21, 21, 21, 4, 21, 4, 21, 21, 21, 22, 23, 24, 4, 21, 4, 4, 4, 4, 4, 21, 21, 21,
  21, 21, 21, 4, 25, 26, 27, 28, 29, 30, 31, 32, 33, 21, 34, 35, 36, 37, 38, 39, 21, 40, 41, 42, 43, 44, 45, 46, 47, 21,
  48, 49, 50, 51, 4, 4, 4, 4, 4, 15, 4, 21, 4, 21, 21, 4, 21, 21, 4, 21, 21, 21, 21, 21, 4, 21, 21, 21, 21, 21, 4, 15,
  15, 15, 15, 4, 15, 15, 15, 4, 15, 15, 15, 4, 4, 21, 21, 21, 21, 21, 4, 4, 21, 21, 21, 4, 4, 21, 21, 4, 4, 4, 4, 15,
  15, 15, 21, 21, 21, 21, 21, 21, 21, 15, 15, 21, 21, 21, 15, 15, 15, 15, 15, 15, 21, 21, 21, 21, 4, 21, 15, 15, 4, 15,
  15, 15, 15, 15, 4, 4, 15, 15, 15, 15, 15, 15, 15, 21, 21, 15, 15, 4, 4, 15, 15, 15, 4, 4, 4, 4, 15, 21, 21, 4, 4, 15,
  21, 15, 15, 4, 15, 15, 21, 4, 4, 4, 4, 4, 15, 15, 4, 4, 15, 15, 4, 21, 21, 21, 21, 4, 21, 4, 4, 4, 21, 21, 4, 4, 4,
  21, 21, 4, 4, 15, 4, 15, 15, 15, 15, 4, 4, 4, 15, 15, 4, 4, 4, 4, 21, 21, 4, 21, 4, 4, 21, 4, 4, 15, 4, 4, 21, 21, 21,
  4, 21, 21, 4, 21, 21, 21, 21, 4, 21, 4, 21, 21, 15, 15, 21, 21, 21, 4, 4, 4, 4, 21, 21, 4, 21, 21, 4, 21, 21, 21, 21,
  21, 21, 21, 21, 4, 4, 4, 4, 4, 4, 4, 4, 15, 15, 4, 21, 21, 21, 4, 4, 4, 21, 21, 4, 4, 21, 4, 4, 21, 21, 4, 21, 4, 21,
  21, 21, 21, 4, 4, 21, 15, 21, 21, 15, 15, 15, 15, 15, 15, 4, 15, 15, 21, 4, 21, 4, 4, 21, 4, 4, 21, 21, 4, 21, 21, 21,
  4, 21, 4, 21, 4, 21, 4, 4, 21, 21, 4, 21, 21, 4, 4, 21, 21, 21, 21, 21, 4, 21, 21, 21, 21, 21, 4, 15, 4, 4, 4, 4, 15,
  15, 4, 15, 4, 4, 4, 4, 4, 4, 21, 15, 4, 4, 4, 4, 21, 4, 21, 4, 21, 4, 21, 4, 4, 4, 21, 4, 4, 4, 4, 4, 4, 4, 21, 4, 21,
  21, 21, 4, 15, 15, 15, 4, 21, 21, 21
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 4, 4
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 3392, 3392, 3410, 10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464,
  4464, 4094, 3575, 4016, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743,
  10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 3392, 3392, 3394, 3744, 3734,
  4464, 4464, 3428, 4465, 3562, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125,
  3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 3392, 3392, 3410, 10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970,
  3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729,
  6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 3855, 10060, 10021, 4464, 4464, 3974, 4096, 3444,
  4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500,
  4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 3593, 3899, 3912,
  3618, 10021, 4464, 4464, 3974, 3777, 3662, 4464, 4464, 4464, 4094, 3575, 4668, 3970, 3577, 4464, 3965, 4464, 3675,
  4095, 4125, 3484, 3479, 7093, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 3691, 3704, 3720, 10060, 3766, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575,
  4820, 3970, 3577, 4464, 3965, 4464, 3750, 3776, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100,
  4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5060, 3793, 3808, 10060, 10021, 4464, 4464, 3974,
  4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866,
  3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 3846,
  6325, 6338, 3871, 10021, 4464, 4464, 3974, 4096, 3928, 4464, 4464, 4464, 4094, 3575, 3457, 3970, 3577, 4464, 3965,
  4464, 3941, 4095, 4125, 3484, 3479, 6265, 3957, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 3885, 3990, 10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464,
  4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086,
  10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 4168, 4032, 4047, 10060, 10021, 4464,
  4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484,
  3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8703, 6280, 6295, 10060, 10021, 4464, 4464, 3974, 4096, 4112, 4464, 4464, 4464, 3425, 3575, 10032, 3970, 3577,
  4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310,
  4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 4699, 4714, 10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464,
  4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005,
  4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 6235, 6250, 10060,
  10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095,
  4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 4158, 4184, 4192, 5033, 4208, 4941, 8321, 9242, 4328, 4246, 4941, 5472, 5735, 6095, 5731, 9756,
  4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 5931, 4881, 5471, 5736, 7944, 8240, 9193, 5520, 7565,
  9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 3602, 5033, 4208, 4941, 8321, 9242, 4328,
  4246, 4941, 5472, 5735, 6095, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 5931, 4881,
  5471, 5736, 7944, 8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  3855, 4344, 4360, 4482, 4411, 3830, 4096, 4397, 4482, 3530, 10104, 4439, 4089, 4915, 3526, 4372, 4463, 4423, 4447,
  4142, 4481, 4539, 4568, 4076, 4498, 4529, 4555, 4062, 4612, 3513, 4381, 3823, 4584, 4628, 4684, 4598, 4759, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 4775, 4788, 4793, 10060, 4809, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094,
  3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095,
  10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8713, 4836, 4851, 10060, 4904, 4464, 4464,
  3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479,
  4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 7063, 7078, 10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464,
  3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642,
  3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159, 6146, 4208, 4941, 8321, 9242, 4328, 4957, 4941, 5472,
  5735, 4986, 5731, 5005, 9160, 7810, 9376, 5523, 5926, 5430, 4940, 5471, 5734, 7943, 5931, 4881, 5471, 5736, 7944,
  8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159, 6146, 4208,
  4941, 8321, 9242, 4328, 4957, 4941, 5472, 5735, 4986, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471,
  5734, 7943, 5931, 4881, 5471, 5736, 7944, 8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 5049, 5076, 5091, 10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970,
  3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729,
  6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5107, 5119, 5129, 10060, 10021, 4464, 4464, 3974, 4096, 3444,
  4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500,
  4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5145,
  10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750,
  4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 5161, 5177, 5192, 5241, 5257, 5284, 6989, 5300, 5829, 5340, 5382, 7187, 5369, 5410, 5446,
  9756, 5468, 4941, 7436, 5488, 5726, 5430, 4940, 5471, 5734, 7943, 9845, 7108, 4219, 5513, 5719, 5539, 6521, 5555,
  5584, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159, 6146, 4208, 4941, 8321, 9242,
  4328, 4957, 4941, 5472, 5735, 4986, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 4290,
  5631, 8635, 8459, 7944, 8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019,
  4931, 7159, 6146, 4208, 4941, 8321, 9242, 8298, 5655, 9267, 5472, 5692, 5708, 5731, 9756, 4941, 4941, 4327, 5523,
  5726, 5430, 4940, 5471, 5734, 7943, 5931, 4881, 5471, 5736, 7944, 8240, 9193, 5520, 6837, 6560, 7728, 7128, 4275,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 5752, 5768, 5783, 6146, 4208, 4941, 8321, 9242, 4328, 4957, 4941, 5472, 5735,
  4986, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 5814, 5845, 5324, 7174, 9625, 9578, 5869, 9517, 5736, 6650, 8240,
  9193, 5520, 7565, 9195, 6005, 7128, 5911, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5947, 5963, 5978, 6021, 6037, 7971,
  6080, 6113, 6143, 4957, 6162, 6181, 5735, 6197, 9049, 6220, 8198, 6354, 6403, 6446, 6484, 5430, 4940, 9364, 6508,
  6537, 5931, 4881, 5471, 5736, 7944, 9471, 6558, 8171, 7867, 8259, 6576, 6592, 4275, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 5019, 4931, 7159, 6146, 4208, 4941, 8321, 9242, 6608, 6624, 4941, 9549, 7440, 6640, 5731, 9756, 4941, 4941,
  4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 5931, 4881, 5471, 5736, 7944, 8240, 9193, 5520, 7565, 9195, 6005,
  7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 6673, 6689, 6704, 6146, 4208, 4941, 8321, 9242, 4328, 4957, 4941,
  5472, 5735, 4986, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 5568, 6745, 5853, 8268,
  4989, 8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159, 6146,
  4208, 4941, 8321, 9242, 8606, 6768, 5394, 5472, 6809, 6825, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940,
  5471, 5734, 7943, 5931, 4881, 5471, 5736, 7944, 8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 6853, 6869, 6884, 6915, 6931, 6975, 6959, 7005, 4328, 4957, 4941, 5472, 5735, 4986, 5731, 7048,
  4941, 7144, 9529, 5523, 5606, 5430, 7213, 7232, 5734, 7272, 8962, 7300, 5471, 7929, 5497, 8240, 9193, 5520, 7565,
  9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159, 6146, 4208, 4941, 8321, 9242, 8747,
  7330, 9300, 7314, 5452, 4986, 5222, 9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 5931, 4881,
  5471, 5736, 7944, 8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 7359, 7375,
  7390, 8442, 7421, 5639, 5271, 7456, 4328, 4957, 4941, 5472, 5735, 4986, 8817, 8829, 8250, 9297, 4327, 8340, 5726,
  7486, 7517, 7981, 7019, 8518, 8532, 4513, 8772, 8035, 7554, 8240, 9193, 5520, 7284, 6781, 5353, 7128, 4275, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 7592, 7608, 7623, 8933, 7662, 5676, 6051, 7701, 6387, 7744, 9669, 5472, 9708, 7773,
  9745, 9756, 5668, 7529, 6379, 7576, 6657, 5430, 7803, 8368, 7826, 7855, 5931, 4881, 5471, 5736, 7944, 8240, 9193,
  5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 7883, 7899, 7914, 5798, 7960, 7997, 7197,
  8021, 4328, 4957, 4941, 5472, 5735, 4986, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 8065, 8108, 7538, 7685, 8049,
  8124, 4305, 6367, 8164, 6461, 8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  5019, 4931, 7159, 5615, 8187, 7032, 8214, 8284, 4328, 4957, 4941, 5472, 5735, 4986, 5731, 9756, 4941, 4941, 4327,
  5523, 5726, 5430, 4940, 5471, 5734, 7943, 5931, 4881, 5471, 5736, 7944, 6719, 8314, 8337, 8356, 9195, 6005, 7128,
  4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8396, 8412, 8427, 6146, 4208, 4941, 8321, 9242, 9111, 4957, 9157, 9190,
  8458, 8475, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 8871, 8503, 5471, 5207, 6204,
  8548, 4888, 8080, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159, 7405, 8576,
  6752, 4230, 8592, 8672, 8622, 9416, 8148, 6417, 8651, 8667, 8688, 8729, 7839, 8745, 5595, 8487, 5895, 8763, 5882,
  8788, 8804, 5931, 4881, 5471, 5736, 7944, 8845, 8560, 9716, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8887, 8903, 8918, 6146, 4208, 4941, 8321, 9242, 7470, 4957, 7307, 7120, 7638, 8949, 5731, 9756, 4941,
  4941, 4327, 5523, 5726, 8978, 9009, 5471, 7715, 9036, 5931, 4881, 5471, 5736, 7944, 8240, 9193, 5520, 7565, 9195,
  4259, 8858, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 9065, 9081, 9096, 9127, 9143, 9660, 9176, 9211, 7501, 9227,
  6064, 7757, 9283, 9316, 9461, 9756, 9649, 9020, 8380, 7256, 5420, 6793, 9350, 6165, 9334, 9392, 5931, 4881, 9678,
  7246, 6542, 5314, 6430, 6899, 8092, 7677, 7343, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159,
  6146, 4208, 4941, 8321, 9242, 4328, 4957, 4941, 5472, 5735, 4986, 5731, 9756, 4941, 4941, 4327, 5523, 9868, 9816,
  9408, 9432, 5225, 9448, 5931, 4881, 5471, 5736, 6097, 9256, 9806, 7646, 7565, 9195, 6005, 7128, 4275, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 5019, 4931, 7159, 6146, 4208, 4941, 8321, 9242, 9487, 9503, 9545, 9776, 5735, 9565, 5731,
  9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 5931, 4881, 5471, 5736, 7944, 8240, 9193, 5520,
  7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159, 6146, 4208, 4941, 8321, 9242,
  4328, 4957, 4941, 5472, 5735, 4986, 5731, 9756, 4941, 4941, 4327, 5523, 5726, 5430, 4940, 5471, 5734, 7943, 5931,
  4881, 5471, 5736, 7944, 8240, 9193, 5520, 9637, 9594, 4970, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 5019,
  4931, 7159, 8993, 9610, 8005, 6945, 9694, 6127, 4957, 6729, 4316, 5993, 9732, 9331, 9756, 4941, 4941, 4327, 5523,
  5726, 5430, 4940, 5471, 5734, 7943, 5931, 4881, 5471, 5736, 7944, 8240, 9193, 5520, 7565, 9195, 6005, 7128, 4275,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 5019, 4931, 7159, 6146, 4208, 4941, 8321, 9242, 4328, 4957, 4941, 5472, 5735,
  4986, 5731, 9756, 4941, 4941, 4327, 5523, 6468, 5430, 9772, 8227, 9792, 9832, 7787, 8139, 7216, 6492, 9861, 8240,
  9193, 5520, 7565, 9195, 6005, 7128, 4275, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 9884, 9914, 9898, 10060, 10021, 4464,
  4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484,
  3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 3632, 9930, 9945, 10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577,
  4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310,
  4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 9961, 9976, 10060, 10021, 4464, 4464, 3974, 4096, 3444, 4464,
  4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4866, 3473, 3500, 4005,
  4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 3646, 10060,
  10021, 4464, 4464, 3974, 4096, 3444, 4464, 4464, 4464, 4094, 3575, 10032, 3970, 3577, 4464, 3965, 4464, 3750, 4095,
  4125, 3484, 3479, 4866, 3473, 3500, 4005, 4743, 10086, 10095, 10100, 4656, 4729, 6310, 4642, 3546, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 9992, 10007, 3744, 3734, 4464, 4464, 3428, 4465, 10048, 4464, 4464, 4464, 4094, 3575, 10032,
  3970, 3577, 4464, 3965, 4464, 3750, 4095, 4125, 3484, 3479, 4135, 10076, 3500, 4005, 4743, 10086, 10095, 10100, 4656,
  4729, 6310, 4642, 3546, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711,
  8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 8711, 2094, 2094, 2094, 2094, 2094, 2094, 2094, 2094, 2094,
  2094, 2094, 2094, 2094, 2094, 2094, 2094, 0, 68608, 2094, 2094, 2094, 2094, 2094, 2094, 2094, 2094, 2094, 2094, 2094,
  2094, 2094, 2094, 2174, 68608, 5120, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 0, 68608, 68608, 0, 146, 0, 0, 0, 0, 68608, 68608, 0, 0, 0, 68608, 6301, 68608, 68608, 68608,
  68608, 68608, 344, 346, 0, 0, 91136, 68608, 0, 0, 0, 68608, 0, 247, 0, 0, 103424, 0, 106496, 68608, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 68608, 98304, 68608, 68608, 68608, 68608, 68608, 105472, 68608, 68608,
  68608, 68608, 103424, 68608, 68608, 68608, 68608, 93184, 68608, 68608, 99328, 68608, 68608, 68608, 106496, 68608,
  68608, 68608, 68608, 68608, 68608, 0, 0, 104601, 68608, 68761, 68761, 68761, 68761, 68761, 68761, 91289, 68761, 68761,
  68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68608, 68608, 68608, 68608, 100352, 88064,
  68608, 88064, 89088, 100352, 68608, 89088, 100352, 88064, 89088, 100352, 68608, 101376, 101376, 101376, 0, 0, 0, 0, 0,
  0, 68608, 68608, 0, 0, 0, 68608, 256, 68608, 68608, 68608, 68608, 68608, 68608, 0, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 0, 61, 0, 0, 0, 0, 0, 0, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2174,
  48, 0, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 7313, 146, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46080, 0, 2174, 68608, 246, 146, 0, 0, 0, 0, 68608, 68608, 0,
  0, 0, 68608, 6301, 68608, 68608, 68608, 68608, 68608, 68608, 430, 431, 432, 432, 0, 0, 68608, 0, 0, 68608, 2095, 2095,
  2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2123, 2123, 2123, 2123, 2123,
  2095, 2095, 2123, 2095, 2123, 2123, 2123, 2123, 2123, 2095, 2123, 2095, 2095, 2095, 2095, 2123, 2095, 2123, 2123,
  2123, 2123, 0, 0, 68608, 68608, 0, 0, 0, 0, 0, 0, 68608, 0, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 0, 0, 0, 0, 0, 0, 68608, 0, 0, 68608, 0, 68608, 68608, 0, 0, 0, 0, 0, 0, 68608, 6301, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 7168, 71, 0, 0, 0,
  0, 0, 0, 0, 9216, 9287, 9216, 0, 9216, 0, 9216, 9216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9216, 0, 2174, 68608, 68608,
  102400, 104448, 68761, 68761, 68761, 68761, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818,
  68818, 68818, 2174, 68608, 68608, 0, 62, 0, 0, 0, 0, 0, 0, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2174, 68608,
  0, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 144, 7315, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 11264, 0, 11264, 0, 0, 0, 0, 0, 0, 0, 0, 61, 0, 0, 61, 0, 61, 0, 61, 0, 0, 0, 61, 0, 0, 61, 0, 61, 61, 0, 2174,
  68608, 0, 7168, 247, 0, 0, 0, 68608, 68608, 0, 0, 0, 68608, 6301, 68608, 68608, 68608, 68608, 68608, 68608, 431, 431,
  432, 433, 0, 0, 68608, 0, 0, 68608, 7168, 0, 0, 103424, 0, 106496, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 91136, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  2174, 68608, 68608, 0, 0, 11264, 0, 0, 0, 0, 0, 11264, 11264, 11264, 11264, 11264, 0, 2174, 68608, 93184, 68608,
  68608, 68608, 99328, 68608, 68608, 68608, 68608, 106496, 68608, 68608, 68608, 68608, 68608, 0, 0, 0, 0, 91136, 68608,
  0, 0, 0, 68608, 256, 0, 12288, 12288, 0, 0, 0, 0, 12288, 0, 0, 12288, 0, 12288, 0, 12288, 12288, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 12288, 0, 2174, 68608, 93184, 68608, 68608, 68608, 99328, 68608, 68608, 68608, 68608, 106496, 68761,
  68761, 68761, 68761, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 98514, 68818, 68818, 68818, 68818,
  68818, 68608, 68608, 68608, 0, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 144, 0, 146, 0, 0, 5120, 0, 68608, 68608, 0, 0, 0, 68608, 6301, 68608, 68608, 68608, 68608,
  68608, 68608, 98304, 68608, 68608, 68608, 68608, 105472, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 0, 0, 0, 0, 0, 0, 68608, 153, 153, 68608, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 16384, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 12288, 0, 0, 0, 16384, 0, 0, 0, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2174, 48,
  0, 48, 48, 68, 68, 68, 0, 0, 0, 48, 2174, 76, 76, 76, 76, 76, 76, 76, 518, 76, 76, 76, 76, 76, 48, 48, 48, 195, 48,
  48, 48, 48, 48, 48, 48, 76, 76, 76, 0, 146, 0, 0, 0, 0, 48, 48, 0, 68, 68, 48, 6301, 76, 76, 76, 76, 114, 114, 114,
  114, 114, 114, 114, 114, 114, 114, 231, 0, 0, 76, 76, 48, 48, 48, 48, 76, 76, 114, 114, 114, 114, 76, 48, 114, 114,
  114, 496, 48, 48, 48, 48, 48, 48, 48, 48, 48, 246, 246, 247, 0, 0, 48, 68, 68, 48, 76, 76, 76, 509, 76, 76, 76, 76,
  76, 76, 283, 76, 76, 76, 288, 76, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 144, 0, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 144, 146, 0, 149, 0, 68608, 68608, 153, 153, 153, 0, 0,
  0, 68608, 2174, 68761, 68761, 68761, 68761, 68761, 153, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761,
  68761, 68761, 102553, 104601, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 0, 146, 0, 0, 0, 0, 68608, 68608, 0,
  153, 153, 68608, 6301, 68761, 68761, 68761, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  68608, 68761, 68761, 68761, 68761, 68818, 68818, 68818, 91346, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68761,
  0, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68818, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 68761, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 0, 0, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761,
  68761, 68761, 68761, 68761, 68761, 68761, 68818, 105682, 68818, 68608, 68608, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 246, 246, 247, 0, 0, 48, 68, 68, 48, 76, 76, 267, 76, 76, 76, 76, 76, 513, 247, 0, 0, 103424,
  153, 106649, 68608, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 68761, 98457, 68761, 68761, 68761, 68761,
  105625, 68761, 68608, 68608, 68608, 103577, 68761, 68761, 68761, 68761, 93337, 68761, 68761, 99481, 68761, 68761,
  68761, 106649, 68608, 68608, 68608, 68608, 68608, 98304, 68608, 68608, 68608, 68608, 68608, 105472, 68608, 68761,
  68761, 68761, 68818, 68818, 102610, 104658, 68608, 68608, 68608, 68608, 68608, 0, 97280, 96256, 68761, 68761, 68761,
  68761, 94361, 68761, 68608, 68608, 94208, 68608, 68608, 68761, 68761, 68818, 68818, 94418, 68818, 68818, 68818, 93394,
  68818, 68818, 68818, 68818, 99538, 68818, 68818, 68818, 103634, 68818, 106706, 68608, 68761, 96409, 68761, 92313,
  68761, 95385, 68761, 68608, 68608, 90112, 92160, 68608, 95232, 97280, 68608, 68608, 94208, 68608, 68608, 68608, 94208,
  68608, 68608, 68608, 68608, 68608, 68608, 94208, 68608, 68608, 102400, 104448, 68608, 68608, 68608, 68608, 68608, 0,
  97280, 96256, 68608, 68608, 68608, 68608, 68608, 343, 345, 0, 0, 91136, 68608, 0, 0, 0, 68608, 0, 68761, 90265, 97433,
  68761, 68818, 68818, 90322, 92370, 68818, 95442, 96466, 97490, 68818, 68818, 68608, 0, 0, 0, 0, 0, 0, 0, 0, 14336,
  14336, 0, 0, 14336, 0, 14336, 14336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14336, 0, 2174, 68608, 96256, 68608, 92160,
  68608, 95232, 68608, 68608, 68608, 90112, 92160, 68608, 95232, 97280, 68608, 68608, 68608, 93184, 68608, 68608, 68608,
  68608, 99328, 68608, 68608, 68608, 103424, 68608, 106496, 68608, 100352, 88217, 68761, 88064, 89088, 100352, 68608,
  89241, 100505, 88274, 89298, 100562, 68818, 101529, 101376, 101586, 0, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 17408, 0, 0,
  17408, 0, 0, 0, 0, 0, 0, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2174, 68608, 0, 68608, 68608, 0, 0, 0, 10240, 44032,
  0, 68608, 2174, 68608, 68608, 68608, 68608, 68608, 0, 0, 0, 0, 91136, 68608, 0, 0, 0, 68608, 353, 0, 73, 73, 0, 0, 0,
  0, 73, 73, 73, 73, 0, 73, 0, 73, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 73, 0, 2174, 68608, 105472, 68608, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 246, 246, 247, 0, 0, 48, 68, 68, 48, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 48, 569, 48, 48, 48, 48, 48, 0, 68608, 68608, 0, 0, 0, 0, 0, 18432, 68608, 2174, 68608, 68608, 68608,
  68608, 68608, 0, 0, 0, 0, 91136, 68608, 0, 153, 153, 68608, 0, 0, 0, 0, 76, 76, 76, 76, 76, 0, 0, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 0, 146, 0, 0, 0, 0, 48, 48, 4348, 68, 68, 48, 6301, 76, 76, 76, 76, 114,
  114, 114, 114, 114, 114, 114, 114, 114, 608, 48, 0, 76, 4348, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
  114, 114, 114, 548, 114, 48, 339, 48, 48, 48, 48, 0, 0, 0, 0, 48, 48, 4348, 68, 68, 48, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0,
  48, 68, 0, 0, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 144, 146, 0, 64, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 20480, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 20480, 0, 0, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 0,
  20480, 20480, 20480, 20480, 0, 20480, 0, 0, 0, 0, 20480, 0, 20480, 20480, 20480, 20480, 0, 2174, 68608, 49, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 49, 0, 0, 0, 49, 49, 49, 49, 49, 0, 0, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 0,
  2174, 68608, 0, 0, 0, 0, 0, 21504, 21504, 0, 0, 0, 0, 0, 21504, 0, 2174, 68608, 50, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 50,
  68, 0, 0, 50, 0, 0, 0, 77, 77, 77, 77, 77, 0, 0, 77, 89, 77, 89, 77, 77, 99, 89, 89, 99, 89, 89, 99, 115, 89, 115,
  115, 89, 0, 2174, 48, 48, 48, 48, 48, 48, 529, 48, 48, 48, 48, 76, 76, 76, 536, 114, 114, 328, 48, 48, 48, 48, 48, 48,
  48, 48, 48, 48, 48, 48, 48, 76, 477, 76, 48, 48, 128, 48, 48, 48, 48, 48, 138, 140, 48, 48, 144, 146, 148, 64, 0, 128,
  48, 68, 68, 68, 0, 0, 0, 48, 2174, 76, 76, 159, 76, 76, 48, 48, 192, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76, 76, 169,
  171, 76, 76, 76, 76, 159, 76, 76, 76, 76, 169, 185, 209, 114, 114, 212, 114, 114, 114, 114, 114, 222, 224, 114, 114,
  2174, 48, 48, 48, 48, 48, 48, 0, 555, 68, 48, 76, 76, 76, 76, 76, 76, 76, 457, 76, 76, 76, 76, 76, 48, 48, 48, 0, 146,
  0, 0, 0, 0, 48, 251, 4348, 68, 68, 48, 6301, 76, 76, 76, 76, 114, 114, 114, 114, 606, 114, 114, 114, 114, 114, 48, 0,
  48, 48, 296, 48, 48, 48, 48, 48, 48, 251, 48, 48, 272, 76, 76, 76, 76, 264, 76, 76, 76, 76, 76, 76, 272, 76, 76, 76,
  76, 76, 266, 76, 76, 76, 76, 76, 76, 76, 76, 266, 76, 76, 4348, 114, 114, 114, 114, 114, 114, 114, 317, 114, 114, 114,
  114, 114, 114, 418, 114, 48, 421, 48, 48, 48, 48, 48, 48, 0, 0, 0, 0, 0, 0, 48, 68, 68, 48, 325, 114, 114, 48, 330,
  331, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 305, 76, 76, 76, 76, 76, 355, 356, 76, 76, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 76, 48, 48, 48, 48, 48, 398, 399, 76, 76, 114, 403, 404, 114, 114, 114, 114, 114, 114, 114, 114, 544,
  114, 114, 114, 114, 114, 114, 114, 48, 48, 48, 48, 527, 48, 48, 48, 48, 48, 48, 48, 76, 76, 76, 76, 114, 114, 114,
  114, 114, 114, 114, 114, 114, 114, 114, 48, 551, 48, 48, 552, 48, 554, 0, 68, 48, 76, 76, 559, 76, 76, 560, 575, 48,
  48, 48, 76, 76, 76, 580, 114, 114, 114, 114, 585, 114, 114, 114, 48, 48, 48, 48, 48, 48, 48, 48, 48, 231, 246, 246,
  247, 589, 114, 114, 114, 48, 48, 48, 48, 48, 0, 0, 48, 76, 76, 76, 76, 402, 114, 114, 114, 114, 114, 114, 114, 114,
  114, 114, 417, 114, 114, 420, 48, 48, 48, 48, 48, 48, 48, 48, 139, 48, 48, 143, 144, 146, 0, 64, 247, 0, 0, 48, 68,
  68, 48, 507, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 178, 76, 76, 76, 76, 76, 0, 146, 0, 0, 0, 0, 48, 48, 4348, 68,
  68, 255, 6301, 76, 76, 76, 76, 271, 76, 76, 359, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 179, 76, 76, 76, 76, 76, 48,
  48, 48, 255, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76, 76, 275, 76, 4348, 114, 114, 114, 114, 114, 114, 114, 114, 318,
  114, 114, 114, 114, 114, 542, 114, 114, 114, 114, 114, 114, 114, 114, 114, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
  48, 48, 76, 76, 76, 76, 114, 51, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 66, 68, 0, 0, 66, 0, 0, 0, 78, 78, 78, 78, 78, 0, 0,
  78, 90, 78, 90, 78, 78, 100, 78, 111, 100, 111, 111, 100, 116, 111, 116, 116, 111, 0, 2174, 48, 48, 48, 48, 48, 135,
  48, 48, 48, 48, 48, 48, 144, 146, 0, 64, 231, 48, 48, 48, 48, 48, 0, 0, 0, 0, 0, 0, 48, 68, 68, 48, 48, 48, 48, 48,
  235, 48, 48, 48, 48, 48, 48, 243, 48, 48, 144, 0, 76, 76, 76, 76, 76, 76, 76, 76, 277, 76, 76, 76, 76, 76, 76, 76, 76,
  76, 521, 76, 48, 48, 48, 247, 0, 0, 48, 68, 68, 506, 76, 76, 76, 76, 76, 511, 76, 76, 76, 76, 455, 76, 76, 76, 76, 76,
  76, 76, 76, 48, 48, 48, 48, 48, 48, 0, 0, 0, 0, 0, 435, 48, 68, 68, 48, 0, 76, 622, 48, 48, 48, 623, 76, 76, 114, 114,
  114, 624, 76, 48, 114, 114, 414, 114, 114, 114, 114, 114, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 246, 246, 247, 52,
  0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 52, 68, 0, 0, 52, 0, 0, 0, 79, 79, 79, 79, 79, 0, 0, 79, 91, 79, 91, 79, 79, 101, 91,
  91, 101, 91, 91, 101, 117, 91, 117, 117, 91, 0, 2174, 48, 48, 48, 48, 48, 299, 48, 48, 48, 48, 304, 48, 76, 76, 76,
  76, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 48, 0, 48, 48, 129, 48, 48, 48, 48, 48, 48, 48, 48, 142, 144,
  146, 0, 64, 0, 129, 48, 68, 68, 68, 0, 0, 0, 48, 2174, 76, 76, 160, 76, 76, 48, 48, 193, 48, 48, 48, 48, 48, 48, 48,
  48, 76, 76, 76, 263, 76, 76, 76, 76, 76, 270, 76, 76, 76, 76, 76, 276, 76, 187, 48, 191, 48, 48, 48, 48, 48, 48, 48,
  48, 203, 76, 207, 76, 0, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 549, 76, 114, 114,
  213, 114, 114, 114, 114, 114, 114, 114, 114, 226, 2174, 48, 48, 48, 48, 48, 48, 48, 48, 239, 48, 48, 48, 48, 238, 48,
  144, 48, 48, 232, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 144, 146, 0, 64, 76, 261, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 76, 76, 76, 76, 48, 463, 48, 76, 278, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 48, 48, 48, 293, 76,
  4348, 114, 114, 114, 114, 314, 114, 114, 114, 114, 114, 114, 114, 114, 114, 545, 114, 114, 114, 114, 114, 48, 48, 340,
  48, 48, 342, 0, 0, 347, 348, 48, 48, 4348, 68, 351, 48, 0, 0, 0, 0, 0, 0, 0, 0, 15360, 15360, 15360, 0, 15360, 0,
  15360, 15360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15360, 0, 2174, 68608, 105472, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 246, 246, 0, 0, 0, 0, 0, 0, 0, 0, 13312, 13312, 0, 0, 13312, 0, 13312,
  13312, 0, 0, 0, 0, 0, 0, 0, 13312, 0, 13312, 13312, 13312, 0, 2174, 68608, 90112, 97280, 68608, 68608, 68608, 90112,
  92160, 68608, 95232, 96256, 97280, 68608, 68608, 68608, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 62, 0, 62, 0, 62, 0, 0, 0,
  62, 0, 0, 62, 0, 62, 62, 0, 2174, 68608, 76, 368, 76, 76, 76, 76, 76, 373, 76, 76, 376, 76, 378, 76, 76, 76, 76, 516,
  76, 517, 76, 76, 76, 76, 76, 76, 48, 48, 48, 385, 48, 48, 388, 48, 48, 48, 48, 48, 48, 48, 48, 48, 240, 48, 48, 48,
  48, 48, 144, 381, 48, 48, 48, 48, 48, 387, 48, 389, 48, 391, 392, 48, 394, 48, 48, 48, 48, 48, 48, 48, 48, 302, 303,
  48, 48, 287, 76, 76, 76, 564, 76, 76, 76, 76, 76, 48, 48, 570, 571, 48, 48, 574, 397, 76, 76, 400, 401, 114, 114, 114,
  114, 114, 114, 407, 114, 114, 410, 114, 114, 540, 114, 541, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 48, 48,
  48, 231, 48, 48, 48, 48, 412, 413, 114, 415, 114, 114, 114, 419, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 533, 76,
  76, 76, 114, 465, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76, 76, 76, 565, 76, 76, 76, 76, 48, 48, 48, 48,
  572, 48, 48, 76, 114, 114, 114, 483, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 547, 114, 114, 114, 48,
  76, 562, 76, 76, 76, 76, 76, 76, 76, 48, 48, 48, 48, 48, 48, 48, 600, 48, 602, 76, 76, 76, 114, 605, 114, 114, 114,
  114, 114, 114, 114, 114, 48, 609, 76, 610, 76, 611, 612, 48, 48, 614, 615, 76, 617, 618, 114, 114, 620, 621, 230, 48,
  48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 144, 0, 146, 0, 0, 0, 0, 48, 48, 4348, 68, 68, 48, 6301, 76, 76,
  259, 76, 4348, 114, 114, 312, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 543, 114, 114, 114, 114, 114,
  114, 114, 114, 48, 48, 48, 48, 48, 424, 48, 48, 53, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 53, 68, 0, 0, 53, 0, 0, 0, 80, 80,
  80, 80, 80, 0, 0, 80, 92, 80, 92, 80, 80, 102, 92, 92, 102, 92, 92, 102, 118, 92, 118, 118, 92, 0, 2174, 48, 48, 48,
  48, 48, 553, 0, 0, 68, 48, 76, 76, 76, 76, 76, 76, 76, 268, 76, 76, 76, 76, 267, 76, 76, 76, 247, 0, 0, 48, 505, 68,
  48, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 181, 76, 76, 76, 76, 0, 146, 0, 0, 0, 249, 48, 48, 4348, 68, 68, 237,
  6301, 76, 76, 76, 76, 595, 76, 76, 48, 48, 48, 48, 599, 48, 48, 48, 48, 48, 48, 0, 0, 0, 0, 0, 0, 436, 68, 68, 48, 48,
  48, 48, 297, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76, 76, 308, 76, 4348, 114, 114, 114, 114, 114, 114, 114, 114, 319,
  114, 114, 114, 114, 114, 48, 48, 48, 500, 48, 592, 0, 48, 76, 76, 76, 511, 54, 0, 0, 0, 0, 0, 0, 64, 65, 0, 0, 54, 68,
  0, 0, 74, 0, 0, 0, 81, 88, 88, 88, 88, 0, 0, 88, 81, 88, 81, 88, 88, 103, 88, 112, 103, 112, 112, 103, 119, 88, 119,
  119, 112, 0, 2174, 48, 48, 48, 48, 76, 578, 579, 76, 114, 114, 583, 584, 114, 114, 114, 588, 48, 48, 130, 48, 48, 48,
  136, 137, 48, 48, 48, 48, 144, 146, 0, 64, 0, 151, 48, 68, 68, 68, 0, 0, 0, 48, 2174, 76, 76, 161, 76, 76, 48, 48,
  194, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76, 76, 48, 151, 48, 48, 48, 197, 198, 48, 48, 48, 48, 76, 161, 76, 76, 167,
  168, 76, 76, 76, 76, 76, 76, 177, 76, 76, 182, 183, 76, 76, 48, 190, 48, 48, 48, 48, 48, 199, 201, 48, 48, 76, 206,
  76, 76, 114, 114, 214, 114, 114, 114, 220, 221, 114, 114, 114, 114, 2174, 48, 48, 48, 48, 48, 48, 48, 48, 472, 48, 48,
  48, 48, 76, 76, 76, 170, 76, 76, 174, 76, 76, 76, 76, 76, 76, 76, 184, 76, 48, 48, 48, 341, 48, 0, 0, 0, 0, 48, 48,
  4348, 350, 68, 48, 0, 0, 0, 0, 0, 0, 0, 0, 19456, 19456, 0, 0, 19456, 0, 19456, 19456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 19456, 0, 2174, 68608, 105472, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 7168,
  0, 247, 0, 0, 48, 68, 68, 48, 76, 76, 76, 76, 510, 76, 76, 76, 76, 76, 282, 76, 76, 76, 76, 76, 76, 48, 48, 48, 48,
  48, 76, 76, 114, 114, 114, 114, 114, 367, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 379, 76, 48, 76, 76, 48,
  76, 76, 48, 114, 76, 114, 114, 76, 0, 2174, 48, 48, 48, 48, 48, 48, 470, 48, 48, 48, 48, 48, 48, 76, 76, 76, 76, 281,
  76, 76, 76, 76, 286, 76, 76, 48, 48, 48, 48, 196, 48, 48, 48, 48, 48, 48, 76, 76, 208, 0, 440, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 76, 76, 76, 76, 48, 523, 48, 76, 452, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 462, 48, 48, 48, 48,
  48, 48, 48, 48, 531, 48, 48, 76, 76, 76, 76, 114, 114, 114, 114, 114, 406, 114, 114, 114, 114, 411, 76, 480, 114, 114,
  114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 48, 48, 231, 48, 48, 0, 0, 48, 76, 76, 277, 76, 247, 0,
  504, 48, 68, 68, 48, 76, 76, 76, 76, 76, 76, 267, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 289, 48, 48, 48, 48, 0,
  146, 0, 0, 0, 0, 48, 48, 4348, 68, 254, 48, 6301, 76, 76, 76, 76, 604, 114, 114, 114, 114, 114, 114, 114, 114, 114,
  48, 0, 55, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 55, 68, 0, 0, 55, 0, 0, 0, 82, 82, 82, 82, 82, 0, 0, 82, 93, 82, 93, 82, 82,
  104, 93, 93, 104, 93, 93, 104, 120, 93, 120, 120, 93, 0, 2174, 48, 48, 48, 48, 134, 48, 48, 48, 48, 48, 48, 48, 144,
  146, 0, 64, 0, 48, 48, 68, 68, 68, 0, 0, 0, 48, 2174, 76, 76, 76, 162, 76, 48, 383, 384, 48, 48, 48, 48, 48, 48, 48,
  48, 48, 48, 48, 48, 76, 76, 307, 76, 76, 114, 114, 114, 215, 114, 114, 114, 114, 114, 114, 114, 114, 2174, 48, 48, 48,
  48, 48, 48, 48, 238, 48, 48, 48, 48, 48, 48, 48, 144, 48, 48, 428, 48, 48, 48, 0, 0, 0, 0, 0, 0, 48, 68, 68, 48, 48,
  48, 48, 234, 48, 48, 48, 48, 48, 241, 48, 48, 48, 48, 144, 0, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 448, 76, 76, 76,
  76, 76, 371, 76, 76, 374, 76, 76, 76, 76, 76, 76, 76, 76, 76, 459, 460, 76, 461, 48, 48, 48, 114, 539, 114, 114, 114,
  114, 114, 114, 114, 114, 546, 114, 114, 114, 114, 48, 48, 48, 48, 48, 0, 0, 48, 76, 76, 76, 76, 114, 114, 114, 114,
  405, 114, 114, 408, 114, 114, 114, 56, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 56, 68, 0, 0, 56, 0, 0, 0, 83, 83, 83, 83, 83,
  0, 0, 83, 94, 83, 94, 83, 83, 105, 94, 94, 105, 94, 94, 105, 121, 94, 121, 121, 94, 0, 2174, 48, 48, 48, 48, 298, 48,
  48, 48, 48, 48, 48, 48, 76, 76, 76, 76, 581, 114, 114, 114, 114, 114, 114, 114, 0, 48, 48, 68, 68, 68, 0, 0, 0, 48,
  2174, 76, 76, 76, 163, 76, 76, 594, 76, 76, 76, 76, 597, 48, 48, 48, 48, 48, 48, 48, 48, 48, 473, 474, 48, 475, 76,
  76, 76, 76, 114, 114, 114, 216, 114, 114, 114, 114, 114, 114, 114, 114, 2174, 48, 48, 48, 48, 48, 48, 48, 471, 48, 48,
  48, 48, 48, 76, 76, 76, 603, 114, 114, 114, 114, 114, 114, 114, 114, 607, 114, 48, 0, 0, 146, 0, 248, 0, 0, 48, 48,
  4348, 68, 68, 48, 6301, 76, 76, 76, 280, 76, 76, 76, 284, 76, 76, 76, 76, 290, 291, 48, 48, 309, 4348, 114, 114, 114,
  114, 114, 114, 114, 114, 114, 114, 114, 322, 114, 114, 114, 48, 497, 48, 48, 48, 48, 48, 48, 48, 48, 246, 246, 247, 0,
  76, 76, 76, 76, 76, 444, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 377, 76, 76, 76, 76, 48, 48, 48, 468, 48, 48, 48,
  48, 48, 48, 48, 48, 48, 76, 76, 76, 370, 76, 76, 76, 76, 76, 76, 76, 76, 76, 267, 76, 76, 76, 114, 114, 114, 114, 114,
  114, 486, 114, 114, 114, 114, 114, 114, 114, 114, 48, 591, 48, 48, 48, 0, 0, 48, 76, 593, 76, 76, 57, 0, 0, 0, 0, 63,
  0, 64, 0, 0, 0, 57, 68, 0, 0, 57, 0, 0, 0, 84, 84, 84, 84, 84, 0, 0, 84, 95, 84, 95, 84, 84, 106, 95, 113, 106, 113,
  113, 106, 122, 113, 122, 122, 113, 0, 2174, 48, 48, 48, 48, 528, 48, 48, 48, 48, 48, 48, 76, 76, 535, 76, 114, 114,
  114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 48, 150, 48, 48, 68, 68, 68, 0, 0, 0, 156, 2174, 76,
  76, 76, 76, 76, 76, 173, 76, 76, 160, 76, 76, 76, 76, 76, 76, 76, 76, 458, 76, 76, 76, 76, 48, 48, 48, 166, 76, 76,
  76, 76, 76, 76, 175, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 180, 76, 76, 76, 76, 76, 76, 114, 114, 114, 114, 114,
  219, 114, 114, 114, 114, 114, 114, 2174, 48, 48, 48, 48, 48, 48, 48, 530, 48, 48, 48, 76, 534, 76, 76, 114, 114, 114,
  114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 492, 114, 48, 48, 48, 238, 429, 231, 0, 0, 0, 0, 0, 0, 48, 437, 438,
  48, 48, 48, 48, 577, 76, 76, 76, 114, 582, 114, 114, 114, 114, 114, 114, 500, 48, 48, 48, 48, 0, 0, 48, 511, 76, 76,
  76, 0, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 267, 76, 450, 277, 494, 114, 495, 48, 48, 48, 498, 48, 48, 48, 48,
  48, 48, 246, 246, 247, 0, 0, 48, 68, 68, 48, 76, 508, 76, 76, 76, 76, 76, 76, 76, 76, 285, 287, 76, 76, 48, 48, 48,
  48, 525, 48, 526, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76, 76, 76, 114, 114, 114, 114, 114, 114, 587, 114, 0, 48, 48,
  68, 68, 155, 0, 0, 0, 48, 2174, 76, 76, 76, 76, 76, 76, 358, 76, 76, 361, 76, 362, 363, 76, 365, 76, 76, 188, 48, 48,
  48, 48, 48, 48, 48, 200, 48, 48, 204, 76, 76, 76, 454, 76, 76, 76, 76, 76, 76, 76, 76, 76, 48, 48, 48, 48, 48, 48, 0,
  0, 68, 48, 76, 76, 76, 76, 76, 76, 76, 76, 360, 76, 76, 76, 76, 76, 76, 76, 48, 598, 48, 48, 48, 48, 48, 48, 48, 48,
  48, 532, 48, 76, 76, 76, 76, 114, 184, 114, 114, 114, 114, 114, 114, 114, 114, 223, 114, 114, 227, 2174, 48, 48, 48,
  48, 48, 48, 236, 48, 48, 48, 48, 48, 48, 48, 48, 144, 561, 76, 76, 76, 76, 76, 567, 76, 76, 48, 48, 48, 48, 48, 48,
  48, 48, 48, 48, 48, 76, 76, 76, 48, 576, 48, 48, 76, 76, 76, 76, 114, 114, 114, 114, 114, 114, 114, 114, 409, 114,
  114, 114, 590, 114, 114, 48, 48, 48, 48, 48, 0, 0, 48, 76, 76, 76, 76, 76, 456, 76, 76, 76, 76, 76, 76, 76, 48, 48,
  48, 48, 386, 48, 48, 48, 390, 48, 48, 48, 48, 48, 396, 58, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 58, 68, 0, 0, 58, 0, 0, 0,
  85, 85, 85, 85, 85, 0, 0, 85, 96, 85, 96, 85, 85, 107, 96, 96, 107, 96, 96, 107, 123, 96, 123, 123, 96, 0, 2174, 48,
  48, 48, 131, 48, 48, 48, 48, 48, 48, 48, 48, 144, 146, 0, 64, 294, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76,
  76, 76, 537, 76, 4348, 114, 114, 114, 114, 114, 315, 114, 114, 114, 114, 114, 114, 114, 114, 416, 114, 114, 114, 48,
  48, 48, 48, 423, 48, 48, 426, 247, 503, 0, 48, 68, 68, 48, 76, 76, 76, 76, 76, 76, 76, 512, 76, 114, 114, 114, 114,
  114, 114, 114, 114, 114, 114, 114, 114, 491, 114, 114, 114, 48, 48, 238, 48, 48, 48, 48, 48, 502, 48, 246, 246, 247,
  550, 48, 48, 48, 48, 48, 0, 0, 68, 48, 76, 558, 76, 76, 76, 76, 76, 566, 76, 76, 76, 48, 48, 48, 48, 48, 573, 48, 0,
  48, 48, 68, 68, 68, 0, 0, 0, 48, 2174, 76, 76, 76, 76, 165, 76, 114, 114, 114, 114, 218, 114, 114, 114, 114, 114, 114,
  114, 2174, 48, 48, 48, 48, 48, 48, 237, 48, 48, 48, 48, 48, 48, 48, 48, 144, 0, 146, 0, 0, 0, 0, 48, 244, 4348, 253,
  68, 48, 6301, 76, 76, 76, 515, 76, 76, 76, 76, 76, 76, 76, 76, 76, 522, 48, 48, 76, 4348, 114, 114, 114, 114, 114,
  114, 114, 114, 114, 114, 114, 114, 114, 324, 326, 114, 114, 329, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 242,
  244, 48, 48, 144, 48, 48, 238, 48, 48, 0, 0, 0, 0, 48, 349, 4348, 68, 68, 48, 0, 0, 0, 0, 0, 0, 0, 13312, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 73, 0, 354, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 366, 76, 382,
  48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 245, 144, 0, 76, 76, 76, 76, 443, 76, 76, 446, 76, 76, 76, 76,
  76, 76, 76, 76, 76, 519, 76, 76, 76, 48, 48, 524, 48, 48, 467, 48, 469, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76, 478,
  76, 114, 114, 114, 114, 114, 485, 114, 114, 488, 114, 114, 114, 114, 114, 114, 48, 48, 48, 48, 48, 48, 48, 48, 335,
  48, 48, 48, 48, 48, 0, 0, 0, 0, 48, 48, 4348, 68, 68, 352, 0, 48, 48, 231, 48, 48, 48, 0, 0, 68, 48, 76, 76, 76, 277,
  76, 76, 76, 48, 613, 48, 48, 48, 616, 76, 114, 619, 114, 114, 114, 48, 48, 48, 48, 48, 48, 48, 501, 48, 48, 246, 246,
  247, 59, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 67, 69, 0, 0, 67, 0, 0, 0, 86, 86, 86, 86, 86, 0, 0, 86, 97, 86, 97, 86, 86,
  108, 110, 110, 108, 110, 110, 108, 124, 110, 124, 124, 110, 0, 2174, 48, 48, 48, 132, 48, 48, 48, 48, 48, 48, 48, 48,
  144, 146, 0, 64, 76, 4348, 114, 114, 114, 114, 114, 114, 114, 114, 114, 320, 114, 114, 114, 114, 48, 48, 48, 48, 48,
  48, 238, 48, 48, 48, 246, 246, 247, 48, 427, 48, 48, 48, 48, 0, 0, 0, 0, 434, 0, 48, 68, 68, 48, 48, 48, 133, 48, 48,
  48, 48, 48, 48, 48, 48, 144, 146, 0, 64, 0, 76, 76, 76, 76, 76, 76, 76, 76, 76, 447, 76, 76, 76, 76, 76, 76, 372, 76,
  76, 375, 76, 76, 76, 76, 76, 380, 479, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 490, 114, 114, 114, 48,
  48, 48, 48, 48, 48, 333, 48, 48, 336, 48, 337, 338, 60, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 60, 70, 0, 0, 60, 0, 0, 0, 87,
  87, 87, 87, 87, 0, 0, 87, 98, 87, 98, 87, 87, 109, 98, 98, 109, 98, 98, 109, 125, 98, 125, 125, 98, 0, 2174, 48, 48,
  48, 233, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 144, 48, 127, 48, 48, 48, 48, 48, 48, 48, 48, 141, 48, 144, 146,
  0, 64, 0, 48, 152, 68, 154, 68, 0, 0, 0, 48, 2174, 76, 158, 76, 76, 76, 262, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 364, 76, 76, 186, 76, 189, 48, 48, 48, 48, 48, 48, 48, 48, 202, 48, 205, 76, 76, 279, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 48, 48, 48, 48, 48, 48, 48, 48, 48, 76, 114, 211, 114, 114, 114, 114, 114, 114, 114, 114, 225, 114,
  2174, 228, 229, 0, 146, 0, 0, 0, 0, 48, 48, 4348, 68, 68, 48, 6301, 257, 258, 76, 114, 114, 114, 114, 114, 114, 114,
  114, 114, 114, 114, 114, 2174, 48, 48, 48, 48, 48, 48, 0, 0, 68, 48, 557, 76, 76, 76, 76, 76, 265, 76, 76, 76, 76, 76,
  76, 76, 76, 275, 76, 48, 295, 48, 48, 48, 48, 48, 301, 48, 48, 48, 48, 76, 306, 76, 76, 369, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 76, 76, 76, 274, 76, 76, 76, 4348, 310, 311, 114, 114, 114, 114, 316, 114, 114, 114, 114, 114, 323,
  114, 327, 114, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 476, 76, 76, 0, 76, 441, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 449, 76, 76, 453, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
  393, 48, 48, 48, 76, 114, 481, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 493, 0, 76, 76, 442, 76,
  76, 76, 445, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 271, 273, 76, 76, 76, 76, 451, 76, 76, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 48, 48, 464, 76, 114, 114, 482, 114, 114, 114, 114, 487, 114, 114, 114, 114, 114, 114, 114, 48, 48,
  48, 48, 48, 332, 48, 48, 48, 48, 231, 48, 48, 0, 0, 68, 556, 76, 76, 76, 76, 277, 76, 48, 231, 48, 48, 48, 48, 48, 48,
  48, 48, 48, 48, 48, 48, 48, 144, 0, 146, 0, 0, 0, 0, 250, 48, 4348, 68, 68, 48, 6301, 76, 76, 76, 514, 76, 76, 76, 76,
  76, 76, 76, 76, 76, 76, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 395, 48, 260, 76, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 76, 76, 76, 76, 48, 48, 292, 48, 76, 4348, 114, 114, 114, 313, 114, 114, 114, 114, 114, 114, 114, 114,
  114, 114, 48, 48, 48, 48, 48, 500, 48, 48, 48, 48, 246, 246, 247, 268, 76, 76, 76, 76, 76, 596, 48, 48, 48, 48, 48,
  48, 48, 48, 601, 0, 48, 48, 68, 68, 68, 0, 0, 0, 48, 2174, 76, 76, 76, 164, 76, 114, 114, 114, 114, 114, 114, 114,
  114, 114, 114, 489, 114, 114, 114, 114, 48, 48, 48, 48, 239, 0, 0, 48, 76, 76, 76, 76, 76, 357, 76, 76, 76, 76, 277,
  76, 76, 76, 76, 76, 172, 76, 76, 176, 76, 76, 76, 76, 76, 76, 76, 76, 269, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76,
  520, 76, 76, 48, 48, 48, 76, 114, 114, 114, 217, 114, 114, 114, 114, 114, 114, 114, 114, 2174, 48, 48, 48, 48, 48, 48,
  300, 48, 48, 48, 48, 48, 76, 76, 76, 76, 114, 114, 114, 114, 114, 586, 114, 114, 76, 4348, 114, 114, 114, 114, 114,
  114, 114, 114, 114, 114, 321, 114, 114, 114, 48, 48, 48, 48, 242, 48, 48, 334, 48, 48, 48, 48, 48, 0, 0, 0, 0, 48, 48,
  4348, 68, 68, 48, 0, 0, 76, 76, 76, 277, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 48, 48, 48, 48, 48, 466, 48, 48,
  48, 48, 48, 48, 48, 48, 48, 48, 48, 76, 76, 76, 563, 76, 76, 76, 76, 76, 76, 568, 48, 48, 48, 48, 48, 48, 0, 0, 0, 0,
  0, 0, 48, 68, 68, 439, 76, 114, 114, 114, 114, 484, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 48, 48, 48, 48,
  499, 48, 48, 48, 48, 48, 246, 246, 247, 538, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 48,
  48, 422, 48, 48, 48, 425, 48, 0, 0, 0, 0, 0, 0, 41984, 0, 0, 41984, 0, 0, 0, 0, 41984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 41984, 0, 2174, 68608, 0, 41984, 41984, 0, 0, 0, 41984, 0, 41984, 0, 0, 0, 0, 0, 41984, 41984, 72, 43008, 43008, 0,
  0, 0, 0, 0, 43008, 43080, 43008, 0, 43008, 0, 43008, 43008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43008, 0, 2174, 68608, 0,
  0, 0, 45056, 45056, 45056, 45056, 45056, 0, 0, 45056, 0, 45056, 0, 45056, 45056, 0, 0, 0, 0, 0, 0, 45056, 0, 0, 0, 0,
  45056, 0, 2174, 68608, 0, 0, 0, 0, 0, 8192, 8192, 8192, 8192, 8192, 8192, 0, 8192, 0, 8192, 8192, 0, 0, 0, 0, 0, 0, 0,
  0, 8192, 0, 0, 8192, 0, 0, 68608, 68608, 0, 0, 0, 0, 0, 0, 68608, 2174, 68608, 68608, 68608, 68608, 68608, 0, 0, 0, 0,
  91136, 68608, 0, 0, 0, 68608, 0, 0, 0, 0, 0, 0, 0, 68608, 68608, 0, 0, 0, 68608, 0, 68608, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 144, 146, 0, 0, 0, 0, 0, 103424, 0, 106496, 68608, 68608, 68608, 68608,
  68608, 68608, 68608, 68608, 68608, 68608, 0, 0, 104448, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 102400,
  104448, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68608, 68761, 68761, 68761,
  68761
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  312, 316, 320, 324, 328, 332, 336, 340, 344, 348, 352, 356, 452, 452, 452, 456, 410, 364, 376, 390, 392, 469, 397,
  468, 422, 401, 452, 527, 492, 405, 384, 542, 452, 452, 452, 453, 477, 409, 414, 420, 391, 392, 392, 470, 426, 467,
  392, 507, 446, 451, 452, 431, 379, 435, 441, 384, 385, 452, 452, 452, 452, 455, 410, 631, 393, 392, 392, 392, 470,
  426, 467, 392, 506, 445, 450, 452, 460, 515, 436, 484, 384, 384, 452, 452, 452, 454, 478, 630, 420, 392, 392, 392,
  472, 466, 392, 506, 445, 450, 452, 460, 515, 437, 485, 384, 385, 452, 452, 476, 479, 415, 392, 392, 470, 427, 392,
  506, 445, 499, 500, 462, 517, 483, 384, 385, 452, 544, 416, 392, 471, 489, 506, 496, 452, 461, 516, 483, 384, 452,
  545, 392, 471, 504, 508, 498, 461, 516, 483, 386, 512, 524, 533, 382, 521, 531, 535, 539, 579, 367, 638, 549, 557,
  560, 564, 566, 570, 574, 573, 578, 579, 579, 579, 646, 591, 553, 579, 579, 579, 592, 579, 614, 588, 579, 599, 606,
  611, 579, 599, 589, 579, 579, 579, 579, 649, 590, 370, 579, 579, 579, 590, 579, 579, 613, 617, 579, 579, 582, 601,
  607, 648, 579, 579, 583, 602, 579, 579, 579, 579, 649, 591, 371, 579, 579, 579, 590, 579, 579, 613, 622, 372, 579,
  581, 616, 372, 648, 579, 579, 583, 641, 579, 579, 579, 579, 646, 552, 579, 579, 579, 592, 579, 580, 616, 372, 579,
  581, 616, 372, 648, 579, 580, 584, 618, 579, 579, 579, 654, 371, 579, 579, 593, 579, 615, 372, 579, 582, 360, 646,
  579, 579, 583, 552, 579, 646, 626, 579, 579, 628, 626, 579, 358, 649, 579, 579, 358, 579, 647, 579, 579, 595, 579,
  650, 649, 579, 579, 652, 594, 649, 653, 650, 635, 651, 645, 452, 6, 66, 32770, 65538, 524290, 2, 2, 4114, 1073741890,
  32770, 589826, 16777222, 10, 66050, 133122, 553648134, 590338, 133122, 165890, 17301550, 554172462, 554172590,
  554172590, 554305710, 979394, 1012610, 554322350, -1642068914, 554596782, -1641544594, 554596782, 554596846,
  554629614, -2097146, -1087896466, -2097138, -2031610, -1048562, -1048498, -1572826, -2092002, -1075313426, -1567682,
  -1567618, -98834, 2, 2, 4, 8, 32, 128, 0, 8, 8, 512, 0, 2, 256, 0, 32, 128, 0, 0, 0, 131072, 536870916, 34, 12, 24,
  2097180, 4194332, 134217756, 28, 28, 28, 28, 4, 0, 12, 16777228, 12, 12, 12, 12, 16777228, 2097164, 12, 234881036,
  268435468, 234881028, 268435460, 1610612740, -2147483644, 234881052, 268435484, 1610612764, -2147483620, 16,
  1073741824, 16777220, 4, 8, 8, 8, 8, 536870916, 12, 12, 32, 12, 12, 12, 2097156, 29360132, 12, 33554444, 67108876,
  134217740, 268435468, 12, 4194316, 8388620, 1610612748, 8388636, 16777244, 33554460, 67108892, 134217756, 268435484,
  134217756, 268435484, 1610612764, -2147483620, 33554436, 67108868, 134217732, 268435460, 1610612740, 1073741828,
  -2147483644, 4, 4, 4, 4, 64, 64, 0, 16, 4, 4194316, 8388620, 1073741836, 12, 2097180, 134217740, 268435468,
  -2147483636, 12, 12, 12, 536870924, 2097164, 33554444, 67108876, 4, 64, 64, 64, 0, 1073741824, 4, 134217756,
  268435484, 536870940, 1073741852, -2147483620, 28, 134217740, 268435468, 12, 12, 28, 2097180, 29360156, 33554436,
  134217732, 268435460, 1073741828, 4, 4, 4, 4194316, 134217740, 268435468, 12, 2097156, 4194308, 8388612, 33554436,
  134217732, 12, 2097164, 134217740, 12, 2097180, 4194332, 8388636, 33554460, 67108892, 0, 2097164, 12, 2097156,
  4194308, 134217732, 4, 12, 29360140, 1610612748, 4194308, 4, 4, 4194316, 12, 2097180, 4194332, 28, 28, 12, 4, 28, 2,
  4, 4, 0, 1073741824, 536870916, 160, 1024, 256, 16, 32, 128, 0, 1024, 1024, 768, 768, 2064, 2064, 2320, 2064, 768,
  1536, 2576, 237, 2832, 2832, 2832, 255, 253, 255, 255, 255, 255, 2303, 7167, 0, 0, 0, 0, 1, 2, 4, 8, 16, 32, 192, 0,
  0, 0, 16, 0, 0, 0, 4, 0, 1, 6, 8, 48, 64, 128, 0, 192, 48, 0, 0, 0, 6, 0, 0, 0, 1, 4, 8, 32, 64, 128, 0, 8, 0, 32, 64,
  32, 0, 0, 0, 4, 8, 8, 536870916, 32, 2, 0, 4, 0, 256, 0, 16, 32, 64, 128, 2, 0, 0, 2, 0, 0, 0, 2, 4, 0, 2, 0, 16
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "%ERROR",
  "separator",
  "identifier",
  "CName",
  "nsName",
  "documentation",
  "literalSegment",
  "eof",
  "'&amp;'",
  "'&amp;='",
  "'('",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'='",
  "'>>'",
  "'?'",
  "'['",
  "']'",
  "'attribute'",
  "'datatypes'",
  "'default'",
  "'div'",
  "'element'",
  "'empty'",
  "'external'",
  "'grammar'",
  "'include'",
  "'inherit'",
  "'list'",
  "'mixed'",
  "'namespace'",
  "'notAllowed'",
  "'parent'",
  "'start'",
  "'string'",
  "'text'",
  "'token'",
  "'{'",
  "'|'",
  "'|='",
  "'}'",
  "'~'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 1024,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 1024
    let $end := $end - $result idiv 64
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 64 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 1024 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 1023) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 1
    let $i0 := $t * 624 + $state - 1
    let $i1 := $i0 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : Parse annotatedPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotatedPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-leadAnnotatedPrimary($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: separator | identifier | CName | documentation | eof |
                                                               '&' | ')' | '*' | '+' | ',' | '>>' | '?' | '[' | 'div' |
                                                               'include' | 'start' | '|' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-followAnnotations($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotatedPrimary", $count, $begin, $end)
};

(:~
 : Try parsing annotatedPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotatedPrimary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-leadAnnotatedPrimary($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: separator | identifier | CName | documentation | eof |
                                                               '&' | ')' | '*' | '+' | ',' | '>>' | '?' | '[' | 'div' |
                                                               'include' | 'start' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-followAnnotations($input, $state)
  return $state
};

(:~
 : Parse innerParticle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-innerParticle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotatedPrimary($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12                             (: '*' :)
          or $state[$p:l1] = 13                             (: '+' :)
          or $state[$p:l1] = 18) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 12) then                   (: '*' :)
          let $state := p:consume(12, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 13) then                   (: '+' :)
          let $state := p:consume(13, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(18, $input, $state)       (: '?' :)
          return $state
      let $state := p:lookahead1W(26, $input, $state)       (: separator | identifier | CName | documentation | eof |
                                                               '&' | ')' | ',' | '>>' | '[' | 'div' | 'include' |
                                                               'start' | '|' | '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-followAnnotations($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "innerParticle", $count, $begin, $end)
};

(:~
 : Try parsing innerParticle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-innerParticle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotatedPrimary($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12                             (: '*' :)
          or $state[$p:l1] = 13                             (: '+' :)
          or $state[$p:l1] = 18) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 12) then                   (: '*' :)
          let $state := p:consumeT(12, $input, $state)      (: '*' :)
          return $state
        else if ($state[$p:l1] = 13) then                   (: '+' :)
          let $state := p:consumeT(13, $input, $state)      (: '+' :)
          return $state
        else
          let $state := p:consumeT(18, $input, $state)      (: '?' :)
          return $state
      let $state := p:lookahead1W(26, $input, $state)       (: separator | identifier | CName | documentation | eof |
                                                               '&' | ')' | ',' | '>>' | '[' | 'div' | 'include' |
                                                               'start' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-followAnnotations($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ref.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ref($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(2, $input, $state)                (: identifier :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ref", $count, $begin, $end)
};

(:~
 : Try parsing ref.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ref($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(2, $input, $state)               (: identifier :)
  return $state
};

(:~
 : Parse datatypeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-datatypeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-literal($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "datatypeValue", $count, $begin, $end)
};

(:~
 : Try parsing datatypeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-datatypeValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-literal($input, $state)
  return $state
};

(:~
 : Parse div.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-div($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(24, $input, $state)               (: 'div' :)
  let $state := p:lookahead1W(6, $input, $state)            (: separator | '{' :)
  let $state := p:consume(40, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'include' | 'start' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-grammar($input, $state)
  let $state := p:consume(43, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "div", $count, $begin, $end)
};

(:~
 : Try parsing div.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-div($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(24, $input, $state)              (: 'div' :)
  let $state := p:lookahead1W(6, $input, $state)            (: separator | '{' :)
  let $state := p:consumeT(40, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'include' | 'start' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-grammar($input, $state)
  let $state := p:consumeT(43, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse foreignElementNameNotKeyword.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-foreignElementNameNotKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: identifier :)
      let $state := p:consume(2, $input, $state)            (: identifier :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-prefixedName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "foreignElementNameNotKeyword", $count, $begin, $end)
};

(:~
 : Try parsing foreignElementNameNotKeyword.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-foreignElementNameNotKeyword($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: identifier :)
      let $state := p:consumeT(2, $input, $state)           (: identifier :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-prefixedName($input, $state)
      return $state
  return $state
};

(:~
 : Parse annotationElementNotKeyword.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationElementNotKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-foreignElementNameNotKeyword($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: separator | '[' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotationAttributesContent($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationElementNotKeyword", $count, $begin, $end)
};

(:~
 : Try parsing annotationElementNotKeyword.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationElementNotKeyword($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-foreignElementNameNotKeyword($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: separator | '[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotationAttributesContent($input, $state)
  return $state
};

(:~
 : Parse includeDiv.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-includeDiv($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(24, $input, $state)               (: 'div' :)
  let $state := p:lookahead1W(6, $input, $state)            (: separator | '{' :)
  let $state := p:consume(40, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(19, $input, $state)           (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'start' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-includeBody($input, $state)
  let $state := p:consume(43, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "includeDiv", $count, $begin, $end)
};

(:~
 : Try parsing includeDiv.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-includeDiv($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(24, $input, $state)              (: 'div' :)
  let $state := p:lookahead1W(6, $input, $state)            (: separator | '{' :)
  let $state := p:consumeT(40, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(19, $input, $state)           (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'start' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-includeBody($input, $state)
  let $state := p:consumeT(43, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse includeComponent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-includeComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 36) then                       (: 'start' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-start($input, $state)
      return $state
    else if ($state[$p:l1] = 2) then                        (: identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-define($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-includeDiv($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "includeComponent", $count, $begin, $end)
};

(:~
 : Try parsing includeComponent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-includeComponent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 36) then                       (: 'start' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-start($input, $state)
      return $state
    else if ($state[$p:l1] = 2) then                        (: identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-define($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-includeDiv($input, $state)
      return $state
  return $state
};

(:~
 : Parse annotatedIncludeComponent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotatedIncludeComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotations($input, $state)
  let $state := p:lookahead1W(11, $input, $state)           (: separator | identifier | 'div' | 'start' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-includeComponent($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotatedIncludeComponent", $count, $begin, $end)
};

(:~
 : Try parsing annotatedIncludeComponent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotatedIncludeComponent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotations($input, $state)
  let $state := p:lookahead1W(11, $input, $state)           (: separator | identifier | 'div' | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-includeComponent($input, $state)
  return $state
};

(:~
 : Parse includeMember.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-includeMember($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 2) then                            (: identifier :)
      let $state := p:lookahead2W(16, $input, $state)       (: separator | '&=' | '=' | '[' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 3                              (: CName :)
          or $state[$p:lk] = 1218) then                     (: identifier '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotationElementNotKeyword($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotatedIncludeComponent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "includeMember", $count, $begin, $end)
};

(:~
 : Try parsing includeMember.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-includeMember($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 2) then                            (: identifier :)
      let $state := p:lookahead2W(16, $input, $state)       (: separator | '&=' | '=' | '[' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 3                              (: CName :)
          or $state[$p:lk] = 1218) then                     (: identifier '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotationElementNotKeyword($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotatedIncludeComponent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production includeBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-includeBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(19, $input, $state)         (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'start' | '}' :)
    return
      if ($state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-includeMember($input, $state)
        return p:parse-includeBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production includeBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-includeBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(19, $input, $state)         (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'start' | '}' :)
    return
      if ($state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-includeMember($input, $state)
        return p:try-includeBody-1($input, $state)
};

(:~
 : Parse includeBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-includeBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-includeBody-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "includeBody", $count, $begin, $end)
};

(:~
 : Try parsing includeBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-includeBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-includeBody-1($input, $state)
  return $state
};

(:~
 : Parse optIncludeBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-optIncludeBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '{' :)
      let $state := p:consume(40, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(19, $input, $state)       (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'start' | '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-includeBody($input, $state)
      let $state := p:consume(43, $input, $state)           (: '}' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "optIncludeBody", $count, $begin, $end)
};

(:~
 : Try parsing optIncludeBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-optIncludeBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '{' :)
      let $state := p:consumeT(40, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(19, $input, $state)       (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'start' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-includeBody($input, $state)
      let $state := p:consumeT(43, $input, $state)          (: '}' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse optInherit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-optInherit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: 'inherit' :)
      let $state := p:consume(30, $input, $state)           (: 'inherit' :)
      let $state := p:lookahead1W(3, $input, $state)        (: separator | '=' :)
      let $state := p:consume(16, $input, $state)           (: '=' :)
      let $state := p:lookahead1W(33, $input, $state)       (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-identifierOrKeyword($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "optInherit", $count, $begin, $end)
};

(:~
 : Try parsing optInherit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-optInherit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: 'inherit' :)
      let $state := p:consumeT(30, $input, $state)          (: 'inherit' :)
      let $state := p:lookahead1W(3, $input, $state)        (: separator | '=' :)
      let $state := p:consumeT(16, $input, $state)          (: '=' :)
      let $state := p:lookahead1W(33, $input, $state)       (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-identifierOrKeyword($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse anyURILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-anyURILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-literal($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "anyURILiteral", $count, $begin, $end)
};

(:~
 : Try parsing anyURILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-anyURILiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-literal($input, $state)
  return $state
};

(:~
 : Parse include.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-include($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: 'include' :)
  let $state := p:lookahead1W(1, $input, $state)            (: separator | literalSegment :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-anyURILiteral($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-optInherit($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: separator | identifier | CName | documentation | eof |
                                                               '[' | 'div' | 'include' | 'start' | '{' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-optIncludeBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "include", $count, $begin, $end)
};

(:~
 : Try parsing include.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-include($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(29, $input, $state)              (: 'include' :)
  let $state := p:lookahead1W(1, $input, $state)            (: separator | literalSegment :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-anyURILiteral($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-optInherit($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: separator | identifier | CName | documentation | eof |
                                                               '[' | 'div' | 'include' | 'start' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-optIncludeBody($input, $state)
  return $state
};

(:~
 : Parse define.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-define($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(2, $input, $state)                (: identifier :)
  let $state := p:lookahead1W(13, $input, $state)           (: separator | '&=' | '=' | '|=' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-assignOp($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-pattern($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "define", $count, $begin, $end)
};

(:~
 : Try parsing define.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-define($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(2, $input, $state)               (: identifier :)
  let $state := p:lookahead1W(13, $input, $state)           (: separator | '&=' | '=' | '|=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-assignOp($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-pattern($input, $state)
  return $state
};

(:~
 : Parse assignOp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-assignOp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: '=' :)
      let $state := p:consume(16, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 42) then                       (: '|=' :)
      let $state := p:consume(42, $input, $state)           (: '|=' :)
      return $state
    else
      let $state := p:consume(9, $input, $state)            (: '&=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "assignOp", $count, $begin, $end)
};

(:~
 : Try parsing assignOp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-assignOp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: '=' :)
      let $state := p:consumeT(16, $input, $state)          (: '=' :)
      return $state
    else if ($state[$p:l1] = 42) then                       (: '|=' :)
      let $state := p:consumeT(42, $input, $state)          (: '|=' :)
      return $state
    else
      let $state := p:consumeT(9, $input, $state)           (: '&=' :)
      return $state
  return $state
};

(:~
 : Parse start.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-start($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(36, $input, $state)               (: 'start' :)
  let $state := p:lookahead1W(13, $input, $state)           (: separator | '&=' | '=' | '|=' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-assignOp($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-pattern($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "start", $count, $begin, $end)
};

(:~
 : Try parsing start.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-start($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(36, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(13, $input, $state)           (: separator | '&=' | '=' | '|=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-assignOp($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-pattern($input, $state)
  return $state
};

(:~
 : Parse component.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-component($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 36) then                       (: 'start' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-start($input, $state)
      return $state
    else if ($state[$p:l1] = 2) then                        (: identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-define($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'include' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-include($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-div($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "component", $count, $begin, $end)
};

(:~
 : Try parsing component.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-component($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 36) then                       (: 'start' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-start($input, $state)
      return $state
    else if ($state[$p:l1] = 2) then                        (: identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-define($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'include' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-include($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-div($input, $state)
      return $state
  return $state
};

(:~
 : Parse annotatedComponent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotatedComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotations($input, $state)
  let $state := p:lookahead1W(15, $input, $state)           (: separator | identifier | 'div' | 'include' | 'start' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-component($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotatedComponent", $count, $begin, $end)
};

(:~
 : Try parsing annotatedComponent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotatedComponent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotations($input, $state)
  let $state := p:lookahead1W(15, $input, $state)           (: separator | identifier | 'div' | 'include' | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-component($input, $state)
  return $state
};

(:~
 : Parse member.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-member($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 2) then                            (: identifier :)
      let $state := p:lookahead2W(16, $input, $state)       (: separator | '&=' | '=' | '[' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 3                              (: CName :)
          or $state[$p:lk] = 1218) then                     (: identifier '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotationElementNotKeyword($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotatedComponent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "member", $count, $begin, $end)
};

(:~
 : Try parsing member.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-member($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 2) then                            (: identifier :)
      let $state := p:lookahead2W(16, $input, $state)       (: separator | '&=' | '=' | '[' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 3                              (: CName :)
          or $state[$p:lk] = 1218) then                     (: identifier '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotationElementNotKeyword($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotatedComponent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production grammar (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-grammar-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(21, $input, $state)         (: separator | identifier | CName | documentation | eof |
                                                               '[' | 'div' | 'include' | 'start' | '}' :)
    return
      if ($state[$p:l1] = 7                                 (: eof :)
       or $state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-member($input, $state)
        return p:parse-grammar-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production grammar (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-grammar-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(21, $input, $state)         (: separator | identifier | CName | documentation | eof |
                                                               '[' | 'div' | 'include' | 'start' | '}' :)
    return
      if ($state[$p:l1] = 7                                 (: eof :)
       or $state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-member($input, $state)
        return p:try-grammar-1($input, $state)
};

(:~
 : Parse grammar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-grammar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-grammar-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "grammar", $count, $begin, $end)
};

(:~
 : Try parsing grammar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-grammar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-grammar-1($input, $state)
  return $state
};

(:~
 : Parse exceptNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-exceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: nsName :)
      let $state := p:consume(4, $input, $state)            (: nsName :)
      return $state
    else
      let $state := p:consume(12, $input, $state)           (: '*' :)
      return $state
  let $state := p:lookahead1W(2, $input, $state)            (: separator | '-' :)
  let $state := p:consume(15, $input, $state)               (: '-' :)
  let $state := p:lookahead1W(42, $input, $state)           (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-leadAnnotatedSimpleNameClass($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "exceptNameClass", $count, $begin, $end)
};

(:~
 : Try parsing exceptNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-exceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: nsName :)
      let $state := p:consumeT(4, $input, $state)           (: nsName :)
      return $state
    else
      let $state := p:consumeT(12, $input, $state)          (: '*' :)
      return $state
  let $state := p:lookahead1W(2, $input, $state)            (: separator | '-' :)
  let $state := p:consumeT(15, $input, $state)              (: '-' :)
  let $state := p:lookahead1W(42, $input, $state)           (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-leadAnnotatedSimpleNameClass($input, $state)
  return $state
};

(:~
 : Parse leadAnnotatedExceptNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-leadAnnotatedExceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotations($input, $state)
  let $state := p:lookahead1W(7, $input, $state)            (: separator | nsName | '*' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-exceptNameClass($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "leadAnnotatedExceptNameClass", $count, $begin, $end)
};

(:~
 : Try parsing leadAnnotatedExceptNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-leadAnnotatedExceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotations($input, $state)
  let $state := p:lookahead1W(7, $input, $state)            (: separator | nsName | '*' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-exceptNameClass($input, $state)
  return $state
};

(:~
 : Parse annotatedExceptNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotatedExceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-leadAnnotatedExceptNameClass($input, $state)
  let $state := p:lookahead1W(14, $input, $state)           (: separator | ')' | '>>' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-followAnnotations($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotatedExceptNameClass", $count, $begin, $end)
};

(:~
 : Try parsing annotatedExceptNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotatedExceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-leadAnnotatedExceptNameClass($input, $state)
  let $state := p:lookahead1W(14, $input, $state)           (: separator | ')' | '>>' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-followAnnotations($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production followAnnotations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-followAnnotations-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: separator | identifier | CName | documentation | eof |
                                                               '&' | ')' | '*' | '+' | ',' | '>>' | '?' | '[' | 'div' |
                                                               'include' | 'start' | '{' | '|' | '}' :)
    return
      if ($state[$p:l1] != 17) then                         (: '>>' :)
        $state
      else
        let $state := p:consume(17, $input, $state)         (: '>>' :)
        let $state := p:lookahead1W(35, $input, $state)     (: separator | identifier | CName | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-annotationElement($input, $state)
        return p:parse-followAnnotations-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production followAnnotations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-followAnnotations-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: separator | identifier | CName | documentation | eof |
                                                               '&' | ')' | '*' | '+' | ',' | '>>' | '?' | '[' | 'div' |
                                                               'include' | 'start' | '{' | '|' | '}' :)
    return
      if ($state[$p:l1] != 17) then                         (: '>>' :)
        $state
      else
        let $state := p:consumeT(17, $input, $state)        (: '>>' :)
        let $state := p:lookahead1W(35, $input, $state)     (: separator | identifier | CName | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-annotationElement($input, $state)
        return p:try-followAnnotations-1($input, $state)
};

(:~
 : Parse followAnnotations.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-followAnnotations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-followAnnotations-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "followAnnotations", $count, $begin, $end)
};

(:~
 : Try parsing followAnnotations.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-followAnnotations($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-followAnnotations-1($input, $state)
  return $state
};

(:~
 : Parse simpleNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-simpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state := p:consume(3, $input, $state)            (: CName :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: nsName :)
      let $state := p:consume(4, $input, $state)            (: nsName :)
      return $state
    else if ($state[$p:l1] = 12) then                       (: '*' :)
      let $state := p:consume(12, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-identifierOrKeyword($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "simpleNameClass", $count, $begin, $end)
};

(:~
 : Try parsing simpleNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-simpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state := p:consumeT(3, $input, $state)           (: CName :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: nsName :)
      let $state := p:consumeT(4, $input, $state)           (: nsName :)
      return $state
    else if ($state[$p:l1] = 12) then                       (: '*' :)
      let $state := p:consumeT(12, $input, $state)          (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-identifierOrKeyword($input, $state)
      return $state
  return $state
};

(:~
 : Parse leadAnnotatedSimpleNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-leadAnnotatedSimpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotations($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: separator | identifier | CName | nsName | '(' | '*' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: '(' :)
      let $state := p:consume(10, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(42, $input, $state)       (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-innerNameClass($input, $state)
      let $state := p:consume(11, $input, $state)           (: ')' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-simpleNameClass($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "leadAnnotatedSimpleNameClass", $count, $begin, $end)
};

(:~
 : Try parsing leadAnnotatedSimpleNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-leadAnnotatedSimpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotations($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: separator | identifier | CName | nsName | '(' | '*' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: '(' :)
      let $state := p:consumeT(10, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(42, $input, $state)       (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-innerNameClass($input, $state)
      let $state := p:consumeT(11, $input, $state)          (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-simpleNameClass($input, $state)
      return $state
  return $state
};

(:~
 : Parse annotatedSimpleNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotatedSimpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-leadAnnotatedSimpleNameClass($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: separator | ')' | '>>' | '{' | '|' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-followAnnotations($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotatedSimpleNameClass", $count, $begin, $end)
};

(:~
 : Try parsing annotatedSimpleNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotatedSimpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-leadAnnotatedSimpleNameClass($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: separator | ')' | '>>' | '{' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-followAnnotations($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production innerNameClass (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-innerNameClass-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: '|' :)
      $state
    else
      let $state := p:consume(41, $input, $state)           (: '|' :)
      let $state := p:lookahead1W(42, $input, $state)       (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotatedSimpleNameClass($input, $state)
      return p:parse-innerNameClass-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production innerNameClass (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-innerNameClass-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: '|' :)
      $state
    else
      let $state := p:consumeT(41, $input, $state)          (: '|' :)
      let $state := p:lookahead1W(42, $input, $state)       (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotatedSimpleNameClass($input, $state)
      return p:try-innerNameClass-1($input, $state)
};

(:~
 : Parse innerNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-innerNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 5) then                            (: documentation :)
      let $state := p:lookahead2W(42, $input, $state)       (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
      return $state
    else if ($state[$p:l1] eq 19) then                      (: '[' :)
      let $state := p:lookahead2W(37, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = (4,                            (: nsName :)
                              12)) then                     (: '*' :)
      let $state := p:lookahead2W(18, $input, $state)       (: separator | ')' | '-' | '>>' | '{' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 147                            (: '[' identifier :)
          or $state[$p:lk] = 211                            (: '[' CName :)
          or $state[$p:lk] = 261                            (: documentation nsName :)
          or $state[$p:lk] = 325                            (: documentation documentation :)
          or $state[$p:lk] = 773                            (: documentation '*' :)
          or $state[$p:lk] = 1221                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2515) then                     (: '[' 'token' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-annotatedSimpleNameClass($input, $state)
          let $state := p:try-innerNameClass-1($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2
     or $state[$p:lk] = 964                                 (: nsName '-' :)
     or $state[$p:lk] = 972) then                           (: '*' '-' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotatedExceptNameClass($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotatedSimpleNameClass($input, $state)
      let $state := p:parse-innerNameClass-1($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "innerNameClass", $count, $begin, $end)
};

(:~
 : Try parsing innerNameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-innerNameClass($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 5) then                            (: documentation :)
      let $state := p:lookahead2W(42, $input, $state)       (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
      return $state
    else if ($state[$p:l1] eq 19) then                      (: '[' :)
      let $state := p:lookahead2W(37, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = (4,                            (: nsName :)
                              12)) then                     (: '*' :)
      let $state := p:lookahead2W(18, $input, $state)       (: separator | ')' | '-' | '>>' | '{' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 147                            (: '[' identifier :)
          or $state[$p:lk] = 211                            (: '[' CName :)
          or $state[$p:lk] = 261                            (: documentation nsName :)
          or $state[$p:lk] = 325                            (: documentation documentation :)
          or $state[$p:lk] = 773                            (: documentation '*' :)
          or $state[$p:lk] = 1221                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2515) then                     (: '[' 'token' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-annotatedSimpleNameClass($input, $state)
          let $state := p:try-innerNameClass-1($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2
     or $state[$p:lk] = 964                                 (: nsName '-' :)
     or $state[$p:lk] = 972) then                           (: '*' '-' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotatedExceptNameClass($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotatedSimpleNameClass($input, $state)
      let $state := p:try-innerNameClass-1($input, $state)
      return $state
  return $state
};

(:~
 : Parse nameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-nameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-innerNameClass($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "nameClass", $count, $begin, $end)
};

(:~
 : Try parsing nameClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-nameClass($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-innerNameClass($input, $state)
  return $state
};

(:~
 : Parse primary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-primary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3                              (: CName :)
          or $state[$p:l1] = 37                             (: 'string' :)
          or $state[$p:l1] = 39) then                       (: 'token' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-datatypeName($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | eof | '&' | ')' | '*' | '+' | ',' |
                                                               '>>' | '?' | '[' | 'div' | 'include' | 'start' | '{' |
                                                               '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 6) then                    (: literalSegment :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-datatypeValue($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-optParams($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 6) then                        (: literalSegment :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-datatypeValue($input, $state)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'empty' :)
      let $state := p:consume(26, $input, $state)           (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'notAllowed' :)
      let $state := p:consume(34, $input, $state)           (: 'notAllowed' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'text' :)
      let $state := p:consume(38, $input, $state)           (: 'text' :)
      return $state
    else if ($state[$p:l1] = 2                              (: identifier :)
          or $state[$p:l1] = 35) then                       (: 'parent' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: 'parent' :)
          let $state := p:consume(35, $input, $state)       (: 'parent' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(0, $input, $state)        (: separator | identifier :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ref($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'external' :)
      let $state := p:consume(27, $input, $state)           (: 'external' :)
      let $state := p:lookahead1W(1, $input, $state)        (: separator | literalSegment :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-anyURILiteral($input, $state)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-optInherit($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: 'grammar' :)
          let $state := p:consume(28, $input, $state)       (: 'grammar' :)
          let $state := p:lookahead1W(6, $input, $state)    (: separator | '{' :)
          let $state := p:consume(40, $input, $state)       (: '{' :)
          let $state := p:lookahead1W(20, $input, $state)   (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'include' | 'start' | '}' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-grammar($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 32) then               (: 'mixed' :)
              let $state := p:consume(32, $input, $state)   (: 'mixed' :)
              return $state
            else if ($state[$p:l1] = 31) then               (: 'list' :)
              let $state := p:consume(31, $input, $state)   (: 'list' :)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 25) then           (: 'element' :)
                  let $state := p:consume(25, $input, $state) (: 'element' :)
                  return $state
                else
                  let $state := p:consume(21, $input, $state) (: 'attribute' :)
                  return $state
              let $state := p:lookahead1W(42, $input, $state) (: separator | identifier | CName | nsName |
                                                                 documentation | '(' | '*' | '[' | 'attribute' |
                                                                 'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                                 'external' | 'grammar' | 'include' | 'inherit' |
                                                                 'list' | 'mixed' | 'namespace' | 'notAllowed' |
                                                                 'parent' | 'start' | 'string' | 'text' | 'token' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-nameClass($input, $state)
              return $state
          let $state := p:lookahead1W(6, $input, $state)    (: separator | '{' :)
          let $state := p:consume(40, $input, $state)       (: '{' :)
          let $state := p:lookahead1W(29, $input, $state)   (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-pattern($input, $state)
          return $state
      let $state := p:consume(43, $input, $state)           (: '}' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "primary", $count, $begin, $end)
};

(:~
 : Try parsing primary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-primary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3                              (: CName :)
          or $state[$p:l1] = 37                             (: 'string' :)
          or $state[$p:l1] = 39) then                       (: 'token' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-datatypeName($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | eof | '&' | ')' | '*' | '+' | ',' |
                                                               '>>' | '?' | '[' | 'div' | 'include' | 'start' | '{' |
                                                               '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 6) then                    (: literalSegment :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-datatypeValue($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-optParams($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 6) then                        (: literalSegment :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-datatypeValue($input, $state)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'empty' :)
      let $state := p:consumeT(26, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'notAllowed' :)
      let $state := p:consumeT(34, $input, $state)          (: 'notAllowed' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'text' :)
      let $state := p:consumeT(38, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 2                              (: identifier :)
          or $state[$p:l1] = 35) then                       (: 'parent' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: 'parent' :)
          let $state := p:consumeT(35, $input, $state)      (: 'parent' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(0, $input, $state)        (: separator | identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ref($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'external' :)
      let $state := p:consumeT(27, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(1, $input, $state)        (: separator | literalSegment :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-anyURILiteral($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-optInherit($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: 'grammar' :)
          let $state := p:consumeT(28, $input, $state)      (: 'grammar' :)
          let $state := p:lookahead1W(6, $input, $state)    (: separator | '{' :)
          let $state := p:consumeT(40, $input, $state)      (: '{' :)
          let $state := p:lookahead1W(20, $input, $state)   (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'include' | 'start' | '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-grammar($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 32) then               (: 'mixed' :)
              let $state := p:consumeT(32, $input, $state)  (: 'mixed' :)
              return $state
            else if ($state[$p:l1] = 31) then               (: 'list' :)
              let $state := p:consumeT(31, $input, $state)  (: 'list' :)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 25) then           (: 'element' :)
                  let $state := p:consumeT(25, $input, $state) (: 'element' :)
                  return $state
                else
                  let $state := p:consumeT(21, $input, $state) (: 'attribute' :)
                  return $state
              let $state := p:lookahead1W(42, $input, $state) (: separator | identifier | CName | nsName |
                                                                 documentation | '(' | '*' | '[' | 'attribute' |
                                                                 'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                                 'external' | 'grammar' | 'include' | 'inherit' |
                                                                 'list' | 'mixed' | 'namespace' | 'notAllowed' |
                                                                 'parent' | 'start' | 'string' | 'text' | 'token' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-nameClass($input, $state)
              return $state
          let $state := p:lookahead1W(6, $input, $state)    (: separator | '{' :)
          let $state := p:consumeT(40, $input, $state)      (: '{' :)
          let $state := p:lookahead1W(29, $input, $state)   (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-pattern($input, $state)
          return $state
      let $state := p:consumeT(43, $input, $state)          (: '}' :)
      return $state
  return $state
};

(:~
 : Parse leadAnnotatedPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-leadAnnotatedPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotations($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: separator | identifier | CName | literalSegment | '(' |
                                                               'attribute' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'list' | 'mixed' | 'notAllowed' | 'parent' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: '(' :)
      let $state := p:consume(10, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(29, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-innerPattern($input, $state)
      let $state := p:consume(11, $input, $state)           (: ')' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-primary($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "leadAnnotatedPrimary", $count, $begin, $end)
};

(:~
 : Try parsing leadAnnotatedPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-leadAnnotatedPrimary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotations($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: separator | identifier | CName | literalSegment | '(' |
                                                               'attribute' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'list' | 'mixed' | 'notAllowed' | 'parent' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: '(' :)
      let $state := p:consumeT(10, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(29, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-innerPattern($input, $state)
      let $state := p:consumeT(11, $input, $state)          (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-primary($input, $state)
      return $state
  return $state
};

(:~
 : Parse param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotations($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-identifierOrKeyword($input, $state)
  let $state := p:lookahead1W(3, $input, $state)            (: separator | '=' :)
  let $state := p:consume(16, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(1, $input, $state)            (: separator | literalSegment :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-literal($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "param", $count, $begin, $end)
};

(:~
 : Try parsing param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-param($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotations($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-identifierOrKeyword($input, $state)
  let $state := p:lookahead1W(3, $input, $state)            (: separator | '=' :)
  let $state := p:consumeT(16, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(1, $input, $state)            (: separator | literalSegment :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-literal($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production optParams (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-optParams-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: separator | identifier | documentation | '[' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' | '}' :)
    return
      if ($state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-param($input, $state)
        return p:parse-optParams-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production optParams (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-optParams-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: separator | identifier | documentation | '[' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' | '}' :)
    return
      if ($state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-param($input, $state)
        return p:try-optParams-1($input, $state)
};

(:~
 : Parse optParams.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-optParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '{' :)
      let $state := p:consume(40, $input, $state)           (: '{' :)
      let $state := p:parse-optParams-1($input, $state)
      let $state := p:consume(43, $input, $state)           (: '}' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "optParams", $count, $begin, $end)
};

(:~
 : Try parsing optParams.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-optParams($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '{' :)
      let $state := p:consumeT(40, $input, $state)          (: '{' :)
      let $state := p:try-optParams-1($input, $state)
      let $state := p:consumeT(43, $input, $state)          (: '}' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse datatypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-datatypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state := p:consume(3, $input, $state)            (: CName :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'string' :)
      let $state := p:consume(37, $input, $state)           (: 'string' :)
      return $state
    else
      let $state := p:consume(39, $input, $state)           (: 'token' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "datatypeName", $count, $begin, $end)
};

(:~
 : Try parsing datatypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-datatypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state := p:consumeT(3, $input, $state)           (: CName :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'string' :)
      let $state := p:consumeT(37, $input, $state)          (: 'string' :)
      return $state
    else
      let $state := p:consumeT(39, $input, $state)          (: 'token' :)
      return $state
  return $state
};

(:~
 : Parse dataExcept.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-dataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-datatypeName($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: separator | '-' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-optParams($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: separator | '-' :)
  let $state := p:consume(15, $input, $state)               (: '-' :)
  let $state := p:lookahead1W(29, $input, $state)           (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-leadAnnotatedPrimary($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "dataExcept", $count, $begin, $end)
};

(:~
 : Try parsing dataExcept.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-dataExcept($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-datatypeName($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: separator | '-' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-optParams($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: separator | '-' :)
  let $state := p:consumeT(15, $input, $state)              (: '-' :)
  let $state := p:lookahead1W(29, $input, $state)           (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-leadAnnotatedPrimary($input, $state)
  return $state
};

(:~
 : Parse anyElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-anyElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-prefixedName($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-identifierOrKeyword($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "anyElementName", $count, $begin, $end)
};

(:~
 : Try parsing anyElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-anyElementName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-prefixedName($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-identifierOrKeyword($input, $state)
      return $state
  return $state
};

(:~
 : Parse nestedAnnotationElement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-nestedAnnotationElement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-anyElementName($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: separator | '[' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotationAttributesContent($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "nestedAnnotationElement", $count, $begin, $end)
};

(:~
 : Try parsing nestedAnnotationElement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-nestedAnnotationElement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-anyElementName($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: separator | '[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotationAttributesContent($input, $state)
  return $state
};

(:~
 : Parse anyAttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-anyAttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-prefixedName($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-identifierOrKeyword($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "anyAttributeName", $count, $begin, $end)
};

(:~
 : Try parsing anyAttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-anyAttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-prefixedName($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-identifierOrKeyword($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production annotationAttributesContent (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationAttributesContent-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: separator | identifier | CName | literalSegment | ']' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    let $state :=
      if ($state[$p:l1] = (2,                               (: identifier :)
                           3,                               (: CName :)
                           21,                              (: 'attribute' :)
                           22,                              (: 'datatypes' :)
                           23,                              (: 'default' :)
                           24,                              (: 'div' :)
                           25,                              (: 'element' :)
                           26,                              (: 'empty' :)
                           27,                              (: 'external' :)
                           28,                              (: 'grammar' :)
                           29,                              (: 'include' :)
                           30,                              (: 'inherit' :)
                           31,                              (: 'list' :)
                           32,                              (: 'mixed' :)
                           33,                              (: 'namespace' :)
                           34,                              (: 'notAllowed' :)
                           35,                              (: 'parent' :)
                           36,                              (: 'start' :)
                           37,                              (: 'string' :)
                           38,                              (: 'text' :)
                           39)) then                        (: 'token' :)
        let $state := p:lookahead2W(10, $input, $state)     (: separator | '=' | '[' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1026                             (: identifier '=' :)
      and $state[$p:lk] != 1027                             (: CName '=' :)
      and $state[$p:lk] != 1045                             (: 'attribute' '=' :)
      and $state[$p:lk] != 1046                             (: 'datatypes' '=' :)
      and $state[$p:lk] != 1047                             (: 'default' '=' :)
      and $state[$p:lk] != 1048                             (: 'div' '=' :)
      and $state[$p:lk] != 1049                             (: 'element' '=' :)
      and $state[$p:lk] != 1050                             (: 'empty' '=' :)
      and $state[$p:lk] != 1051                             (: 'external' '=' :)
      and $state[$p:lk] != 1052                             (: 'grammar' '=' :)
      and $state[$p:lk] != 1053                             (: 'include' '=' :)
      and $state[$p:lk] != 1054                             (: 'inherit' '=' :)
      and $state[$p:lk] != 1055                             (: 'list' '=' :)
      and $state[$p:lk] != 1056                             (: 'mixed' '=' :)
      and $state[$p:lk] != 1057                             (: 'namespace' '=' :)
      and $state[$p:lk] != 1058                             (: 'notAllowed' '=' :)
      and $state[$p:lk] != 1059                             (: 'parent' '=' :)
      and $state[$p:lk] != 1060                             (: 'start' '=' :)
      and $state[$p:lk] != 1061                             (: 'string' '=' :)
      and $state[$p:lk] != 1062                             (: 'text' '=' :)
      and $state[$p:lk] != 1063) then                       (: 'token' '=' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-anyAttributeName($input, $state)
        let $state := p:lookahead1W(3, $input, $state)      (: separator | '=' :)
        let $state := p:consume(16, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(1, $input, $state)      (: separator | literalSegment :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-literal($input, $state)
        return p:parse-annotationAttributesContent-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production annotationAttributesContent (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationAttributesContent-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: separator | identifier | CName | literalSegment | ']' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    let $state :=
      if ($state[$p:l1] = (2,                               (: identifier :)
                           3,                               (: CName :)
                           21,                              (: 'attribute' :)
                           22,                              (: 'datatypes' :)
                           23,                              (: 'default' :)
                           24,                              (: 'div' :)
                           25,                              (: 'element' :)
                           26,                              (: 'empty' :)
                           27,                              (: 'external' :)
                           28,                              (: 'grammar' :)
                           29,                              (: 'include' :)
                           30,                              (: 'inherit' :)
                           31,                              (: 'list' :)
                           32,                              (: 'mixed' :)
                           33,                              (: 'namespace' :)
                           34,                              (: 'notAllowed' :)
                           35,                              (: 'parent' :)
                           36,                              (: 'start' :)
                           37,                              (: 'string' :)
                           38,                              (: 'text' :)
                           39)) then                        (: 'token' :)
        let $state := p:lookahead2W(10, $input, $state)     (: separator | '=' | '[' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1026                             (: identifier '=' :)
      and $state[$p:lk] != 1027                             (: CName '=' :)
      and $state[$p:lk] != 1045                             (: 'attribute' '=' :)
      and $state[$p:lk] != 1046                             (: 'datatypes' '=' :)
      and $state[$p:lk] != 1047                             (: 'default' '=' :)
      and $state[$p:lk] != 1048                             (: 'div' '=' :)
      and $state[$p:lk] != 1049                             (: 'element' '=' :)
      and $state[$p:lk] != 1050                             (: 'empty' '=' :)
      and $state[$p:lk] != 1051                             (: 'external' '=' :)
      and $state[$p:lk] != 1052                             (: 'grammar' '=' :)
      and $state[$p:lk] != 1053                             (: 'include' '=' :)
      and $state[$p:lk] != 1054                             (: 'inherit' '=' :)
      and $state[$p:lk] != 1055                             (: 'list' '=' :)
      and $state[$p:lk] != 1056                             (: 'mixed' '=' :)
      and $state[$p:lk] != 1057                             (: 'namespace' '=' :)
      and $state[$p:lk] != 1058                             (: 'notAllowed' '=' :)
      and $state[$p:lk] != 1059                             (: 'parent' '=' :)
      and $state[$p:lk] != 1060                             (: 'start' '=' :)
      and $state[$p:lk] != 1061                             (: 'string' '=' :)
      and $state[$p:lk] != 1062                             (: 'text' '=' :)
      and $state[$p:lk] != 1063) then                       (: 'token' '=' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-anyAttributeName($input, $state)
        let $state := p:lookahead1W(3, $input, $state)      (: separator | '=' :)
        let $state := p:consumeT(16, $input, $state)        (: '=' :)
        let $state := p:lookahead1W(1, $input, $state)      (: separator | literalSegment :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-literal($input, $state)
        return p:try-annotationAttributesContent-1($input, $state)
};

(:~
 : Parse the 2nd loop of production annotationAttributesContent (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationAttributesContent-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: separator | identifier | CName | literalSegment | ']' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    return
      if ($state[$p:l1] = 20) then                          (: ']' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 6) then                  (: literalSegment :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-literal($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-nestedAnnotationElement($input, $state)
            return $state
        return p:parse-annotationAttributesContent-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production annotationAttributesContent (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationAttributesContent-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: separator | identifier | CName | literalSegment | ']' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    return
      if ($state[$p:l1] = 20) then                          (: ']' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 6) then                  (: literalSegment :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-literal($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-nestedAnnotationElement($input, $state)
            return $state
        return p:try-annotationAttributesContent-2($input, $state)
};

(:~
 : Parse annotationAttributesContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationAttributesContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(19, $input, $state)               (: '[' :)
  let $state := p:parse-annotationAttributesContent-1($input, $state)
  let $state := p:parse-annotationAttributesContent-2($input, $state)
  let $state := p:consume(20, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationAttributesContent", $count, $begin, $end)
};

(:~
 : Try parsing annotationAttributesContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationAttributesContent($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(19, $input, $state)              (: '[' :)
  let $state := p:try-annotationAttributesContent-1($input, $state)
  let $state := p:try-annotationAttributesContent-2($input, $state)
  let $state := p:consumeT(20, $input, $state)              (: ']' :)
  return $state
};

(:~
 : Parse foreignElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-foreignElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-prefixedName($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-identifierOrKeyword($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "foreignElementName", $count, $begin, $end)
};

(:~
 : Try parsing foreignElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-foreignElementName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CName :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-prefixedName($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-identifierOrKeyword($input, $state)
      return $state
  return $state
};

(:~
 : Parse annotationElement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationElement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-foreignElementName($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: separator | '[' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotationAttributesContent($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationElement", $count, $begin, $end)
};

(:~
 : Try parsing annotationElement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationElement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-foreignElementName($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: separator | '[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotationAttributesContent($input, $state)
  return $state
};

(:~
 : Parse prefixedName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-prefixedName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(3, $input, $state)                (: CName :)
  let $end := $state[$p:e0]
  return p:reduce($state, "prefixedName", $count, $begin, $end)
};

(:~
 : Try parsing prefixedName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-prefixedName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(3, $input, $state)               (: CName :)
  return $state
};

(:~
 : Parse foreignAttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-foreignAttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-prefixedName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "foreignAttributeName", $count, $begin, $end)
};

(:~
 : Try parsing foreignAttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-foreignAttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-prefixedName($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotations-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(43, $input, $state)         (: separator | identifier | CName | nsName | documentation |
                                                               literalSegment | '(' | '*' | '[' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] != 5) then                          (: documentation :)
        $state
      else
        let $state := p:consume(5, $input, $state)          (: documentation :)
        return p:parse-annotations-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotations-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(43, $input, $state)         (: separator | identifier | CName | nsName | documentation |
                                                               literalSegment | '(' | '*' | '[' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] != 5) then                          (: documentation :)
        $state
      else
        let $state := p:consumeT(5, $input, $state)         (: documentation :)
        return p:try-annotations-1($input, $state)
};

(:~
 : Parse the 2nd loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotations-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    let $state :=
      if ($state[$p:l1] eq 3) then                          (: CName :)
        let $state := p:lookahead2W(10, $input, $state)     (: separator | '=' | '[' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1027) then                       (: CName '=' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-foreignAttributeName($input, $state)
        let $state := p:lookahead1W(3, $input, $state)      (: separator | '=' :)
        let $state := p:consume(16, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(1, $input, $state)      (: separator | literalSegment :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-literal($input, $state)
        return p:parse-annotations-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotations-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    let $state :=
      if ($state[$p:l1] eq 3) then                          (: CName :)
        let $state := p:lookahead2W(10, $input, $state)     (: separator | '=' | '[' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1027) then                       (: CName '=' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-foreignAttributeName($input, $state)
        let $state := p:lookahead1W(3, $input, $state)      (: separator | '=' :)
        let $state := p:consumeT(16, $input, $state)        (: '=' :)
        let $state := p:lookahead1W(1, $input, $state)      (: separator | literalSegment :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-literal($input, $state)
        return p:try-annotations-2($input, $state)
};

(:~
 : Parse the 3rd loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotations-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] = 20) then                          (: ']' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-annotationElement($input, $state)
        return p:parse-annotations-3($input, $state)
};

(:~
 : Try parsing the 3rd loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotations-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] = 20) then                          (: ']' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-annotationElement($input, $state)
        return p:try-annotations-3($input, $state)
};

(:~
 : Parse annotations.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-annotations-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:consume(19, $input, $state)           (: '[' :)
      let $state := p:parse-annotations-2($input, $state)
      let $state := p:parse-annotations-3($input, $state)
      let $state := p:consume(20, $input, $state)           (: ']' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "annotations", $count, $begin, $end)
};

(:~
 : Try parsing annotations.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotations($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-annotations-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:consumeT(19, $input, $state)          (: '[' :)
      let $state := p:try-annotations-2($input, $state)
      let $state := p:try-annotations-3($input, $state)
      let $state := p:consumeT(20, $input, $state)          (: ']' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse leadAnnotatedDataExcept.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-leadAnnotatedDataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotations($input, $state)
  let $state := p:lookahead1W(12, $input, $state)           (: separator | CName | 'string' | 'token' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-dataExcept($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "leadAnnotatedDataExcept", $count, $begin, $end)
};

(:~
 : Try parsing leadAnnotatedDataExcept.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-leadAnnotatedDataExcept($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotations($input, $state)
  let $state := p:lookahead1W(12, $input, $state)           (: separator | CName | 'string' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-dataExcept($input, $state)
  return $state
};

(:~
 : Parse annotatedDataExcept.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotatedDataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-leadAnnotatedDataExcept($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: separator | identifier | CName | documentation | eof |
                                                               ')' | '>>' | '[' | 'div' | 'include' | 'start' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-followAnnotations($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotatedDataExcept", $count, $begin, $end)
};

(:~
 : Try parsing annotatedDataExcept.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotatedDataExcept($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-leadAnnotatedDataExcept($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: separator | identifier | CName | documentation | eof |
                                                               ')' | '>>' | '[' | 'div' | 'include' | 'start' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-followAnnotations($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production innerPattern (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-innerPattern-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 8                                  (: '&' :)
    and $state[$p:l1] != 14                                 (: ',' :)
    and $state[$p:l1] != 41) then                           (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: '|' :)
          let $state := p:consume(41, $input, $state)       (: '|' :)
          return $state
        else if ($state[$p:l1] = 14) then                   (: ',' :)
          let $state := p:consume(14, $input, $state)       (: ',' :)
          return $state
        else
          let $state := p:consume(8, $input, $state)        (: '&' :)
          return $state
      let $state := p:lookahead1W(29, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-innerParticle($input, $state)
      return p:parse-innerPattern-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production innerPattern (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-innerPattern-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 8                                  (: '&' :)
    and $state[$p:l1] != 14                                 (: ',' :)
    and $state[$p:l1] != 41) then                           (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: '|' :)
          let $state := p:consumeT(41, $input, $state)      (: '|' :)
          return $state
        else if ($state[$p:l1] = 14) then                   (: ',' :)
          let $state := p:consumeT(14, $input, $state)      (: ',' :)
          return $state
        else
          let $state := p:consumeT(8, $input, $state)       (: '&' :)
          return $state
      let $state := p:lookahead1W(29, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-innerParticle($input, $state)
      return p:try-innerPattern-1($input, $state)
};

(:~
 : Parse innerPattern.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-innerPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 5) then                            (: documentation :)
      let $state := p:lookahead2W(29, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] eq 19) then                      (: '[' :)
      let $state := p:lookahead2W(37, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = (3,                            (: CName :)
                              37,                           (: 'string' :)
                              39)) then                     (: 'token' :)
      let $state := p:lookahead2W(32, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | eof | '&' | ')' | '*' | '+' | ',' |
                                                               '-' | '>>' | '?' | '[' | 'div' | 'include' | 'start' |
                                                               '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 147                            (: '[' identifier :)
          or $state[$p:lk] = 197                            (: documentation CName :)
          or $state[$p:lk] = 211                            (: '[' CName :)
          or $state[$p:lk] = 325                            (: documentation documentation :)
          or $state[$p:lk] = 1221                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2373                           (: documentation 'string' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2501                           (: documentation 'token' :)
          or $state[$p:lk] = 2515                           (: '[' 'token' :)
          or $state[$p:lk] = 2563                           (: CName '{' :)
          or $state[$p:lk] = 2597                           (: 'string' '{' :)
          or $state[$p:lk] = 2599) then                     (: 'token' '{' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-annotatedDataExcept($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 963                                 (: CName '-' :)
     or $state[$p:lk] = 997                                 (: 'string' '-' :)
     or $state[$p:lk] = 999) then                           (: 'token' '-' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotatedDataExcept($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-innerParticle($input, $state)
      let $state := p:parse-innerPattern-1($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "innerPattern", $count, $begin, $end)
};

(:~
 : Try parsing innerPattern.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-innerPattern($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 5) then                            (: documentation :)
      let $state := p:lookahead2W(29, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] eq 19) then                      (: '[' :)
      let $state := p:lookahead2W(37, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = (3,                            (: CName :)
                              37,                           (: 'string' :)
                              39)) then                     (: 'token' :)
      let $state := p:lookahead2W(32, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | eof | '&' | ')' | '*' | '+' | ',' |
                                                               '-' | '>>' | '?' | '[' | 'div' | 'include' | 'start' |
                                                               '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 147                            (: '[' identifier :)
          or $state[$p:lk] = 197                            (: documentation CName :)
          or $state[$p:lk] = 211                            (: '[' CName :)
          or $state[$p:lk] = 325                            (: documentation documentation :)
          or $state[$p:lk] = 1221                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2373                           (: documentation 'string' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2501                           (: documentation 'token' :)
          or $state[$p:lk] = 2515                           (: '[' 'token' :)
          or $state[$p:lk] = 2563                           (: CName '{' :)
          or $state[$p:lk] = 2597                           (: 'string' '{' :)
          or $state[$p:lk] = 2599) then                     (: 'token' '{' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-annotatedDataExcept($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 963                                 (: CName '-' :)
     or $state[$p:lk] = 997                                 (: 'string' '-' :)
     or $state[$p:lk] = 999) then                           (: 'token' '-' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotatedDataExcept($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-innerParticle($input, $state)
      let $state := p:try-innerPattern-1($input, $state)
      return $state
  return $state
};

(:~
 : Parse pattern.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-pattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-innerPattern($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "pattern", $count, $begin, $end)
};

(:~
 : Try parsing pattern.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-pattern($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-innerPattern($input, $state)
  return $state
};

(:~
 : Parse topLevelBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-topLevelBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 2) then                            (: identifier :)
      let $state := p:lookahead2W(25, $input, $state)       (: separator | eof | '&' | '&=' | '*' | '+' | ',' | '=' |
                                                               '>>' | '?' | '[' | '|' | '|=' :)
      return $state
    else if ($state[$p:l1] eq 3) then                       (: CName :)
      let $state := p:lookahead2W(24, $input, $state)       (: separator | literalSegment | eof | '&' | '*' | '+' |
                                                               ',' | '-' | '>>' | '?' | '[' | '{' | '|' :)
      return $state
    else if ($state[$p:l1] eq 5) then                       (: documentation :)
      let $state := p:lookahead2W(34, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'list' | 'mixed' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] eq 19) then                      (: '[' :)
      let $state := p:lookahead2W(37, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 133                            (: documentation identifier :)
          or $state[$p:lk] = 147                            (: '[' identifier :)
          or $state[$p:lk] = 211                            (: '[' CName :)
          or $state[$p:lk] = 325                            (: documentation documentation :)
          or $state[$p:lk] = 1221                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2515) then                     (: '[' 'token' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-pattern($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2
     or $state[$p:lk] = 7                                   (: eof :)
     or $state[$p:lk] = 24                                  (: 'div' :)
     or $state[$p:lk] = 29                                  (: 'include' :)
     or $state[$p:lk] = 36                                  (: 'start' :)
     or $state[$p:lk] = 578                                 (: identifier '&=' :)
     or $state[$p:lk] = 1026                                (: identifier '=' :)
     or $state[$p:lk] = 1218                                (: identifier '[' :)
     or $state[$p:lk] = 1219                                (: CName '[' :)
     or $state[$p:lk] = 1541                                (: documentation 'div' :)
     or $state[$p:lk] = 1861                                (: documentation 'include' :)
     or $state[$p:lk] = 2309                                (: documentation 'start' :)
     or $state[$p:lk] = 2690) then                          (: identifier '|=' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-grammar($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-pattern($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "topLevelBody", $count, $begin, $end)
};

(:~
 : Parse datatypePrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-datatypePrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-identifierOrKeyword($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "datatypePrefix", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production literal (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-literal-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(44, $input, $state)         (: separator | identifier | CName | documentation |
                                                               literalSegment | eof | '&' | '(' | ')' | '*' | '+' |
                                                               ',' | '>>' | '?' | '[' | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' | '{' | '|' | '}' |
                                                               '~' :)
    return
      if ($state[$p:l1] != 44) then                         (: '~' :)
        $state
      else
        let $state := p:consume(44, $input, $state)         (: '~' :)
        let $state := p:lookahead1W(1, $input, $state)      (: separator | literalSegment :)
        let $state := p:consume(6, $input, $state)          (: literalSegment :)
        return p:parse-literal-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production literal (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-literal-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(44, $input, $state)         (: separator | identifier | CName | documentation |
                                                               literalSegment | eof | '&' | '(' | ')' | '*' | '+' |
                                                               ',' | '>>' | '?' | '[' | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' | '{' | '|' | '}' |
                                                               '~' :)
    return
      if ($state[$p:l1] != 44) then                         (: '~' :)
        $state
      else
        let $state := p:consumeT(44, $input, $state)        (: '~' :)
        let $state := p:lookahead1W(1, $input, $state)      (: separator | literalSegment :)
        let $state := p:consumeT(6, $input, $state)         (: literalSegment :)
        return p:try-literal-1($input, $state)
};

(:~
 : Parse literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(6, $input, $state)                (: literalSegment :)
  let $state := p:parse-literal-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "literal", $count, $begin, $end)
};

(:~
 : Try parsing literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-literal($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(6, $input, $state)               (: literalSegment :)
  let $state := p:try-literal-1($input, $state)
  return $state
};

(:~
 : Parse namespaceURILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-namespaceURILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: literalSegment :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-literal($input, $state)
      return $state
    else
      let $state := p:consume(30, $input, $state)           (: 'inherit' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "namespaceURILiteral", $count, $begin, $end)
};

(:~
 : Parse identifierOrKeyword.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-identifierOrKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: identifier :)
      let $state := p:consume(2, $input, $state)            (: identifier :)
      return $state
    else if ($state[$p:l1] = 21) then                       (: 'attribute' :)
      let $state := p:consume(21, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: 'default' :)
      let $state := p:consume(23, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 22) then                       (: 'datatypes' :)
      let $state := p:consume(22, $input, $state)           (: 'datatypes' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: 'div' :)
      let $state := p:consume(24, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: 'element' :)
      let $state := p:consume(25, $input, $state)           (: 'element' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'empty' :)
      let $state := p:consume(26, $input, $state)           (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'external' :)
      let $state := p:consume(27, $input, $state)           (: 'external' :)
      return $state
    else if ($state[$p:l1] = 28) then                       (: 'grammar' :)
      let $state := p:consume(28, $input, $state)           (: 'grammar' :)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'include' :)
      let $state := p:consume(29, $input, $state)           (: 'include' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: 'inherit' :)
      let $state := p:consume(30, $input, $state)           (: 'inherit' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: 'list' :)
      let $state := p:consume(31, $input, $state)           (: 'list' :)
      return $state
    else if ($state[$p:l1] = 32) then                       (: 'mixed' :)
      let $state := p:consume(32, $input, $state)           (: 'mixed' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: 'namespace' :)
      let $state := p:consume(33, $input, $state)           (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'notAllowed' :)
      let $state := p:consume(34, $input, $state)           (: 'notAllowed' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: 'parent' :)
      let $state := p:consume(35, $input, $state)           (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: 'start' :)
      let $state := p:consume(36, $input, $state)           (: 'start' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'string' :)
      let $state := p:consume(37, $input, $state)           (: 'string' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'text' :)
      let $state := p:consume(38, $input, $state)           (: 'text' :)
      return $state
    else
      let $state := p:consume(39, $input, $state)           (: 'token' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "identifierOrKeyword", $count, $begin, $end)
};

(:~
 : Try parsing identifierOrKeyword.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-identifierOrKeyword($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: identifier :)
      let $state := p:consumeT(2, $input, $state)           (: identifier :)
      return $state
    else if ($state[$p:l1] = 21) then                       (: 'attribute' :)
      let $state := p:consumeT(21, $input, $state)          (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: 'default' :)
      let $state := p:consumeT(23, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 22) then                       (: 'datatypes' :)
      let $state := p:consumeT(22, $input, $state)          (: 'datatypes' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: 'div' :)
      let $state := p:consumeT(24, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: 'element' :)
      let $state := p:consumeT(25, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'empty' :)
      let $state := p:consumeT(26, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'external' :)
      let $state := p:consumeT(27, $input, $state)          (: 'external' :)
      return $state
    else if ($state[$p:l1] = 28) then                       (: 'grammar' :)
      let $state := p:consumeT(28, $input, $state)          (: 'grammar' :)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'include' :)
      let $state := p:consumeT(29, $input, $state)          (: 'include' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: 'inherit' :)
      let $state := p:consumeT(30, $input, $state)          (: 'inherit' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: 'list' :)
      let $state := p:consumeT(31, $input, $state)          (: 'list' :)
      return $state
    else if ($state[$p:l1] = 32) then                       (: 'mixed' :)
      let $state := p:consumeT(32, $input, $state)          (: 'mixed' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: 'namespace' :)
      let $state := p:consumeT(33, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'notAllowed' :)
      let $state := p:consumeT(34, $input, $state)          (: 'notAllowed' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: 'parent' :)
      let $state := p:consumeT(35, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: 'start' :)
      let $state := p:consumeT(36, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'string' :)
      let $state := p:consumeT(37, $input, $state)          (: 'string' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'text' :)
      let $state := p:consumeT(38, $input, $state)          (: 'text' :)
      return $state
    else
      let $state := p:consumeT(39, $input, $state)          (: 'token' :)
      return $state
  return $state
};

(:~
 : Parse namespacePrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-namespacePrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-identifierOrKeyword($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "namespacePrefix", $count, $begin, $end)
};

(:~
 : Parse decl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-decl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22) then                       (: 'datatypes' :)
      let $state := p:consume(22, $input, $state)           (: 'datatypes' :)
      let $state := p:lookahead1W(33, $input, $state)       (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-datatypePrefix($input, $state)
      let $state := p:lookahead1W(3, $input, $state)        (: separator | '=' :)
      let $state := p:consume(16, $input, $state)           (: '=' :)
      let $state := p:lookahead1W(1, $input, $state)        (: separator | literalSegment :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-literal($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: 'namespace' :)
          let $state := p:consume(33, $input, $state)       (: 'namespace' :)
          let $state := p:lookahead1W(33, $input, $state)   (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-namespacePrefix($input, $state)
          return $state
        else
          let $state := p:consume(23, $input, $state)       (: 'default' :)
          let $state := p:lookahead1W(5, $input, $state)    (: separator | 'namespace' :)
          let $state := p:consume(33, $input, $state)       (: 'namespace' :)
          let $state := p:lookahead1W(36, $input, $state)   (: separator | identifier | '=' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 16) then              (: '=' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-namespacePrefix($input, $state)
              return $state
            else
              $state
          return $state
      let $state := p:lookahead1W(3, $input, $state)        (: separator | '=' :)
      let $state := p:consume(16, $input, $state)           (: '=' :)
      let $state := p:lookahead1W(8, $input, $state)        (: separator | literalSegment | 'inherit' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-namespaceURILiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "decl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production topLevel (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-topLevel-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(41, $input, $state)         (: separator | identifier | CName | documentation |
                                                               literalSegment | eof | '(' | '[' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] != 22                               (: 'datatypes' :)
      and $state[$p:l1] != 23                               (: 'default' :)
      and $state[$p:l1] != 33) then                         (: 'namespace' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-decl($input, $state)
        return p:parse-topLevel-1($input, $state)
};

(:~
 : Parse topLevel.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-topLevel($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-topLevel-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-topLevelBody($input, $state)
  let $state := p:consume(7, $input, $state)                (: eof :)
  let $end := $state[$p:e0]
  return p:reduce($state, "topLevel", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 6),
    0, 0, 0,
    subsequence($state, 10),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 6),
    0, 0, 0,
    subsequence($state, 10)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 1) then                                 (: separator :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 3)
    else
      p:matchW($input, $state[$p:e1], $set)
  return
  (
    $match[1] * 64 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 10)
  )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from lexer state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $dpi for input position $e0. Reconstruct state from the parameters.
 :
 : @param $state the lexer state to be restored.
 : @param $update the lexer state containing updates.
 : @param $dpi the decision point id.
 : @param $e0 the input position.
 : @param $v the id of the successful alternative.
 : @param $lk the new lookahead code.
 : @return the reconstructed state.
 :)
declare function p:memoize($state as item()+,
                           $update as item()+,
                           $dpi as xs:integer,
                           $e0 as xs:integer,
                           $v as xs:integer,
                           $lk as xs:integer) as item()+
{
  $lk,
  subsequence($state, $p:b0, $p:memo - $p:b0),
  let $memo := $update[$p:memo]
  let $errors := ($memo, $update[$p:error])[.]
  return
    element memo
    {
      $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
      $memo/value,
      element value {attribute key {$e0 * 4 + $dpi}, $v}
    },
  subsequence($state, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $dpi
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $dpi the decision point id.
 : @return the updated state.
 :)
declare function p:memoized($state as item()+, $dpi as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 4 + $dpi])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol topLevel from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-topLevel($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, false(), <memo/>)
  let $state := p:parse-topLevel($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : The input filename, or string, if surrounded by curly braces.
 :)
declare variable $input as xs:string external;

let $result :=
  if (matches($input, "^\{.*\}$")) then
    p:parse-topLevel(substring($input, 2, string-length($input) - 2))
  else
    p:parse-topLevel(unparsed-text($input, "utf-8"))
return
  if (empty($result/self::ERROR)) then
    $result
  else
    error(xs:QName("p:parse-topLevel"), concat("&#10;    ", replace($result, "&#10;", "&#10;    ")))

(: End :)
