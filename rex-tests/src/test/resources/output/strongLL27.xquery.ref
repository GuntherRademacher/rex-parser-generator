xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sun Jun 6, 2021 17:04 (UTC+02) by REx v5.53 which is Copyright (c) 1979-2021 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q strongLL27.ebnf -xquery -ll 27 -a xquery :)

                                                                      (: line 68 "strongLL27.ebnf" :)
                                                                      declare namespace p="strongLL27";
                                                                      declare option saxon:output "method=text";
                                                                      (: line 10 "strongLL27.xquery" :)
(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the code of the
 : level-4-lookahead token.
 :)
declare variable $p:l4 as xs:integer := 13;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-4-lookahead token.
 :)
declare variable $p:b4 as xs:integer := 14;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-4-lookahead token.
 :)
declare variable $p:e4 as xs:integer := 15;

(:~
 : The index of the lexer state for accessing the code of the
 : level-5-lookahead token.
 :)
declare variable $p:l5 as xs:integer := 16;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-5-lookahead token.
 :)
declare variable $p:b5 as xs:integer := 17;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-5-lookahead token.
 :)
declare variable $p:e5 as xs:integer := 18;

(:~
 : The index of the lexer state for accessing the code of the
 : level-6-lookahead token.
 :)
declare variable $p:l6 as xs:integer := 19;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-6-lookahead token.
 :)
declare variable $p:b6 as xs:integer := 20;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-6-lookahead token.
 :)
declare variable $p:e6 as xs:integer := 21;

(:~
 : The index of the lexer state for accessing the code of the
 : level-7-lookahead token.
 :)
declare variable $p:l7 as xs:integer := 22;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-7-lookahead token.
 :)
declare variable $p:b7 as xs:integer := 23;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-7-lookahead token.
 :)
declare variable $p:e7 as xs:integer := 24;

(:~
 : The index of the lexer state for accessing the code of the
 : level-8-lookahead token.
 :)
declare variable $p:l8 as xs:integer := 25;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-8-lookahead token.
 :)
declare variable $p:b8 as xs:integer := 26;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-8-lookahead token.
 :)
declare variable $p:e8 as xs:integer := 27;

(:~
 : The index of the lexer state for accessing the code of the
 : level-9-lookahead token.
 :)
declare variable $p:l9 as xs:integer := 28;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-9-lookahead token.
 :)
declare variable $p:b9 as xs:integer := 29;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-9-lookahead token.
 :)
declare variable $p:e9 as xs:integer := 30;

(:~
 : The index of the lexer state for accessing the code of the
 : level-10-lookahead token.
 :)
declare variable $p:l10 as xs:integer := 31;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-10-lookahead token.
 :)
declare variable $p:b10 as xs:integer := 32;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-10-lookahead token.
 :)
declare variable $p:e10 as xs:integer := 33;

(:~
 : The index of the lexer state for accessing the code of the
 : level-11-lookahead token.
 :)
declare variable $p:l11 as xs:integer := 34;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-11-lookahead token.
 :)
declare variable $p:b11 as xs:integer := 35;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-11-lookahead token.
 :)
declare variable $p:e11 as xs:integer := 36;

(:~
 : The index of the lexer state for accessing the code of the
 : level-12-lookahead token.
 :)
declare variable $p:l12 as xs:integer := 37;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-12-lookahead token.
 :)
declare variable $p:b12 as xs:integer := 38;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-12-lookahead token.
 :)
declare variable $p:e12 as xs:integer := 39;

(:~
 : The index of the lexer state for accessing the code of the
 : level-13-lookahead token.
 :)
declare variable $p:l13 as xs:integer := 40;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-13-lookahead token.
 :)
declare variable $p:b13 as xs:integer := 41;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-13-lookahead token.
 :)
declare variable $p:e13 as xs:integer := 42;

(:~
 : The index of the lexer state for accessing the code of the
 : level-14-lookahead token.
 :)
declare variable $p:l14 as xs:integer := 43;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-14-lookahead token.
 :)
declare variable $p:b14 as xs:integer := 44;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-14-lookahead token.
 :)
declare variable $p:e14 as xs:integer := 45;

(:~
 : The index of the lexer state for accessing the code of the
 : level-15-lookahead token.
 :)
declare variable $p:l15 as xs:integer := 46;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-15-lookahead token.
 :)
declare variable $p:b15 as xs:integer := 47;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-15-lookahead token.
 :)
declare variable $p:e15 as xs:integer := 48;

(:~
 : The index of the lexer state for accessing the code of the
 : level-16-lookahead token.
 :)
declare variable $p:l16 as xs:integer := 49;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-16-lookahead token.
 :)
declare variable $p:b16 as xs:integer := 50;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-16-lookahead token.
 :)
declare variable $p:e16 as xs:integer := 51;

(:~
 : The index of the lexer state for accessing the code of the
 : level-17-lookahead token.
 :)
declare variable $p:l17 as xs:integer := 52;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-17-lookahead token.
 :)
declare variable $p:b17 as xs:integer := 53;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-17-lookahead token.
 :)
declare variable $p:e17 as xs:integer := 54;

(:~
 : The index of the lexer state for accessing the code of the
 : level-18-lookahead token.
 :)
declare variable $p:l18 as xs:integer := 55;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-18-lookahead token.
 :)
declare variable $p:b18 as xs:integer := 56;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-18-lookahead token.
 :)
declare variable $p:e18 as xs:integer := 57;

(:~
 : The index of the lexer state for accessing the code of the
 : level-19-lookahead token.
 :)
declare variable $p:l19 as xs:integer := 58;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-19-lookahead token.
 :)
declare variable $p:b19 as xs:integer := 59;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-19-lookahead token.
 :)
declare variable $p:e19 as xs:integer := 60;

(:~
 : The index of the lexer state for accessing the code of the
 : level-20-lookahead token.
 :)
declare variable $p:l20 as xs:integer := 61;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-20-lookahead token.
 :)
declare variable $p:b20 as xs:integer := 62;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-20-lookahead token.
 :)
declare variable $p:e20 as xs:integer := 63;

(:~
 : The index of the lexer state for accessing the code of the
 : level-21-lookahead token.
 :)
declare variable $p:l21 as xs:integer := 64;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-21-lookahead token.
 :)
declare variable $p:b21 as xs:integer := 65;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-21-lookahead token.
 :)
declare variable $p:e21 as xs:integer := 66;

(:~
 : The index of the lexer state for accessing the code of the
 : level-22-lookahead token.
 :)
declare variable $p:l22 as xs:integer := 67;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-22-lookahead token.
 :)
declare variable $p:b22 as xs:integer := 68;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-22-lookahead token.
 :)
declare variable $p:e22 as xs:integer := 69;

(:~
 : The index of the lexer state for accessing the code of the
 : level-23-lookahead token.
 :)
declare variable $p:l23 as xs:integer := 70;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-23-lookahead token.
 :)
declare variable $p:b23 as xs:integer := 71;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-23-lookahead token.
 :)
declare variable $p:e23 as xs:integer := 72;

(:~
 : The index of the lexer state for accessing the code of the
 : level-24-lookahead token.
 :)
declare variable $p:l24 as xs:integer := 73;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-24-lookahead token.
 :)
declare variable $p:b24 as xs:integer := 74;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-24-lookahead token.
 :)
declare variable $p:e24 as xs:integer := 75;

(:~
 : The index of the lexer state for accessing the code of the
 : level-25-lookahead token.
 :)
declare variable $p:l25 as xs:integer := 76;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-25-lookahead token.
 :)
declare variable $p:b25 as xs:integer := 77;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-25-lookahead token.
 :)
declare variable $p:e25 as xs:integer := 78;

(:~
 : The index of the lexer state for accessing the code of the
 : level-26-lookahead token.
 :)
declare variable $p:l26 as xs:integer := 79;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-26-lookahead token.
 :)
declare variable $p:b26 as xs:integer := 80;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-26-lookahead token.
 :)
declare variable $p:e26 as xs:integer := 81;

(:~
 : The index of the lexer state for accessing the code of the
 : level-27-lookahead token.
 :)
declare variable $p:l27 as xs:integer := 82;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-27-lookahead token.
 :)
declare variable $p:b27 as xs:integer := 83;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-27-lookahead token.
 :)
declare variable $p:e27 as xs:integer := 84;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 85;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 86;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
  17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  54, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
  58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 117, 117, 117, 90,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 0, 26, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
  20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 90, 27
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  159, 159, 159, 159, 109, 159, 159, 108, 117, 159, 159, 117, 264, 159, 159, 265, 201, 159, 159, 203, 142, 159, 159,
  145, 120, 159, 159, 128, 160, 159, 159, 139, 159, 158, 159, 156, 159, 169, 159, 168, 159, 177, 159, 177, 159, 278,
  159, 279, 159, 215, 159, 217, 159, 180, 159, 183, 159, 148, 159, 197, 159, 228, 159, 211, 159, 159, 227, 225, 159,
  159, 237, 236, 159, 159, 245, 245, 159, 159, 292, 293, 159, 159, 249, 251, 159, 159, 186, 189, 159, 159, 131, 259,
  159, 159, 310, 273, 159, 159, 159, 287, 159, 159, 159, 301, 309, 159, 159, 307, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0,
  160, 0, 0, 0, 0, 0, 0, 288, 0, 0, 0, 288, 0, 0, 0, 0, 0, 0, 800, 0, 0, 0, 320, 0, 0, 0, 0, 0, 256, 0, 0, 0, 0, 0, 0,
  544, 0, 0, 0, 352, 0, 0, 0, 0, 0, 0, 0, 0, 320, 0, 0, 384, 0, 0, 0, 0, 0, 0, 0, 0, 416, 0, 0, 0, 0, 0, 512, 0, 0, 0,
  0, 0, 768, 0, 0, 0, 0, 0, 0, 0, 544, 0, 0, 0, 0, 0, 224, 0, 0, 0, 0, 0, 0, 0, 576, 0, 0, 0, 0, 0, 480, 0, 0, 0, 0, 0,
  0, 0, 608, 0, 0, 0, 0, 0, 0, 0, 576, 0, 0, 640, 0, 0, 0, 0, 0, 0, 0, 0, 672, 0, 0, 0, 0, 0, 736, 0, 0, 0, 0, 0, 0, 0,
  800, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 0, 832, 0, 0, 0, 0, 0, 448, 0, 0, 0, 0, 0, 864, 0, 864, 0, 0, 0, 0, 0, 704,
  0, 0, 0, 0, 0, 0, 896, 896, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 832
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576,
  2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435452
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "END",
  "'a'",
  "'b'",
  "'c'",
  "'d'",
  "'e'",
  "'f'",
  "'g'",
  "'h'",
  "'i'",
  "'j'",
  "'k'",
  "'l'",
  "'m'",
  "'n'",
  "'o'",
  "'p'",
  "'q'",
  "'r'",
  "'s'",
  "'t'",
  "'u'",
  "'v'",
  "'w'",
  "'x'",
  "'y'",
  "'z'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 32,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 32
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 32
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 32 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        0
    let $current := $current + 1
    let $i0 := 32 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 8
    let $next-state := $p:TRANSITION[$i0 mod 8 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 31) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 32, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 0
    let $i0 := $t * 27 + $state - 1
    return p:token((), $p:EXPECTED[$i0 + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Parse y.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-y($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(27, $input, $state)            (: 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' |
                                                               'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' |
                                                               's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' :)
  let $state :=
    if ($state[$p:l1] = 26) then                            (: 'y' :)
      let $state := p:lookahead2(32, 27, $input, $state)    (: 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' |
                                                               'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' |
                                                               's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' :)
      let $state :=
        if ($state[$p:lk] = 59) then                        (: 'y' 'z' :)
          let $state := p:lookahead3(64, 26, $input, $state) (: END | 'z' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 34                             (: 'y' 'a' :)
          or $state[$p:lk] = 35                             (: 'y' 'b' :)
          or $state[$p:lk] = 36                             (: 'y' 'c' :)
          or $state[$p:lk] = 37                             (: 'y' 'd' :)
          or $state[$p:lk] = 38                             (: 'y' 'e' :)
          or $state[$p:lk] = 39                             (: 'y' 'f' :)
          or $state[$p:lk] = 40                             (: 'y' 'g' :)
          or $state[$p:lk] = 41                             (: 'y' 'h' :)
          or $state[$p:lk] = 42                             (: 'y' 'i' :)
          or $state[$p:lk] = 43                             (: 'y' 'j' :)
          or $state[$p:lk] = 44                             (: 'y' 'k' :)
          or $state[$p:lk] = 45                             (: 'y' 'l' :)
          or $state[$p:lk] = 46                             (: 'y' 'm' :)
          or $state[$p:lk] = 47                             (: 'y' 'n' :)
          or $state[$p:lk] = 48                             (: 'y' 'o' :)
          or $state[$p:lk] = 49                             (: 'y' 'p' :)
          or $state[$p:lk] = 50                             (: 'y' 'q' :)
          or $state[$p:lk] = 51                             (: 'y' 'r' :)
          or $state[$p:lk] = 52                             (: 'y' 's' :)
          or $state[$p:lk] = 53                             (: 'y' 't' :)
          or $state[$p:lk] = 54                             (: 'y' 'u' :)
          or $state[$p:lk] = 55                             (: 'y' 'v' :)
          or $state[$p:lk] = 56                             (: 'y' 'w' :)
          or $state[$p:lk] = 57                             (: 'y' 'x' :)
          or $state[$p:lk] = 58                             (: 'y' 'y' :)
          or $state[$p:lk] = 91) then                       (: 'y' 'z' 'z' :)
      let $state := p:consume(26, $input, $state)           (: 'y' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse a.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-a($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(0, $input, $state)             (: 'a' :)
  let $state :=
    if ($state[$p:l1] = 2) then                             (: 'a' :)
      let $state := p:lookahead2(32, 1, $input, $state)     (: 'b' :)
      let $state :=
        if ($state[$p:lk] = 35) then                        (: 'a' 'b' :)
          let $state := p:lookahead3(64, 2, $input, $state) (: 'c' :)
          let $state :=
            if ($state[$p:lk] = 68) then                    (: 'a' 'b' 'c' :)
              let $state := p:lookahead4(96, 3, $input, $state) (: 'd' :)
              let $state :=
                if ($state[$p:lk] = 101) then               (: 'a' 'b' 'c' 'd' :)
                  let $state := p:lookahead5(128, 4, $input, $state) (: 'e' :)
                  let $state :=
                    if ($state[$p:lk] = 134) then           (: 'a' 'b' 'c' 'd' 'e' :)
                      let $state := p:lookahead6(160, 5, $input, $state) (: 'f' :)
                      let $state :=
                        if ($state[$p:lk] = 167) then       (: 'a' 'b' 'c' 'd' 'e' 'f' :)
                          let $state := p:lookahead7(192, 6, $input, $state) (: 'g' :)
                          let $state :=
                            if ($state[$p:lk] = 200) then   (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' :)
                              let $state := p:lookahead8(224, 7, $input, $state) (: 'h' :)
                              let $state :=
                                if ($state[$p:lk] = 233) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' :)
                                  let $state := p:lookahead9(256, 8, $input, $state) (: 'i' :)
                                  let $state :=
                                    if ($state[$p:lk] = 266) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' :)
                                      let $state := p:lookahead10(288, 9, $input, $state) (: 'j' :)
                                      let $state :=
                                        if ($state[$p:lk] = 299) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' :)
                                          let $state := p:lookahead11(320, 10, $input, $state) (: 'k' :)
                                          let $state :=
                                            if ($state[$p:lk] = 332) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' :)
                                              let $state := p:lookahead12(352, 11, $input, $state) (: 'l' :)
                                              let $state :=
                                                if ($state[$p:lk] = 365) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i'
                                                                                 'j' 'k' 'l' :)
                                                  let $state := p:lookahead13(384, 12, $input, $state) (: 'm' :)
                                                  let $state :=
                                                    if ($state[$p:lk] = 398) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h'
                                                                                     'i' 'j' 'k' 'l' 'm' :)
                                                      let $state := p:lookahead14(416, 13, $input, $state) (: 'n' :)
                                                      let $state :=
                                                        if ($state[$p:lk] = 431) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                         'h' 'i' 'j' 'k' 'l' 'm' 'n' :)
                                                          let $state := p:lookahead15(448, 14, $input, $state) (: 'o' :)
                                                          let $state :=
                                                            if ($state[$p:lk] = 464) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                             'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                             'o' :)
                                                              let $state := p:lookahead16(480, 15, $input, $state) (: 'p' :)
                                                              let $state :=
                                                                if ($state[$p:lk] = 497) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                 'o' 'p' :)
                                                                  let $state := p:lookahead17(512, 16, $input, $state) (: 'q' :)
                                                                  let $state :=
                                                                    if ($state[$p:lk] = 530) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                     'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                     'o' 'p' 'q' :)
                                                                      let $state := p:lookahead18(544, 17, $input, $state) (: 'r' :)
                                                                      let $state :=
                                                                        if ($state[$p:lk] = 563) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                         'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                         'o' 'p' 'q' 'r' :)
                                                                          let $state := p:lookahead19(576, 18, $input, $state) (: 's' :)
                                                                          let $state :=
                                                                            if ($state[$p:lk] = 596) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                             'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                             'o' 'p' 'q' 'r' 's' :)
                                                                              let $state := p:lookahead20(608, 19, $input, $state) (: 't' :)
                                                                              let $state :=
                                                                                if ($state[$p:lk] = 629) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                                 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                                 'o' 'p' 'q' 'r' 's' 't' :)
                                                                                  let $state := p:lookahead21(640, 20, $input, $state) (: 'u' :)
                                                                                  let $state :=
                                                                                    if ($state[$p:lk] = 662) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                                     'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                                     'o' 'p' 'q' 'r' 's' 't' 'u' :)
                                                                                      let $state := p:lookahead22(672, 21, $input, $state) (: 'v' :)
                                                                                      let $state :=
                                                                                        if ($state[$p:lk] = 695) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                                         'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                                         'o' 'p' 'q' 'r' 's' 't' 'u'
                                                                                                                         'v' :)
                                                                                          let $state := p:lookahead23(704, 22, $input, $state) (: 'w' :)
                                                                                          let $state :=
                                                                                            if ($state[$p:lk] = 728) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                                             'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                                             'o' 'p' 'q' 'r' 's' 't' 'u'
                                                                                                                             'v' 'w' :)
                                                                                              let $state := p:lookahead24(736, 23, $input, $state) (: 'x' :)
                                                                                              let $state :=
                                                                                                if ($state[$p:lk] = 761) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                                                 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                                                 'o' 'p' 'q' 'r' 's' 't' 'u'
                                                                                                                                 'v' 'w' 'x' :)
                                                                                                  let $state := p:lookahead25(768, 27, $input, $state) (: 'a' | 'b' | 'c' | 'd' | 'e' |
                                                                                                                                                          'f' | 'g' | 'h' | 'i' | 'j' |
                                                                                                                                                          'k' | 'l' | 'm' | 'n' | 'o' |
                                                                                                                                                          'p' | 'q' | 'r' | 's' | 't' |
                                                                                                                                                          'u' | 'v' | 'w' | 'x' | 'y' |
                                                                                                                                                          'z' :)
                                                                                                  let $state :=
                                                                                                    if ($state[$p:lk] = 794) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                                                     'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                                                     'o' 'p' 'q' 'r' 's' 't' 'u'
                                                                                                                                     'v' 'w' 'x' 'y' :)
                                                                                                      let $state := p:lookahead26(800, 27, $input, $state) (: 'a' | 'b' | 'c' | 'd' | 'e' |
                                                                                                                                                              'f' | 'g' | 'h' | 'i' | 'j' |
                                                                                                                                                              'k' | 'l' | 'm' | 'n' | 'o' |
                                                                                                                                                              'p' | 'q' | 'r' | 's' | 't' |
                                                                                                                                                              'u' | 'v' | 'w' | 'x' | 'y' |
                                                                                                                                                              'z' :)
                                                                                                      let $state :=
                                                                                                        if ($state[$p:lk] = 827) then (: 'a' 'b' 'c' 'd' 'e' 'f' 'g'
                                                                                                                                         'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                                                                                                         'o' 'p' 'q' 'r' 's' 't' 'u'
                                                                                                                                         'v' 'w' 'x' 'y' 'z' :)
                                                                                                          let $state := p:lookahead27(832, 26, $input, $state) (: END | 'z' :)
                                                                                                          return $state
                                                                                                        else
                                                                                                          $state
                                                                                                      return $state
                                                                                                    else
                                                                                                      $state
                                                                                                  return $state
                                                                                                else
                                                                                                  $state
                                                                                              return $state
                                                                                            else
                                                                                              $state
                                                                                          return $state
                                                                                        else
                                                                                          $state
                                                                                      return $state
                                                                                    else
                                                                                      $state
                                                                                  return $state
                                                                                else
                                                                                  $state
                                                                              return $state
                                                                            else
                                                                              $state
                                                                          return $state
                                                                        else
                                                                          $state
                                                                      return $state
                                                                    else
                                                                      $state
                                                                  return $state
                                                                else
                                                                  $state
                                                              return $state
                                                            else
                                                              $state
                                                          return $state
                                                        else
                                                          $state
                                                      return $state
                                                    else
                                                      $state
                                                  return $state
                                                else
                                                  $state
                                              return $state
                                            else
                                              $state
                                          return $state
                                        else
                                          $state
                                      return $state
                                    else
                                      $state
                                  return $state
                                else
                                  $state
                              return $state
                            else
                              $state
                          return $state
                        else
                          $state
                      return $state
                    else
                      $state
                  return $state
                else
                  $state
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 770                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'a' :)
          or $state[$p:lk] = 802) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'a' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(0, $input, $state)         (: 'a' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 771                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'b' :)
          or $state[$p:lk] = 803) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'b' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 772                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'c' :)
          or $state[$p:lk] = 804) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'c' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 773                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'd' :)
          or $state[$p:lk] = 805) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'd' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 774                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'e' :)
          or $state[$p:lk] = 806) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'e' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 775                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'f' :)
          or $state[$p:lk] = 807) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'f' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 776                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'g' :)
          or $state[$p:lk] = 808) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'g' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 777                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'h' :)
          or $state[$p:lk] = 809) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'h' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 778                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'i' :)
          or $state[$p:lk] = 810) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'i' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 779                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'j' :)
          or $state[$p:lk] = 811) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'j' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 780                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'k' :)
          or $state[$p:lk] = 812) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'k' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 781                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'l' :)
          or $state[$p:lk] = 813) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'l' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 782                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'm' :)
          or $state[$p:lk] = 814) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'm' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 783                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'n' :)
          or $state[$p:lk] = 815) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'n' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 784                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'o' :)
          or $state[$p:lk] = 816) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'o' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 785                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'p' :)
          or $state[$p:lk] = 817) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'p' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 786                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'q' :)
          or $state[$p:lk] = 818) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'q' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 787                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'r' :)
          or $state[$p:lk] = 819) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'r' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 788                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 's' :)
          or $state[$p:lk] = 820) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 's' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 789                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 't' :)
          or $state[$p:lk] = 821) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 't' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 790                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'u' :)
          or $state[$p:lk] = 822) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'u' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 791                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'v' :)
          or $state[$p:lk] = 823) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'v' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 792                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'w' :)
          or $state[$p:lk] = 824) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'w' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 793                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'x' :)
          or $state[$p:lk] = 825) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'x' :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else if ($state[$p:lk] = 826                            (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'y' :)
          or $state[$p:lk] = 833) then                      (: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
                                                               'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' END :)
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(24, $input, $state)        (: 'y' :)
      let $state := p:consume(26, $input, $state)           (: 'y' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
    else
      let $state := p:consume(2, $input, $state)            (: 'a' :)
      let $state := p:lookahead1(1, $input, $state)         (: 'b' :)
      let $state := p:consume(3, $input, $state)            (: 'b' :)
      let $state := p:lookahead1(2, $input, $state)         (: 'c' :)
      let $state := p:consume(4, $input, $state)            (: 'c' :)
      let $state := p:lookahead1(3, $input, $state)         (: 'd' :)
      let $state := p:consume(5, $input, $state)            (: 'd' :)
      let $state := p:lookahead1(4, $input, $state)         (: 'e' :)
      let $state := p:consume(6, $input, $state)            (: 'e' :)
      let $state := p:lookahead1(5, $input, $state)         (: 'f' :)
      let $state := p:consume(7, $input, $state)            (: 'f' :)
      let $state := p:lookahead1(6, $input, $state)         (: 'g' :)
      let $state := p:consume(8, $input, $state)            (: 'g' :)
      let $state := p:lookahead1(7, $input, $state)         (: 'h' :)
      let $state := p:consume(9, $input, $state)            (: 'h' :)
      let $state := p:lookahead1(8, $input, $state)         (: 'i' :)
      let $state := p:consume(10, $input, $state)           (: 'i' :)
      let $state := p:lookahead1(9, $input, $state)         (: 'j' :)
      let $state := p:consume(11, $input, $state)           (: 'j' :)
      let $state := p:lookahead1(10, $input, $state)        (: 'k' :)
      let $state := p:consume(12, $input, $state)           (: 'k' :)
      let $state := p:lookahead1(11, $input, $state)        (: 'l' :)
      let $state := p:consume(13, $input, $state)           (: 'l' :)
      let $state := p:lookahead1(12, $input, $state)        (: 'm' :)
      let $state := p:consume(14, $input, $state)           (: 'm' :)
      let $state := p:lookahead1(13, $input, $state)        (: 'n' :)
      let $state := p:consume(15, $input, $state)           (: 'n' :)
      let $state := p:lookahead1(14, $input, $state)        (: 'o' :)
      let $state := p:consume(16, $input, $state)           (: 'o' :)
      let $state := p:lookahead1(15, $input, $state)        (: 'p' :)
      let $state := p:consume(17, $input, $state)           (: 'p' :)
      let $state := p:lookahead1(16, $input, $state)        (: 'q' :)
      let $state := p:consume(18, $input, $state)           (: 'q' :)
      let $state := p:lookahead1(17, $input, $state)        (: 'r' :)
      let $state := p:consume(19, $input, $state)           (: 'r' :)
      let $state := p:lookahead1(18, $input, $state)        (: 's' :)
      let $state := p:consume(20, $input, $state)           (: 's' :)
      let $state := p:lookahead1(19, $input, $state)        (: 't' :)
      let $state := p:consume(21, $input, $state)           (: 't' :)
      let $state := p:lookahead1(20, $input, $state)        (: 'u' :)
      let $state := p:consume(22, $input, $state)           (: 'u' :)
      let $state := p:lookahead1(21, $input, $state)        (: 'v' :)
      let $state := p:consume(23, $input, $state)           (: 'v' :)
      let $state := p:lookahead1(22, $input, $state)        (: 'w' :)
      let $state := p:consume(24, $input, $state)           (: 'w' :)
      let $state := p:lookahead1(23, $input, $state)        (: 'x' :)
      let $state := p:consume(25, $input, $state)           (: 'x' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-y($input, $state)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      let $state := p:lookahead1(25, $input, $state)        (: 'z' :)
      let $state := p:consume(27, $input, $state)           (: 'z' :)
      return $state
  return $state
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 81),
    0, 0, 0,
    subsequence($state, 85)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:match($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 6)
    else
    (
      p:match($input, $state[$p:e2], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 16)
  )
};

(:~
 : Lookahead one token on level 4.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead4($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l4] ne 0) then
      subsequence($state, $p:l4, 6)
    else
    (
      p:match($input, $state[$p:e3], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 11),
    $match,
    subsequence($state, 19)
  )
};

(:~
 : Lookahead one token on level 5.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead5($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l5] ne 0) then
      subsequence($state, $p:l5, 6)
    else
    (
      p:match($input, $state[$p:e4], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 14),
    $match,
    subsequence($state, 22)
  )
};

(:~
 : Lookahead one token on level 6.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead6($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l6] ne 0) then
      subsequence($state, $p:l6, 6)
    else
    (
      p:match($input, $state[$p:e5], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 17),
    $match,
    subsequence($state, 25)
  )
};

(:~
 : Lookahead one token on level 7.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead7($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l7] ne 0) then
      subsequence($state, $p:l7, 6)
    else
    (
      p:match($input, $state[$p:e6], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 20),
    $match,
    subsequence($state, 28)
  )
};

(:~
 : Lookahead one token on level 8.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead8($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l8] ne 0) then
      subsequence($state, $p:l8, 6)
    else
    (
      p:match($input, $state[$p:e7], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 23),
    $match,
    subsequence($state, 31)
  )
};

(:~
 : Lookahead one token on level 9.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead9($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l9] ne 0) then
      subsequence($state, $p:l9, 6)
    else
    (
      p:match($input, $state[$p:e8], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 26),
    $match,
    subsequence($state, 34)
  )
};

(:~
 : Lookahead one token on level 10.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead10($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l10] ne 0) then
      subsequence($state, $p:l10, 6)
    else
    (
      p:match($input, $state[$p:e9], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 29),
    $match,
    subsequence($state, 37)
  )
};

(:~
 : Lookahead one token on level 11.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead11($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l11] ne 0) then
      subsequence($state, $p:l11, 6)
    else
    (
      p:match($input, $state[$p:e10], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 32),
    $match,
    subsequence($state, 40)
  )
};

(:~
 : Lookahead one token on level 12.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead12($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l12] ne 0) then
      subsequence($state, $p:l12, 6)
    else
    (
      p:match($input, $state[$p:e11], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 35),
    $match,
    subsequence($state, 43)
  )
};

(:~
 : Lookahead one token on level 13.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead13($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l13] ne 0) then
      subsequence($state, $p:l13, 6)
    else
    (
      p:match($input, $state[$p:e12], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 38),
    $match,
    subsequence($state, 46)
  )
};

(:~
 : Lookahead one token on level 14.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead14($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l14] ne 0) then
      subsequence($state, $p:l14, 6)
    else
    (
      p:match($input, $state[$p:e13], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 41),
    $match,
    subsequence($state, 49)
  )
};

(:~
 : Lookahead one token on level 15.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead15($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l15] ne 0) then
      subsequence($state, $p:l15, 6)
    else
    (
      p:match($input, $state[$p:e14], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 44),
    $match,
    subsequence($state, 52)
  )
};

(:~
 : Lookahead one token on level 16.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead16($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l16] ne 0) then
      subsequence($state, $p:l16, 6)
    else
    (
      p:match($input, $state[$p:e15], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 47),
    $match,
    subsequence($state, 55)
  )
};

(:~
 : Lookahead one token on level 17.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead17($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l17] ne 0) then
      subsequence($state, $p:l17, 6)
    else
    (
      p:match($input, $state[$p:e16], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 50),
    $match,
    subsequence($state, 58)
  )
};

(:~
 : Lookahead one token on level 18.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead18($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l18] ne 0) then
      subsequence($state, $p:l18, 6)
    else
    (
      p:match($input, $state[$p:e17], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 53),
    $match,
    subsequence($state, 61)
  )
};

(:~
 : Lookahead one token on level 19.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead19($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l19] ne 0) then
      subsequence($state, $p:l19, 6)
    else
    (
      p:match($input, $state[$p:e18], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 56),
    $match,
    subsequence($state, 64)
  )
};

(:~
 : Lookahead one token on level 20.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead20($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l20] ne 0) then
      subsequence($state, $p:l20, 6)
    else
    (
      p:match($input, $state[$p:e19], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 59),
    $match,
    subsequence($state, 67)
  )
};

(:~
 : Lookahead one token on level 21.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead21($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l21] ne 0) then
      subsequence($state, $p:l21, 6)
    else
    (
      p:match($input, $state[$p:e20], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 62),
    $match,
    subsequence($state, 70)
  )
};

(:~
 : Lookahead one token on level 22.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead22($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l22] ne 0) then
      subsequence($state, $p:l22, 6)
    else
    (
      p:match($input, $state[$p:e21], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 65),
    $match,
    subsequence($state, 73)
  )
};

(:~
 : Lookahead one token on level 23.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead23($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l23] ne 0) then
      subsequence($state, $p:l23, 6)
    else
    (
      p:match($input, $state[$p:e22], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 68),
    $match,
    subsequence($state, 76)
  )
};

(:~
 : Lookahead one token on level 24.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead24($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l24] ne 0) then
      subsequence($state, $p:l24, 6)
    else
    (
      p:match($input, $state[$p:e23], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 71),
    $match,
    subsequence($state, 79)
  )
};

(:~
 : Lookahead one token on level 25.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead25($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l25] ne 0) then
      subsequence($state, $p:l25, 6)
    else
    (
      p:match($input, $state[$p:e24], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 74),
    $match,
    subsequence($state, 82)
  )
};

(:~
 : Lookahead one token on level 26.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead26($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l26] ne 0) then
      subsequence($state, $p:l26, 6)
    else
    (
      p:match($input, $state[$p:e25], $set),
      0, 0, 0
    )
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 77),
    $match,
    subsequence($state, 85)
  )
};

(:~
 : Lookahead one token on level 27.
 :
 : @param $prefix the prefix code representing lower level lookahead.
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead27($prefix as xs:integer, $set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l27] ne 0) then
      subsequence($state, $p:l27, 3)
    else
      p:match($input, $state[$p:e26], $set)
  return
  (
    $match[1] + $prefix,
    subsequence($state, $p:b0, 80),
    $match,
    subsequence($state, 85)
  )
};

(:~
 : Parse start symbol a from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-a($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-a($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

                                                                      (: line 103 "strongLL27.ebnf" :)
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyaz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxybz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxycz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxydz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyez"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyfz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxygz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyhz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyiz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyjz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxykz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxylz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxymz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxynz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyoz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxypz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyqz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyrz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxysz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxytz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyuz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyvz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxywz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyxz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyyz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyzz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxaz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxbz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxcz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxdz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxez"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxfz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxgz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxhz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxiz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxjz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxkz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxlz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxmz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxnz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxoz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxpz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxqz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxrz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxsz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxtz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxuz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxvz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxwz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxxz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxyz"),
                                                                      p:parse-a("abcdefghijklmnopqrstuvwxzz"),
                                                                      "pass"
                                                                      (: line 3521 "strongLL27.xquery" :)
(: End :)
