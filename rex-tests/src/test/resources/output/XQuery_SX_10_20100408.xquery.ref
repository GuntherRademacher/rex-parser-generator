xquery version "1.0" encoding "UTF-8";

(: This file was generated on Wed Sep 22, 2021 20:16 (UTC+02) by REx v5.54 which is Copyright (c) 1979-2021 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q XQuery_SX_10_20100408.ebnf -xquery -tree -main :)

declare namespace p="XQuery_SX_10_20100408";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  65, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 30, 30, 30, 30, 30, 30, 33, 30, 30, 30, 34, 30, 30, 35, 6, 36, 6, 30, 6, 37, 38,
  39, 40, 41, 42, 43, 44, 45, 30, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 30, 61, 62, 63, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 354, 370,
  386, 422, 422, 422, 414, 338, 330, 338, 330, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338,
  338, 338, 439, 439, 439, 439, 439, 439, 439, 323, 338, 338, 338, 338, 338, 338, 338, 338, 400, 422, 422, 423, 421,
  422, 422, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 337, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338,
  338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 338, 422, 65, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
  30, 30, 30, 30, 30, 33, 30, 30, 30, 34, 30, 30, 35, 6, 36, 6, 30, 6, 37, 38, 39, 40, 41, 42, 43, 44, 45, 30, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 30, 61, 62, 63, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 30, 6, 6,
  6, 6, 6, 6, 6, 64, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
  64, 64, 64, 64
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 6, 30, 6, 30, 30, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 12290, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 4113, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
  31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
  89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 8448, 8509, 8548, 8513, 8548, 8548, 8548, 8529, 8548,
  8550, 8545, 8566, 17625, 17625, 8582, 17625, 17625, 17625, 13166, 13173, 17625, 8603, 8609, 8871, 8625, 21959, 17222,
  8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818,
  8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003,
  9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258,
  9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563,
  9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 9805,
  9812, 11247, 9828, 17625, 17625, 8582, 17625, 17625, 9844, 13166, 13173, 17625, 8603, 8609, 8871, 9865, 21959, 17222,
  8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818,
  8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003,
  9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258,
  9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563,
  9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9881, 9897, 17625, 22022, 17625, 17625, 14436, 23423, 14432,
  17625, 16545, 9916, 17625, 17625, 8582, 17625, 17888, 17625, 13166, 13173, 17625, 8603, 8609, 8871, 9932, 21959,
  17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625,
  8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687,
  9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229,
  9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564,
  9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9948, 17625, 17625, 20582, 17625, 17625, 17625, 20021,
  17625, 17625, 17625, 9984, 17625, 17625, 10000, 17625, 10931, 17625, 13166, 13173, 17625, 8603, 8609, 8871, 10022,
  21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625,
  17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968,
  9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192,
  9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505,
  9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 10038, 17625, 21079, 10068, 17625, 10039,
  20021, 10040, 10039, 10056, 10086, 17625, 17625, 8582, 17625, 17625, 17625, 13166, 13173, 17625, 8603, 8609, 8871,
  8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594, 17625,
  17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903, 12380,
  8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157, 9176,
  9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445, 9489,
  9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 17625, 17625, 20582, 17625, 17625,
  17625, 20021, 17625, 17625, 17625, 10102, 17625, 17625, 8582, 17625, 17625, 17625, 13166, 13173, 17625, 8603, 8609,
  8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594,
  17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903,
  12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157,
  9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445,
  9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 17625, 17625, 20582, 17625,
  17625, 17625, 23378, 17625, 17625, 17625, 10118, 17625, 17625, 8582, 17625, 17625, 17625, 13166, 13173, 17625, 8603,
  8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594,
  17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903,
  12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157,
  9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445,
  9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 10134, 10150, 17625, 22482, 17625,
  17625, 15952, 12588, 15948, 17625, 18025, 8493, 17625, 17625, 8582, 17625, 12610, 17625, 13166, 13173, 17625, 8603,
  8609, 8871, 10169, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797,
  9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023,
  8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745,
  9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378,
  9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 10274, 10189, 10193,
  10185, 10189, 10189, 10282, 10260, 10209, 10246, 10298, 17625, 17625, 10314, 17625, 17625, 17625, 13166, 13173, 17625,
  8603, 8609, 8871, 8625, 21959, 21059, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797,
  9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023,
  8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745,
  9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378,
  9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 24201, 17625, 21276,
  10335, 17625, 10335, 18877, 8718, 8728, 8463, 8478, 17625, 17625, 10357, 17625, 17625, 17625, 13166, 13173, 17625,
  8603, 8609, 8871, 8625, 21959, 17752, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797,
  9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023,
  8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745,
  9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378,
  9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 17625, 17625, 20582,
  17625, 17625, 17625, 20021, 10392, 10400, 10378, 10416, 17625, 17625, 8582, 17625, 17625, 17625, 13166, 13173, 17625,
  8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 10432, 8755, 8776,
  8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887,
  13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173,
  9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429,
  13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 17625, 17625,
  20582, 17625, 17625, 17625, 20021, 10480, 10488, 25267, 10504, 17625, 17625, 8582, 17625, 17625, 17625, 13166, 13173,
  17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755,
  8776, 8797, 8983, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887,
  13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173,
  9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429,
  13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 20858, 17625,
  20582, 10520, 17625, 10555, 10579, 10595, 10602, 9900, 10618, 17625, 17625, 8582, 17625, 17625, 17625, 13166, 13173,
  17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755,
  8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887,
  13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173,
  9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429,
  13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 10634, 17625, 17625,
  20582, 17625, 17625, 17625, 20021, 10657, 10664, 9122, 10680, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501,
  17625, 17315, 16036, 10766, 10696, 17625, 17222, 21729, 17625, 18791, 10721, 15191, 14500, 17573, 23003, 23003, 24104,
  10766, 10766, 10766, 20825, 17625, 17625, 17625, 17625, 10718, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766,
  10766, 17622, 10738, 17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 17622, 17625,
  17625, 12984, 15191, 24101, 13409, 23003, 10766, 10765, 13786, 17625, 8987, 10721, 24095, 23003, 18428, 10766, 23207,
  17624, 17625, 23816, 23003, 14701, 18974, 17625, 10722, 10783, 16599, 14572, 20152, 21548, 25210, 18366, 10808, 20976,
  10849, 14699, 10898, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 9785, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 17625, 17625, 23791,
  10947, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 10963, 17625, 17222, 17625,
  17625, 17625, 10721, 15191, 14500, 17573, 23003, 23003, 24104, 10766, 10766, 10766, 17623, 17625, 17625, 17625, 17625,
  12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625, 17625, 17625, 17625, 15313, 14166,
  23003, 23003, 23003, 14697, 10766, 10766, 10766, 17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766,
  13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722,
  23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 10985,
  17625, 20582, 17625, 17625, 17625, 20021, 11005, 11029, 11021, 10102, 17625, 17625, 8582, 17625, 17625, 11045, 13166,
  13173, 17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802,
  8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284,
  8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154,
  9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473,
  9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 17625,
  17625, 20582, 17625, 17625, 17625, 20021, 17625, 17625, 14915, 11068, 17625, 17625, 8582, 17625, 17625, 17625, 15311,
  14501, 17625, 17315, 16036, 10766, 11084, 17625, 17222, 17625, 18082, 17625, 10721, 15191, 14500, 17573, 23003, 23003,
  24104, 10766, 10766, 10766, 11106, 17625, 17625, 17625, 25062, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766,
  10766, 10766, 11132, 17625, 17625, 17625, 8921, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 11182,
  17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766,
  10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700,
  17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 21350, 17625, 23398, 22180, 17625, 16181, 11213, 17625, 11204,
  17626, 11229, 11245, 17625, 11263, 17625, 17625, 17625, 13166, 13173, 17625, 11285, 11291, 11632, 8625, 21959, 15362,
  8641, 17625, 12826, 8659, 11566, 8703, 11307, 12053, 11347, 11696, 12084, 11756, 11381, 12098, 17625, 17625, 17625,
  8818, 8834, 8952, 8673, 11419, 11331, 11450, 11458, 11639, 11818, 11632, 11784, 8887, 13023, 8903, 12380, 8938, 11474,
  11320, 11943, 11504, 11912, 11520, 11771, 11392, 11536, 9092, 9112, 9138, 11581, 11597, 12029, 11608, 11624, 11655,
  11667, 9192, 9229, 9258, 11683, 11489, 11712, 11741, 11805, 11846, 9373, 11862, 11434, 11999, 11725, 9429, 13378,
  11900, 8687, 11884, 11928, 11959, 11975, 12015, 11875, 12045, 11365, 11359, 12069, 11830, 11989, 11403, 12117, 12131,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785, 10745,
  17625, 20582, 9062, 17625, 10749, 12152, 12168, 12175, 14439, 12191, 17625, 17625, 8582, 17625, 17625, 17625, 13166,
  13173, 17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802,
  8755, 8776, 8797, 9594, 17625, 17625, 17625, 12207, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871,
  9413, 8887, 13023, 8903, 15788, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 12223, 9092, 9112, 9138, 11581,
  9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457,
  9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733,
  9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785,
  17625, 17625, 20582, 17625, 17625, 17625, 24741, 12254, 12261, 23936, 12277, 17625, 17625, 8582, 17625, 17625, 9205,
  13166, 13173, 17625, 8603, 8609, 8871, 12293, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781,
  8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871,
  9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581,
  9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457,
  9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733,
  9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12309,
  12785, 17625, 20582, 17625, 17625, 17625, 20021, 12338, 12345, 10153, 12361, 12377, 17625, 8582, 17625, 17625, 12396,
  13166, 13173, 17625, 8603, 8609, 8871, 12421, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781,
  8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871,
  9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581,
  9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457,
  9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733,
  9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12437,
  12447, 17625, 20582, 17625, 17625, 17625, 20021, 12481, 12488, 12467, 12504, 12520, 17625, 8582, 17625, 17625, 10530,
  13166, 13173, 17625, 8603, 8609, 8871, 12537, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781,
  8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871,
  9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581,
  9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457,
  9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733,
  9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12553,
  17625, 17625, 20582, 12604, 17625, 17625, 20021, 13523, 11116, 17625, 12626, 17625, 17625, 8582, 17625, 17625, 12642,
  13166, 13173, 17625, 8603, 8609, 8871, 12663, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781,
  8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871,
  9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581,
  9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457,
  9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733,
  9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 9785,
  17625, 17625, 20582, 17625, 17625, 17625, 20021, 17625, 17625, 9242, 12679, 17625, 17625, 8582, 17625, 17625, 17625,
  13166, 13173, 17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781,
  8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871,
  9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581,
  9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457,
  9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733,
  9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695,
  17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625, 17625, 8582, 17625, 17625, 17625,
  15311, 14501, 17625, 17315, 16036, 10766, 10696, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003,
  23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625, 17625, 8922, 12985, 15191, 18320, 23003, 23003, 23003, 20994,
  10766, 10766, 10766, 16612, 17625, 17625, 17625, 8921, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766,
  11182, 17625, 17625, 13237, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594,
  10766, 10766, 17624, 17625, 12732, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334,
  14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064,
  15174, 14778, 12716, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 10696, 17625,
  17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625,
  17625, 8922, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 16612, 17625, 17625, 17625, 8921,
  15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 11182, 17625, 17625, 12984, 15191, 24101, 23003, 23003,
  10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786,
  17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787,
  17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625, 17625, 8582, 17625, 17625,
  17625, 15311, 14501, 17625, 17315, 16036, 10766, 10696, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136,
  23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625, 17625, 8922, 12760, 15191, 18320, 23003, 23003, 23003,
  20994, 10766, 10766, 10766, 16612, 17625, 17625, 17625, 8921, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766,
  10766, 11182, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003,
  24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766,
  25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021,
  24064, 15174, 14778, 12716, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 10696,
  17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625,
  17625, 17625, 8922, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 16612, 17625, 17625, 17625,
  12405, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 11182, 17625, 17625, 12984, 15191, 24101, 23003,
  23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701,
  13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137,
  14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625, 17625, 8582, 17625,
  17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 12779, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500,
  16136, 23003, 23003, 22893, 10766, 10766, 10766, 12801, 17625, 17625, 17625, 8922, 12985, 15191, 18320, 23003, 23003,
  23003, 20994, 10766, 10766, 10766, 16612, 17625, 17625, 17625, 8921, 15313, 14166, 23003, 23003, 23003, 14697, 10766,
  10766, 10766, 11182, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095,
  23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003,
  10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625,
  20021, 24064, 15174, 14778, 12716, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766,
  10696, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623,
  17625, 17625, 17625, 17625, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625, 17625,
  17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 17622, 17625, 17625, 12984, 15191, 24101,
  23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003,
  14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689,
  24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625, 17625, 8582,
  17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 12820, 17625, 17222, 17625, 17625, 17625, 10721, 15191,
  14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625, 17625, 17625, 12985, 15191, 18320, 23003,
  23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625, 17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697,
  10766, 10766, 10766, 17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721,
  24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152,
  23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 17625,
  17625, 20021, 24064, 15174, 14778, 12842, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036,
  10766, 10696, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766,
  17623, 17625, 17625, 17625, 17625, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625,
  17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 17622, 17625, 17625, 12984, 15191,
  24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816,
  23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694,
  14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625, 17625,
  8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 10696, 17625, 17222, 17625, 17625, 17625, 10721,
  15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625, 17625, 17625, 12985, 15191, 18320,
  23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625, 17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003,
  14697, 10766, 10766, 10766, 17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625,
  22633, 24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572,
  20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12858, 17625, 17625, 20582, 17625,
  17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315,
  16036, 10766, 10696, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766,
  10766, 17623, 17625, 17625, 17625, 17625, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622,
  17625, 17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 17622, 17625, 17625, 12984,
  15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625,
  23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699,
  14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 9785, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 12879, 12894, 15955, 10102, 17625,
  17625, 8582, 17625, 17625, 17625, 13166, 13173, 17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 10833, 8659,
  11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459,
  8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031,
  9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337,
  9357, 9373, 9400, 9465, 9457, 9473, 9429, 11551, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871,
  9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 12924, 17625, 17625, 20582, 17625, 17625, 17625, 16625, 14620, 14630, 14269, 12951, 17625,
  17625, 8582, 17625, 17625, 17625, 13166, 13173, 17625, 8603, 8609, 8871, 12967, 21959, 17222, 8641, 17625, 12826,
  8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849,
  10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009,
  9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317,
  9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622,
  8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 12695, 14289, 17625, 20582, 15753, 12983, 13001, 13039, 13055, 13065, 13081, 13097,
  13113, 13137, 13153, 13189, 13210, 13253, 13280, 13325, 13365, 13394, 18351, 21432, 13429, 17625, 17222, 23166, 13456,
  17625, 10721, 15191, 13492, 23101, 23003, 23003, 20945, 10766, 10766, 19933, 17623, 13519, 13539, 18912, 8922, 10702,
  13578, 13599, 16995, 23003, 16785, 20994, 16234, 10766, 13649, 16612, 13676, 20866, 25372, 16190, 13699, 13726, 18747,
  14950, 13309, 14697, 13761, 24526, 13783, 13802, 13228, 12647, 12984, 15191, 24101, 23003, 21593, 10766, 10766, 13827,
  13853, 13876, 10721, 24095, 23003, 24594, 10766, 10766, 17403, 17625, 23816, 16030, 13927, 24385, 21845, 13967, 23002,
  14701, 14572, 20152, 23003, 10766, 25334, 14700, 13988, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 12804, 17625,
  20582, 17625, 14012, 17625, 14030, 14046, 14056, 14072, 14088, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501,
  17625, 17315, 16036, 10766, 10696, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893,
  10766, 10766, 10766, 17623, 17625, 17625, 17625, 14104, 12985, 15191, 14128, 23003, 23003, 23023, 20994, 10766, 10766,
  24914, 16612, 17625, 17625, 17625, 8921, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 11182, 24819,
  17625, 10563, 14163, 20237, 23003, 23003, 14182, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766,
  17624, 12863, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 22875, 23003, 10766, 25334, 14700, 17312,
  24857, 14205, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 14265, 20582, 17625, 14285, 21951, 14305, 14321, 14335, 14351,
  14367, 17625, 24298, 8582, 19034, 17625, 17625, 15311, 14501, 17625, 17315, 18532, 13767, 10696, 17625, 17222, 14383,
  14402, 14419, 18263, 14455, 25092, 9534, 19710, 23003, 22893, 14478, 10766, 10766, 17623, 21342, 17625, 17625, 21925,
  12985, 14494, 18320, 13613, 23003, 13627, 16570, 23721, 10767, 14517, 16612, 17625, 17625, 17625, 14534, 15313, 14166,
  23003, 23003, 23003, 14697, 10766, 10766, 10766, 11182, 17625, 17625, 12984, 15191, 24101, 23003, 13741, 10766, 10766,
  14568, 17625, 17625, 25070, 14588, 25128, 24594, 15098, 10766, 14610, 17625, 14646, 21152, 14701, 14681, 17625, 10722,
  23002, 14717, 20788, 20152, 23003, 10766, 25334, 14700, 17312, 20371, 14738, 14694, 14689, 24137, 14787, 14765, 17399,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625,
  14809, 20582, 17625, 14811, 14827, 21705, 14846, 14856, 14872, 14888, 17625, 17625, 8582, 17625, 17625, 19147, 19166,
  14501, 14904, 14931, 16036, 14966, 10696, 22688, 14986, 23572, 24770, 20686, 15017, 15192, 15046, 15062, 23003, 21566,
  22893, 15097, 18993, 15114, 17623, 17625, 17625, 17625, 8922, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766,
  10766, 10766, 16612, 15131, 17485, 10969, 8921, 15313, 14166, 20247, 23003, 23003, 24849, 15150, 10766, 23740, 11182,
  17625, 17625, 15168, 15190, 20631, 23003, 15208, 15225, 24037, 13786, 11269, 18799, 15244, 15266, 15544, 24594, 24129,
  15288, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 15308, 23002, 15672, 25326, 20152, 23003, 10766, 25334, 14700,
  17927, 15329, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 13554, 20582, 19416, 15356, 12568, 15378, 15394, 15404,
  15420, 15436, 20539, 21680, 15452, 16509, 22143, 15134, 15514, 15560, 15614, 15657, 15693, 15709, 12779, 22174, 15891,
  24713, 17625, 15747, 23518, 15191, 15769, 16136, 23233, 15864, 19721, 15677, 22372, 15804, 15820, 15836, 15880, 15907,
  15935, 12908, 15971, 16001, 16017, 16052, 16081, 16116, 16152, 21986, 20776, 16168, 13219, 9960, 13013, 10539, 15575,
  19111, 25301, 16206, 20908, 18379, 16223, 14518, 16257, 16273, 16295, 16312, 16328, 16349, 15985, 16403, 16447, 16475,
  22280, 16525, 17625, 21833, 10641, 16561, 16586, 17706, 16641, 16662, 17731, 16704, 16739, 16774, 16801, 16826, 16863,
  10722, 22889, 23277, 14572, 16887, 13745, 22040, 16936, 17713, 16952, 16976, 17011, 17037, 14689, 18140, 17053, 17387,
  17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695,
  17625, 16871, 20582, 17625, 17079, 16867, 17102, 17118, 17128, 17144, 17160, 17625, 21463, 8582, 17625, 17176, 17625,
  13467, 17600, 17502, 19964, 20637, 17197, 10696, 17217, 17222, 17625, 9849, 17625, 22078, 17238, 21372, 24362, 20341,
  23003, 22893, 17257, 10766, 10766, 17623, 17625, 17625, 17625, 8922, 12985, 15191, 18320, 23003, 23003, 19983, 20994,
  10766, 10766, 22365, 16612, 17625, 20830, 17625, 8921, 15313, 17282, 23003, 23003, 17331, 14697, 10766, 19492, 10766,
  11182, 9096, 17625, 12984, 17241, 24101, 23003, 14659, 10766, 10766, 17349, 17625, 17625, 10721, 24095, 23003, 24594,
  10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334,
  14700, 17312, 24857, 14699, 14694, 14689, 14249, 14787, 17373, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 23370, 14386, 20021, 17419,
  17426, 17442, 17458, 17625, 17625, 8582, 17625, 16847, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 17474, 17625,
  17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625,
  17625, 17625, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625, 17625, 17625, 17501,
  15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003,
  10766, 10766, 13786, 17625, 23551, 10721, 24095, 23003, 24594, 10766, 10766, 16490, 17518, 23816, 23003, 14701, 13786,
  17567, 17589, 16901, 16459, 17616, 14552, 18112, 18625, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 18543,
  17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625, 18281, 8582, 17625, 17625,
  22530, 15311, 20012, 22524, 19377, 16960, 15152, 10696, 17625, 23653, 16501, 17642, 17625, 10721, 15191, 14500, 16136,
  23003, 23003, 17661, 10766, 10766, 19486, 17623, 17625, 10923, 17625, 17625, 12985, 15191, 17692, 23003, 23003, 23003,
  18123, 10766, 10766, 10766, 17729, 17625, 17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766,
  10766, 17622, 17625, 17747, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003,
  24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 21097, 18764,
  25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 24071, 20582, 8643, 17777, 17768, 17802,
  17818, 17828, 17844, 17860, 17625, 17625, 17876, 18662, 20421, 21207, 13440, 23845, 18054, 18213, 24890, 17912, 10696,
  17625, 17222, 17625, 21644, 22531, 22667, 23611, 17972, 16136, 17999, 23003, 23251, 17021, 24166, 22059, 17623, 10319,
  18015, 18041, 18079, 12985, 18834, 18098, 23003, 23003, 18156, 15481, 10766, 16646, 23875, 17622, 17625, 22338, 17625,
  17625, 15313, 14166, 24591, 23003, 23003, 22827, 10766, 10766, 10766, 20277, 18182, 18198, 18259, 15191, 24101, 23003,
  23003, 10766, 10766, 15228, 25428, 18279, 18297, 18336, 20985, 18403, 18452, 24560, 18481, 17625, 18519, 16065, 24018,
  15721, 12451, 10722, 23002, 14701, 16241, 20152, 23003, 10766, 25334, 14700, 17676, 10871, 14699, 14694, 17357, 18559,
  14787, 18584, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625, 17625, 8582, 17625,
  18660, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 10696, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500,
  16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625, 17625, 17625, 12985, 15191, 18320, 23003, 23003,
  23003, 20994, 10766, 10766, 10766, 17622, 17625, 17625, 17625, 17625, 15313, 14166, 14142, 23003, 23003, 23121, 10766,
  10766, 10766, 17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095,
  23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003,
  10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 16839, 14830,
  19792, 18678, 18688, 18704, 18720, 23976, 17625, 8582, 17625, 16847, 17625, 13951, 14462, 17625, 18736, 13633, 18763,
  18780, 18815, 17222, 9769, 17625, 17625, 10721, 18833, 14500, 16136, 18599, 23003, 18850, 16671, 18893, 24278, 17623,
  18911, 17625, 17896, 17625, 12985, 18928, 18320, 17938, 24882, 21558, 14232, 18949, 18971, 18990, 19009, 20601, 19028,
  17625, 19050, 15313, 15529, 23003, 23003, 19072, 14697, 10766, 19187, 23058, 24407, 17625, 17625, 12984, 19106, 14594,
  23003, 23003, 19813, 10766, 13786, 24932, 17625, 15919, 15598, 23003, 24594, 19127, 10766, 17624, 19145, 23816, 23003,
  14701, 13786, 17625, 19163, 23002, 19182, 18465, 20152, 23003, 10766, 22992, 14700, 17312, 24857, 14699, 15340, 19203,
  19228, 14749, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 12695, 17625, 13681, 20582, 22938, 13683, 17625, 20021, 19254, 19264, 19280, 19296, 14014, 17625, 8582,
  20562, 17625, 17625, 9384, 19879, 17625, 19312, 16036, 19342, 10696, 9289, 17222, 17625, 19362, 17625, 10721, 15191,
  14500, 16136, 19087, 23003, 22977, 16680, 10766, 18132, 10822, 19411, 17625, 17625, 17625, 12985, 15191, 18320, 24956,
  19432, 23003, 20994, 19462, 15498, 10766, 17622, 17625, 13339, 21020, 17625, 15313, 14166, 15209, 23003, 18166, 14697,
  23908, 10766, 19508, 17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721,
  24095, 23003, 24594, 10766, 10766, 19530, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152,
  23003, 10766, 24329, 19326, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 20135, 22708, 17625, 9968,
  19552, 17786, 19571, 19582, 19598, 19614, 17625, 19630, 19648, 16377, 17625, 16387, 19664, 16364, 19680, 19696, 22804,
  19737, 10696, 19783, 17222, 17625, 17625, 21673, 10721, 15191, 14500, 16136, 23003, 17333, 22893, 10766, 10766, 19808,
  20795, 17625, 19829, 17625, 17625, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625,
  17625, 19850, 24230, 19872, 22778, 19895, 23003, 16915, 19913, 10766, 21038, 17201, 13837, 19949, 9789, 20716, 19999,
  20037, 20071, 16990, 18243, 14241, 20105, 13811, 20131, 20151, 24095, 19978, 24594, 22258, 10766, 18865, 10989, 20168,
  20255, 19760, 20207, 17625, 20223, 12744, 19238, 20271, 20152, 16752, 18637, 25334, 14700, 20293, 20327, 19446, 14694,
  14689, 16688, 20361, 17387, 20387, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 12695, 17625, 10070, 20408, 17625, 20444, 17625, 20460, 20476, 20486, 20502, 20518, 21331, 20534,
  20555, 20578, 18817, 20598, 20617, 20653, 20702, 20732, 20748, 20764, 10696, 17625, 17222, 21512, 17625, 17625, 10721,
  15191, 14500, 10230, 23003, 23473, 20191, 23202, 10766, 20811, 17623, 8912, 10341, 19856, 20846, 10362, 20882, 20931,
  21182, 20311, 23003, 20961, 10766, 19925, 14970, 15731, 17484, 21019, 17625, 17625, 15313, 14166, 23003, 23243, 23003,
  14697, 10766, 21036, 10766, 17622, 11090, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 21054, 17625,
  10721, 13291, 23003, 13413, 10766, 10766, 21075, 17625, 15851, 21095, 18436, 13786, 17625, 10722, 23002, 14701, 14572,
  16333, 23003, 21113, 21131, 18568, 18418, 21168, 14699, 14694, 14689, 24137, 14787, 24624, 21202, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625,
  21469, 21223, 20021, 24064, 24777, 21240, 21256, 17625, 13349, 8582, 16296, 17625, 21272, 15311, 23622, 13346, 17315,
  16036, 10766, 10696, 21292, 17222, 17625, 21316, 13904, 10721, 21366, 14500, 16136, 20183, 21388, 19212, 16810, 23901,
  21419, 10912, 17625, 17625, 21448, 21485, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 20115,
  17625, 17625, 11789, 21224, 13972, 14166, 23003, 14945, 23003, 14697, 19129, 10766, 10766, 17622, 21510, 17625, 12984,
  15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625,
  23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 21528, 14700, 17312, 24857, 14699,
  14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 15174, 14778, 12716, 17625,
  17625, 8582, 17625, 22946, 24797, 12935, 21898, 17625, 21582, 17956, 21609, 21625, 17625, 22511, 17625, 17625, 17625,
  10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625, 17625, 17625, 12985, 15191,
  18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625, 17625, 17625, 17625, 15313, 14166, 23003, 23003,
  23003, 14697, 10766, 10766, 10766, 17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625,
  17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 21538, 14793,
  14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 21660,
  21696, 17625, 21721, 21745, 21761, 21771, 21787, 21803, 17625, 12579, 21819, 21869, 17625, 17625, 21891, 21914, 21941,
  17315, 21975, 21003, 10696, 17625, 21300, 22002, 13911, 22018, 10721, 18312, 14500, 18503, 14147, 20345, 22893, 10766,
  22038, 22056, 17623, 17625, 17625, 21636, 17625, 22075, 15191, 22094, 23470, 22108, 23003, 24453, 18895, 10766, 22912,
  17622, 17625, 22128, 22159, 18495, 22196, 22220, 22577, 15081, 23703, 10792, 10766, 22236, 22274, 22296, 17625, 20667,
  12984, 15191, 15272, 23003, 23003, 19514, 10766, 25033, 17625, 24208, 10721, 24095, 23003, 20915, 10766, 21115, 17624,
  22332, 15467, 23003, 16094, 13786, 9597, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 14220, 17297, 17312, 18387,
  19386, 14694, 14689, 23285, 22354, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 13891, 13860, 23173, 22388, 22404, 22420, 22430, 22446, 22462,
  22478, 17625, 8582, 20392, 22498, 19632, 13503, 15641, 22547, 22563, 14665, 22597, 22619, 22660, 17222, 22683, 22704,
  22724, 22750, 22766, 23998, 22794, 22820, 21146, 22893, 19474, 17266, 10766, 17623, 22843, 9076, 22861, 17625, 12985,
  15191, 18320, 23003, 17949, 23003, 20994, 10766, 22909, 10766, 17622, 22845, 25353, 15779, 22928, 15313, 22962, 23020,
  23003, 24252, 23039, 10766, 10766, 24514, 16129, 17625, 17625, 12700, 15588, 24101, 20055, 23074, 10766, 24484, 13786,
  17625, 23093, 10721, 24095, 17544, 23117, 16100, 18236, 17624, 17625, 23816, 23003, 14701, 13786, 9213, 10722, 23137,
  14701, 23153, 20152, 23003, 10766, 25334, 23189, 17312, 17063, 23713, 10882, 23223, 23267, 14787, 17387, 17399, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625,
  22734, 17625, 17625, 17625, 20021, 23301, 23312, 23328, 23344, 17625, 17625, 23360, 24724, 23394, 17645, 24982, 23414,
  23439, 23455, 18612, 23489, 10696, 19056, 23534, 23550, 10006, 23567, 23588, 13583, 23638, 23689, 23003, 21403, 16920,
  23737, 19395, 23756, 23779, 10223, 19555, 17625, 17625, 23807, 23832, 22204, 20305, 24438, 19897, 20994, 23861, 23891,
  18644, 17622, 23924, 17625, 23952, 23972, 23992, 15030, 23077, 20082, 23003, 24014, 15490, 24034, 18955, 16535, 17625,
  11188, 24053, 24087, 20896, 9547, 23003, 24120, 24153, 13786, 24187, 24224, 12763, 13476, 24246, 16758, 24268, 15115,
  17624, 24294, 22316, 25294, 24314, 22603, 24355, 13121, 24339, 24378, 24401, 24423, 16418, 24500, 25334, 14700, 17312,
  24857, 14699, 24548, 24576, 19750, 14787, 24610, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 12521, 19834, 15001, 24640, 24650, 24666,
  24682, 14403, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 24698, 17625, 17222, 17625,
  17625, 24740, 10721, 15191, 14500, 16136, 23003, 23003, 21186, 10766, 10766, 10766, 24757, 23673, 24793, 24813, 17625,
  19012, 15191, 24835, 23004, 23003, 24873, 20994, 24532, 24171, 24906, 17622, 20678, 17625, 17625, 17625, 15629, 14166,
  22112, 23003, 23003, 14697, 23050, 10766, 10766, 23510, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766,
  13786, 24930, 17625, 10721, 22644, 23003, 19090, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722,
  23002, 14701, 14572, 20152, 15074, 24476, 25334, 14700, 17312, 24857, 14699, 10860, 24948, 24137, 13660, 17387, 17399,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625,
  17625, 13562, 17625, 23956, 17181, 18063, 24972, 20428, 24998, 25014, 17625, 17625, 8582, 17625, 17625, 17625, 15311,
  14501, 17625, 17533, 16036, 25030, 10696, 17625, 25049, 17625, 17625, 19536, 10721, 25086, 14500, 16136, 20050, 23003,
  22893, 14189, 10766, 10766, 17623, 17625, 17625, 17625, 17625, 22307, 18933, 18320, 23003, 20089, 23003, 20994, 10766,
  22250, 10766, 17622, 17625, 17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 17622,
  17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 14543, 10721, 24095, 23003, 24594, 10766,
  10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 25108, 23003, 10766, 25334, 14700,
  17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 16279, 17625, 17625, 17625, 21494, 25144, 25154,
  25170, 25186, 17625, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 16036, 10766, 10696, 17625, 17222,
  17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 17625, 17625, 17625,
  17625, 12985, 15191, 18320, 23003, 23003, 23003, 20994, 10766, 10766, 10766, 17622, 17625, 17625, 17625, 17625, 15313,
  14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766, 17622, 17625, 17625, 12984, 15191, 24101, 13301, 13996, 10766,
  25202, 23500, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625,
  10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387,
  17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12858,
  17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064, 17086, 25226, 25242, 17625, 17625, 25258, 17625, 17625, 8587,
  13264, 13710, 17625, 25283, 16036, 25317, 10696, 17625, 17222, 17625, 17983, 17625, 10721, 15191, 14500, 16136, 23003,
  23003, 16431, 10766, 10766, 19767, 13941, 17625, 17625, 17625, 17625, 12985, 15191, 18320, 23003, 23003, 23003, 20994,
  10766, 10766, 10766, 17622, 17625, 17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766, 10766,
  17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003, 24594,
  10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334,
  14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 12695, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 24064,
  15174, 14778, 12716, 23666, 17625, 8582, 17625, 17625, 17625, 15311, 14501, 17625, 17315, 18225, 14722, 10696, 17625,
  17222, 17625, 17625, 17625, 10721, 15191, 14500, 16136, 23003, 23003, 22893, 10766, 10766, 10766, 17623, 25350, 17625,
  17625, 17625, 12985, 15191, 18320, 17551, 23003, 23003, 20994, 24467, 10766, 10766, 17622, 21875, 17625, 17625, 17625,
  15250, 14166, 23003, 25123, 23003, 14697, 15292, 10766, 10766, 17622, 12136, 17625, 12984, 23600, 24101, 22581, 16207,
  10766, 23763, 19346, 17625, 17625, 10721, 24095, 23003, 24594, 10766, 10766, 25369, 17625, 23816, 23003, 14701, 13786,
  17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766, 25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787,
  17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  9785, 17625, 17625, 25406, 25402, 11157, 25388, 12238, 25422, 11145, 11166, 10102, 17625, 17625, 8582, 17625, 14112,
  17625, 13166, 13173, 17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760,
  8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464,
  8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138,
  11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465,
  9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447,
  9733, 9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  9785, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 25444, 25451, 12101, 25467, 17625, 17625, 8582, 17625, 17625,
  17625, 13166, 13173, 17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760,
  8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464,
  8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138,
  11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465,
  9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447,
  9733, 9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  9785, 17625, 17625, 20582, 17625, 17625, 17625, 12322, 25483, 25493, 13194, 25509, 17625, 17625, 8582, 17625, 11052,
  17625, 13166, 13173, 17625, 8603, 8609, 8871, 8625, 21959, 17222, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760,
  8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625, 17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464,
  8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968, 9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138,
  11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192, 9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465,
  9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505, 9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447,
  9733, 9764, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625,
  9785, 17625, 17625, 20582, 17625, 17625, 17625, 20021, 17625, 17625, 17625, 25525, 17625, 17625, 8582, 17625, 17625,
  17625, 15311, 14501, 17625, 17315, 16036, 10766, 10696, 17625, 17222, 17625, 17625, 17625, 10721, 15191, 14500, 17573,
  23003, 23003, 24104, 10766, 10766, 10766, 17623, 17625, 17625, 17625, 17625, 12985, 15191, 18320, 23003, 23003, 23003,
  20994, 10766, 10766, 10766, 17622, 17625, 17625, 17625, 17625, 15313, 14166, 23003, 23003, 23003, 14697, 10766, 10766,
  10766, 17622, 17625, 17625, 12984, 15191, 24101, 23003, 23003, 10766, 10766, 13786, 17625, 17625, 10721, 24095, 23003,
  24594, 10766, 10766, 17624, 17625, 23816, 23003, 14701, 13786, 17625, 10722, 23002, 14701, 14572, 20152, 23003, 10766,
  25334, 14700, 17312, 24857, 14699, 14694, 14689, 24137, 14787, 17387, 17399, 17625, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 16722, 16716,
  25541, 25548, 21853, 16723, 17625, 17625, 17625, 17625, 17625, 17625, 13166, 13173, 17625, 8603, 8609, 8871, 25564,
  21959, 17625, 8641, 17625, 12826, 8659, 11566, 8703, 8744, 8760, 8781, 8802, 8755, 8776, 8797, 9594, 17625, 17625,
  17625, 8818, 8834, 8952, 9271, 8849, 10459, 8870, 9646, 8854, 10464, 8871, 9284, 8887, 13023, 8903, 12380, 8938, 8968,
  9687, 9003, 9025, 9677, 9693, 9009, 9031, 9047, 9092, 9112, 9138, 11581, 9154, 9173, 9745, 9157, 9176, 9748, 9192,
  9229, 9258, 9305, 9321, 9341, 9317, 9337, 9357, 9373, 9400, 9465, 9457, 9473, 9429, 13378, 9445, 9489, 9520, 9505,
  9564, 9563, 9580, 9613, 9638, 9622, 8871, 9662, 9709, 9717, 10447, 9733, 9764, 17625, 17625, 17625, 17625, 17625,
  17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 17625, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 47292,
  47292, 47292, 47292, 0, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 69632, 0, 0, 69632, 69632, 69632, 0, 12290, 3, 4, 0, 0, 57344,
  0, 0, 0, 0, 0, 0, 191, 192, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 24972, 49341, 49341, 47292, 47292, 49341,
  49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 227, 49341, 49341, 49341, 49341, 49341,
  49341, 49341, 49341, 49341, 49341, 49341, 34816, 36864, 49341, 49341, 49341, 49341, 49341, 32768, 49341, 49341, 47292,
  49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 49341, 0,
  47292, 49341, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 47292, 49341, 0, 191, 192, 0, 0, 227, 227, 227, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 477, 0, 0, 0, 0, 0, 0, 0, 0, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296,
  567296, 567296, 0, 567296, 567296, 567296, 567296, 567296, 0, 542720, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 671744, 0, 0,
  690176, 0, 677888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209, 0, 0, 784384, 792576, 798720, 0, 808960, 823296,
  880640, 0, 0, 0, 569344, 569344, 671744, 569344, 569344, 569344, 569344, 569344, 569344, 569344, 569344, 0, 800768, 0,
  0, 0, 567296, 567834, 567834, 567834, 567834, 897562, 666191, 567887, 567887, 696911, 567887, 567887, 567887, 725583,
  567887, 567887, 778831, 808960, 823296, 569344, 569344, 569344, 880640, 569344, 569344, 569344, 569344, 0, 671744, 0,
  0, 792576, 0, 0, 0, 0, 0, 0, 69632, 0, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 0, 0, 823296, 823296, 0, 0, 0, 0, 0, 772096, 0, 0, 567296, 567296, 671744, 567296, 567296,
  567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 739328, 567296, 567296, 567296, 567296,
  759808, 763904, 567296, 567296, 567296, 759808, 763904, 567296, 768000, 567296, 567296, 784384, 567296, 567296,
  792576, 798720, 567296, 808960, 567296, 823296, 567296, 567296, 567296, 567296, 823296, 567296, 567296, 567296,
  567296, 567296, 567296, 567296, 567296, 567296, 880640, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 0, 0,
  567296, 790528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 755712, 796672, 0, 0, 0, 669696, 0, 722944, 0, 0, 0, 0, 800768,
  0, 0, 800768, 569344, 669696, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296,
  567296, 567296, 722944, 567296, 567296, 567296, 567296, 567296, 567296, 800768, 567296, 567296, 567296, 567296,
  567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 0, 0, 0, 692224, 0, 0,
  0, 0, 0, 731136, 0, 0, 782336, 0, 0, 815104, 0, 788480, 0, 0, 0, 0, 0, 0, 815104, 0, 0, 0, 0, 0, 0, 0, 0, 909, 0, 0,
  0, 0, 0, 0, 0, 0, 953, 0, 0, 0, 0, 0, 0, 0, 0, 765952, 0, 0, 0, 0, 569344, 569344, 569344, 692224, 694272, 569344,
  569344, 569344, 731136, 569344, 569344, 569344, 569344, 569344, 569344, 722944, 569344, 569344, 569344, 755712,
  569344, 569344, 569344, 796672, 800768, 765952, 569344, 569344, 782336, 569344, 569344, 569344, 569344, 569344,
  569344, 569344, 569344, 909312, 0, 0, 567296, 567296, 544768, 884, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1436, 0, 0,
  567296, 731136, 567296, 567296, 567296, 745472, 567296, 567296, 765952, 567296, 567296, 567296, 567296, 782336,
  786432, 788480, 567296, 567296, 815104, 567296, 567296, 567296, 567296, 567296, 815104, 567296, 567296, 567296,
  567296, 567296, 567296, 567296, 567296, 567296, 860160, 868352, 567296, 876544, 567296, 567296, 567296, 567296,
  567296, 567296, 567296, 909312, 567296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 733184, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0, 0,
  0, 102400, 102400, 0, 0, 0, 0, 0, 0, 923, 0, 0, 0, 0, 0, 929, 0, 0, 932, 0, 0, 0, 825344, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1298, 0, 0, 749568, 0, 794624, 0, 0, 0, 0, 0, 0, 874496, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 81920, 81920,
  81920, 81920, 81920, 81920, 81920, 0, 0, 0, 663552, 0, 0, 0, 905216, 0, 0, 0, 0, 0, 882688, 888832, 663552, 888832,
  905216, 0, 663552, 567296, 567296, 567296, 567296, 686080, 567296, 698368, 567296, 567296, 567296, 567296, 567296,
  567296, 567296, 567296, 567296, 567296, 567296, 733184, 741376, 567296, 749568, 567296, 567296, 567296, 567296,
  567296, 567296, 567296, 825344, 567296, 567296, 567296, 567296, 0, 0, 0, 0, 0, 804864, 0, 821248, 0, 845824, 0, 0,
  854016, 0, 0, 0, 0, 0, 0, 0, 112640, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1585, 0, 0, 0, 0, 0, 0, 802816, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 770048, 0, 0, 0, 0, 0, 0, 0, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 0, 0, 0, 872448,
  870400, 684032, 0, 0, 0, 0, 743424, 0, 0, 569344, 684032, 569344, 569344, 569344, 569344, 569344, 569344, 569344,
  569344, 0, 800768, 0, 0, 0, 567296, 567296, 567296, 0, 546816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 667, 0, 0, 0,
  569344, 743424, 569344, 569344, 802816, 845824, 569344, 870400, 845824, 567296, 567296, 567296, 684032, 567296,
  567296, 567296, 567296, 567296, 714752, 567296, 567296, 567296, 567296, 743424, 567296, 770048, 776192, 567296,
  567296, 802816, 804864, 567296, 567296, 802816, 804864, 567296, 831488, 567296, 567296, 841728, 567296, 845824,
  567296, 567296, 870400, 567296, 567296, 567296, 911360, 567296, 567296, 567296, 911360, 0, 0, 0, 0, 0, 712704, 729088,
  0, 0, 0, 0, 0, 0, 0, 903168, 0, 0, 0, 0, 774144, 0, 0, 0, 827392, 0, 710656, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296,
  296, 501, 296, 296, 296, 0, 0, 0, 0, 0, 569344, 569344, 569344, 712704, 569344, 569344, 569344, 569344, 567296,
  567296, 567296, 0, 546816, 191, 0, 0, 0, 191, 0, 192, 0, 0, 0, 192, 0, 0, 757760, 0, 829440, 0, 0, 0, 901120, 0,
  747520, 737280, 761856, 0, 0, 837632, 569344, 665600, 567296, 567296, 696320, 567296, 567296, 567296, 724992, 567296,
  567296, 778240, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 702464, 710656,
  712704, 567296, 567296, 729088, 567296, 567296, 567296, 567296, 827392, 567296, 567296, 843776, 567296, 567296,
  567296, 567296, 567296, 681984, 0, 0, 567296, 567296, 567296, 567296, 897024, 665600, 567296, 567296, 696320, 567296,
  567296, 567296, 724992, 567296, 567296, 778240, 851968, 0, 0, 890880, 0, 0, 0, 673792, 0, 780288, 673792, 700416,
  569344, 780288, 851968, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 897024, 0, 700416, 0, 0,
  806912, 0, 0, 0, 0, 0, 0, 727, 0, 0, 766, 342, 768, 770, 342, 342, 342, 342, 342, 1352, 342, 342, 1354, 1355, 342,
  342, 342, 342, 342, 1361, 567296, 673792, 679936, 700416, 567296, 567296, 567296, 567296, 751616, 780288, 833536,
  567296, 851968, 567296, 567296, 567296, 890880, 890880, 0, 0, 0, 0, 811008, 0, 0, 0, 720896, 720896, 567296, 716800,
  720896, 567296, 567296, 544768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1587, 0, 567296, 567296, 567296, 567296,
  567296, 884736, 567296, 716800, 720896, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296,
  567296, 0, 704512, 0, 0, 567296, 567296, 884736, 0, 0, 0, 0, 813056, 0, 0, 567296, 567296, 567296, 567296, 567296,
  567296, 567296, 567296, 0, 567296, 567296, 669696, 567296, 567296, 567296, 567296, 0, 0, 0, 567296, 567296, 727040,
  567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 727040, 567296, 567296, 567296, 567296, 567296,
  567296, 567296, 909312, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 692224, 694272, 567296, 567296,
  567296, 706560, 567296, 567296, 567296, 567296, 567296, 567296, 731136, 567296, 567296, 567296, 745472, 567296,
  567296, 567296, 567296, 567296, 688128, 0, 858112, 567296, 567296, 735232, 567296, 567296, 567296, 567296, 858112,
  708608, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 856064, 567296, 753664, 835584, 567296, 567296,
  753664, 835584, 567296, 718848, 567296, 718848, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296,
  882688, 567296, 888832, 567296, 894976, 905216, 907264, 567296, 0, 0, 0, 567296, 567296, 567296, 839680, 839680, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 694, 0, 0, 0, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1311, 0, 0, 278,
  278, 278, 278, 0, 0, 0, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 0, 0, 278, 1, 12290, 3,
  4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 0, 472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 710, 0, 0, 0, 0, 542720,
  645, 645, 4, 0, 0, 0, 0, 0, 0, 0, 671744, 0, 0, 690176, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55296, 0,
  191, 55296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 79872, 191, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  24969, 192, 0, 542720, 0, 0, 4, 0, 0, 0, 191, 0, 0, 0, 671744, 0, 0, 690176, 532658, 12290, 3, 4, 0, 184, 0, 0, 0, 0,
  0, 184, 0, 0, 0, 0, 0, 0, 0, 1130, 0, 0, 0, 0, 0, 0, 0, 0, 241, 0, 242, 244, 213, 0, 0, 0, 0, 532658, 12290, 3, 4, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 227, 227, 227, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 709, 0, 0, 0, 715, 0,
  542720, 0, 0, 4, 0, 0, 0, 0, 646, 650, 0, 671744, 0, 0, 690176, 0, 0, 0, 0, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 59392, 0, 59392, 0, 59392, 59392, 59392, 59392, 59392, 59392, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 214, 215, 59392, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 191, 192, 0, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 394, 395, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  61440, 0, 192, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 118784, 0, 542720, 0, 0, 4, 0, 0, 0, 0, 0, 0,
  192, 671744, 0, 0, 690176, 190, 190, 63678, 230, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190,
  190, 190, 228, 190, 190, 190, 63678, 190, 190, 63678, 63678, 63678, 63678, 63678, 190, 63678, 63678, 63678, 63678,
  63678, 0, 0, 0, 0, 0, 0, 907, 0, 0, 0, 0, 0, 0, 0, 0, 0, 766, 342, 342, 342, 342, 342, 773, 190, 190, 0, 190, 190,
  190, 190, 63678, 63718, 63718, 63718, 63718, 63718, 63718, 63678, 63678, 63678, 63678, 190, 190, 190, 63678, 190,
  63678, 190, 190, 190, 190, 190, 190, 0, 0, 190, 63678, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 34816, 36864,
  190, 190, 190, 190, 190, 32768, 63678, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 428, 428, 428, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 913, 0, 0, 0, 0, 0, 0, 0, 69632, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 928, 0, 0, 0,
  0, 0, 0, 227, 227, 96256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 965, 0, 296, 296, 0, 10603, 0, 0, 0, 0, 71680, 10603,
  10603, 10603, 10603, 10603, 10603, 10603, 71680, 71680, 71680, 71680, 0, 0, 0, 71680, 71680, 71680, 71680, 71680,
  71680, 71680, 71680, 71680, 73728, 71680, 73728, 71680, 71680, 71680, 0, 0, 10603, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 191, 192, 567296, 567296, 567296, 567296, 567296, 880640, 567296, 567296, 567296, 567296, 567296, 567296,
  567296, 0, 10240, 567296, 567296, 567296, 567296, 567296, 667648, 567296, 567296, 567296, 567296, 856064, 667648,
  567296, 567296, 567296, 567296, 567296, 567296, 567296, 567296, 755712, 567296, 567296, 567296, 567296, 567296,
  567296, 796672, 800768, 567296, 567296, 567296, 567296, 75776, 75776, 75776, 75776, 0, 0, 0, 75776, 75776, 75776,
  75776, 75776, 75776, 75776, 75776, 75776, 77824, 75776, 77824, 75776, 75776, 75776, 0, 0, 75776, 1, 12290, 3, 4, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 0, 79872, 0, 79872, 79872, 79872, 79872, 0, 0, 0, 0, 0, 0, 0, 0, 124928, 0, 0,
  0, 0, 0, 0, 0, 0, 953, 0, 0, 1159, 1160, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 79872, 79872, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1320,
  0, 0, 0, 0, 0, 296, 0, 79872, 79872, 0, 0, 0, 79872, 79872, 34816, 36864, 79872, 79872, 0, 0, 0, 32768, 79872, 79872,
  79872, 79872, 0, 0, 0, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872,
  79872, 0, 0, 79872, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 192, 1, 179, 3, 4, 0, 0, 185, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1445, 296, 296, 296, 296, 296, 81920, 81920, 81920, 81920, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920,
  81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 81920, 1, 0, 3, 4, 39094, 39094, 0, 391, 0, 0, 0, 0, 0,
  191, 192, 0, 0, 0, 0, 4, 39094, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 964, 0, 0, 296, 296, 0, 106496, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 0, 1112, 0, 0, 0, 0, 1116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1387, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1088, 296,
  1600, 342, 342, 342, 342, 342, 342, 1606, 342, 342, 342, 342, 342, 342, 342, 342, 1232, 1233, 364, 364, 364, 1237,
  364, 364, 342, 342, 1679, 342, 342, 342, 364, 1683, 364, 364, 364, 364, 364, 1688, 364, 364, 0, 0, 0, 0, 888, 0, 0, 0,
  894, 0, 0, 0, 0, 0, 0, 0, 723, 0, 0, 0, 739328, 0, 759808, 763904, 0, 342, 1704, 364, 364, 364, 364, 364, 364, 364,
  364, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 1743, 342, 364, 364, 364, 364, 1708, 1709, 1710, 1711, 364, 0, 0,
  0, 0, 342, 342, 342, 342, 342, 342, 1742, 342, 342, 364, 364, 364, 364, 0, 0, 0, 342, 1738, 342, 342, 342, 342, 342,
  342, 342, 364, 1746, 364, 364, 0, 0, 0, 0, 889, 0, 0, 0, 895, 0, 0, 0, 0, 0, 0, 0, 924, 0, 0, 0, 0, 0, 0, 0, 0, 462,
  0, 0, 0, 0, 0, 0, 0, 86401, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 88064, 643, 0, 0, 4, 39094,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1145, 0, 0, 0, 0, 0, 0, 0, 193, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1524, 0, 1525,
  90391, 90391, 90391, 90391, 0, 0, 0, 90391, 0, 90391, 0, 0, 0, 0, 0, 90391, 0, 0, 193, 0, 0, 0, 0, 0, 90391, 90391,
  90391, 90391, 90391, 90391, 90391, 90391, 0, 90391, 0, 90391, 90391, 90391, 0, 0, 0, 0, 0, 0, 110592, 0, 92160, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 397312, 0, 0, 0, 0, 0, 386, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 643,
  386, 0, 0, 4, 39094, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1296, 0, 0, 0, 0, 364, 364, 643, 885, 0, 886, 0, 0, 0, 892, 0,
  0, 0, 0, 0, 0, 0, 0, 126976, 0, 126976, 0, 0, 0, 0, 0, 364, 364, 364, 885, 885, 886, 1108, 0, 0, 0, 0, 892, 1110, 0,
  0, 0, 0, 0, 0, 0, 389120, 389120, 389120, 389120, 0, 0, 389120, 0, 0, 0, 389120, 0, 0, 0, 0, 0, 0, 0, 389120, 389120,
  0, 0, 0, 0, 0, 389120, 0, 0, 389120, 389120, 364, 364, 364, 1108, 0, 1110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1309, 0,
  0, 0, 0, 0, 194, 195, 0, 194, 0, 0, 0, 195, 0, 195, 0, 0, 0, 0, 0, 0, 34816, 36864, 0, 0, 0, 0, 0, 32768, 0, 1, 12290,
  3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 67584, 191, 192, 0, 98304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278, 278, 0, 0,
  429, 68014, 429, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1421, 0, 0, 0, 0, 0, 0, 0, 0, 0, 567834, 567834, 567834,
  567834, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 590, 567887, 567887, 567887, 567887, 567887, 823296,
  823296, 0, 0, 0, 0, 0, 772096, 0, 0, 567834, 567834, 672282, 567834, 567834, 567834, 567834, 567834, 692762, 694810,
  567834, 567834, 567834, 707098, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 756250, 567834,
  567834, 567834, 567834, 567834, 567834, 797210, 768538, 567834, 567834, 784922, 567834, 567834, 793114, 799258,
  567834, 809498, 567834, 823834, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 567887, 567887, 567887,
  567887, 567887, 567887, 567887, 567887, 567887, 0, 704512, 0, 0, 567834, 567834, 823887, 567887, 567887, 567887,
  567887, 567887, 567887, 567887, 567887, 567887, 881231, 567887, 567887, 567887, 567887, 567887, 567887, 860751,
  868943, 567887, 877135, 567887, 567887, 567887, 567887, 567887, 567887, 668186, 567834, 567834, 567834, 567834,
  856602, 668239, 567887, 567887, 567887, 567887, 670234, 567834, 567834, 567834, 567834, 567834, 567834, 567834,
  567834, 567834, 567834, 567834, 567834, 567834, 723482, 567834, 567834, 703002, 711194, 713242, 567834, 567834,
  729626, 567834, 567834, 567834, 567834, 827930, 567834, 567834, 844314, 801306, 567834, 567834, 567834, 567834,
  567834, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 0, 567887, 567887, 670287,
  567887, 567887, 567887, 567887, 765952, 569344, 569344, 782336, 569344, 569344, 569344, 569344, 569344, 569344,
  569344, 569344, 909312, 0, 0, 567834, 567834, 715290, 567834, 567834, 567834, 567834, 743962, 567834, 770586, 776730,
  567834, 567834, 803354, 805402, 567834, 567834, 815642, 567834, 567834, 567834, 567834, 567834, 567834, 567834,
  567834, 567834, 860698, 868890, 567834, 877082, 694863, 567887, 567887, 567887, 707151, 567887, 567887, 567887,
  567887, 567887, 567887, 731727, 567887, 567887, 567887, 746063, 567887, 909903, 567887, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 733184, 0, 0, 0, 0, 0, 0, 108544, 696320, 778240, 0, 569344, 696320, 569344, 569344, 778240, 569344, 569344,
  569344, 569344, 569344, 739328, 569344, 569344, 759808, 763904, 569344, 569344, 784384, 792576, 798720, 569344,
  569344, 569344, 569344, 569344, 569344, 733184, 569344, 569344, 569344, 569344, 825344, 569344, 569344, 569344,
  882688, 888832, 905216, 0, 664090, 567834, 567834, 567834, 567834, 686618, 567834, 698906, 567834, 567834, 567834,
  567834, 567834, 567834, 567834, 567834, 883226, 567834, 889370, 567834, 895514, 905754, 907802, 567834, 664143,
  567887, 567887, 567887, 567887, 686671, 567887, 698959, 567887, 567887, 567887, 567887, 567887, 567887, 567887,
  567887, 567887, 567887, 567887, 567887, 567887, 567887, 567887, 567887, 723535, 567887, 567887, 567887, 567887,
  567887, 567887, 733775, 741967, 567887, 750159, 567887, 567887, 567887, 567887, 567887, 567887, 567887, 825935,
  567887, 567887, 567887, 567887, 567887, 883279, 567887, 889423, 567887, 895567, 905807, 907855, 567887, 0, 0, 0,
  569344, 743424, 569344, 569344, 802816, 845824, 569344, 870400, 845824, 567834, 567834, 567834, 684570, 567834,
  567834, 567834, 567834, 567834, 881178, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 0, 0, 567887, 832026,
  567834, 567834, 842266, 567834, 846362, 567834, 567834, 870938, 567834, 567834, 567834, 911898, 567887, 567887,
  567887, 567887, 827983, 567887, 567887, 844367, 567887, 567887, 567887, 567887, 567887, 681984, 0, 0, 684623, 567887,
  567887, 567887, 567887, 567887, 715343, 567887, 567887, 567887, 567887, 744015, 567887, 770639, 776783, 567887,
  567887, 760399, 764495, 567887, 768591, 567887, 567887, 784975, 567887, 567887, 793167, 799311, 567887, 809551,
  567887, 567887, 766543, 567887, 567887, 567887, 567887, 782927, 787023, 789071, 567887, 567887, 815695, 567887,
  567887, 567887, 0, 546816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1146, 0, 0, 0, 567887, 803407, 805455, 567887, 832079,
  567887, 567887, 842319, 567887, 846415, 567887, 567887, 870991, 567887, 567887, 567887, 756303, 567887, 567887,
  567887, 567887, 567887, 567887, 797263, 801359, 567887, 567887, 567887, 567887, 567887, 688128, 0, 858112, 567834,
  567834, 735770, 567834, 567834, 567834, 567834, 858650, 911951, 0, 0, 0, 0, 0, 712704, 729088, 0, 0, 0, 0, 0, 0, 0,
  903168, 0, 0, 0, 0, 0, 569344, 569344, 569344, 712704, 569344, 569344, 569344, 569344, 567834, 567834, 567834, 567834,
  567834, 885274, 567887, 717391, 721487, 567887, 567887, 567887, 567887, 567887, 567887, 567887, 567887, 897615, 0,
  700416, 0, 0, 806912, 0, 0, 569344, 666138, 567834, 567834, 696858, 567834, 567834, 567834, 725530, 567834, 567834,
  778778, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 909850, 567834, 567887, 567887, 567887, 567887,
  567887, 567887, 692815, 851968, 0, 0, 890880, 0, 0, 0, 673792, 0, 780288, 673792, 700416, 569344, 780288, 851968,
  567834, 731674, 567834, 567834, 567834, 746010, 567834, 567834, 766490, 567834, 567834, 567834, 567834, 782874,
  786970, 789018, 674330, 680474, 700954, 567834, 567834, 567834, 567834, 752154, 780826, 834074, 567834, 852506,
  567834, 567834, 567834, 891418, 567887, 674383, 680527, 701007, 567887, 567887, 567887, 567887, 752207, 780879,
  834127, 567887, 852559, 567887, 567887, 567887, 735823, 567887, 567887, 567887, 567887, 858703, 708608, 567834,
  567834, 567834, 567834, 567834, 567834, 567887, 567887, 567887, 567887, 567887, 703055, 711247, 713295, 567887,
  567887, 729679, 891471, 0, 0, 0, 0, 811008, 0, 0, 0, 720896, 720896, 567834, 717338, 721434, 567834, 567834, 567834,
  733722, 741914, 567834, 750106, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 825882, 567834, 885327, 0, 0,
  0, 0, 813056, 0, 0, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 567834, 739866, 567834, 567834, 567834,
  567834, 760346, 764442, 567834, 0, 0, 0, 567834, 567834, 727578, 567834, 567834, 567834, 567834, 567834, 567834,
  567887, 567887, 727631, 567887, 672335, 567887, 567887, 567887, 567887, 567887, 567887, 567887, 567887, 567887,
  567887, 567887, 739919, 567887, 567887, 544768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 393216, 393216, 856655,
  567834, 754202, 836122, 567834, 567887, 754255, 836175, 567887, 719386, 567834, 719439, 567887, 567834, 567887,
  567834, 567887, 840218, 840271, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1297, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 0, 102400,
  34816, 36864, 0, 0, 0, 0, 0, 32768, 102400, 102400, 102400, 102400, 0, 0, 0, 102400, 102400, 102400, 102400, 102400,
  102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 0, 0, 102400, 1, 12290, 3, 4, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 191, 192, 790528, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 26624, 0, 0, 0, 755712, 796672, 567296, 909312, 567296,
  191, 0, 192, 0, 0, 0, 0, 0, 0, 0, 0, 733184, 0, 0, 0, 0, 0, 0, 389120, 0, 389386, 389386, 0, 0, 0, 0, 0, 389386,
  104728, 104728, 104728, 104728, 0, 0, 0, 104728, 104728, 104728, 104728, 104728, 104728, 104728, 104728, 104728,
  104728, 104728, 104728, 104728, 104728, 0, 0, 104836, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 542720,
  0, 112640, 4, 0, 0, 0, 0, 0, 0, 0, 671744, 0, 0, 690176, 1, 12290, 3, 4, 0, 0, 0, 118784, 0, 0, 0, 0, 118784, 0, 0, 0,
  0, 0, 0, 0, 395264, 267, 267, 0, 0, 0, 0, 0, 267, 118784, 118784, 118784, 118784, 0, 0, 0, 118784, 118784, 118784,
  118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 0, 0, 118784, 1, 12290, 3, 4,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 100352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 694272, 0, 0, 0, 0, 0, 0,
  53248, 0, 114688, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 953, 0, 0, 0, 0, 1161, 0, 0, 0, 542720, 0, 114688, 4, 0, 0, 0, 0, 0,
  0, 0, 671744, 0, 0, 690176, 1, 12290, 3, 4, 0, 0, 0, 0, 120832, 0, 0, 0, 0, 120832, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1586, 0, 0, 0, 0, 120832, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121113, 121113, 121113, 121113, 0, 0, 0, 121113,
  121113, 121113, 121113, 121113, 121113, 121113, 121113, 121113, 121113, 121113, 121113, 121113, 121113, 0, 0, 121113,
  1, 12290, 0, 4, 0, 0, 0, 0, 129024, 0, 0, 0, 0, 191, 192, 94208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 0,
  542720, 0, 0, 0, 0, 83968, 137216, 0, 0, 0, 0, 671744, 0, 0, 690176, 1, 12290, 538804, 4, 0, 0, 0, 0, 0, 186, 0, 0, 0,
  0, 186, 0, 0, 0, 0, 0, 205, 0, 0, 233, 0, 233, 0, 0, 0, 0, 0, 0, 0, 417, 418, 0, 0, 0, 0, 0, 0, 0, 0, 34816, 61708, 0,
  0, 0, 0, 0, 32768, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 1, 12290, 538804, 4,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1310, 0, 0, 0, 0, 542720,
  116736, 116736, 4, 0, 0, 0, 0, 0, 0, 0, 671744, 0, 0, 690176, 131072, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191,
  192, 1, 12290, 3, 4, 39094, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1323, 0, 0, 296, 364, 1, 12290, 3, 4, 39094, 39094, 0,
  0, 0, 0, 0, 0, 0, 191, 192, 0, 1527, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296, 296, 342, 342, 342, 342, 1603, 1604,
  1605, 342, 342, 342, 342, 342, 342, 1611, 342, 0, 0, 958, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 1449,
  0, 644, 0, 0, 4, 39094, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 0, 364, 364, 644, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 197, 198, 199, 0, 0, 0, 0, 4, 182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 739328, 0, 759808, 763904, 0, 364, 1,
  12290, 3, 4, 39094, 39302, 0, 0, 0, 0, 0, 0, 0, 191, 192, 1, 12290, 3, 4, 39095, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1523, 0, 0, 0, 133120, 133120, 133120, 133120, 0, 0, 0, 133120, 0, 133120, 0, 0, 0, 0, 0, 133120, 133120, 133120,
  133120, 133120, 133120, 133120, 133120, 0, 133120, 0, 133120, 133120, 133120, 0, 0, 0, 0, 0, 0, 960, 0, 0, 963, 0, 0,
  0, 0, 966, 296, 1, 12290, 3, 181, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 502, 296, 296,
  296, 135168, 1, 12290, 3, 1065349, 0, 0, 0, 0, 0, 392, 0, 0, 0, 191, 192, 0, 542720, 0, 0, 1065349, 0, 0, 0, 0, 0, 0,
  0, 671744, 0, 0, 690176, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 0, 0, 0, 0, 196, 0, 0, 0, 196,
  252, 196, 253, 0, 0, 0, 0, 0, 0, 0, 1143, 0, 374784, 0, 0, 0, 0, 0, 0, 0, 0, 878592, 0, 0, 909312, 0, 0, 0, 0, 0, 196,
  0, 261, 0, 0, 0, 0, 34816, 36864, 269, 0, 0, 253, 0, 32768, 282, 282, 282, 282, 297, 297, 297, 314, 317, 314, 317,
  317, 317, 317, 317, 317, 317, 317, 336, 297, 336, 317, 317, 317, 343, 343, 343, 365, 343, 343, 343, 343, 343, 365,
  365, 365, 365, 365, 365, 365, 343, 343, 365, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 0,
  398, 0, 0, 401, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1594, 296, 296, 296, 296, 296, 1598, 0, 0, 0, 413, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 425, 0, 0, 227, 227, 227, 0, 0, 432, 0, 0, 0, 0, 437, 0, 0, 0, 0, 0, 0, 0, 569344, 569344, 569344, 569344,
  569344, 569344, 569344, 569344, 569344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 445, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  395264, 395264, 395264, 395264, 456, 0, 0, 0, 0, 0, 0, 0, 463, 0, 0, 0, 0, 0, 0, 0, 0, 1118, 0, 0, 0, 0, 0, 0, 0, 0,
  1293, 0, 0, 0, 0, 0, 0, 0, 0, 1319, 0, 0, 0, 0, 0, 0, 296, 0, 398, 0, 0, 0, 0, 0, 0, 0, 0, 474, 0, 0, 0, 0, 0, 0, 0,
  296, 296, 296, 296, 296, 503, 296, 296, 296, 0, 413, 0, 0, 0, 0, 0, 296, 296, 296, 496, 296, 296, 296, 296, 296, 296,
  296, 296, 0, 1454, 342, 342, 342, 342, 342, 342, 342, 1353, 342, 342, 342, 342, 342, 342, 342, 342, 1220, 342, 342,
  342, 342, 342, 342, 342, 296, 296, 296, 296, 296, 516, 296, 296, 296, 0, 0, 0, 0, 401, 0, 0, 0, 0, 0, 0, 1129, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 416, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 432, 0, 0, 474, 0, 0, 0, 532, 533, 0, 0, 0, 0, 0, 0,
  0, 696320, 778240, 0, 569344, 696320, 569344, 569344, 778240, 569344, 0, 0, 0, 456, 432, 342, 342, 342, 545, 342, 342,
  342, 342, 342, 566, 342, 342, 342, 1351, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1478, 364,
  364, 0, 0, 0, 0, 4, 39094, 0, 0, 0, 647, 651, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 499, 296, 296, 296, 296, 0, 0,
  0, 0, 702, 0, 0, 0, 0, 0, 708, 0, 0, 0, 0, 0, 0, 0, 296, 492, 296, 296, 296, 296, 296, 296, 296, 296, 0, 342, 342,
  342, 342, 342, 342, 1459, 296, 296, 296, 296, 756, 296, 296, 296, 296, 296, 702, 0, 0, 0, 0, 0, 0, 0, 296, 494, 296,
  296, 296, 296, 296, 296, 509, 0, 0, 0, 904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 918, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 931, 0, 0, 0, 0, 0, 205, 206, 207, 0, 0, 0, 0, 0, 0, 0, 0, 224, 225, 0, 0, 227, 0, 0, 0, 296,
  296, 296, 296, 972, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 750, 296, 751, 296, 296, 296, 296, 296,
  296, 986, 296, 296, 296, 0, 0, 0, 0, 0, 766, 342, 342, 342, 342, 997, 342, 342, 342, 342, 342, 342, 342, 342, 1007,
  342, 342, 342, 342, 1030, 1031, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 0, 364, 364, 597, 364, 364, 364,
  1090, 364, 364, 364, 364, 364, 364, 364, 364, 1099, 364, 364, 364, 364, 364, 342, 342, 342, 342, 1781, 342, 364, 364,
  364, 364, 1785, 0, 0, 0, 0, 1114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 1164, 0, 0, 0, 296, 296,
  296, 296, 1171, 1172, 296, 296, 296, 296, 296, 296, 296, 296, 296, 0, 0, 0, 0, 0, 0, 477, 296, 1177, 296, 296, 296,
  296, 296, 296, 296, 296, 296, 296, 296, 1162, 0, 342, 342, 342, 1365, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 1653, 342, 342, 1239, 364, 1241, 364, 364, 1243, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  630, 364, 364, 364, 364, 364, 364, 364, 1265, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 0, 0,
  0, 364, 364, 364, 1108, 0, 1110, 0, 0, 1279, 0, 0, 0, 0, 0, 0, 0, 0, 1419, 0, 0, 0, 0, 0, 0, 1424, 364, 364, 364,
  1404, 364, 364, 364, 364, 364, 1408, 364, 364, 364, 0, 0, 0, 0, 0, 0, 0, 0, 1282, 0, 1284, 0, 0, 0, 1414, 0, 0, 0, 0,
  1418, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 0, 0, 0, 0, 0, 0, 0, 0, 1426, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1437, 0, 0, 0, 0,
  0, 221, 222, 0, 0, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 659, 0, 0, 0, 0, 0, 0, 0, 0, 0, 707, 0, 0, 0, 0, 0, 0, 342, 1553,
  342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 1563, 364, 364, 0, 0, 0, 887, 0, 0, 0, 893, 0, 0, 0, 0, 0, 0,
  0, 296, 296, 296, 296, 296, 500, 296, 296, 296, 0, 0, 0, 1591, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296,
  296, 296, 296, 1176, 364, 1691, 0, 1693, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1370, 342, 342, 342,
  342, 342, 342, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 408, 0, 0, 0, 0, 262, 0, 0, 0, 0, 34816, 36864, 0, 0,
  274, 0, 274, 32768, 0, 0, 0, 0, 298, 298, 298, 0, 262, 274, 262, 262, 262, 262, 262, 262, 262, 262, 262, 298, 262,
  262, 262, 262, 344, 344, 344, 366, 344, 344, 344, 344, 344, 366, 366, 366, 366, 366, 366, 366, 344, 344, 366, 1,
  12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 950, 0, 0, 0, 953, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  391168, 0, 0, 0, 0, 0, 0, 296, 296, 296, 985, 296, 296, 296, 296, 0, 0, 0, 0, 0, 766, 342, 342, 342, 342, 1193, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 791, 793, 342, 342, 342, 296, 296, 1326, 296, 296, 296, 296, 296,
  296, 296, 296, 296, 296, 296, 296, 296, 0, 0, 342, 364, 364, 364, 1376, 364, 364, 1378, 364, 364, 364, 364, 364, 364,
  364, 364, 364, 842, 364, 364, 364, 364, 364, 364, 342, 342, 1720, 1721, 342, 1723, 342, 364, 364, 364, 364, 1729,
  1730, 364, 1732, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 1673, 342, 342, 342, 342, 342, 1047, 342, 342, 11065, 364, 364,
  364, 364, 364, 364, 364, 1392, 364, 364, 364, 364, 364, 364, 364, 364, 0, 1766, 342, 342, 342, 342, 342, 1772, 200,
  201, 202, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 135168, 135168, 0, 0, 200, 201, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 196, 0, 0, 0, 0, 0, 201, 0, 201, 0, 201, 0, 34816, 36864, 201, 0, 275, 0, 275, 32768, 283, 283, 283, 283,
  299, 299, 299, 283, 318, 328, 318, 318, 332, 332, 333, 333, 333, 333, 333, 333, 333, 333, 318, 299, 318, 333, 333,
  333, 345, 345, 345, 367, 345, 345, 345, 345, 345, 367, 367, 367, 367, 367, 367, 367, 345, 345, 367, 1, 12290, 3, 4,
  39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 684, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 238, 0, 0, 698, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 409, 0, 717, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 727, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 102400, 296, 296, 296, 296, 296, 296, 746, 296, 296, 296, 296, 296, 296, 296,
  296, 296, 0, 0, 0, 0, 0, 0, 407, 827, 829, 364, 364, 364, 364, 364, 364, 838, 364, 843, 364, 364, 364, 364, 848, 296,
  296, 296, 296, 296, 973, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 0, 0, 0, 0, 0, 0, 0, 1089, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1262, 0, 0, 0, 0, 1154, 0, 0, 0, 953, 0, 0, 0, 0, 0, 0, 0,
  0, 1432, 0, 0, 0, 0, 0, 0, 0, 0, 1642, 0, 296, 296, 1643, 296, 296, 342, 1401, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 0, 0, 0, 0, 0, 0, 0, 296, 296, 1451, 296, 296, 296, 296, 296, 0, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 1346, 342, 364, 0, 0, 0, 1505, 0, 0, 0, 0, 1508, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 135168,
  135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 0, 0, 0, 0, 0,
  0, 1530, 296, 296, 296, 296, 296, 296, 1536, 296, 342, 342, 342, 342, 342, 1367, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 0, 364, 594, 364, 364, 364, 364, 364, 364, 1569, 364, 364, 364, 364, 364, 364, 364, 364, 364, 0, 0, 0,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 342, 342, 1615,
  342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 637, 364, 364, 364, 364, 342, 1719, 342, 342, 342,
  342, 342, 364, 364, 364, 1728, 364, 364, 364, 364, 364, 342, 1778, 342, 342, 342, 342, 364, 1782, 364, 364, 364, 364,
  342, 342, 342, 1787, 364, 364, 364, 1789, 342, 342, 364, 364, 342, 364, 342, 342, 342, 342, 342, 364, 364, 364, 364,
  364, 364, 364, 342, 342, 342, 342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 1624, 364, 364, 0, 0, 0, 0, 204,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 239, 257, 257, 284, 284,
  284, 284, 300, 300, 300, 284, 319, 329, 319, 319, 319, 319, 319, 319, 319, 319, 319, 300, 319, 319, 319, 319, 346,
  346, 346, 368, 346, 346, 346, 346, 346, 368, 368, 368, 368, 368, 368, 368, 346, 346, 368, 1, 12290, 3, 4, 39094,
  39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480, 0, 0, 0, 0, 0, 0, 0, 386, 386, 386, 386,
  386, 386, 386, 0, 0, 0, 480, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 342, 560, 342, 342, 342, 342, 1206, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 1211, 342, 342, 342, 342, 364, 364, 364, 613, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 1101, 364, 364, 364, 670, 671, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 227, 0, 681, 0, 0,
  0, 0, 0, 256, 0, 0, 34816, 36864, 0, 0, 0, 276, 0, 32768, 0, 0, 0, 0, 731, 0, 0, 0, 0, 0, 734, 296, 736, 296, 296,
  296, 296, 296, 296, 296, 296, 296, 1184, 296, 296, 296, 0, 0, 342, 296, 753, 296, 296, 296, 296, 296, 296, 296, 296,
  0, 0, 0, 0, 0, 762, 670, 671, 0, 0, 0, 0, 0, 0, 0, 766, 342, 769, 342, 342, 342, 342, 342, 342, 1648, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 1209, 1210, 342, 1212, 342, 342, 342, 828, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 1491, 862, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  1501, 0, 0, 1113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 478, 0, 483, 364, 1240, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 640, 364, 0, 0, 0, 0, 0, 1317, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 0, 0, 0, 0, 342,
  342, 1324, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 752, 1362, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1202, 364, 364, 1375, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 0, 0, 1412, 0, 0, 0, 0, 0, 1441, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296, 296,
  296, 1175, 296, 1450, 296, 296, 296, 296, 296, 296, 296, 0, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1345,
  342, 342, 364, 364, 364, 1493, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1249, 1250, 364, 364, 1588,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 342, 364, 364, 1706, 364, 364, 364,
  364, 364, 364, 0, 0, 0, 0, 342, 342, 342, 342, 1740, 1741, 342, 342, 342, 364, 364, 364, 364, 0, 0, 0, 0, 205, 233, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1100206, 429, 0, 0, 0, 0, 0, 207, 0, 205, 0, 207, 0, 34816, 36864, 207, 0, 0, 0, 0,
  32768, 285, 285, 285, 285, 301, 301, 301, 285, 320, 285, 320, 320, 320, 320, 320, 320, 320, 320, 337, 301, 337, 320,
  320, 320, 347, 347, 347, 369, 347, 347, 347, 347, 347, 369, 369, 369, 369, 369, 369, 369, 347, 347, 369, 1, 12290, 3,
  4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 426, 0, 227, 227, 227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 439, 0, 0, 0, 0, 0,
  296, 296, 296, 296, 296, 296, 296, 296, 1538, 342, 342, 342, 1045, 342, 342, 342, 342, 11065, 364, 364, 364, 364, 364,
  364, 364, 1245, 364, 364, 364, 364, 364, 364, 364, 364, 1081, 364, 364, 364, 364, 364, 364, 364, 0, 486, 0, 0, 0, 486,
  0, 296, 296, 495, 296, 498, 296, 296, 505, 296, 296, 296, 296, 296, 296, 296, 296, 1183, 296, 296, 296, 296, 0, 0,
  342, 342, 342, 1462, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1469, 510, 296, 513, 296, 515, 296, 296,
  296, 296, 0, 0, 0, 0, 0, 525, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296, 1174, 296, 296, 296, 296, 296, 296,
  296, 296, 296, 1332, 296, 296, 296, 296, 296, 296, 296, 296, 0, 342, 342, 342, 342, 1457, 342, 342, 0, 527, 0, 0, 0,
  0, 0, 0, 405, 0, 0, 0, 0, 486, 534, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 1173, 296, 296, 296, 296, 296, 296,
  296, 296, 296, 452, 0, 0, 524, 0, 0, 0, 0, 0, 486, 527, 0, 342, 342, 543, 342, 548, 342, 342, 558, 342, 567, 342, 342,
  342, 1616, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 844, 364, 364, 847, 364, 570, 342, 342, 575,
  578, 581, 342, 342, 342, 342, 0, 364, 364, 596, 364, 601, 364, 364, 611, 364, 620, 364, 623, 364, 364, 628, 631, 634,
  364, 364, 364, 364, 364, 364, 1571, 364, 364, 364, 364, 364, 364, 0, 0, 0, 0, 0, 1109, 0, 648, 0, 0, 0, 1111, 0, 0, 0,
  0, 0, 0, 721, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 196, 0, 234, 0, 196, 196, 296, 296, 296, 296, 296, 296, 757, 296, 759,
  296, 0, 0, 0, 0, 0, 0, 0, 0, 292864, 0, 0, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 694272, 0, 364, 364, 864, 364, 364,
  364, 364, 364, 364, 364, 364, 875, 364, 364, 364, 880, 364, 364, 644, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 898, 0, 900, 0, 0,
  0, 0, 0, 906, 0, 0, 0, 0, 911, 912, 0, 914, 915, 0, 0, 0, 0, 0, 296, 296, 1533, 296, 296, 296, 296, 296, 342, 342,
  342, 342, 798, 342, 342, 342, 342, 342, 342, 342, 342, 805, 342, 342, 0, 0, 919, 0, 0, 0, 0, 0, 0, 0, 927, 0, 0, 0, 0,
  0, 0, 0, 677, 0, 0, 0, 227, 227, 0, 0, 0, 933, 0, 0, 0, 937, 0, 939, 0, 0, 0, 0, 944, 0, 0, 0, 0, 0, 0, 0, 1443, 0, 0,
  0, 296, 296, 1447, 296, 296, 0, 0, 0, 0, 951, 0, 0, 953, 0, 0, 0, 0, 955, 0, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 133120, 133120, 967, 296, 969, 296, 296, 296, 296, 974, 296, 976, 296, 296, 296, 979, 296, 296,
  0, 342, 342, 342, 342, 1341, 342, 342, 342, 342, 342, 342, 342, 1347, 982, 296, 296, 296, 296, 296, 296, 296, 963, 0,
  900, 900, 0, 766, 992, 993, 342, 994, 342, 342, 342, 998, 342, 342, 342, 342, 342, 342, 1006, 342, 342, 342, 342, 342,
  1543, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 0, 364, 364, 364, 364, 364, 342, 1010, 342, 342, 1013, 342,
  342, 342, 342, 342, 342, 1019, 1021, 342, 342, 342, 342, 342, 1544, 342, 342, 342, 342, 342, 342, 342, 342, 1551, 342,
  342, 1027, 1028, 1029, 342, 342, 342, 342, 342, 342, 1036, 342, 1038, 342, 342, 342, 342, 342, 1558, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 1489, 364, 364, 364, 364, 364, 1042, 342, 342, 342, 342, 342, 342, 1049, 11065,
  1050, 1051, 364, 1052, 364, 364, 364, 0, 890, 0, 896, 0, 0, 0, 0, 0, 0, 0, 0, 0, 766, 342, 342, 342, 342, 342, 342,
  1056, 364, 364, 364, 364, 364, 364, 1064, 364, 364, 364, 364, 1068, 364, 364, 1071, 364, 364, 1107, 0, 0, 0, 1108, 0,
  0, 0, 0, 0, 1110, 0, 0, 0, 0, 0, 0, 195, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 953, 0, 0, 0, 0, 0, 1162, 0, 1203, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1373, 364, 364, 364, 1242, 364, 364, 364, 364, 1246,
  364, 1248, 364, 364, 364, 364, 364, 364, 1063, 364, 364, 364, 364, 364, 364, 364, 364, 364, 0, 0, 1635, 0, 0, 1637, 0,
  1263, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1275, 1276, 364, 364, 1108, 0, 1110, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 226, 0, 227, 0, 0, 0, 1286, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 455, 0, 1301, 0, 0,
  0, 1304, 0, 1306, 1307, 0, 0, 0, 0, 0, 0, 339968, 0, 0, 1315, 0, 1316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296,
  296, 296, 1644, 296, 1325, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 1336, 296, 296, 296, 296, 296,
  296, 296, 520, 296, 473, 0, 523, 473, 0, 0, 0, 0, 0, 0, 447, 0, 0, 0, 0, 0, 0, 453, 0, 0, 0, 0, 0, 473, 0, 0, 0, 0,
  481, 0, 342, 1349, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1359, 1360, 342, 342, 342, 1645, 342, 342,
  342, 342, 342, 342, 342, 342, 1652, 342, 342, 342, 342, 815, 342, 342, 342, 342, 342, 342, 342, 342, 11065, 766, 364,
  342, 342, 1364, 342, 342, 342, 342, 1369, 342, 342, 342, 1371, 342, 342, 342, 342, 342, 364, 1618, 364, 364, 364, 364,
  364, 364, 364, 1625, 364, 364, 364, 364, 364, 1377, 364, 364, 364, 364, 364, 364, 364, 1383, 364, 1385, 364, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1509, 0, 0, 0, 0, 0, 0, 0, 689, 0, 0, 0, 0, 0, 0, 0, 0, 449, 0, 0, 0, 0, 0, 0, 0, 364, 364, 364,
  364, 1405, 364, 364, 364, 1407, 364, 364, 364, 364, 0, 0, 0, 0, 0, 0, 1280, 0, 0, 0, 0, 0, 0, 0, 191, 191, 191, 191,
  191, 191, 191, 0, 0, 296, 296, 296, 1452, 296, 296, 296, 296, 0, 342, 342, 342, 342, 342, 342, 342, 342, 11065, 364,
  364, 364, 364, 364, 364, 1055, 1460, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1468, 342, 342, 342, 342,
  342, 1617, 364, 364, 364, 364, 364, 364, 1623, 364, 364, 364, 0, 0, 0, 1108, 0, 0, 0, 0, 0, 1110, 0, 0, 0, 0, 0, 0, 0,
  135168, 34816, 36864, 0, 0, 0, 0, 0, 32768, 364, 364, 364, 364, 1484, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 1083, 364, 364, 364, 364, 1492, 364, 364, 364, 364, 364, 364, 364, 1496, 364, 364, 364, 364, 364, 364, 364,
  835, 840, 364, 364, 364, 364, 364, 364, 364, 836, 364, 364, 364, 364, 364, 364, 364, 364, 0, 342, 342, 1768, 1769,
  342, 342, 364, 1514, 0, 0, 0, 0, 0, 1519, 1520, 0, 1521, 0, 1522, 0, 0, 0, 0, 0, 0, 0, 6144, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1528, 1529, 0, 296, 1532, 296, 296, 296, 1535, 296, 1537, 342, 342, 342, 342, 342, 1647,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1477, 342, 364, 364, 364, 1541, 342, 342, 342, 342, 342, 342,
  342, 1546, 342, 1548, 342, 342, 342, 342, 342, 342, 1032, 342, 342, 342, 342, 342, 342, 342, 342, 1041, 1552, 1554,
  342, 1556, 1557, 364, 364, 364, 1561, 364, 364, 364, 364, 364, 364, 364, 837, 364, 364, 364, 364, 846, 364, 364, 364,
  1566, 364, 1568, 364, 364, 364, 364, 364, 1572, 1574, 364, 1576, 1577, 0, 0, 0, 0, 0, 0, 237, 239, 0, 0, 0, 0, 0, 0,
  0, 0, 464, 0, 0, 0, 0, 0, 0, 0, 0, 1581, 0, 1582, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1640, 151552, 0, 0, 0, 0, 296, 296, 296, 296, 296, 342, 1601, 342, 342, 342, 342, 342, 342, 342, 1608, 342, 342,
  1610, 342, 342, 342, 342, 1216, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 823, 342, 11065, 766, 826, 364,
  0, 0, 0, 0, 0, 1670, 0, 0, 0, 296, 342, 342, 342, 342, 1676, 364, 0, 0, 0, 0, 0, 1694, 362496, 342, 342, 342, 342,
  342, 342, 342, 342, 587, 342, 0, 364, 364, 364, 599, 364, 1703, 364, 364, 364, 364, 364, 364, 364, 364, 1712, 0, 0, 0,
  0, 342, 342, 342, 342, 1366, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1005, 342, 342, 342, 342, 1718,
  342, 342, 342, 342, 342, 342, 364, 364, 1727, 364, 364, 364, 364, 364, 364, 834, 364, 364, 364, 364, 364, 364, 364,
  364, 849, 1734, 1735, 0, 1737, 342, 342, 1739, 342, 342, 342, 342, 342, 1745, 364, 364, 1747, 1773, 364, 364, 364,
  1777, 342, 342, 342, 342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364, 0, 0, 0, 0, 1716, 342, 0, 0, 0, 0,
  208, 0, 236, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 0, 0, 0, 0, 362, 362, 0, 0, 0, 0, 208, 208, 0, 0, 34816, 36864, 0, 271,
  0, 208, 0, 32768, 0, 0, 0, 0, 302, 302, 302, 208, 271, 208, 271, 271, 271, 271, 271, 271, 271, 271, 271, 302, 271,
  271, 271, 271, 348, 348, 348, 370, 348, 348, 348, 348, 348, 370, 370, 370, 370, 370, 370, 370, 348, 348, 370, 1,
  12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 0, 460, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 224, 0, 0,
  0, 0, 364, 364, 364, 614, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1272, 364, 364, 364, 0, 0, 0, 0,
  660, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 227, 0, 0, 0, 296, 741, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296,
  296, 296, 296, 296, 1335, 296, 296, 364, 364, 364, 831, 364, 364, 364, 364, 839, 364, 364, 364, 364, 364, 364, 364,
  855, 364, 364, 858, 364, 364, 364, 364, 364, 296, 296, 296, 296, 1179, 296, 296, 296, 296, 296, 296, 296, 296, 0, 0,
  342, 342, 342, 1680, 342, 342, 1682, 364, 364, 364, 364, 364, 364, 364, 1689, 364, 0, 0, 0, 0, 0, 0, 0, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 1213, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 807, 342, 364, 364, 1403, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 0, 0, 0, 342, 342, 342, 1756, 1757,
  342, 342, 342, 364, 1786, 342, 342, 342, 1788, 364, 364, 364, 342, 342, 364, 364, 342, 364, 342, 342, 342, 342, 364,
  364, 364, 364, 342, 342, 364, 364, 342, 364, 342, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1511, 0, 0, 0, 286, 286, 286,
  286, 303, 303, 303, 286, 286, 286, 286, 286, 286, 286, 286, 286, 303, 286, 286, 286, 286, 349, 349, 349, 371, 349,
  349, 349, 349, 349, 371, 371, 371, 371, 371, 371, 371, 349, 349, 371, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0,
  0, 191, 192, 0, 0, 0, 0, 4, 39094, 0, 0, 0, 648, 652, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1136, 1150, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 460, 0, 0, 1516, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 368640, 0, 0, 0, 0, 0, 342,
  342, 342, 342, 342, 554, 342, 342, 342, 342, 342, 342, 1465, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1003, 342,
  342, 342, 342, 342, 342, 0, 0, 0, 0, 0, 323584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 0, 0, 0,
  0, 1592, 0, 0, 0, 0, 0, 1595, 296, 296, 296, 296, 296, 296, 296, 296, 296, 0, 0, 0, 460, 0, 0, 0, 364, 1627, 364, 364,
  364, 364, 364, 364, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 479, 0, 484, 811, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 11065, 766, 364, 0, 0, 0, 0, 0,
  0, 0, 342, 342, 342, 342, 1699, 1700, 1701, 1702, 296, 296, 296, 296, 296, 296, 296, 989, 0, 0, 0, 0, 0, 766, 342,
  342, 342, 342, 1472, 342, 342, 342, 342, 342, 342, 342, 342, 364, 364, 364, 364, 1685, 364, 364, 364, 364, 364, 364,
  1106, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1513, 0, 0, 0, 0, 0, 1303, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227,
  1099776, 1099776, 0, 0, 0, 250, 0, 0, 0, 0, 0, 0, 0, 209, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 34816,
  36864, 0, 0, 0, 0, 212, 32768, 0, 0, 0, 210, 0, 0, 0, 0, 34816, 36864, 0, 0, 0, 0, 0, 32768, 287, 287, 287, 287, 304,
  304, 304, 287, 321, 287, 331, 331, 331, 331, 331, 331, 331, 331, 338, 304, 338, 331, 331, 331, 350, 350, 350, 372,
  350, 350, 350, 350, 350, 372, 372, 372, 372, 372, 372, 372, 350, 350, 372, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0,
  0, 0, 0, 191, 192, 0, 427, 227, 227, 227, 0, 0, 0, 0, 0, 0, 436, 0, 0, 0, 0, 0, 0, 0, 28672, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 942, 0, 0, 0, 0, 0, 0, 364, 609, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 641, 364, 0, 0, 0, 0,
  0, 0, 0, 342, 342, 1697, 342, 342, 342, 342, 342, 342, 1000, 1001, 342, 342, 1004, 342, 342, 342, 342, 342, 342, 1015,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 589, 0, 364, 364, 364, 364, 364, 296, 296, 296, 296, 296, 296, 296, 758,
  296, 296, 733, 0, 0, 0, 0, 0, 0, 0, 705, 0, 0, 0, 0, 0, 712, 0, 0, 342, 775, 342, 342, 342, 342, 342, 342, 342, 342,
  790, 342, 342, 342, 342, 794, 0, 0, 0, 0, 0, 922, 0, 0, 925, 926, 0, 0, 0, 0, 0, 0, 0, 192, 192, 192, 192, 192, 192,
  192, 0, 0, 0, 934, 0, 0, 0, 0, 0, 0, 941, 0, 0, 0, 945, 0, 0, 0, 0, 0, 0, 427, 0, 475, 0, 0, 0, 0, 0, 0, 0, 0, 34816,
  36864, 0, 0, 0, 224, 0, 32768, 0, 0, 949, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 711, 0, 0, 296, 296, 984, 296, 296,
  296, 296, 296, 0, 925, 0, 0, 0, 766, 342, 342, 342, 342, 1646, 342, 342, 342, 342, 342, 1651, 342, 342, 342, 342, 342,
  342, 1048, 342, 11065, 364, 364, 364, 364, 364, 364, 364, 872, 364, 364, 364, 364, 364, 364, 364, 364, 0, 342, 1767,
  342, 342, 342, 1771, 364, 1025, 342, 342, 342, 342, 342, 342, 342, 342, 1035, 342, 342, 342, 342, 342, 342, 342, 1219,
  342, 342, 342, 1223, 342, 342, 342, 342, 0, 0, 0, 0, 1289, 0, 0, 1292, 0, 0, 0, 0, 0, 0, 0, 1300, 0, 0, 0, 1302, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1312, 0, 0, 0, 0, 0, 342, 342, 342, 342, 549, 342, 556, 342, 342, 342, 342, 342, 584, 342,
  342, 342, 342, 0, 364, 364, 364, 364, 364, 364, 1495, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1380, 364, 364,
  364, 1384, 364, 1386, 1313, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 737, 296, 296, 0, 1425, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 424, 0, 0, 0, 0, 0, 1440, 0, 0, 0, 0, 0, 0, 1446, 296, 296, 1448, 296, 296, 296, 296, 296,
  296, 296, 747, 296, 296, 296, 296, 296, 296, 296, 296, 0, 0, 0, 0, 0, 766, 342, 342, 296, 296, 296, 296, 296, 296,
  1453, 296, 1420, 342, 1455, 342, 342, 342, 1458, 342, 342, 573, 342, 576, 342, 342, 586, 342, 342, 0, 364, 364, 364,
  598, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 342, 1674, 342, 342, 342, 342, 342, 1230, 1231, 342, 342, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 0, 0, 0, 0, 342, 1717, 342, 1470, 342, 342, 342, 342, 1473, 342, 342, 1475, 342, 342,
  342, 364, 1479, 364, 0, 0, 0, 0, 0, 0, 0, 342, 1696, 342, 342, 342, 342, 342, 342, 342, 1474, 342, 342, 342, 342, 342,
  364, 364, 364, 364, 1562, 364, 364, 364, 364, 364, 364, 364, 364, 1482, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  1490, 364, 364, 364, 364, 364, 1631, 364, 364, 364, 0, 0, 0, 0, 0, 0, 337920, 364, 1502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1512, 0, 0, 0, 0, 0, 0, 1156, 1157, 0, 0, 0, 0, 0, 0, 0, 0, 707, 766, 342, 342, 342, 342, 342, 342, 1526, 0, 0, 0,
  0, 296, 296, 296, 296, 1534, 296, 296, 296, 342, 342, 342, 342, 577, 342, 342, 342, 342, 342, 0, 364, 364, 364, 364,
  364, 342, 342, 1779, 1780, 342, 342, 364, 364, 1783, 1784, 364, 364, 364, 364, 1762, 1763, 364, 364, 364, 0, 342, 342,
  342, 342, 342, 342, 364, 364, 364, 1684, 364, 364, 364, 364, 364, 364, 364, 342, 342, 342, 342, 364, 364, 364, 364,
  342, 342, 364, 364, 1792, 1793, 342, 342, 776, 781, 342, 342, 342, 342, 342, 342, 342, 342, 792, 342, 342, 342, 342,
  580, 342, 342, 342, 342, 342, 0, 364, 595, 364, 364, 364, 364, 364, 1657, 364, 364, 364, 364, 364, 1662, 364, 364,
  364, 364, 364, 364, 1658, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1098, 364, 364, 364, 364, 364, 364, 0, 457, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 454, 0, 288, 288, 288, 288, 305, 305, 305, 288, 322, 288, 322, 322, 322, 322,
  322, 322, 322, 322, 322, 305, 322, 322, 322, 340, 351, 351, 351, 373, 351, 351, 351, 351, 351, 373, 373, 373, 373,
  373, 373, 373, 351, 351, 373, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 407, 0, 0, 0, 0, 342, 342,
  544, 342, 342, 551, 342, 342, 342, 342, 342, 342, 1194, 342, 1196, 342, 342, 1198, 342, 342, 342, 342, 604, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1665, 0, 0, 0, 0, 4, 182, 0, 0, 0, 648, 652, 0, 0, 0,
  0, 0, 0, 0, 722, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1433, 0, 0, 0, 0, 0, 0, 0, 657, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  468, 0, 740, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 981, 342, 812, 342, 342, 342,
  342, 342, 342, 342, 820, 342, 342, 342, 11065, 766, 364, 0, 0, 0, 0, 0, 0, 0, 1507, 0, 0, 1510, 0, 0, 0, 0, 0, 0, 0,
  69632, 34816, 36864, 0, 0, 0, 0, 0, 32768, 364, 851, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 1070, 364, 901, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 948, 296, 296, 296, 971, 296, 296, 296, 296, 296,
  296, 296, 296, 296, 296, 296, 296, 977, 296, 296, 296, 296, 364, 1058, 1059, 364, 364, 1062, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 1270, 364, 364, 364, 364, 364, 364, 364, 1074, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 0, 1578, 0, 364, 364, 1091, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 860,
  364, 861, 1105, 364, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 910, 296, 296, 0, 0, 0, 0, 0, 1128, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 451, 0, 0, 0, 0, 0, 0, 0, 1152, 0, 0, 1155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665, 0, 0, 0, 0, 669, 342, 1214,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1224, 342, 342, 777, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 364, 364, 1480, 296, 296, 296, 296, 1328, 296, 296, 296, 296, 296, 296, 296, 296, 296,
  296, 296, 1186, 296, 0, 0, 342, 364, 1481, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1251,
  364, 0, 1515, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480, 0, 0, 1589, 1590, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296,
  296, 296, 296, 296, 296, 507, 342, 1614, 342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1259,
  364, 364, 364, 364, 1748, 1749, 364, 364, 364, 0, 0, 0, 1754, 342, 342, 342, 342, 342, 342, 342, 817, 342, 342, 342,
  342, 342, 11065, 766, 364, 1760, 364, 364, 364, 364, 364, 364, 364, 0, 342, 342, 342, 342, 342, 342, 364, 364, 364,
  364, 1620, 1621, 1622, 364, 364, 364, 364, 289, 289, 289, 295, 306, 306, 306, 289, 323, 289, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 306, 323, 323, 323, 323, 352, 352, 352, 374, 352, 352, 352, 352, 352, 374, 374, 374, 374, 374,
  374, 374, 352, 352, 374, 1, 12290, 3, 4, 39094, 39302, 0, 0, 0, 0, 0, 0, 0, 191, 192, 408, 0, 0, 0, 0, 342, 342, 342,
  342, 342, 552, 342, 342, 562, 342, 342, 342, 342, 1681, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1690, 605,
  364, 364, 615, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1409, 0, 0, 0, 0, 0, 0, 0, 0, 703, 0, 0, 0,
  0, 0, 0, 0, 0, 713, 0, 0, 0, 0, 0, 342, 342, 342, 546, 342, 342, 342, 342, 342, 342, 342, 364, 1726, 364, 364, 364,
  364, 364, 364, 364, 856, 364, 364, 364, 859, 364, 364, 364, 364, 0, 0, 0, 0, 905, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  233, 0, 235, 0, 0, 1009, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1023, 342, 342, 342, 342, 1722,
  342, 1724, 364, 364, 364, 364, 364, 364, 1731, 364, 1733, 364, 364, 364, 1060, 364, 364, 364, 364, 364, 364, 364,
  1067, 364, 364, 364, 364, 364, 833, 364, 364, 841, 364, 364, 845, 364, 364, 364, 364, 364, 870, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 1258, 364, 364, 364, 364, 364, 364, 1264, 364, 364, 364, 1268, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 1381, 364, 364, 364, 364, 364, 364, 0, 0, 0, 0, 1506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 726, 0,
  0, 0, 0, 0, 0, 0, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 930, 0, 0, 290, 294, 294, 294, 307, 307, 307, 294, 294,
  290, 294, 294, 294, 294, 294, 294, 334, 294, 294, 294, 307, 294, 339, 334, 294, 353, 353, 353, 375, 353, 353, 353,
  353, 353, 375, 375, 375, 375, 375, 375, 375, 353, 353, 375, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191,
  192, 410, 411, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 482, 0, 0, 0, 227, 227, 227, 0, 0, 0, 0, 0, 435, 0, 0, 0, 0,
  440, 0, 0, 0, 0, 490, 0, 0, 296, 493, 296, 296, 296, 296, 296, 296, 508, 526, 0, 0, 0, 0, 0, 0, 0, 0, 0, 531, 0, 0, 0,
  0, 473, 0, 536, 0, 0, 0, 342, 540, 342, 342, 342, 342, 342, 342, 563, 342, 342, 342, 779, 342, 784, 342, 342, 342,
  342, 789, 342, 342, 342, 342, 342, 342, 816, 342, 342, 342, 821, 342, 342, 11065, 766, 364, 364, 364, 364, 616, 364,
  364, 364, 364, 364, 364, 364, 364, 638, 364, 364, 364, 364, 364, 1764, 1765, 364, 0, 342, 342, 342, 342, 342, 342,
  364, 1559, 364, 364, 364, 364, 364, 364, 364, 364, 364, 874, 364, 364, 364, 364, 364, 364, 0, 0, 658, 0, 0, 0, 0, 0,
  664, 0, 0, 0, 0, 0, 0, 0, 0, 34816, 36864, 0, 272, 0, 0, 0, 32768, 364, 364, 364, 866, 364, 364, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 1382, 364, 364, 364, 364, 0, 0, 0, 0, 921, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 256, 0,
  0, 0, 0, 0, 0, 0, 0, 1141, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 943, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1167, 296, 1169, 296, 296,
  296, 296, 296, 296, 296, 296, 296, 0, 0, 0, 0, 0, 0, 408, 342, 1190, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 1040, 342, 342, 342, 1227, 342, 342, 342, 342, 342, 342, 364, 364, 1235, 364, 364, 364, 364, 364,
  1076, 364, 1080, 364, 364, 364, 364, 364, 364, 364, 364, 873, 364, 364, 364, 364, 364, 364, 364, 0, 0, 1288, 0, 0,
  1290, 1291, 0, 0, 1294, 0, 0, 0, 0, 1299, 0, 0, 0, 0, 0, 342, 539, 342, 342, 342, 342, 342, 342, 561, 342, 342, 342,
  342, 1463, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1037, 342, 342, 342, 342, 296, 296, 296, 296, 296,
  1329, 296, 296, 1331, 296, 296, 296, 1334, 296, 296, 296, 296, 296, 296, 296, 296, 521, 0, 0, 0, 0, 0, 0, 0, 0, 34816,
  36864, 0, 0, 0, 0, 0, 32768, 296, 296, 1337, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1344, 342, 342, 342, 342,
  783, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1357, 342, 342, 342, 342, 1348, 342, 1350, 342, 342, 342,
  342, 342, 342, 342, 1356, 342, 342, 342, 342, 342, 342, 1207, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1017, 342,
  342, 342, 342, 342, 342, 364, 1402, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 0, 0, 0, 0, 890, 0, 0, 0,
  0, 0, 896, 0, 0, 0, 0, 0, 1427, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 212, 213, 0, 0, 1439, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 296, 296, 296, 296, 296, 342, 0, 0, 0, 0, 0, 1531, 296, 296, 296, 296, 296, 296, 296, 342, 1539, 342, 342, 778,
  342, 342, 342, 342, 787, 342, 342, 342, 342, 342, 342, 342, 342, 819, 342, 342, 342, 342, 11065, 766, 364, 364, 1567,
  364, 364, 364, 1570, 364, 364, 364, 364, 364, 364, 364, 0, 0, 1579, 0, 0, 0, 0, 0, 1593, 0, 0, 0, 0, 296, 296, 1596,
  1597, 296, 296, 0, 342, 342, 342, 1340, 342, 342, 1342, 342, 342, 342, 342, 342, 342, 342, 1195, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 1547, 342, 342, 342, 1550, 342, 342, 364, 364, 1628, 364, 364, 364, 364, 364, 364, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1285, 364, 0, 1692, 0, 325632, 0, 0, 0, 342, 342, 342, 1698, 342, 342, 342, 342, 342, 999,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1018, 342, 1022, 342, 342, 342, 342, 364, 364, 364, 1707, 364, 364,
  364, 364, 364, 0, 0, 0, 1715, 342, 342, 342, 780, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 804,
  342, 342, 342, 364, 1774, 1775, 364, 364, 342, 342, 342, 342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  1713, 0, 1714, 0, 342, 342, 364, 1796, 1797, 342, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 397, 452, 0, 0, 0, 216, 217,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 0, 0, 245, 0, 360, 360, 0,
  0, 0, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 216, 246, 216, 0, 0, 0, 216, 0, 0, 0, 34816, 36864, 0, 216, 217, 215, 217,
  32768, 291, 291, 291, 291, 308, 308, 308, 315, 324, 330, 324, 324, 324, 324, 324, 324, 324, 324, 324, 308, 324, 324,
  324, 324, 354, 354, 354, 376, 354, 354, 354, 354, 354, 376, 376, 376, 376, 376, 376, 376, 354, 354, 376, 1, 12290, 3,
  4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 412, 0, 414, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 0,
  0, 0, 227, 227, 227, 0, 431, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 0, 0, 0, 0, 0, 0, 441, 442, 0, 444, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 227, 0, 0, 0, 0, 399, 471, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1121, 0, 0, 485, 0, 0, 488, 0, 0,
  491, 296, 296, 296, 497, 296, 296, 504, 296, 296, 0, 342, 342, 1339, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  0, 364, 592, 364, 364, 364, 296, 512, 296, 296, 296, 296, 518, 296, 296, 0, 0, 0, 0, 402, 0, 0, 0, 0, 0, 0, 1305, 0,
  0, 0, 1308, 0, 0, 0, 0, 0, 0, 0, 1117, 0, 0, 0, 0, 0, 0, 0, 0, 724, 0, 0, 0, 0, 0, 0, 0, 0, 0, 528, 0, 0, 488, 0, 471,
  0, 0, 0, 402, 402, 414, 0, 0, 0, 0, 0, 0, 1318, 0, 0, 0, 0, 1322, 0, 0, 0, 296, 0, 0, 444, 0, 0, 342, 342, 342, 547,
  550, 342, 557, 342, 342, 342, 569, 571, 342, 342, 342, 579, 582, 342, 342, 342, 342, 0, 364, 364, 364, 600, 603, 364,
  610, 364, 364, 364, 622, 624, 364, 364, 364, 632, 635, 364, 364, 364, 364, 364, 1094, 364, 1096, 364, 364, 364, 1100,
  364, 364, 364, 364, 364, 364, 1632, 364, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 899, 0, 364, 364, 865, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 878, 364, 364, 0, 884, 722, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1133, 0, 0, 0,
  0, 0, 0, 0, 0, 952, 0, 0, 0, 954, 0, 464, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1131, 0, 0, 0, 0, 0,
  0, 296, 968, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 980, 296, 296, 0, 342, 1338, 342, 342, 342, 342,
  342, 342, 1343, 342, 342, 342, 342, 342, 1217, 1218, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1476, 342, 342,
  364, 364, 364, 296, 296, 296, 296, 296, 987, 296, 296, 909, 0, 0, 0, 0, 766, 342, 342, 342, 814, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 11065, 766, 364, 342, 1043, 342, 342, 342, 342, 342, 342, 11065, 364, 364, 364, 364, 364,
  1054, 364, 0, 0, 0, 0, 0, 0, 0, 1695, 342, 342, 342, 342, 342, 342, 342, 342, 1466, 342, 342, 342, 342, 342, 342, 342,
  342, 11065, 364, 364, 364, 364, 364, 364, 364, 625, 627, 364, 364, 636, 364, 364, 364, 364, 1123, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1149, 364, 1253, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1261,
  364, 0, 0, 0, 0, 1417, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 428, 428, 0, 0, 0, 364, 0, 0, 1504, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 227, 0, 0, 59392, 342, 1542, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1654, 342,
  1655, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1500, 364, 364, 0, 1667, 0, 1669, 0,
  0, 0, 0, 0, 296, 342, 342, 342, 1675, 342, 342, 796, 342, 342, 799, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 1549, 342, 342, 342, 342, 342, 364, 1705, 364, 364, 364, 364, 364, 364, 364, 0, 0, 0, 0, 342, 342, 342, 996, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 824, 11065, 766, 364, 1795, 342, 364, 342, 364, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 475, 0, 0, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1163, 355, 377, 355, 355, 355,
  355, 355, 377, 377, 377, 377, 377, 377, 377, 355, 355, 377, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191,
  192, 0, 0, 0, 455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 69632, 0, 0, 0, 659, 0, 0, 0, 663, 0, 0, 0, 0, 0, 0,
  0, 0, 678, 679, 0, 227, 227, 0, 0, 0, 0, 699, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 714, 0, 0, 0, 0, 0, 399, 0, 0, 402,
  403, 404, 0, 0, 0, 0, 0, 0, 0, 908, 0, 0, 0, 0, 0, 0, 0, 0, 194, 195, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 745, 296,
  296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 0, 0, 660, 0, 0, 0, 342, 795, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 808, 342, 342, 797, 342, 342, 342, 800, 342, 342, 342, 342, 342, 342, 342, 809, 810, 364,
  364, 364, 867, 364, 364, 364, 364, 364, 364, 364, 364, 876, 364, 364, 364, 364, 619, 364, 364, 364, 626, 364, 629,
  364, 364, 639, 364, 364, 0, 0, 935, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 947, 0, 0, 0, 0, 0, 415, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 243, 0, 0, 0, 0, 0, 0, 342016, 0, 0, 0, 0, 0, 0, 715, 0, 0, 0, 0, 0, 0, 0, 0, 34816, 36864, 0, 273, 0, 0, 0,
  32768, 0, 1287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 696, 0, 364, 1666, 0, 1668, 0, 0, 0, 0, 0, 0, 296, 342, 342,
  342, 342, 342, 342, 342, 342, 1607, 342, 342, 342, 342, 342, 342, 342, 1649, 342, 1650, 342, 342, 342, 342, 342, 342,
  342, 1033, 342, 342, 342, 342, 342, 342, 342, 342, 801, 342, 802, 803, 342, 342, 342, 342, 476, 0, 0, 0, 0, 342, 342,
  342, 342, 342, 553, 342, 342, 342, 342, 342, 342, 1368, 342, 342, 342, 342, 342, 1372, 342, 342, 342, 606, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 642, 0, 0, 0, 0, 4, 39094, 0, 0, 0, 649, 653, 0, 0, 0, 0,
  0, 0, 0, 940, 0, 0, 0, 0, 0, 0, 0, 0, 706, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 219, 220, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0,
  0, 0, 0, 0, 658, 0, 0, 0, 0, 0, 0, 0, 0, 0, 419, 420, 421, 0, 423, 0, 0, 218, 0, 0, 0, 0, 0, 0, 0, 218, 0, 0, 0, 0, 0,
  0, 0, 0, 34816, 36864, 270, 0, 204, 0, 204, 32768, 0, 0, 0, 218, 0, 0, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 690, 691, 0, 0,
  0, 0, 0, 0, 218, 0, 218, 0, 0, 0, 218, 0, 34816, 36864, 218, 218, 220, 0, 220, 32768, 0, 0, 0, 0, 309, 309, 309, 0,
  218, 220, 218, 218, 218, 218, 218, 218, 335, 218, 218, 309, 218, 218, 218, 218, 356, 356, 356, 378, 356, 356, 356,
  356, 356, 378, 378, 378, 378, 378, 378, 378, 356, 356, 378, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191,
  192, 0, 0, 227, 227, 227, 0, 0, 0, 0, 0, 0, 0, 0, 438, 0, 0, 0, 0, 0, 0, 1430, 0, 0, 0, 0, 1435, 0, 0, 0, 0, 0, 0, 0,
  1584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6144, 0, 0, 0, 6144, 6144, 6144, 0, 0, 443, 0, 0, 446, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1119, 0, 0, 0, 0, 0, 0, 0, 487, 489, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296, 296, 296, 0, 0, 0, 0, 0, 0, 476, 296,
  296, 296, 514, 296, 296, 519, 296, 296, 0, 487, 0, 0, 0, 0, 0, 0, 0, 953, 0, 0, 0, 0, 0, 956, 0, 0, 0, 0, 0, 529, 0,
  0, 0, 0, 0, 530, 0, 0, 0, 0, 0, 0, 0, 201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 772096, 0, 0, 0, 0, 819200, 0, 342, 572, 574,
  342, 342, 583, 342, 342, 342, 342, 0, 364, 364, 364, 364, 364, 364, 1077, 1079, 364, 364, 364, 364, 1085, 1086, 1087,
  364, 0, 0, 0, 685, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 697, 0, 0, 0, 719, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 191,
  191, 0, 850, 852, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1664, 364, 364, 863, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 877, 364, 881, 957, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  296, 296, 296, 738, 296, 296, 296, 296, 296, 296, 296, 988, 296, 0, 0, 0, 0, 0, 766, 342, 342, 342, 1012, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1199, 342, 342, 342, 0, 1124, 1125, 1126, 1127, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1135, 0, 0, 0, 0, 0, 461, 423, 0, 0, 0, 0, 0, 0, 467, 0, 469, 0, 0, 0, 0, 1140, 0, 1142, 0, 0, 0, 1144, 0, 0, 0,
  1148, 0, 0, 0, 0, 0, 661, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 195, 0, 0, 0, 0, 0, 0, 1165, 0, 0, 1168, 296, 1170, 296,
  296, 296, 296, 296, 296, 296, 296, 0, 0, 990, 959, 0, 766, 342, 342, 296, 296, 1178, 296, 296, 1180, 1181, 296, 296,
  296, 296, 296, 296, 0, 1187, 1188, 364, 364, 364, 1254, 1255, 364, 1257, 364, 364, 364, 364, 364, 364, 1260, 364, 364,
  364, 364, 1075, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1487, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 1266, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1395, 1396, 364, 364, 364, 1400, 364, 364,
  1277, 0, 0, 0, 0, 0, 0, 0, 1281, 0, 0, 0, 0, 0, 0, 0, 961, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296, 296,
  342, 342, 1540, 0, 0, 0, 0, 0, 1518, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1132, 0, 0, 0, 0, 0, 364, 364, 364, 1776, 364, 342,
  342, 342, 342, 342, 342, 364, 364, 364, 364, 364, 364, 1095, 364, 364, 364, 364, 364, 364, 364, 364, 364, 857, 364,
  364, 364, 364, 364, 364, 248, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 255, 0, 258, 259, 260, 0, 0, 0, 0, 263, 0, 0, 34816,
  36864, 0, 260, 0, 263, 0, 32768, 0, 0, 0, 221, 310, 310, 310, 263, 325, 263, 325, 325, 325, 325, 325, 325, 325, 325,
  325, 310, 325, 325, 325, 341, 357, 357, 357, 379, 357, 357, 357, 357, 357, 379, 379, 379, 379, 379, 379, 379, 357,
  357, 379, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 397, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 227, 192, 192, 0, 0, 0, 0, 0, 397, 0, 0, 0, 0, 0, 0, 0, 466, 0, 0, 0, 0, 0, 0, 676, 0, 0, 0, 0, 227, 227, 0, 0, 0,
  0, 0, 0, 470, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 482, 0, 0, 0, 0, 524,
  0, 482, 0, 0, 0, 342, 541, 342, 342, 342, 342, 342, 342, 564, 342, 342, 342, 1192, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 1358, 342, 342, 342, 364, 364, 364, 617, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 1575, 364, 364, 0, 0, 0, 0, 0, 0, 0, 4, 39094, 0, 0, 0, 0, 0, 0, 0, 654, 0, 0, 0, 0, 0, 0, 1442, 0, 0, 0, 0,
  296, 296, 296, 296, 296, 296, 296, 296, 0, 342, 342, 1456, 342, 342, 342, 342, 656, 0, 0, 0, 0, 0, 662, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 733, 0, 296, 296, 296, 296, 296, 0, 0, 0, 0, 686, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 666, 0, 668, 0, 0, 0,
  0, 0, 701, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 212, 0, 0, 0, 0, 718, 0, 0, 0, 0, 0, 0, 725, 0, 0, 0, 0, 0, 0, 0,
  223, 0, 0, 0, 0, 227, 0, 0, 0, 729, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 739, 296, 742, 296, 744, 296,
  296, 296, 296, 296, 296, 296, 749, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 1185, 296, 296, 0, 0, 342, 0, 0,
  729, 763, 764, 0, 0, 729, 0, 766, 342, 342, 342, 342, 342, 342, 585, 342, 342, 342, 0, 364, 593, 364, 364, 364, 774,
  342, 342, 782, 342, 342, 786, 342, 342, 342, 342, 342, 342, 342, 342, 342, 364, 364, 364, 1236, 364, 364, 364, 0, 902,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1122, 0, 0, 0, 0, 936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 946, 0, 0, 0, 0, 0, 0,
  1641, 0, 0, 0, 296, 296, 296, 296, 296, 342, 342, 1602, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 11065, 766, 364, 364, 1073, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1102, 364,
  1104, 0, 1151, 0, 0, 0, 0, 0, 0, 0, 715, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0, 0, 465, 0, 0, 0, 0, 0, 0, 0,
  296, 296, 296, 296, 296, 296, 296, 1182, 296, 296, 296, 296, 296, 0, 0, 342, 342, 813, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 11065, 766, 364, 0, 0, 0, 0, 0, 0, 0, 1672, 0, 296, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 1008, 1189, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 1039, 342, 342, 342, 1226, 342, 342, 342, 342, 342, 342, 342, 364, 1234, 364, 364, 364, 364, 364, 364, 1244, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 1269, 364, 364, 364, 364, 364, 364, 364, 342, 1363, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 1200, 342, 342, 0, 0, 0, 0, 1428, 0, 0, 1431, 0, 0, 0, 0, 0, 0, 0, 0,
  708, 766, 342, 342, 342, 342, 342, 342, 342, 342, 1471, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 364, 364,
  364, 364, 364, 1238, 364, 1599, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1612, 364, 364,
  364, 1629, 364, 364, 364, 364, 364, 1634, 0, 0, 1636, 0, 0, 0, 0, 0, 0, 688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 0, 0, 0,
  0, 0, 0, 1677, 1678, 342, 342, 342, 342, 364, 364, 364, 364, 364, 1686, 1687, 364, 364, 364, 364, 832, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 1498, 364, 364, 364, 364, 364, 364, 1750, 364, 364, 0, 1753, 0, 342, 1755,
  342, 342, 342, 342, 342, 342, 785, 342, 342, 788, 342, 342, 342, 342, 342, 342, 342, 1208, 342, 342, 342, 342, 342,
  342, 342, 342, 818, 342, 822, 342, 342, 11065, 766, 364, 364, 1761, 364, 364, 364, 364, 364, 364, 0, 342, 342, 342,
  342, 342, 342, 364, 364, 1619, 364, 364, 364, 364, 364, 364, 364, 364, 0, 342, 342, 342, 342, 1770, 342, 364, 292,
  292, 292, 292, 311, 311, 311, 292, 326, 292, 326, 292, 292, 292, 292, 292, 292, 292, 292, 326, 311, 326, 292, 292,
  292, 358, 358, 358, 380, 358, 358, 358, 358, 358, 380, 380, 380, 380, 380, 380, 380, 358, 358, 380, 1, 12290, 3, 4,
  39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 227, 227, 227, 0, 0, 0, 0, 434, 0, 0, 0, 0, 0, 0, 0, 238, 0, 0, 0,
  0, 0, 0, 0, 0, 265, 265, 0, 0, 0, 0, 0, 265, 0, 458, 458, 459, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 229, 0, 0, 0, 511,
  296, 296, 296, 296, 517, 296, 296, 296, 0, 0, 0, 0, 0, 0, 0, 0, 55560, 36864, 0, 0, 0, 0, 0, 32768, 0, 484, 0, 0, 459,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 434, 0, 0, 0, 484, 537, 342, 542, 342, 342, 342, 342, 342, 559, 565, 568, 342, 342, 995,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 806, 342, 342, 364, 364, 612, 618, 621, 364, 364,
  364, 364, 364, 633, 364, 364, 364, 364, 364, 364, 1406, 364, 364, 364, 364, 364, 364, 0, 0, 0, 0, 1278, 0, 0, 0, 0, 0,
  0, 0, 0, 732, 0, 0, 296, 296, 296, 296, 296, 0, 0, 672, 673, 0, 0, 0, 0, 0, 0, 680, 227, 227, 0, 0, 682, 683, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1438, 0, 0, 0, 0, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 693, 0, 695, 0, 0, 730, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 735, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 1333, 296, 296, 296, 296, 296, 296,
  296, 296, 296, 296, 748, 296, 296, 296, 296, 296, 296, 296, 296, 296, 0, 416, 455, 0, 0, 0, 0, 296, 296, 754, 755,
  296, 296, 296, 296, 296, 760, 0, 0, 0, 761, 720, 0, 0, 0, 0, 0, 675, 0, 0, 0, 0, 0, 227, 227, 0, 0, 0, 0, 0, 0, 400,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 910, 0, 0, 0, 0, 0, 916, 0, 0, 761, 0, 0, 765, 683, 761, 0, 766, 767, 342, 342, 771, 342,
  342, 342, 1215, 342, 342, 342, 342, 342, 1221, 342, 342, 342, 342, 342, 342, 342, 1725, 364, 364, 364, 364, 364, 364,
  364, 364, 1065, 364, 364, 364, 364, 364, 364, 364, 364, 364, 830, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 364, 1273, 1274, 364, 364, 364, 364, 868, 869, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1394,
  364, 364, 364, 364, 364, 364, 882, 364, 0, 0, 0, 0, 0, 890, 0, 0, 0, 896, 0, 0, 0, 0, 0, 0, 0, 86401, 86401, 86401,
  86401, 86401, 86401, 86401, 0, 0, 0, 0, 0, 0, 959, 0, 0, 0, 962, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296,
  296, 342, 342, 342, 296, 296, 970, 296, 296, 296, 296, 296, 975, 296, 296, 296, 978, 296, 296, 296, 296, 296, 296,
  296, 296, 522, 0, 0, 0, 0, 0, 475, 0, 1057, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1069, 364,
  364, 364, 364, 1093, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1103, 364, 1072, 364, 364, 364, 364, 364, 1078, 364,
  364, 1082, 364, 364, 364, 364, 364, 364, 854, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1247, 364, 364, 364, 364,
  364, 364, 0, 0, 0, 0, 0, 1115, 0, 0, 0, 0, 0, 1120, 0, 0, 0, 0, 0, 0, 0, 104835, 104835, 104835, 104835, 104835,
  104835, 104835, 104728, 104728, 1137, 0, 1138, 1139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 245, 0, 0, 0, 0, 0, 0, 1153,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 406, 407, 0, 0, 0, 0, 0, 1166, 0, 296, 296, 296, 296, 296, 296, 296, 296, 296,
  296, 296, 0, 0, 718, 0, 0, 0, 1225, 342, 342, 342, 342, 342, 342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364,
  1564, 364, 364, 1252, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1398, 364, 364, 0,
  1314, 0, 0, 0, 0, 0, 0, 0, 0, 1321, 0, 0, 0, 0, 296, 296, 296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209, 210, 0, 0, 0, 0, 0,
  296, 296, 296, 1327, 296, 296, 296, 1330, 296, 296, 296, 296, 296, 296, 296, 296, 0, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 0, 0, 364, 364, 1374, 364, 364, 364, 364, 364, 364, 1379, 364, 364, 364, 364, 364,
  364, 364, 1486, 364, 364, 364, 364, 364, 364, 364, 364, 0, 342, 342, 342, 342, 342, 342, 364, 364, 364, 1388, 364,
  364, 1390, 1391, 364, 364, 364, 364, 364, 1397, 364, 364, 364, 364, 853, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 1084, 364, 364, 364, 364, 0, 0, 1415, 1416, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1422, 0, 0, 0, 0, 0, 0, 69632, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1434, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1429, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1158, 0, 0, 0, 0, 0,
  342, 1461, 342, 342, 342, 1464, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1222, 342, 342, 342, 342, 342, 364,
  364, 364, 1483, 364, 1485, 364, 364, 364, 1488, 364, 364, 364, 364, 364, 364, 871, 364, 364, 364, 364, 364, 364, 364,
  879, 364, 0, 0, 0, 1517, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 422, 0, 0, 0, 342, 342, 1555, 342, 342, 364, 364, 1560,
  364, 364, 364, 364, 364, 364, 1565, 364, 0, 0, 0, 0, 0, 0, 1671, 0, 0, 296, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 1609, 342, 342, 342, 1580, 0, 0, 0, 0, 0, 1583, 0, 0, 0, 0, 0, 0, 0, 0, 0, 766, 342, 342, 342, 342,
  772, 342, 1613, 342, 342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1573, 364, 364, 364, 0, 0,
  0, 1626, 364, 364, 364, 1630, 364, 364, 364, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1283, 0, 0, 0, 0, 1638, 0, 0, 0, 0, 0, 0,
  0, 0, 296, 296, 296, 296, 296, 342, 342, 1011, 342, 342, 1014, 342, 342, 342, 342, 342, 1020, 342, 342, 1024, 342,
  342, 1044, 342, 1046, 342, 342, 342, 11065, 364, 364, 364, 364, 1053, 364, 364, 364, 364, 1061, 364, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 1659, 364, 364, 364, 364, 364, 364, 364, 364, 1393, 364, 364, 364, 364, 364, 1399,
  364, 364, 364, 364, 364, 1656, 364, 364, 364, 364, 364, 364, 364, 364, 1663, 364, 364, 364, 364, 1267, 364, 364, 364,
  364, 364, 364, 1271, 364, 364, 364, 364, 364, 1256, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1066, 364, 364,
  364, 364, 364, 0, 0, 1736, 342, 342, 342, 342, 342, 342, 342, 342, 1744, 364, 364, 364, 364, 364, 1494, 364, 364, 364,
  364, 1497, 364, 364, 1499, 364, 364, 364, 364, 364, 364, 1752, 0, 0, 0, 342, 342, 342, 342, 342, 1758, 1759, 342, 342,
  1191, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 364, 364, 364, 364, 342, 342, 342, 342, 364,
  364, 364, 364, 342, 1790, 364, 1791, 342, 364, 342, 342, 342, 342, 364, 364, 364, 364, 342, 342, 364, 364, 342, 364,
  1794, 293, 293, 293, 293, 312, 312, 312, 316, 293, 316, 293, 293, 293, 293, 293, 293, 293, 293, 293, 312, 293, 293,
  293, 293, 359, 359, 359, 381, 359, 359, 359, 359, 359, 381, 381, 381, 381, 381, 381, 381, 359, 359, 381, 1, 12290, 3,
  4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 0, 4, 39094, 0, 0, 0, 0, 0, 0, 0, 0, 655, 0, 0, 0, 0, 0, 687,
  0, 0, 0, 0, 692, 0, 0, 0, 0, 0, 0, 0, 448, 0, 0, 0, 434, 0, 0, 0, 0, 716, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  104725, 364, 883, 0, 0, 0, 0, 0, 0, 891, 0, 0, 0, 897, 0, 0, 0, 0, 0, 0, 704, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 0, 0, 0,
  0, 355, 355, 917, 0, 0, 920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 476, 0, 0, 0, 0, 0, 0, 0, 0, 938, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1295, 0, 0, 0, 0, 0, 296, 983, 296, 296, 296, 296, 296, 296, 0, 0, 0, 0, 991, 766, 342, 342, 342, 1228,
  1229, 342, 342, 342, 342, 364, 364, 364, 364, 364, 364, 364, 364, 364, 0, 0, 0, 0, 342, 342, 1026, 342, 342, 342, 342,
  342, 342, 342, 1034, 342, 342, 342, 342, 342, 342, 342, 1016, 342, 342, 342, 342, 342, 342, 342, 342, 588, 342, 0,
  364, 364, 364, 364, 602, 364, 364, 364, 1092, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1097, 364,
  364, 364, 364, 364, 364, 364, 1413, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1423, 0, 364, 364, 364, 1751, 364, 0,
  0, 0, 342, 342, 342, 342, 342, 342, 342, 342, 1002, 342, 342, 342, 342, 342, 342, 342, 0, 225, 0, 0, 296, 296, 296,
  224, 0, 224, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 296, 296, 296, 296, 506, 296, 360, 382, 360, 360, 360, 360, 360, 382,
  382, 382, 382, 382, 382, 382, 360, 360, 382, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 607, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1410, 1411, 0, 0, 0, 0, 0, 674, 0, 0, 0, 0, 0,
  0, 227, 227, 0, 0, 0, 0, 0, 0, 711, 953, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1444, 0, 296, 296, 296, 296, 296, 296, 296, 743,
  296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 296, 0, 717, 0, 0, 0, 0, 0, 0, 1639, 0, 0, 0, 0, 0, 0, 0,
  296, 296, 296, 296, 296, 342, 342, 1204, 1205, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1467, 342,
  342, 342, 342, 0, 0, 0, 0, 313, 313, 313, 0, 327, 0, 327, 327, 327, 327, 327, 327, 327, 327, 327, 313, 327, 327, 327,
  327, 361, 361, 361, 383, 361, 361, 361, 361, 361, 383, 383, 383, 383, 383, 383, 383, 361, 361, 383, 1, 12290, 3, 4,
  39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 364, 364, 364, 364, 1389, 364, 364, 364, 364, 364, 364, 364, 364, 364,
  364, 364, 1660, 364, 1661, 364, 364, 364, 364, 364, 362, 384, 362, 362, 362, 362, 362, 384, 384, 384, 384, 384, 384,
  384, 362, 362, 384, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 227, 227, 227, 0, 0, 0, 433, 0,
  0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 535, 0, 0, 0, 0, 342, 342, 342, 342, 342,
  555, 342, 342, 342, 342, 342, 342, 1545, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1197, 342, 342, 342, 342, 1201,
  342, 608, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 1633, 364, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 296, 342, 342, 342, 342, 342, 0, 0, 903, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1134, 0, 0, 364, 0, 1503, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1147, 0, 0, 0, 0, 0, 389120, 0, 0, 0, 0, 0, 0, 389120, 0, 0, 389120, 0, 389120,
  389120, 389120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 389120, 227, 0, 389120, 0, 0, 0, 0, 0, 0, 389120, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1420, 0, 0, 0, 0, 0, 393216, 393216, 393216, 393216, 0, 0, 0, 393216, 393216, 393216, 393216, 393216,
  393216, 393216, 393216, 393216, 393216, 393216, 393216, 393216, 393216, 0, 0, 393216, 1, 12290, 3, 4, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 191, 192, 0, 0, 395264, 0, 0, 0, 0, 0, 395264, 0, 395264, 395264, 395264, 395264, 395264, 395264, 395264,
  395264, 395264, 395264, 395264, 395264, 395264, 395264, 0, 0, 395264, 1, 12290, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191,
  192, 0, 1, 12290, 3, 4, 39094, 39094, 0, 0, 0, 0, 0, 0, 0, 191, 192, 6144, 6144, 0, 6144, 0, 0, 0, 6144, 6144, 6144,
  6144, 6144, 6144, 6144, 6144, 6144, 6144, 6144, 6144, 6144, 6144, 0, 0, 0, 542720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  671744, 0, 0, 690176
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  50, 95, 111, 127, 142, 254, 158, 174, 588, 65, 707, 698, 79, 605, 207, 223, 239, 270, 189, 286, 302, 318, 334, 350,
  366, 382, 398, 414, 430, 446, 462, 478, 494, 510, 526, 542, 558, 621, 637, 573, 653, 669, 685, 602, 605, 605, 605,
  605, 605, 204, 723, 727, 735, 736, 734, 735, 740, 730, 744, 748, 752, 756, 802, 802, 760, 802, 802, 802, 802, 802,
  802, 802, 802, 1836, 802, 802, 802, 802, 948, 802, 802, 1002, 802, 802, 802, 802, 802, 802, 802, 1335, 802, 802, 802,
  802, 1002, 766, 1531, 1489, 776, 802, 1073, 875, 867, 789, 802, 976, 802, 858, 801, 1488, 808, 813, 1072, 843, 843,
  844, 867, 867, 867, 824, 802, 802, 802, 1555, 1503, 808, 1414, 843, 843, 843, 888, 867, 867, 867, 832, 827, 802, 802,
  1276, 1412, 809, 843, 843, 1404, 867, 867, 867, 836, 802, 802, 1487, 808, 842, 843, 843, 867, 867, 868, 1402, 1405,
  869, 1144, 843, 867, 862, 865, 873, 879, 851, 883, 886, 853, 892, 896, 899, 903, 907, 917, 912, 916, 1946, 921, 925,
  929, 933, 937, 941, 802, 1677, 802, 802, 1107, 1137, 802, 802, 1111, 802, 1120, 1124, 1638, 1135, 802, 1880, 1142,
  802, 802, 1182, 802, 1675, 954, 802, 802, 1355, 1016, 958, 962, 966, 970, 973, 1692, 980, 802, 1115, 986, 990, 994,
  1000, 1006, 1013, 1020, 1025, 802, 1040, 802, 1113, 1028, 1899, 1044, 1050, 802, 1848, 1057, 802, 802, 1558, 1061,
  802, 802, 1287, 802, 802, 1078, 1066, 1184, 802, 802, 1488, 848, 843, 1403, 867, 867, 857, 802, 1399, 843, 1405, 868,
  802, 1504, 1429, 1070, 802, 802, 1085, 1137, 802, 802, 1286, 981, 802, 1077, 1082, 1089, 1095, 1099, 1225, 802, 1148,
  1152, 1457, 802, 1456, 1159, 1224, 1829, 1511, 1127, 828, 1129, 1453, 1700, 1164, 1168, 1167, 1172, 1178, 1543, 1371,
  1182, 1188, 1199, 1518, 1206, 1211, 1210, 1215, 1219, 1222, 802, 802, 1538, 802, 1231, 1229, 1235, 1239, 1243, 1246,
  1250, 802, 1053, 1699, 1496, 1500, 1021, 1328, 1439, 1392, 1155, 1254, 762, 1258, 802, 1538, 1285, 1498, 1502, 1263,
  1445, 1267, 1062, 1274, 1280, 1284, 802, 1482, 1291, 802, 802, 1308, 1046, 1313, 1021, 1754, 1582, 1541, 1381, 1297,
  802, 802, 1361, 1301, 802, 802, 1307, 1045, 1312, 1259, 1348, 1317, 982, 1322, 802, 802, 1867, 1326, 802, 1548, 1045,
  1332, 1658, 1343, 802, 1352, 802, 820, 1359, 802, 1386, 1365, 1346, 1380, 1195, 802, 1194, 802, 1385, 1391, 1396,
  1521, 1116, 1523, 1409, 1418, 1339, 1338, 802, 1644, 1865, 1845, 943, 1102, 944, 1422, 1426, 1103, 1621, 1623, 1433,
  1437, 802, 802, 1771, 1443, 1031, 1610, 1450, 1461, 1465, 1469, 1473, 1476, 802, 1270, 1854, 1858, 772, 1486, 1493,
  1874, 1887, 1508, 1515, 1009, 802, 1771, 1443, 1856, 1838, 779, 1727, 802, 1528, 1535, 802, 1303, 1547, 802, 1387,
  1552, 802, 1138, 1587, 1592, 772, 1562, 1566, 1571, 795, 802, 1575, 802, 802, 1524, 1579, 802, 802, 1586, 1591, 802,
  802, 782, 1035, 802, 1596, 802, 802, 1567, 1579, 802, 1600, 1607, 802, 1781, 1034, 802, 1614, 802, 1744, 1633, 785,
  1627, 802, 792, 802, 1632, 802, 1631, 1762, 1202, 802, 819, 818, 816, 1174, 1637, 769, 1651, 1650, 1642, 1648, 1446,
  1293, 1656, 1191, 1662, 1672, 1376, 1656, 1374, 1681, 1685, 1689, 802, 802, 1318, 1696, 1091, 1704, 1708, 1712, 1716,
  1720, 1724, 802, 802, 1751, 1036, 1731, 1735, 1776, 1652, 1739, 1787, 1757, 1743, 1748, 802, 1318, 1761, 1824, 1766,
  802, 802, 1915, 1786, 802, 982, 1818, 802, 1795, 1842, 1852, 1862, 802, 1337, 1871, 802, 996, 802, 802, 802, 802, 802,
  802, 1368, 802, 802, 802, 802, 1160, 802, 802, 771, 802, 802, 802, 802, 802, 802, 802, 802, 802, 802, 802, 802, 802,
  802, 802, 802, 1770, 1810, 1775, 1780, 802, 1905, 1785, 802, 982, 1791, 802, 804, 1799, 1806, 1530, 1619, 838, 1829,
  802, 802, 1814, 1756, 802, 982, 1818, 802, 803, 1828, 1802, 1617, 802, 1834, 950, 1878, 1794, 1884, 802, 1809, 802,
  1892, 802, 1891, 1896, 1903, 802, 1478, 802, 1480, 1909, 802, 797, 796, 1919, 802, 1821, 1929, 1923, 1668, 1912, 1927,
  1665, 1933, 1937, 1939, 1940, 802, 802, 802, 802, 802, 802, 802, 802, 1603, 1944, 908, 1131, 802, 802, 802, 802, 802,
  802, 802, 802, 1830, 802, 802, 802, 802, 802, 802, 802, 802, 802, 802, 802, 802, 1336, 802, 802, 802, 2018, 2024,
  2228, 1953, 1950, 1957, 1959, 1959, 1973, 1971, 1960, 1967, 1959, 1959, 1959, 1959, 1964, 1975, 1959, 1959, 1959,
  1982, 1979, 1989, 1986, 1990, 1996, 1994, 1998, 2002, 2006, 2010, 2013, 2017, 2022, 2909, 2802, 3116, 2585, 2030,
  2030, 2030, 3268, 2030, 3101, 2038, 2030, 2029, 2030, 2030, 2778, 2030, 2030, 2396, 2396, 2072, 2030, 2030, 2966,
  2030, 2030, 3001, 2030, 2030, 3034, 2862, 2051, 3214, 2083, 2030, 2030, 3039, 2243, 2030, 2030, 2030, 2878, 3330,
  2526, 2030, 2030, 2030, 2030, 2031, 2757, 2396, 2396, 2396, 2396, 2279, 2396, 2396, 2071, 2030, 2030, 3059, 2029,
  2030, 2030, 2030, 2926, 2079, 2803, 2083, 2087, 2030, 2030, 2030, 2047, 2251, 2082, 2083, 2083, 2113, 2804, 2030,
  2030, 2030, 3281, 2092, 2247, 2247, 2247, 2247, 2111, 2396, 2396, 2246, 2247, 2248, 2043, 2043, 2246, 2248, 2046,
  2030, 2030, 2030, 2065, 2046, 2030, 2792, 2247, 2249, 2043, 2043, 2043, 2043, 2046, 2030, 2046, 2030, 2247, 2247,
  2110, 2043, 2250, 2043, 2045, 2245, 2244, 2247, 2247, 2043, 2046, 2247, 2247, 2112, 2043, 2043, 2122, 2248, 2043,
  2122, 2250, 2117, 2120, 2046, 3196, 2127, 2126, 2404, 2628, 2131, 2137, 2632, 2632, 2632, 2030, 2142, 2631, 2148,
  2152, 2133, 2632, 2632, 2632, 2632, 2632, 2144, 2166, 2162, 2165, 2170, 2173, 2177, 2180, 2184, 2188, 2194, 2190,
  2625, 2633, 2198, 2199, 2203, 2030, 2210, 2032, 2220, 2030, 2030, 2030, 3290, 2030, 2030, 3276, 2030, 2030, 2030,
  3296, 2030, 3205, 2502, 2267, 2285, 2289, 2844, 2297, 2777, 2308, 2316, 2318, 2322, 2326, 2330, 2331, 2335, 2337,
  2341, 2341, 2342, 2346, 2030, 2030, 3115, 2058, 2503, 2268, 2030, 2030, 2030, 2074, 3190, 2364, 2030, 3234, 2030,
  3197, 2578, 2370, 2262, 3010, 2030, 2030, 2232, 2238, 3320, 2375, 2030, 2030, 2244, 2030, 3011, 3326, 2376, 2030,
  2030, 3180, 3184, 2382, 2391, 2401, 2030, 2030, 3189, 2384, 3348, 2030, 2030, 2030, 2214, 2030, 3346, 3350, 2030,
  2030, 3190, 3194, 2790, 2844, 3003, 2241, 2030, 2030, 2030, 2911, 2743, 3205, 2502, 2267, 2408, 2030, 2030, 2030,
  2234, 2732, 2030, 3042, 2413, 2030, 2030, 3216, 2572, 2030, 3073, 2431, 2436, 2435, 2030, 2030, 2030, 2243, 2030,
  3197, 2030, 2409, 2476, 2464, 2030, 2030, 2246, 2247, 2247, 2030, 3189, 3193, 2030, 2942, 2944, 3199, 3010, 3216,
  2459, 2431, 2477, 2449, 2454, 2030, 2030, 2355, 3065, 2030, 3275, 2951, 3131, 2475, 2463, 2467, 2030, 2030, 3291,
  2030, 3290, 3216, 3129, 2473, 2477, 2481, 2267, 2030, 2030, 2377, 2030, 2030, 2030, 2075, 2030, 3192, 2030, 3123,
  2586, 2030, 3080, 2544, 2047, 2542, 2510, 2030, 2030, 2403, 2138, 2494, 2508, 2465, 2030, 2030, 2030, 2257, 2507,
  2464, 2030, 2030, 2394, 2397, 2030, 3191, 3195, 2514, 2842, 2522, 2454, 2030, 2031, 2679, 2490, 2466, 2030, 2030,
  2030, 2261, 2842, 3048, 2047, 2542, 2561, 2030, 2030, 2047, 3097, 2484, 2030, 2371, 3054, 2028, 3198, 2548, 2529,
  2560, 2026, 2517, 2030, 2030, 2447, 2453, 2518, 2030, 3097, 2485, 2030, 3091, 2030, 2073, 2813, 2787, 2030, 3093,
  2030, 2527, 3096, 2029, 3333, 2843, 3094, 2030, 2101, 3094, 2567, 2030, 3093, 2030, 3097, 2551, 3096, 3094, 2527,
  3096, 3094, 2291, 2291, 2293, 2030, 2030, 2468, 2483, 2025, 2216, 2591, 2030, 2030, 2469, 2582, 2489, 2595, 2602,
  2843, 2611, 2615, 2622, 3134, 2637, 2653, 2645, 2646, 2647, 2651, 2640, 2641, 2641, 2641, 2641, 2686, 2030, 3270,
  3274, 3272, 2030, 2030, 2030, 2378, 2213, 2030, 2856, 2692, 2607, 2858, 2095, 2030, 2256, 2221, 2862, 2696, 2702,
  2030, 2030, 2525, 2030, 2031, 2714, 3312, 2719, 2724, 2030, 2030, 2030, 2468, 2440, 2268, 2718, 2723, 2029, 2030,
  2098, 2030, 2763, 2769, 2442, 2029, 2770, 2443, 2030, 2030, 2618, 2304, 2030, 3216, 2728, 2030, 2030, 2732, 2030,
  2030, 2488, 2030, 3062, 2030, 2030, 2030, 2606, 2763, 2783, 2787, 3266, 2785, 3264, 2030, 2030, 2666, 2664, 2733,
  2030, 2487, 2030, 2280, 2030, 2030, 2030, 2073, 2817, 2030, 2030, 3261, 2790, 2030, 2377, 2789, 2030, 2030, 2774,
  2927, 2312, 2788, 2030, 2386, 2272, 2278, 2311, 2787, 2030, 2030, 2674, 2764, 2597, 2735, 2967, 2030, 2387, 2255,
  2030, 2030, 3097, 2485, 2030, 2485, 2030, 2030, 2485, 2809, 2030, 2030, 2030, 2673, 2030, 2987, 2030, 2030, 2030,
  2617, 2598, 2030, 2030, 2030, 2682, 3223, 2030, 3224, 2030, 2395, 2396, 2108, 2247, 2247, 2247, 2250, 2043, 2043,
  2604, 2030, 2597, 2030, 2395, 2396, 2396, 2030, 2246, 2030, 3222, 2790, 3224, 3289, 3100, 2030, 2741, 3292, 2030,
  3291, 2030, 2426, 2458, 2430, 3100, 3098, 2030, 3100, 3099, 3099, 2030, 2030, 2681, 2670, 2500, 2861, 3096, 2030,
  2030, 2030, 2420, 3083, 2849, 2053, 2030, 2468, 2483, 2030, 2047, 2962, 2509, 2466, 2976, 2853, 2866, 2054, 2875,
  2884, 2898, 2888, 2890, 2890, 2895, 2891, 2902, 2904, 2904, 2904, 2908, 2030, 2030, 2698, 3330, 2030, 2030, 2713,
  3311, 2060, 2030, 2030, 2030, 2791, 2396, 2396, 2088, 2915, 2923, 2030, 2468, 2657, 2733, 2030, 2030, 2489, 2030,
  2030, 2030, 2394, 2396, 2955, 2871, 2029, 2030, 2533, 3198, 3024, 3178, 3182, 2029, 2030, 2565, 3095, 2030, 2075,
  2818, 2030, 2030, 2030, 2705, 3141, 2933, 2030, 2030, 2734, 2030, 2030, 2997, 2940, 2242, 2030, 2571, 2576, 2030,
  2240, 2030, 2030, 2528, 2559, 2981, 2030, 2030, 2030, 2796, 2303, 2980, 2029, 2030, 2587, 2067, 2030, 2030, 3072,
  2430, 2060, 2030, 2030, 2263, 3304, 2030, 2030, 2030, 2825, 2061, 3002, 2030, 2991, 2606, 2708, 3016, 3003, 2709,
  3017, 2029, 2030, 2607, 2274, 2243, 2257, 2860, 3055, 2030, 2985, 2985, 2033, 3333, 2841, 2030, 2031, 3007, 3015,
  2752, 2030, 3035, 2862, 2030, 2660, 2030, 2869, 2985, 3217, 3021, 2030, 2687, 3352, 2838, 3030, 3016, 3003, 2030,
  2734, 2030, 3133, 2030, 2030, 2822, 2030, 3098, 2030, 2030, 2985, 3332, 3023, 2030, 3046, 3015, 2752, 2030, 2030,
  3333, 2030, 2030, 2030, 2951, 3069, 3077, 2030, 2030, 2790, 2790, 2027, 2030, 2030, 2421, 2030, 2030, 2030, 3025,
  2030, 2969, 2030, 2030, 2808, 2030, 2969, 2030, 2968, 2030, 2736, 2744, 2030, 2736, 2880, 2741, 2030, 2967, 2735,
  2030, 2740, 2030, 2030, 2225, 2030, 2485, 2968, 2030, 2485, 2968, 2967, 2486, 2538, 2104, 2104, 2735, 2030, 2740,
  2030, 3206, 2758, 3064, 2206, 2577, 2030, 2030, 2030, 2366, 2032, 3105, 3287, 2357, 2205, 3109, 3113, 2352, 3120,
  3138, 3145, 3149, 3153, 3157, 3157, 3157, 3172, 3160, 3163, 3166, 3163, 3168, 3176, 2030, 2745, 2973, 3303, 3288,
  2300, 2497, 3126, 2292, 2030, 2734, 3188, 3210, 3221, 2030, 3228, 3242, 2030, 2030, 2030, 3029, 2779, 3240, 2790,
  2030, 2755, 2759, 2030, 2749, 2790, 2030, 2030, 2030, 3238, 2758, 2030, 2030, 2030, 3052, 3087, 2030, 2030, 2536,
  3132, 2030, 2030, 2030, 3196, 3254, 2030, 2030, 2030, 3203, 3232, 2030, 2030, 2030, 3212, 3250, 2789, 2030, 2030,
  2030, 3232, 2961, 3249, 3258, 2030, 2799, 2059, 2030, 2030, 2025, 2030, 2030, 2910, 3287, 2359, 2555, 3287, 2359,
  3086, 3114, 2030, 2030, 2030, 3246, 2073, 2960, 2830, 2834, 2827, 2831, 3017, 2030, 2878, 3215, 2030, 2911, 3288,
  2360, 2757, 2025, 2030, 2030, 2030, 2281, 3280, 2268, 2030, 2030, 2842, 2030, 2736, 2030, 3286, 2358, 2554, 2030,
  2918, 2790, 2030, 2417, 2030, 2425, 2735, 2039, 2030, 2030, 2845, 2030, 2034, 3334, 2842, 2030, 2030, 3196, 3282,
  2030, 2919, 2030, 2030, 2675, 2765, 3297, 2833, 2790, 2030, 2931, 3003, 2349, 2832, 3301, 2030, 2030, 2950, 3130,
  2687, 2742, 3308, 2030, 2937, 2029, 2948, 2030, 3316, 3324, 2030, 2030, 2030, 2993, 2059, 2030, 2943, 3196, 2029,
  2688, 3340, 2030, 2030, 2958, 3130, 2995, 2030, 3338, 2215, 2030, 2739, 2030, 2959, 2829, 2833, 3330, 2030, 2966,
  3339, 3344, 2030, 2030, 2879, 2738, 2742, 2030, 2737, 3318, 2030, 2736, 2740, 2030, 2739, 2740, 2736, 2740, 2736,
  2030, 2869, 2030, 2227, 2032, 2632, 2632, 2158, 2154, 8388608, 8390656, 608174080, 4194304, 4194304, 4194304,
  603979776, 276824064, 1082130432, 8388608, 8388608, 8388608, 8388608, 561152, 16777216, 8390656, 8390656, 276824064,
  276824064, 1082130432, -2139095040, 67710976, 537546752, 8388608, 8388608, 8388608, 8388612, 8390656, 276824064,
  10485760, 10485760, 10487808, 1115684868, 1115684868, 1384120320, 1115684868, 41943044, 41943044, 41943044, 41943044,
  1115684868, 41943044, 41943044, 1384120324, 41943044, 1117782020, 1115684868, 1115684868, 1115684868, 1115684868,
  1048576, 5242880, 9437184, 9437200, 5242880, 277872640, 9437184, 277872640, 9437184, 1351618320, -795865328,
  -795865324, -795865328, -795865328, -795865324, 1116733444, 1116733444, 1385172756, 8, 32, 64, 128, 128, 262144,
  262144, 134217728, 0, 0, 0, -2147483648, 0, 0, 0, 0, 1, 0, 8, 0, 528384, 0, 0, 16384, 131072, 1048592, 1048592,
  1048592, 1048592, 0, 0, 0, 48, 1536, 1792, 0, 0, 0, 268435456, 268697616, 16777216, 16777216, 0, 0, 0, 16, 192, 0,
  524288, 4096, 4096, 4096, 4096, 2097152, 2097152, 0, 0, 0, 6, 8, 64, 1048592, 1048592, 1536, 1024, 2048, 2048, 2048,
  2048, 2048, 0, 0, 0, 36, 2097152, 2097152, 0, 1048576, 2097152, 939524096, 1073741824, 2048, 4096, 0, 0, 32768,
  33554432, 33554432, 33554432, 33554432, 2097152, 1048576, 1048576, 1048576, 16, 1048592, 1048592, 1048592, 2048,
  1048592, 1048576, 1048576, 1048592, 1048576, 1048592, 1048576, 1048576, 1048576, 0, 33554432, 67108864, 1073741824, 0,
  65, 32769, 65537, 131073, 131073, 1, 33554433, 1, 1, 1, 0, 1, 16385, 1, 1, 196673, 65, 1, 67, 536870915, 131137, 65,
  65, 65, 65537, 1, 1, 1, 67, 3, 196673, 131139, 0, 0, 65, 1, 1, 1, 65, 20709376, 516298965, 516298965, 516298965, 1, 1,
  3, 516298965, 516292823, 516298965, 516292823, 516292823, 1053163735, 516292823, 516298967, 516298967, 516331735,
  516364503, 516298967, 516331735, 516298967, 516298967, 516298967, 0, 516298967, 1053229291, 516298967, 1053229291,
  -2129918463, -2129912175, -2129912175, -2129912173, 516298967, 516331735, -1613887789, 0, 0, 0, 536870912, 536870912,
  0, 256, 1073741824, 0, 0, 65536, 0, 0, 0, 131080, 0, 8192, 32768, 65536, 262144, 1, 16384, 1, 0, 0, 0, 138412032, 0,
  20447232, 0, 4096, 128, 8192, 12582912, 402653184, 0, 0, 0, 805306368, 0, 0, 0, 1048576, 1048576, 1048576, 1048576,
  1048592, 1048592, 1048592, 1024, 29884416, 0, 0, 256, 512, 8192, 1572864, 0, 0, 0, 64, 0, 8388608, 33554432,
  134217728, 0, 0, 128, 128, 1024, 65536, 2097152, 134217728, 134348800, 2097152, 0, 0, 1048576, 0, 0, 0, 2097152, 128,
  1152, 128, 512, 0, 0, 0, 1073741824, 0, 0, 2097152, 8328, 2097152, 0, 0, 65536, 32, 448, 1024, 8192, 917504,
  -2145386240, 0, 176197632, 512, 1024, 8192, 49152, 8388608, 176197632, 0, 786497, 786497, -2010242616, -2010242616,
  -2010242616, 787009, -2011029046, 176984641, -2011029046, -2011029046, -2010504758, -2010504758, -2010242614,
  -2010242613, -2010242613, -2010242613, -2010242613, -2010242613, -2010242613, -2011028022, -2010242613, -2010242613,
  -2010242613, -42046984, -42046984, -42046984, -42046984, -42046982, -42046981, -42046981, -42046982, 0, 0, 196608, 0,
  0, 524336, 536870912, 0, 536870912, 0, 4, 0, 65536, 32, 524288, 0, 1152, 512, 0, 256, -2147483648, 41943040, 0, 0, 0,
  512, 3014656, -2013265920, 0, 0, 0, 1024, 2097152, 0, 42729472, 134217728, 0, 128, 0, 1024, 0, 17301504, 0, 2752512,
  3014656, 0, 0, 2097152, 2097152, 2097152, 2097152, 1048576, 0, 1480, 0, 0, 1, 1, 0, 41943040, 0, 64, 786432, 0, 8192,
  917504, 2097152, -2013265920, 0, 384, -2013265920, 0, 0, 12582912, 33554432, -2147483648, 0, 655360, 917504, 0, 0,
  2048, 8192, 16384, 917504, 1048576, 1048576, 23068672, -67108864, 0, 0, 32768, 131072, 2097152, 8388608, 201326592,
  805306368, -2147483648, 8, 64, 256, 8192, 131072, 786432, 917504, 2097152, 134217728, -2147483648, 0, 8, 48, 64, 256,
  2048, 16777216, 67108864, 134217728, 268435456, -536870912, 0, 0, 0, 4096, 0, 16384, 131072, 786432, 1048576, 2097152,
  4194304, 16777216, 67108864, 0, 4096, 32768, 2097152, 8388608, 33554432, 0, 0, 8388608, 0, 0, 0, 5424, 2048, 8192,
  16384, 524288, 0, 576, 512, 8192, 32768, 65536, 131072, 2097152, 8388608, 524288, 1048576, 2097152, 4194304, 67108864,
  134217728, -536870912, 0, 8192, 256, -2147483648, 32, 1610612736, -2147483648, 0, 0, 256, 8192, 524288, 4096, 0, 0, 0,
  32, 256, 2048, 67108864, 0, 512, 0, 0, 33554432, 0, 33554432, 0, 256, 2048, 524288, 2097152, 134217728, -2147483648,
  256, 2097152, -2147483648, 0, 0, 33554432, 32, 524288, 512, 256, 0, 2048, 2097152, 1610612736, -2147483648, 0, 0,
  32768, 8388608, 33554432, 0, 32, 1073741824, 8, 16, 32, 131072, 16777216, 16777216, 536870912, 0, 0, 0, 36864, 128,
  16777216, 0, 16777216, -2147483648, 0, 0, 524288, 524288, 4096, 8192, 524288, 33554432, 8, 0, 0, 4096, 128, 524288,
  33554432, 16777216, 4096, 0, 131072, 0, 0, 1, 16, 32, 0, 32, 536870912, 131080, 131072, 32, 0, 0, 1, 20, 32, 0, 32,
  65536, 0, 1, 1, 67117056, 1, 1, 3, 1, 1, 1, 1, 7, 1479804161, 1479804161, 1479804161, 2016740657, -50991233,
  -50991233, -50991233, -50991233, 1479935233, 2016740657, 2016740657, 2016740657, 2016740657, 2033521969, 2016740657,
  2033521969, 2016740657, 2016740657, 1479935233, 1882522929, 0, 128, 8192, 0, 1, 2, 2, 1310720, 1478492160, 0, 0, 1,
  1280, 65536, 1310720, 2015363072, 0, 1, 6, 8, 16, 96, 0, 2015363072, 0, 0, 1, 1328, 1881145344, 2032140288, 0, 0, 0,
  262144, 0, 262144, 1048576, 2097152, 402653184, 0, 939524096, 0, 0, 6, 32768, 0, 5120, 956301312, 0, 1, 16, 448, 8192,
  786432, 2097152, 12582912, 1, 6, 24, 96, 256, 114688, 262144, 1048576, 2097152, 4194304, 4194304, 8388608, 1006632960,
  1073741824, -2147483648, 16, 32, 131072, 536870912, 0, 524288, 0, 33554432, 0, 0, 0, 2, 4, 0, 0, 0, 4, 0, 0, 4, 32, 1,
  1024, 2097152, 134217728, 268435456, -2147483648, 0, 1, 16, 4096, 8388608, 16777216, 134217728, 0, 16, 96, 512, 1024,
  2048, 8192, 2048, 8192, 49152, 65536, 2097152, 16, 32, 1024, 2097152, 2, 0, 0, 0, 398, 2048, 8192, 49152, 2097152,
  8388608, 67108864, 134217728, 268435456, 0, 0, 0, 2097152, 1048576, 8, 32, 131072, 0, 1, 16, 8388608, 0, 2048, 2048,
  2048, 0, 0, 1024, 134217728, 268435456, 0, 8, 64, 1024, 49152, 64, 49152, 134217728, 268435456, 0, 0, 64, 32768, 0, 1,
  128, 256, 2048, 16384, 32768, 131072, 262144, 3145728, 33554432, 67108864, 134217728, 2048, 256, 16781312, 24576, 0,
  524288, 0, 0, 0, 128, -2147483648, 16777216, 0, 512, 268435456, 268697600, 0, 268435456, 0, 1, 256, 1024, 65536,
  262144, 1048576, 268435456, 536870912, 1073741824, 262144, 0, 268435456, 0, 2, 0, 0, 25600, 54, 1074790400, 65536,
  1074790912, 0, 2, 4, 32768, 0, 0, 132708, 132196, 132196, 132452, -1878653708, 1074988644, -1878653708, -1878653708,
  -1878653708, -1878653708, -1878629132, -1878653708, -1878645516, -1341782796, -1878653708, -1878653708, -1878653708,
  197732, -1878645516, -1878653706, -1628559883, -1628559883, -1628559883, -1628559883, -1628559883, 0, 0, 0, 4194304,
  0, 262144, 64, 1536, 131072, 0, 4, 64, 49152, 268435456, 0, 1024, 320, 0, 6, 8, 96, 512, 52, 192, 1024, 393216,
  268435456, -2147483648, 0, 52, 192, 393216, 1179648, 0, 0, 8, 8192, 0, 0, 0, 1245184, 0, 0, 8, 48, 256, 0, 9216,
  805306368, 0, 6, 8, 128, 256, 2048, 8192, 524288, 16, 0, 0, 0, 8388608, 33554432, 0, 64, 1024, 131072, 0, 8, 2, 2,
  917504, 2097152, 46137344, 469762048, -2147483648, 128, -2147483648, 0, 0, 8, 131072, 0, 192, 0, 0, 16, 8388608, 0, 0,
  20, 192, 128, 262144, 268435456, -2147483648, 0, 0, 128, 256, 8192, 786432, 0, 0, 0, 576, 2097152, 12582912, 33554432,
  67108864, 134217728, 268435456, 2048, 4096, 16777216, 524288, 0, 0, 256, 24576, 0, 128, 256, 786432, 2097152, 0, 256,
  512, 65536, 262144, 128, 268435456, -2147483648, 0, 8, 64, 384, 0, 128, 256, 524288, 2097152, -2147483648, 0, 512,
  1048576, 536870912, 1073741824, 0, 0, 524288, 12582912, 33554432, 134217728, 268435456, 536870912, 0, 0, 536870912, 0,
  0, 512, 1073741824, 0, 8, 112, 384, 2048, -2147483648, 2048, 4096, 0, 8, 256, 8192, 32768, 262144, 524288, 0, 64, 512,
  256, 1073741824, 4096, 0, 0, 32, 1073741824, 0, 0, 0, 32768, 0, 0, 0, 8192, 0, 4194304, 536870912, 536870912, 8454144,
  524320, 536870912, 576, 536871424, 256, 0, 0, 0, 16777216, 16777216, 0, 1610612736, 1610612736, 0, 8, 8192, 256, 0, 0,
  48, 256, 2048, 8192, 16384, 131072, 0, 0, 1479804161, 33554688, 0, 8978480, 0, 20, 32, 192, 1610612736, -2147328000,
  -2130550784, -2147328000, -2147327999, 167928064, 704798976, 167928064, -2138349520, -1979571968, -2138349520,
  -1979571968, -1979555584, -1979555584, -1979555584, -1979555584, -1975361280, -1442684160, 506915214, 506915214,
  506915214, 506915214, 1043786126, 1043786126, 506915214, 506915214, -1103697522, -1442684672, -1442701056,
  -1442684672, -1442701056, -1103697522, -1640568434, 0, 0, 53, 448, 9216, 917504, 48234496, 469762048, -2147483648, 0,
  589824, 0, 0, 0, 67108864, 0, 0, 512, 0, 0, 0, 256, -2147483648, 0, 0, 24576, 131072, 0, 0, 128, 4096, 32768, 131072,
  167772160, 0, 0, 128, 262144, 0, 0, 0, 8, 0, 720896, 0, 0, 0, 134217728, 268435456, 0, 0, 256, 8192, 167772160, 0,
  768, 0, 0, 136, 8192, 0, 398, 59392, 393216, 3145728, 234881024, 268435456, 0, 0, 256, 8192, 16384, 32768, 393216,
  3145728, 100663296, 131072, 33554432, 134217728, 196608, 100663296, 134217728, 268435456, 0, 32, 1024, 134217728,
  268435456, 536870912, -2147483648, 0, 0, 7, 3960, 122880, 1310720, -52428800, 0, 0, 0, 524288, 1048576, 0, 256, 16384,
  131072, 33554432, 0, 0, 262144, 1024, 0, 0, 4, 64, 32768, 0, 0, 6, 256, 16384, 32768, 131072, 67108864, 268435456, 0,
  0, 320, 0, 0, 65536, 524288, 512, 256, 512, 3072, 8192, 114688, 6, 256, 32768, 262144, 0, 0, 456, 8192, 2097152,
  268435456, 0, 0, 456, 2228224, 262144, 2097152, 0, 0, 2048, 4096, 16777216, 24576, 0, 262144, 4, 0, 65536, 524288, 4,
  65536, 0, 0, 2552, 24576, 25034752, -67108864, 0, 0, 1, 8
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "END",
  "EOF",
  "PragmaContents",
  "Wildcard",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "QName",
  "NCName",
  "S",
  "S",
  "CommentContents",
  "'!='",
  "'""'",
  "'#)'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'['",
  "']'",
  "']]>'",
  "'after'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'assignable'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'before'",
  "'block'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'copy'",
  "'copy-namespaces'",
  "'declare'",
  "'default'",
  "'delete'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'eq'",
  "'every'",
  "'except'",
  "'exit'",
  "'external'",
  "'first'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'inherit'",
  "'insert'",
  "'instance'",
  "'intersect'",
  "'into'",
  "'is'",
  "'item'",
  "'last'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'mod'",
  "'modify'",
  "'module'",
  "'namespace'",
  "'ne'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nodes'",
  "'of'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'processing-instruction'",
  "'rename'",
  "'replace'",
  "'return'",
  "'returning'",
  "'revalidation'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sequential'",
  "'simple'",
  "'skip'",
  "'some'",
  "'stable'",
  "'strict'",
  "'strip'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'typeswitch'",
  "'unassignable'",
  "'union'",
  "'unordered'",
  "'updating'",
  "'valid'",
  "'validate'",
  "'value'",
  "'variable'",
  "'version'",
  "'where'",
  "'while'",
  "'with'",
  "'xquery'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 2048
    let $end := $end - $result idiv 256
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 1797 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 16
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 16 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(60, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 46) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 24) then                 (: CommentContents :)
            let $state := p:consumeT(24, $input, $state)    (: CommentContents :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(32, $input, $state)              (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consumeT(46, $input, $state)              (: (':' ')') :)
  return $state
};

(:~
 : Try parsing the 1st loop of production WhiteSpace (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WhiteSpace-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 23) then                     (: S^WhiteSpace :)
        let $state := p:consumeT(23, $input, $state)        (: S^WhiteSpace :)
        return $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Comment($input, $state)
        return $state
    let $state := p:lookahead1(16, $input, $state)          (: END | S^WhiteSpace | ('(' ':') :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        p:try-WhiteSpace-1($input, $state)
};

(:~
 : Try parsing WhiteSpace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WhiteSpace($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-WhiteSpace-1($input, $state)
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QueryBody", $count, $begin, $end)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QueryBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModule", $count, $begin, $end)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'option' :)
  let $state := p:consume(144, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:consume(11, $input, $state)               (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OptionDecl", $count, $begin, $end)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WhiteSpace | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Param", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(68, $input, $state)         (: S^WhiteSpace | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: S^WhiteSpace | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParamList", $count, $begin, $end)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 90) then                           (: 'declare' :)
      let $state := p:lookahead2W(117, $input, $state)      (: S^WhiteSpace | ('(' ':') | 'function' | 'sequential' |
                                                               'simple' | 'updating' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42074) then                    (: 'declare' 'sequential' :)
      let $state := p:consume(90, $input, $state)           (: 'declare' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'sequential' :)
      let $state := p:consume(164, $input, $state)          (: 'sequential' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'function' :)
      let $state := p:consume(113, $input, $state)          (: 'function' :)
      let $state := p:lookahead1W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WhiteSpace | '(' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(63, $input, $state)       (: S^WhiteSpace | '$' | ('(' ':') | ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: '$' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParamList($input, $state)
          return $state
        else
          $state
      let $state := p:consume(33, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(106, $input, $state)      (: S^WhiteSpace | ('(' ':') | 'as' | 'external' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 71) then                   (: 'as' :)
          let $state := p:consume(71, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(160, $input, $state)  (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(85, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'external' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 189) then                  (: '{' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Block($input, $state)
          return $state
        else
          let $state := p:consume(108, $input, $state)      (: 'external' :)
          return $state
      return $state
    else
      let $state := p:consume(90, $input, $state)           (: 'declare' :)
      let $state := p:lookahead1W(108, $input, $state)      (: S^WhiteSpace | ('(' ':') | 'function' | 'simple' |
                                                               'updating' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 179) then                  (: 'updating' :)
          let $state := p:consume(179, $input, $state)      (: 'updating' :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 165) then              (: 'simple' :)
              let $state := p:consume(165, $input, $state)  (: 'simple' :)
              return $state
            else
              $state
          return $state
      let $state := p:lookahead1W(40, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'function' :)
      let $state := p:consume(113, $input, $state)          (: 'function' :)
      let $state := p:lookahead1W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WhiteSpace | '(' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(63, $input, $state)       (: S^WhiteSpace | '$' | ('(' ':') | ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: '$' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParamList($input, $state)
          return $state
        else
          $state
      let $state := p:consume(33, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(106, $input, $state)      (: S^WhiteSpace | ('(' ':') | 'as' | 'external' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 71) then                   (: 'as' :)
          let $state := p:consume(71, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(160, $input, $state)  (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(85, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'external' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 189) then                  (: '{' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-EnclosedExpr($input, $state)
          return $state
        else
          let $state := p:consume(108, $input, $state)      (: 'external' :)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDecl", $count, $begin, $end)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 126) then                      (: 'is' :)
      let $state := p:consume(126, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<<' :)
      let $state := p:consume(54, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(60, $input, $state)           (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeComp", $count, $begin, $end)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 57) then                       (: '=' :)
      let $state := p:consume(57, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '!=' :)
      let $state := p:consume(25, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: '<' :)
      let $state := p:consume(50, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<=' :)
      let $state := p:consume(55, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '>' :)
      let $state := p:consume(58, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(59, $input, $state)           (: '>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GeneralComp", $count, $begin, $end)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 104) then                      (: 'eq' :)
      let $state := p:consume(104, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'ne' :)
      let $state := p:consume(138, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'lt' :)
      let $state := p:consume(133, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'le' :)
      let $state := p:consume(130, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'gt' :)
      let $state := p:consume(116, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(114, $input, $state)          (: 'ge' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueComp", $count, $begin, $end)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(141, $input, $state)          (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | 'with' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 61) then                       (: '?' :)
      let $state := p:consume(61, $input, $state)           (: '?' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleType", $count, $begin, $end)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(159, $input, $state)           (: QName^Token | S | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'block' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'exit' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'insert' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22) then                       (: S :)
      let $state := p:consume(22, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1(11, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22) then                       (: S :)
      let $state := p:consume(22, $input, $state)           (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:consume(3, $input, $state)            (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:consume(27, $input, $state)               (: '#)' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Pragma", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(67, $input, $state)         (: S^WhiteSpace | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 31) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(172, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 192) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExtensionExpr", $count, $begin, $end)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: '@' :)
      let $state := p:consume(63, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(161, $input, $state)          (: Wildcard | QName^Token | S^WhiteSpace | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NodeTest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevForwardStep", $count, $begin, $end)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'child' :)
      let $state := p:consume(84, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descendant' :)
      let $state := p:consume(93, $input, $state)           (: 'descendant' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:consume(75, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'self' :)
      let $state := p:consume(163, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'descendant-or-self' :)
      let $state := p:consume(94, $input, $state)           (: 'descendant-or-self' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'following-sibling' :)
      let $state := p:consume(111, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(110, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardAxis", $count, $begin, $end)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 75) then                           (: 'attribute' :)
      let $state := p:lookahead2W(148, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (84,                           (: 'child' :)
                              93,                           (: 'descendant' :)
                              94,                           (: 'descendant-or-self' :)
                              110,                          (: 'following' :)
                              111,                          (: 'following-sibling' :)
                              163)) then                    (: 'self' :)
      let $state := p:lookahead2W(145, $input, $state)      (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 12107                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12116                          (: 'child' '::' :)
          or $state[$p:lk] = 12125                          (: 'descendant' '::' :)
          or $state[$p:lk] = 12126                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 12142                          (: 'following' '::' :)
          or $state[$p:lk] = 12143                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 12195) then                    (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(161, $input, $state)      (: Wildcard | QName^Token | S^WhiteSpace | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevForwardStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardStep", $count, $begin, $end)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(42, $input, $state)               (: '..' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevReverseStep", $count, $begin, $end)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Wildcard :)
      let $state := p:consume(4, $input, $state)            (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameTest", $count, $begin, $end)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (75,                                (: 'attribute' :)
                         86,                                (: 'comment' :)
                         98,                                (: 'document-node' :)
                         99,                                (: 'element' :)
                         141,                               (: 'node' :)
                         153,                               (: 'processing-instruction' :)
                         161,                               (: 'schema-attribute' :)
                         162,                               (: 'schema-element' :)
                         171)) then                         (: 'text' :)
      let $state := p:lookahead2W(144, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7755                           (: 'attribute' '(' :)
          or $state[$p:lk] = 7766                           (: 'comment' '(' :)
          or $state[$p:lk] = 7778                           (: 'document-node' '(' :)
          or $state[$p:lk] = 7779                           (: 'element' '(' :)
          or $state[$p:lk] = 7821                           (: 'node' '(' :)
          or $state[$p:lk] = 7833                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 7841                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 7842                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 7851) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeTest", $count, $begin, $end)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 149) then                      (: 'parent' :)
      let $state := p:consume(149, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'ancestor' :)
      let $state := p:consume(68, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'preceding-sibling' :)
      let $state := p:consume(151, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'preceding' :)
      let $state := p:consume(150, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(69, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WhiteSpace | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseAxis", $count, $begin, $end)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 42) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(161, $input, $state)      (: Wildcard | QName^Token | S^WhiteSpace | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseStep", $count, $begin, $end)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (68,                                (: 'ancestor' :)
                         69,                                (: 'ancestor-or-self' :)
                         149,                               (: 'parent' :)
                         150,                               (: 'preceding' :)
                         151)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(145, $input, $state)      (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42                             (: '..' :)
          or $state[$p:lk] = 12100                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 12101                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 12181                          (: 'parent' '::' :)
          or $state[$p:lk] = 12182                          (: 'preceding' '::' :)
          or $state[$p:lk] = 12183) then                    (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(143, $input, $state)          (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | '|' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AxisStep", $count, $begin, $end)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(64, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(65, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Predicate", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(143, $input, $state)        (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | '|' | '}' :)
    return
      if ($state[$p:l1] != 64) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PredicateList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PredicateList", $count, $begin, $end)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(153, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(133, $input, $state)          (: NCName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: '{' :)
      let $state := p:consume(189, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(192, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(172, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 192) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompPIConstructor", $count, $begin, $end)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(86, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(171, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompTextConstructor", $count, $begin, $end)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(75, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(164, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: '{' :)
      let $state := p:consume(189, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(192, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(172, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 192) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompAttrConstructor", $count, $begin, $end)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContentExpr", $count, $begin, $end)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(99, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(164, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: '{' :)
      let $state := p:consume(189, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(192, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(172, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 192) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompElemConstructor", $count, $begin, $end)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(97, $input, $state)               (: 'document' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompDocConstructor", $count, $begin, $end)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 97) then                       (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComputedConstructor", $count, $begin, $end)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(56, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(4, $input, $state)             (: PITarget :)
  let $state := p:consume(18, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(14, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22) then                       (: S :)
      let $state := p:consume(22, $input, $state)           (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:consume(6, $input, $state)            (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(9, $input, $state)             (: '?>' :)
  let $state := p:consume(62, $input, $state)               (: '?>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirPIConstructor", $count, $begin, $end)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(51, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(5, $input, $state)                (: DirCommentContents :)
  let $state := p:lookahead1(6, $input, $state)             (: '-->' :)
  let $state := p:consume(40, $input, $state)               (: '-->' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(52, $input, $state)               (: '<![CDATA[' :)
  let $state := p:lookahead1(3, $input, $state)             (: CDataSectionContents :)
  let $state := p:consume(7, $input, $state)                (: CDataSectionContents :)
  let $state := p:lookahead1(10, $input, $state)            (: ']]>' :)
  let $state := p:consume(66, $input, $state)               (: ']]>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CDataSection", $count, $begin, $end)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50                             (: '<' :)
          or $state[$p:l1] = 51                             (: '<!--' :)
          or $state[$p:l1] = 56) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 52) then                       (: '<![CDATA[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 15) then                       (: ElementContentChar :)
      let $state := p:consume(15, $input, $state)           (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemContent", $count, $begin, $end)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: AposAttrContentChar :)
      let $state := p:consume(17, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AposAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExpr", $count, $begin, $end)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12) then                       (: PredefinedEntityRef :)
      let $state := p:consume(12, $input, $state)           (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: CharRef :)
      let $state := p:consume(19, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: '{{' :)
      let $state := p:consume(190, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: '}}' :)
      let $state := p:consume(193, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnclosedExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CommonContent", $count, $begin, $end)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: QuotAttrContentChar :)
      let $state := p:consume(16, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QuotAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(120, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 26) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 13) then                 (: EscapeQuot :)
            let $state := p:consume(13, $input, $state)     (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(121, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 29) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 14) then                 (: EscapeApos :)
            let $state := p:consume(14, $input, $state)     (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(15, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26) then                       (: '"' :)
      let $state := p:consume(26, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(26, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(29, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(29, $input, $state)           (: "'" :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeValue", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(19, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 22) then                         (: S :)
        $state
      else
        let $state := p:consume(22, $input, $state)         (: S :)
        let $state := p:lookahead1(162, $input, $state)     (: QName^Token | S | '/>' | '>' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'block' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'exit' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'insert' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 22                      (: S :)
               and $state[$p:l1] != 45                      (: '/>' :)
               and $state[$p:l1] != 58) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QName($input, $state)
            let $state := p:lookahead1(12, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 22) then             (: S :)
                let $state := p:consume(22, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(7, $input, $state)   (: '=' :)
            let $state := p:consume(57, $input, $state)     (: '=' :)
            let $state := p:lookahead1(18, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 22) then             (: S :)
                let $state := p:consume(22, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-DirAttributeList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(127, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 53) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(50, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '/>' :)
      let $state := p:consume(45, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(58, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(53, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 22) then                   (: S :)
          let $state := p:consume(22, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(8, $input, $state)         (: '>' :)
      let $state := p:consume(58, $input, $state)           (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemConstructor", $count, $begin, $end)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirectConstructor", $count, $begin, $end)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50                             (: '<' :)
          or $state[$p:l1] = 51                             (: '<!--' :)
          or $state[$p:l1] = 56) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComputedConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Constructor", $count, $begin, $end)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(178, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnorderedExpr", $count, $begin, $end)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(147, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderedExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(68, $input, $state)         (: S^WhiteSpace | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(168, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(170, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionCall", $count, $begin, $end)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(41, $input, $state)               (: '.' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemExpr", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(170, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedExpr", $count, $begin, $end)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarRef", $count, $begin, $end)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 8) then                        (: IntegerLiteral :)
      let $state := p:consume(8, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 9) then                        (: DecimalLiteral :)
      let $state := p:consume(9, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(10, $input, $state)           (: DoubleLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: StringLiteral :)
      let $state := p:consume(11, $input, $state)           (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (97,                                (: 'document' :)
                         147,                               (: 'ordered' :)
                         178)) then                         (: 'unordered' :)
      let $state := p:lookahead2W(66, $input, $state)       (: S^WhiteSpace | '(' | ('(' ':') | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8                              (: IntegerLiteral :)
          or $state[$p:lk] = 9                              (: DecimalLiteral :)
          or $state[$p:lk] = 10                             (: DoubleLiteral :)
          or $state[$p:lk] = 11) then                       (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 28) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 30) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 41) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 48531) then                    (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 48562) then                    (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 50                             (: '<' :)
          or $state[$p:lk] = 51                             (: '<!--' :)
          or $state[$p:lk] = 56                             (: '<?' :)
          or $state[$p:lk] = 75                             (: 'attribute' :)
          or $state[$p:lk] = 86                             (: 'comment' :)
          or $state[$p:lk] = 99                             (: 'element' :)
          or $state[$p:lk] = 153                            (: 'processing-instruction' :)
          or $state[$p:lk] = 171                            (: 'text' :)
          or $state[$p:lk] = 48481) then                    (: 'document' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Constructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionCall($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpr", $count, $begin, $end)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(143, $input, $state)          (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | '|' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FilterExpr", $count, $begin, $end)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 75) then                           (: 'attribute' :)
      let $state := p:lookahead2W(175, $input, $state)      (: EOF | QName^Token | S^WhiteSpace | '!=' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'block' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'exit' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'insert' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 20811) then                    (: 'attribute' 'case' :)
          let $state := p:lookahead3W(165, $input, $state)  (: QName^Token | S^WhiteSpace | '$' | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 21835) then               (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(62, $input, $state)   (: StringLiteral | S^WhiteSpace | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 23371) then               (: 'attribute' 'default' :)
          let $state := p:lookahead3W(99, $input, $state)   (: S^WhiteSpace | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 25931) then               (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WhiteSpace | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 31563) then               (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(93, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 37451) then               (: 'attribute' 'order' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] eq 43083) then               (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18507,                    (: 'attribute' 'ascending' :)
                                  24395)) then              (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(118, $input, $state)  (: S^WhiteSpace | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (28747,                    (: 'attribute' 'for' :)
                                  33867)) then              (: 'attribute' 'let' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WhiteSpace | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (21067,                    (: 'attribute' 'cast' :)
                                  21323,                    (: 'attribute' 'castable' :)
                                  44619)) then              (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(79, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (17227,                    (: 'attribute' 'after' :)
                                  17995,                    (: 'attribute' 'and' :)
                                  18251,                    (: 'attribute' 'as' :)
                                  19787,                    (: 'attribute' 'before' :)
                                  24651,                    (: 'attribute' 'div' :)
                                  25675,                    (: 'attribute' 'else' :)
                                  26699,                    (: 'attribute' 'eq' :)
                                  27211,                    (: 'attribute' 'except' :)
                                  29259,                    (: 'attribute' 'ge' :)
                                  29771,                    (: 'attribute' 'gt' :)
                                  30027,                    (: 'attribute' 'idiv' :)
                                  31819,                    (: 'attribute' 'intersect' :)
                                  32075,                    (: 'attribute' 'into' :)
                                  32331,                    (: 'attribute' 'is' :)
                                  33355,                    (: 'attribute' 'le' :)
                                  34123,                    (: 'attribute' 'lt' :)
                                  34379,                    (: 'attribute' 'mod' :)
                                  34635,                    (: 'attribute' 'modify' :)
                                  35403,                    (: 'attribute' 'ne' :)
                                  37195,                    (: 'attribute' 'or' :)
                                  40011,                    (: 'attribute' 'return' :)
                                  40779,                    (: 'attribute' 'satisfies' :)
                                  44363,                    (: 'attribute' 'to' :)
                                  45387,                    (: 'attribute' 'union' :)
                                  47435,                    (: 'attribute' 'where' :)
                                  47947)) then              (: 'attribute' 'with' :)
          let $state := p:lookahead3W(171, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 99) then                      (: 'element' :)
      let $state := p:lookahead2W(174, $input, $state)      (: EOF | QName^Token | S^WhiteSpace | '!=' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 20835) then                    (: 'element' 'case' :)
          let $state := p:lookahead3W(165, $input, $state)  (: QName^Token | S^WhiteSpace | '$' | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 21859) then               (: 'element' 'collation' :)
          let $state := p:lookahead3W(62, $input, $state)   (: StringLiteral | S^WhiteSpace | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 23395) then               (: 'element' 'default' :)
          let $state := p:lookahead3W(99, $input, $state)   (: S^WhiteSpace | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 25955) then               (: 'element' 'empty' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WhiteSpace | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 31587) then               (: 'element' 'instance' :)
          let $state := p:lookahead3W(93, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 37475) then               (: 'element' 'order' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] eq 43107) then               (: 'element' 'stable' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18531,                    (: 'element' 'ascending' :)
                                  24419)) then              (: 'element' 'descending' :)
          let $state := p:lookahead3W(118, $input, $state)  (: S^WhiteSpace | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (28771,                    (: 'element' 'for' :)
                                  33891)) then              (: 'element' 'let' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WhiteSpace | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (21091,                    (: 'element' 'cast' :)
                                  21347,                    (: 'element' 'castable' :)
                                  44643)) then              (: 'element' 'treat' :)
          let $state := p:lookahead3W(79, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (17251,                    (: 'element' 'after' :)
                                  18019,                    (: 'element' 'and' :)
                                  18275,                    (: 'element' 'as' :)
                                  19811,                    (: 'element' 'before' :)
                                  24675,                    (: 'element' 'div' :)
                                  25699,                    (: 'element' 'else' :)
                                  26723,                    (: 'element' 'eq' :)
                                  27235,                    (: 'element' 'except' :)
                                  29283,                    (: 'element' 'ge' :)
                                  29795,                    (: 'element' 'gt' :)
                                  30051,                    (: 'element' 'idiv' :)
                                  31843,                    (: 'element' 'intersect' :)
                                  32099,                    (: 'element' 'into' :)
                                  32355,                    (: 'element' 'is' :)
                                  33379,                    (: 'element' 'le' :)
                                  34147,                    (: 'element' 'lt' :)
                                  34403,                    (: 'element' 'mod' :)
                                  34659,                    (: 'element' 'modify' :)
                                  35427,                    (: 'element' 'ne' :)
                                  37219,                    (: 'element' 'or' :)
                                  40035,                    (: 'element' 'return' :)
                                  40803,                    (: 'element' 'satisfies' :)
                                  44387,                    (: 'element' 'to' :)
                                  45411,                    (: 'element' 'union' :)
                                  47459,                    (: 'element' 'where' :)
                                  47971)) then              (: 'element' 'with' :)
          let $state := p:lookahead3W(171, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 153) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(153, $input, $state)      (: EOF | NCName^Token | S^WhiteSpace | '!=' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 20889) then                    (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(165, $input, $state)  (: QName^Token | S^WhiteSpace | '$' | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 21913) then               (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(62, $input, $state)   (: StringLiteral | S^WhiteSpace | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 23449) then               (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(99, $input, $state)   (: S^WhiteSpace | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 26009) then               (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WhiteSpace | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 31641) then               (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(93, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 37529) then               (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] eq 43161) then               (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18585,                    (: 'processing-instruction' 'ascending' :)
                                  24473)) then              (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(118, $input, $state)  (: S^WhiteSpace | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (28825,                    (: 'processing-instruction' 'for' :)
                                  33945)) then              (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WhiteSpace | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (21145,                    (: 'processing-instruction' 'cast' :)
                                  21401,                    (: 'processing-instruction' 'castable' :)
                                  44697)) then              (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(79, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (17305,                    (: 'processing-instruction' 'after' :)
                                  18073,                    (: 'processing-instruction' 'and' :)
                                  18329,                    (: 'processing-instruction' 'as' :)
                                  19865,                    (: 'processing-instruction' 'before' :)
                                  24729,                    (: 'processing-instruction' 'div' :)
                                  25753,                    (: 'processing-instruction' 'else' :)
                                  26777,                    (: 'processing-instruction' 'eq' :)
                                  27289,                    (: 'processing-instruction' 'except' :)
                                  29337,                    (: 'processing-instruction' 'ge' :)
                                  29849,                    (: 'processing-instruction' 'gt' :)
                                  30105,                    (: 'processing-instruction' 'idiv' :)
                                  31897,                    (: 'processing-instruction' 'intersect' :)
                                  32153,                    (: 'processing-instruction' 'into' :)
                                  32409,                    (: 'processing-instruction' 'is' :)
                                  33433,                    (: 'processing-instruction' 'le' :)
                                  34201,                    (: 'processing-instruction' 'lt' :)
                                  34457,                    (: 'processing-instruction' 'mod' :)
                                  34713,                    (: 'processing-instruction' 'modify' :)
                                  35481,                    (: 'processing-instruction' 'ne' :)
                                  37273,                    (: 'processing-instruction' 'or' :)
                                  40089,                    (: 'processing-instruction' 'return' :)
                                  40857,                    (: 'processing-instruction' 'satisfies' :)
                                  44441,                    (: 'processing-instruction' 'to' :)
                                  45465,                    (: 'processing-instruction' 'union' :)
                                  47513,                    (: 'processing-instruction' 'where' :)
                                  48025)) then              (: 'processing-instruction' 'with' :)
          let $state := p:lookahead3W(171, $input, $state)  (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (86,                           (: 'comment' :)
                              97,                           (: 'document' :)
                              147,                          (: 'ordered' :)
                              171,                          (: 'text' :)
                              178)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(151, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (68,                           (: 'ancestor' :)
                              69,                           (: 'ancestor-or-self' :)
                              84,                           (: 'child' :)
                              93,                           (: 'descendant' :)
                              94,                           (: 'descendant-or-self' :)
                              110,                          (: 'following' :)
                              111,                          (: 'following-sibling' :)
                              149,                          (: 'parent' :)
                              150,                          (: 'preceding' :)
                              151,                          (: 'preceding-sibling' :)
                              163)) then                    (: 'self' :)
      let $state := p:lookahead2W(148, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (20,                           (: QName^Token :)
                              67,                           (: 'after' :)
                              70,                           (: 'and' :)
                              71,                           (: 'as' :)
                              72,                           (: 'ascending' :)
                              77,                           (: 'before' :)
                              78,                           (: 'block' :)
                              81,                           (: 'case' :)
                              82,                           (: 'cast' :)
                              83,                           (: 'castable' :)
                              85,                           (: 'collation' :)
                              88,                           (: 'copy' :)
                              90,                           (: 'declare' :)
                              91,                           (: 'default' :)
                              92,                           (: 'delete' :)
                              95,                           (: 'descending' :)
                              96,                           (: 'div' :)
                              100,                          (: 'else' :)
                              101,                          (: 'empty' :)
                              104,                          (: 'eq' :)
                              105,                          (: 'every' :)
                              106,                          (: 'except' :)
                              107,                          (: 'exit' :)
                              109,                          (: 'first' :)
                              112,                          (: 'for' :)
                              114,                          (: 'ge' :)
                              116,                          (: 'gt' :)
                              117,                          (: 'idiv' :)
                              119,                          (: 'import' :)
                              122,                          (: 'insert' :)
                              123,                          (: 'instance' :)
                              124,                          (: 'intersect' :)
                              125,                          (: 'into' :)
                              126,                          (: 'is' :)
                              128,                          (: 'last' :)
                              130,                          (: 'le' :)
                              132,                          (: 'let' :)
                              133,                          (: 'lt' :)
                              134,                          (: 'mod' :)
                              135,                          (: 'modify' :)
                              136,                          (: 'module' :)
                              138,                          (: 'ne' :)
                              145,                          (: 'or' :)
                              146,                          (: 'order' :)
                              154,                          (: 'rename' :)
                              155,                          (: 'replace' :)
                              156,                          (: 'return' :)
                              159,                          (: 'satisfies' :)
                              167,                          (: 'some' :)
                              168,                          (: 'stable' :)
                              173,                          (: 'to' :)
                              174,                          (: 'treat' :)
                              177,                          (: 'union' :)
                              180,                          (: 'valid' :)
                              181,                          (: 'validate' :)
                              185,                          (: 'where' :)
                              187,                          (: 'with' :)
                              188)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(144, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8                              (: IntegerLiteral :)
          or $state[$p:lk] = 9                              (: DecimalLiteral :)
          or $state[$p:lk] = 10                             (: DoubleLiteral :)
          or $state[$p:lk] = 11                             (: StringLiteral :)
          or $state[$p:lk] = 28                             (: '$' :)
          or $state[$p:lk] = 30                             (: '(' :)
          or $state[$p:lk] = 41                             (: '.' :)
          or $state[$p:lk] = 50                             (: '<' :)
          or $state[$p:lk] = 51                             (: '<!--' :)
          or $state[$p:lk] = 56                             (: '<?' :)
          or $state[$p:lk] = 5195                           (: 'attribute' QName^Token :)
          or $state[$p:lk] = 5219                           (: 'element' QName^Token :)
          or $state[$p:lk] = 5529                           (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 7700                           (: QName^Token '(' :)
          or $state[$p:lk] = 7747                           (: 'after' '(' :)
          or $state[$p:lk] = 7748                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 7749                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 7750                           (: 'and' '(' :)
          or $state[$p:lk] = 7751                           (: 'as' '(' :)
          or $state[$p:lk] = 7752                           (: 'ascending' '(' :)
          or $state[$p:lk] = 7757                           (: 'before' '(' :)
          or $state[$p:lk] = 7758                           (: 'block' '(' :)
          or $state[$p:lk] = 7761                           (: 'case' '(' :)
          or $state[$p:lk] = 7762                           (: 'cast' '(' :)
          or $state[$p:lk] = 7763                           (: 'castable' '(' :)
          or $state[$p:lk] = 7764                           (: 'child' '(' :)
          or $state[$p:lk] = 7765                           (: 'collation' '(' :)
          or $state[$p:lk] = 7768                           (: 'copy' '(' :)
          or $state[$p:lk] = 7770                           (: 'declare' '(' :)
          or $state[$p:lk] = 7771                           (: 'default' '(' :)
          or $state[$p:lk] = 7772                           (: 'delete' '(' :)
          or $state[$p:lk] = 7773                           (: 'descendant' '(' :)
          or $state[$p:lk] = 7774                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 7775                           (: 'descending' '(' :)
          or $state[$p:lk] = 7776                           (: 'div' '(' :)
          or $state[$p:lk] = 7777                           (: 'document' '(' :)
          or $state[$p:lk] = 7780                           (: 'else' '(' :)
          or $state[$p:lk] = 7781                           (: 'empty' '(' :)
          or $state[$p:lk] = 7784                           (: 'eq' '(' :)
          or $state[$p:lk] = 7785                           (: 'every' '(' :)
          or $state[$p:lk] = 7786                           (: 'except' '(' :)
          or $state[$p:lk] = 7787                           (: 'exit' '(' :)
          or $state[$p:lk] = 7789                           (: 'first' '(' :)
          or $state[$p:lk] = 7790                           (: 'following' '(' :)
          or $state[$p:lk] = 7791                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 7792                           (: 'for' '(' :)
          or $state[$p:lk] = 7794                           (: 'ge' '(' :)
          or $state[$p:lk] = 7796                           (: 'gt' '(' :)
          or $state[$p:lk] = 7797                           (: 'idiv' '(' :)
          or $state[$p:lk] = 7799                           (: 'import' '(' :)
          or $state[$p:lk] = 7802                           (: 'insert' '(' :)
          or $state[$p:lk] = 7803                           (: 'instance' '(' :)
          or $state[$p:lk] = 7804                           (: 'intersect' '(' :)
          or $state[$p:lk] = 7805                           (: 'into' '(' :)
          or $state[$p:lk] = 7806                           (: 'is' '(' :)
          or $state[$p:lk] = 7808                           (: 'last' '(' :)
          or $state[$p:lk] = 7810                           (: 'le' '(' :)
          or $state[$p:lk] = 7812                           (: 'let' '(' :)
          or $state[$p:lk] = 7813                           (: 'lt' '(' :)
          or $state[$p:lk] = 7814                           (: 'mod' '(' :)
          or $state[$p:lk] = 7815                           (: 'modify' '(' :)
          or $state[$p:lk] = 7816                           (: 'module' '(' :)
          or $state[$p:lk] = 7818                           (: 'ne' '(' :)
          or $state[$p:lk] = 7825                           (: 'or' '(' :)
          or $state[$p:lk] = 7826                           (: 'order' '(' :)
          or $state[$p:lk] = 7827                           (: 'ordered' '(' :)
          or $state[$p:lk] = 7829                           (: 'parent' '(' :)
          or $state[$p:lk] = 7830                           (: 'preceding' '(' :)
          or $state[$p:lk] = 7831                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 7834                           (: 'rename' '(' :)
          or $state[$p:lk] = 7835                           (: 'replace' '(' :)
          or $state[$p:lk] = 7836                           (: 'return' '(' :)
          or $state[$p:lk] = 7839                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 7843                           (: 'self' '(' :)
          or $state[$p:lk] = 7847                           (: 'some' '(' :)
          or $state[$p:lk] = 7848                           (: 'stable' '(' :)
          or $state[$p:lk] = 7853                           (: 'to' '(' :)
          or $state[$p:lk] = 7854                           (: 'treat' '(' :)
          or $state[$p:lk] = 7857                           (: 'union' '(' :)
          or $state[$p:lk] = 7858                           (: 'unordered' '(' :)
          or $state[$p:lk] = 7860                           (: 'valid' '(' :)
          or $state[$p:lk] = 7861                           (: 'validate' '(' :)
          or $state[$p:lk] = 7865                           (: 'where' '(' :)
          or $state[$p:lk] = 7867                           (: 'with' '(' :)
          or $state[$p:lk] = 7868                           (: 'xquery' '(' :)
          or $state[$p:lk] = 17483                          (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 17507                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 17739                          (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 17763                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 19275                          (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 19299                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 20043                          (: 'attribute' 'block' :)
          or $state[$p:lk] = 20067                          (: 'element' 'block' :)
          or $state[$p:lk] = 21579                          (: 'attribute' 'child' :)
          or $state[$p:lk] = 21603                          (: 'element' 'child' :)
          or $state[$p:lk] = 22091                          (: 'attribute' 'comment' :)
          or $state[$p:lk] = 22115                          (: 'element' 'comment' :)
          or $state[$p:lk] = 22603                          (: 'attribute' 'copy' :)
          or $state[$p:lk] = 22627                          (: 'element' 'copy' :)
          or $state[$p:lk] = 23115                          (: 'attribute' 'declare' :)
          or $state[$p:lk] = 23139                          (: 'element' 'declare' :)
          or $state[$p:lk] = 23627                          (: 'attribute' 'delete' :)
          or $state[$p:lk] = 23651                          (: 'element' 'delete' :)
          or $state[$p:lk] = 23883                          (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 23907                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 24139                          (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 24163                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 24907                          (: 'attribute' 'document' :)
          or $state[$p:lk] = 24931                          (: 'element' 'document' :)
          or $state[$p:lk] = 25163                          (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 25187                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 25419                          (: 'attribute' 'element' :)
          or $state[$p:lk] = 25443                          (: 'element' 'element' :)
          or $state[$p:lk] = 26187                          (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 26211                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 26955                          (: 'attribute' 'every' :)
          or $state[$p:lk] = 26979                          (: 'element' 'every' :)
          or $state[$p:lk] = 27467                          (: 'attribute' 'exit' :)
          or $state[$p:lk] = 27491                          (: 'element' 'exit' :)
          or $state[$p:lk] = 27979                          (: 'attribute' 'first' :)
          or $state[$p:lk] = 28003                          (: 'element' 'first' :)
          or $state[$p:lk] = 28235                          (: 'attribute' 'following' :)
          or $state[$p:lk] = 28259                          (: 'element' 'following' :)
          or $state[$p:lk] = 28491                          (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 28515                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 30283                          (: 'attribute' 'if' :)
          or $state[$p:lk] = 30307                          (: 'element' 'if' :)
          or $state[$p:lk] = 30539                          (: 'attribute' 'import' :)
          or $state[$p:lk] = 30563                          (: 'element' 'import' :)
          or $state[$p:lk] = 31307                          (: 'attribute' 'insert' :)
          or $state[$p:lk] = 31331                          (: 'element' 'insert' :)
          or $state[$p:lk] = 32587                          (: 'attribute' 'item' :)
          or $state[$p:lk] = 32611                          (: 'element' 'item' :)
          or $state[$p:lk] = 32843                          (: 'attribute' 'last' :)
          or $state[$p:lk] = 32867                          (: 'element' 'last' :)
          or $state[$p:lk] = 34891                          (: 'attribute' 'module' :)
          or $state[$p:lk] = 34915                          (: 'element' 'module' :)
          or $state[$p:lk] = 36171                          (: 'attribute' 'node' :)
          or $state[$p:lk] = 36195                          (: 'element' 'node' :)
          or $state[$p:lk] = 37707                          (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 37731                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 38219                          (: 'attribute' 'parent' :)
          or $state[$p:lk] = 38243                          (: 'element' 'parent' :)
          or $state[$p:lk] = 38475                          (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 38499                          (: 'element' 'preceding' :)
          or $state[$p:lk] = 38731                          (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 38755                          (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 39243                          (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 39267                          (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 39499                          (: 'attribute' 'rename' :)
          or $state[$p:lk] = 39523                          (: 'element' 'rename' :)
          or $state[$p:lk] = 39755                          (: 'attribute' 'replace' :)
          or $state[$p:lk] = 39779                          (: 'element' 'replace' :)
          or $state[$p:lk] = 41291                          (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 41315                          (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 41547                          (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 41571                          (: 'element' 'schema-element' :)
          or $state[$p:lk] = 41803                          (: 'attribute' 'self' :)
          or $state[$p:lk] = 41827                          (: 'element' 'self' :)
          or $state[$p:lk] = 42827                          (: 'attribute' 'some' :)
          or $state[$p:lk] = 42851                          (: 'element' 'some' :)
          or $state[$p:lk] = 43851                          (: 'attribute' 'text' :)
          or $state[$p:lk] = 43875                          (: 'element' 'text' :)
          or $state[$p:lk] = 44875                          (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 44899                          (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 45643                          (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 45667                          (: 'element' 'unordered' :)
          or $state[$p:lk] = 46155                          (: 'attribute' 'valid' :)
          or $state[$p:lk] = 46179                          (: 'element' 'valid' :)
          or $state[$p:lk] = 46411                          (: 'attribute' 'validate' :)
          or $state[$p:lk] = 46435                          (: 'element' 'validate' :)
          or $state[$p:lk] = 47691                          (: 'attribute' 'while' :)
          or $state[$p:lk] = 47715                          (: 'element' 'while' :)
          or $state[$p:lk] = 48203                          (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 48227                          (: 'element' 'xquery' :)
          or $state[$p:lk] = 48459                          (: 'attribute' '{' :)
          or $state[$p:lk] = 48470                          (: 'comment' '{' :)
          or $state[$p:lk] = 48481                          (: 'document' '{' :)
          or $state[$p:lk] = 48483                          (: 'element' '{' :)
          or $state[$p:lk] = 48531                          (: 'ordered' '{' :)
          or $state[$p:lk] = 48537                          (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 48555                          (: 'text' '{' :)
          or $state[$p:lk] = 48562                          (: 'unordered' '{' :)
          or $state[$p:lk] = 12403531                       (: 'attribute' 'after' '{' :)
          or $state[$p:lk] = 12403555                       (: 'element' 'after' '{' :)
          or $state[$p:lk] = 12403609                       (: 'processing-instruction' 'after' '{' :)
          or $state[$p:lk] = 12404299                       (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 12404323                       (: 'element' 'and' '{' :)
          or $state[$p:lk] = 12404377                       (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 12404555                       (: 'attribute' 'as' '{' :)
          or $state[$p:lk] = 12404579                       (: 'element' 'as' '{' :)
          or $state[$p:lk] = 12404633                       (: 'processing-instruction' 'as' '{' :)
          or $state[$p:lk] = 12404811                       (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 12404835                       (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 12404889                       (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 12406091                       (: 'attribute' 'before' '{' :)
          or $state[$p:lk] = 12406115                       (: 'element' 'before' '{' :)
          or $state[$p:lk] = 12406169                       (: 'processing-instruction' 'before' '{' :)
          or $state[$p:lk] = 12407115                       (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 12407139                       (: 'element' 'case' '{' :)
          or $state[$p:lk] = 12407193                       (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 12407371                       (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 12407395                       (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 12407449                       (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 12407627                       (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 12407651                       (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 12407705                       (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 12408139                       (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 12408163                       (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 12408217                       (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 12409675                       (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 12409699                       (: 'element' 'default' '{' :)
          or $state[$p:lk] = 12409753                       (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 12410699                       (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 12410723                       (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 12410777                       (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 12410955                       (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 12410979                       (: 'element' 'div' '{' :)
          or $state[$p:lk] = 12411033                       (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 12411979                       (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 12412003                       (: 'element' 'else' '{' :)
          or $state[$p:lk] = 12412057                       (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 12412235                       (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 12412259                       (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 12412313                       (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 12413003                       (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 12413027                       (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 12413081                       (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 12413515                       (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 12413539                       (: 'element' 'except' '{' :)
          or $state[$p:lk] = 12413593                       (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 12415051                       (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 12415075                       (: 'element' 'for' '{' :)
          or $state[$p:lk] = 12415129                       (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 12415563                       (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 12415587                       (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 12415641                       (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 12416075                       (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 12416099                       (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 12416153                       (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 12416331                       (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 12416355                       (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 12416409                       (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 12417867                       (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 12417891                       (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 12417945                       (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 12418123                       (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 12418147                       (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 12418201                       (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 12418379                       (: 'attribute' 'into' '{' :)
          or $state[$p:lk] = 12418403                       (: 'element' 'into' '{' :)
          or $state[$p:lk] = 12418457                       (: 'processing-instruction' 'into' '{' :)
          or $state[$p:lk] = 12418635                       (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 12418659                       (: 'element' 'is' '{' :)
          or $state[$p:lk] = 12418713                       (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 12419659                       (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 12419683                       (: 'element' 'le' '{' :)
          or $state[$p:lk] = 12419737                       (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 12420171                       (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 12420195                       (: 'element' 'let' '{' :)
          or $state[$p:lk] = 12420249                       (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 12420427                       (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 12420451                       (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 12420505                       (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 12420683                       (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 12420707                       (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 12420761                       (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 12420939                       (: 'attribute' 'modify' '{' :)
          or $state[$p:lk] = 12420963                       (: 'element' 'modify' '{' :)
          or $state[$p:lk] = 12421017                       (: 'processing-instruction' 'modify' '{' :)
          or $state[$p:lk] = 12421707                       (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 12421731                       (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 12421785                       (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 12423499                       (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 12423523                       (: 'element' 'or' '{' :)
          or $state[$p:lk] = 12423577                       (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 12423755                       (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 12423779                       (: 'element' 'order' '{' :)
          or $state[$p:lk] = 12423833                       (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 12426315                       (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 12426339                       (: 'element' 'return' '{' :)
          or $state[$p:lk] = 12426393                       (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 12427083                       (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 12427107                       (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 12427161                       (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 12429387                       (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 12429411                       (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 12429465                       (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 12430667                       (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 12430691                       (: 'element' 'to' '{' :)
          or $state[$p:lk] = 12430745                       (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 12430923                       (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 12430947                       (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 12431001                       (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 12431691                       (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 12431715                       (: 'element' 'union' '{' :)
          or $state[$p:lk] = 12431769                       (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 12433739                       (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 12433763                       (: 'element' 'where' '{' :)
          or $state[$p:lk] = 12433817                       (: 'processing-instruction' 'where' '{' :)
          or $state[$p:lk] = 12434251                       (: 'attribute' 'with' '{' :)
          or $state[$p:lk] = 12434275                       (: 'element' 'with' '{' :)
          or $state[$p:lk] = 12434329) then                 (: 'processing-instruction' 'with' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FilterExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AxisStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StepExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 43                                 (: '/' :)
    and $state[$p:l1] != 44) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 43) then                   (: '/' :)
          let $state := p:consume(43, $input, $state)       (: '/' :)
          return $state
        else
          let $state := p:consume(44, $input, $state)       (: '//' :)
          return $state
      let $state := p:lookahead1W(167, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | ('(' ':') | '.' | '..' | '<' |
                                                               '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'block' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'exit' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'insert' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelativePathExpr", $count, $begin, $end)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '/' :)
      let $state := p:consume(43, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(176, $input, $state)      (: EOF | Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '!=' | '$' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 2                          (: EOF :)
              or $state[$p:l1] = 25                         (: '!=' :)
              or $state[$p:l1] = 33                         (: ')' :)
              or $state[$p:l1] = 34                         (: '*' :)
              or $state[$p:l1] = 36                         (: '+' :)
              or $state[$p:l1] = 38                         (: ',' :)
              or $state[$p:l1] = 39                         (: '-' :)
              or $state[$p:l1] = 49                         (: ';' :)
              or $state[$p:l1] = 54                         (: '<<' :)
              or $state[$p:l1] = 55                         (: '<=' :)
              or $state[$p:l1] = 57                         (: '=' :)
              or $state[$p:l1] = 58                         (: '>' :)
              or $state[$p:l1] = 59                         (: '>=' :)
              or $state[$p:l1] = 60                         (: '>>' :)
              or $state[$p:l1] = 65                         (: ']' :)
              or $state[$p:l1] = 191                        (: '|' :)
              or $state[$p:l1] = 192) then                  (: '}' :)
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 44) then                       (: '//' :)
      let $state := p:consume(44, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(167, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | ('(' ':') | '.' | '..' | '<' |
                                                               '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'block' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'exit' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'insert' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PathExpr", $count, $begin, $end)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'lax' :)
      let $state := p:consume(129, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(169, $input, $state)          (: 'strict' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidationMode", $count, $begin, $end)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(180, $input, $state)              (: 'valid' :)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WhiteSpace | ('(' ':') | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 189) then                     (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidationMode($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidateExpr", $count, $begin, $end)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 180) then                          (: 'valid' :)
      let $state := p:lookahead2W(157, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'strict' | 'to' | 'treat' |
                                                               'union' | 'where' | 'with' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 33204                          (: 'valid' 'lax' :)
          or $state[$p:lk] = 43444                          (: 'valid' 'strict' :)
          or $state[$p:lk] = 48564) then                    (: 'valid' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(168, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
    return
      if ($state[$p:l1] != 36                               (: '+' :)
      and $state[$p:l1] != 39) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 39) then                 (: '-' :)
            let $state := p:consume(39, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(36, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpr", $count, $begin, $end)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(142, $input, $state)          (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | 'with' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 82) then                       (: 'cast' :)
      let $state := p:consume(82, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'as' :)
      let $state := p:consume(71, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpr", $count, $begin, $end)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(140, $input, $state)          (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | 'with' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'castable' :)
      let $state := p:consume(83, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'as' :)
      let $state := p:consume(71, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastableExpr", $count, $begin, $end)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(139, $input, $state)          (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 174) then                      (: 'treat' :)
      let $state := p:consume(174, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'as' :)
      let $state := p:consume(71, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TreatExpr", $count, $begin, $end)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(138, $input, $state)          (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'union' | 'where' |
                                                               'with' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 123) then                      (: 'instance' :)
      let $state := p:consume(123, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(46, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'of' :)
      let $state := p:consume(143, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceofExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(136, $input, $state)        (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | 'with' | '|' | '}' :)
    return
      if ($state[$p:l1] != 106                              (: 'except' :)
      and $state[$p:l1] != 124) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 124) then                (: 'intersect' :)
            let $state := p:consume(124, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(106, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(168, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntersectExceptExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 177                                (: 'union' :)
    and $state[$p:l1] != 191) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 177) then                  (: 'union' :)
          let $state := p:consume(177, $input, $state)      (: 'union' :)
          return $state
        else
          let $state := p:consume(191, $input, $state)      (: '|' :)
          return $state
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 34                                 (: '*' :)
    and $state[$p:l1] != 96                                 (: 'div' :)
    and $state[$p:l1] != 117                                (: 'idiv' :)
    and $state[$p:l1] != 134) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '*' :)
          let $state := p:consume(34, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 96) then                   (: 'div' :)
          let $state := p:consume(96, $input, $state)       (: 'div' :)
          return $state
        else if ($state[$p:l1] = 117) then                  (: 'idiv' :)
          let $state := p:consume(117, $input, $state)      (: 'idiv' :)
          return $state
        else
          let $state := p:consume(134, $input, $state)      (: 'mod' :)
          return $state
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 36                                 (: '+' :)
    and $state[$p:l1] != 39) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 36) then                   (: '+' :)
          let $state := p:consume(36, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(39, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpr", $count, $begin, $end)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 173) then                      (: 'to' :)
      let $state := p:consume(173, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RangeExpr", $count, $begin, $end)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-RangeExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25                             (: '!=' :)
          or $state[$p:l1] = 50                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<<' :)
          or $state[$p:l1] = 55                             (: '<=' :)
          or $state[$p:l1] = 57                             (: '=' :)
          or $state[$p:l1] = 58                             (: '>' :)
          or $state[$p:l1] = 59                             (: '>=' :)
          or $state[$p:l1] = 60                             (: '>>' :)
          or $state[$p:l1] = 104                            (: 'eq' :)
          or $state[$p:l1] = 114                            (: 'ge' :)
          or $state[$p:l1] = 116                            (: 'gt' :)
          or $state[$p:l1] = 126                            (: 'is' :)
          or $state[$p:l1] = 130                            (: 'le' :)
          or $state[$p:l1] = 133                            (: 'lt' :)
          or $state[$p:l1] = 138) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 104                        (: 'eq' :)
              or $state[$p:l1] = 114                        (: 'ge' :)
              or $state[$p:l1] = 116                        (: 'gt' :)
              or $state[$p:l1] = 130                        (: 'le' :)
              or $state[$p:l1] = 133                        (: 'lt' :)
              or $state[$p:l1] = 138) then                  (: 'ne' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 54                         (: '<<' :)
              or $state[$p:l1] = 60                         (: '>>' :)
              or $state[$p:l1] = 126) then                  (: 'is' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeComp($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComparisonExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 70) then                           (: 'and' :)
      $state
    else
      let $state := p:consume(70, $input, $state)           (: 'and' :)
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 145) then                          (: 'or' :)
      $state
    else
      let $state := p:consume(145, $input, $state)          (: 'or' :)
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrExpr", $count, $begin, $end)
};

(:~
 : Parse WhileBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhileBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhileBody", $count, $begin, $end)
};

(:~
 : Parse WhileExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhileExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(186, $input, $state)              (: 'while' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WhileBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhileExpr", $count, $begin, $end)
};

(:~
 : Parse ExitExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExitExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(107, $input, $state)              (: 'exit' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'returning' :)
  let $state := p:consume(157, $input, $state)              (: 'returning' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExitExpr", $count, $begin, $end)
};

(:~
 : Parse AssignmentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AssignmentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WhiteSpace | ('(' ':') | ':=' :)
  let $state := p:consume(48, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AssignmentExpr", $count, $begin, $end)
};

(:~
 : Parse BlockBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BlockBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BlockBody", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production BlockVarDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BlockVarDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(70, $input, $state)         (: S^WhiteSpace | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: S^WhiteSpace | '$' | ('(' ':') :)
        let $state := p:consume(28, $input, $state)         (: '$' :)
        let $state := p:lookahead1W(160, $input, $state)    (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VarName($input, $state)
        let $state := p:lookahead1W(113, $input, $state)    (: S^WhiteSpace | ('(' ':') | ',' | ':=' | ';' | 'as' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 71) then                 (: 'as' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(102, $input, $state)    (: S^WhiteSpace | ('(' ':') | ',' | ':=' | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 48) then                 (: ':=' :)
            let $state := p:consume(48, $input, $state)     (: ':=' :)
            let $state := p:lookahead1W(168, $input, $state) (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                                DoubleLiteral | StringLiteral | QName^Token |
                                                                S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                                'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                                'block' | 'case' | 'cast' | 'castable' | 'child' |
                                                                'collation' | 'comment' | 'copy' | 'declare' |
                                                                'default' | 'delete' | 'descendant' |
                                                                'descendant-or-self' | 'descending' | 'div' |
                                                                'document' | 'document-node' | 'element' | 'else' |
                                                                'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                'exit' | 'first' | 'following' | 'following-sibling' |
                                                                'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                                'insert' | 'instance' | 'intersect' | 'into' | 'is' |
                                                                'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                                'modify' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                                'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'text' | 'to' | 'treat' |
                                                                'typeswitch' | 'union' | 'unordered' | 'valid' |
                                                                'validate' | 'where' | 'while' | 'with' | 'xquery' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            return $state
          else
            $state
        return p:parse-BlockVarDecl-1($input, $state)
};

(:~
 : Parse BlockVarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BlockVarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WhiteSpace | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WhiteSpace | ('(' ':') | ',' | ':=' | ';' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(102, $input, $state)          (: S^WhiteSpace | ('(' ':') | ',' | ':=' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: ':=' :)
      let $state := p:consume(48, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  let $state := p:parse-BlockVarDecl-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BlockVarDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production BlockDecls (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BlockDecls-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(168, $input, $state)        (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 90) then                         (: 'declare' :)
        let $state := p:lookahead2W(130, $input, $state)    (: S^WhiteSpace | '!=' | '$' | '(' | ('(' ':') | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | '|' | '}' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 7258) then                       (: 'declare' '$' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-BlockVarDecl($input, $state)
        let $state := p:consume(49, $input, $state)         (: ';' :)
        return p:parse-BlockDecls-1($input, $state)
};

(:~
 : Parse BlockDecls.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BlockDecls($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BlockDecls-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BlockDecls", $count, $begin, $end)
};

(:~
 : Parse Block.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Block($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(189, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-BlockDecls($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-BlockBody($input, $state)
  let $state := p:consume(192, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Block", $count, $begin, $end)
};

(:~
 : Parse BlockExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BlockExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(78, $input, $state)               (: 'block' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WhiteSpace | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BlockExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TransformExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TransformExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(71, $input, $state)         (: S^WhiteSpace | ('(' ':') | ',' | 'modify' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: S^WhiteSpace | '$' | ('(' ':') :)
        let $state := p:consume(28, $input, $state)         (: '$' :)
        let $state := p:lookahead1W(160, $input, $state)    (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VarName($input, $state)
        let $state := p:lookahead1W(25, $input, $state)     (: S^WhiteSpace | ('(' ':') | ':=' :)
        let $state := p:consume(48, $input, $state)         (: ':=' :)
        let $state := p:lookahead1W(168, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-TransformExpr-1($input, $state)
};

(:~
 : Parse TransformExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TransformExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(88, $input, $state)               (: 'copy' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WhiteSpace | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WhiteSpace | ('(' ':') | ':=' :)
  let $state := p:consume(48, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-TransformExpr-1($input, $state)
  let $state := p:consume(135, $input, $state)              (: 'modify' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'return' :)
  let $state := p:consume(156, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TransformExpr", $count, $begin, $end)
};

(:~
 : Parse ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(155, $input, $state)              (: 'replace' :)
  let $state := p:lookahead1W(92, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 182) then                      (: 'value' :)
      let $state := p:consume(182, $input, $state)          (: 'value' :)
      let $state := p:lookahead1W(46, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'of' :)
      let $state := p:consume(143, $input, $state)          (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'node' :)
  let $state := p:consume(141, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'with' :)
  let $state := p:consume(187, $input, $state)              (: 'with' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReplaceExpr", $count, $begin, $end)
};

(:~
 : Parse NewNameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NewNameExpr", $count, $begin, $end)
};

(:~
 : Parse RenameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(154, $input, $state)              (: 'rename' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'node' :)
  let $state := p:consume(141, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'as' :)
  let $state := p:consume(71, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NewNameExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RenameExpr", $count, $begin, $end)
};

(:~
 : Parse DeleteExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(92, $input, $state)               (: 'delete' :)
  let $state := p:lookahead1W(91, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 141) then                      (: 'node' :)
      let $state := p:consume(141, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(142, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DeleteExpr", $count, $begin, $end)
};

(:~
 : Parse TargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TargetExpr", $count, $begin, $end)
};

(:~
 : Parse InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: 'after' :)
      let $state := p:consume(67, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'before' :)
      let $state := p:consume(77, $input, $state)           (: 'before' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 71) then                   (: 'as' :)
          let $state := p:consume(71, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(86, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 109) then              (: 'first' :)
              let $state := p:consume(109, $input, $state)  (: 'first' :)
              return $state
            else
              let $state := p:consume(128, $input, $state)  (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(42, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'into' :)
      let $state := p:consume(125, $input, $state)          (: 'into' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InsertExprTargetChoice", $count, $begin, $end)
};

(:~
 : Parse SourceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SourceExpr", $count, $begin, $end)
};

(:~
 : Parse InsertExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(122, $input, $state)              (: 'insert' :)
  let $state := p:lookahead1W(91, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 141) then                      (: 'node' :)
      let $state := p:consume(141, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(142, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SourceExpr($input, $state)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WhiteSpace | ('(' ':') | 'after' | 'as' | 'before' |
                                                               'into' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InsertExpr", $count, $begin, $end)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(118, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'then' :)
  let $state := p:consume(172, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'else' :)
  let $state := p:consume(100, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IfExpr", $count, $begin, $end)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(81, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(163, $input, $state)          (: QName^Token | S^WhiteSpace | '$' | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:consume(28, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'as' :)
      let $state := p:consume(71, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'return' :)
  let $state := p:consume(156, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConcatExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(119, $input, $state)        (: EOF | S^WhiteSpace | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(168, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-ConcatExpr-1($input, $state)
};

(:~
 : Parse ConcatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-ConcatExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ConcatExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ApplyExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ApplyExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(173, $input, $state)        (: EOF | Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | ']' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'block' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'exit' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'insert' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' | '}' :)
    return
      if ($state[$p:l1] = 2                                 (: EOF :)
       or $state[$p:l1] = 33                                (: ')' :)
       or $state[$p:l1] = 65                                (: ']' :)
       or $state[$p:l1] = 192) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ConcatExpr($input, $state)
        let $state := p:consume(49, $input, $state)         (: ';' :)
        return p:parse-ApplyExpr-1($input, $state)
};

(:~
 : Parse ApplyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ApplyExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: ';' :)
      let $state := p:consume(49, $input, $state)           (: ';' :)
      let $state := p:parse-ApplyExpr-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ApplyExpr", $count, $begin, $end)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ApplyExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(32, $input, $state)         (: S^WhiteSpace | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(82, $input, $state)         (: S^WhiteSpace | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 81) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(175, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(91, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WhiteSpace | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:consume(28, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'return' :)
  let $state := p:consume(156, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeswitchExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(73, $input, $state)         (: S^WhiteSpace | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: S^WhiteSpace | '$' | ('(' ':') :)
        let $state := p:consume(28, $input, $state)         (: '$' :)
        let $state := p:lookahead1W(160, $input, $state)    (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VarName($input, $state)
        let $state := p:lookahead1W(78, $input, $state)     (: S^WhiteSpace | ('(' ':') | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 71) then                 (: 'as' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(41, $input, $state)     (: S^WhiteSpace | ('(' ':') | 'in' :)
        let $state := p:consume(120, $input, $state)        (: 'in' :)
        let $state := p:lookahead1W(168, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 167) then                      (: 'some' :)
      let $state := p:consume(167, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(105, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WhiteSpace | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'in' :)
  let $state := p:consume(120, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(159, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QuantifiedExpr", $count, $begin, $end)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72                             (: 'ascending' :)
          or $state[$p:l1] = 95) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 72) then                   (: 'ascending' :)
          let $state := p:consume(72, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(95, $input, $state)       (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(114, $input, $state)          (: S^WhiteSpace | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 101) then                      (: 'empty' :)
      let $state := p:consume(101, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(87, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 115) then                  (: 'greatest' :)
          let $state := p:consume(115, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(131, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(103, $input, $state)          (: S^WhiteSpace | ('(' ':') | ',' | 'collation' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'collation' :)
      let $state := p:consume(85, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WhiteSpace | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderModifier", $count, $begin, $end)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(122, $input, $state)          (: S^WhiteSpace | ('(' ':') | ',' | 'ascending' |
                                                               'collation' | 'descending' | 'empty' | 'return' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderModifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(72, $input, $state)         (: S^WhiteSpace | ('(' ':') | ',' | 'return' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(168, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpecList", $count, $begin, $end)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 146) then                      (: 'order' :)
      let $state := p:consume(146, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(31, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'by' :)
      let $state := p:consume(80, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(168, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'order' :)
      let $state := p:consume(146, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(31, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'by' :)
      let $state := p:consume(80, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderByClause", $count, $begin, $end)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(185, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhereClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(123, $input, $state)        (: S^WhiteSpace | ('(' ':') | ',' | 'for' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: S^WhiteSpace | '$' | ('(' ':') :)
        let $state := p:consume(28, $input, $state)         (: '$' :)
        let $state := p:lookahead1W(160, $input, $state)    (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VarName($input, $state)
        let $state := p:lookahead1W(74, $input, $state)     (: S^WhiteSpace | ('(' ':') | ':=' | 'as' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 71) then                 (: 'as' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(25, $input, $state)     (: S^WhiteSpace | ('(' ':') | ':=' :)
        let $state := p:consume(48, $input, $state)         (: ':=' :)
        let $state := p:lookahead1W(168, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(132, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WhiteSpace | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WhiteSpace | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WhiteSpace | ('(' ':') | ':=' :)
  let $state := p:consume(48, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetClause", $count, $begin, $end)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(74, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WhiteSpace | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PositionalVar", $count, $begin, $end)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarName", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(123, $input, $state)        (: S^WhiteSpace | ('(' ':') | ',' | 'for' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: S^WhiteSpace | '$' | ('(' ':') :)
        let $state := p:consume(28, $input, $state)         (: '$' :)
        let $state := p:lookahead1W(160, $input, $state)    (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VarName($input, $state)
        let $state := p:lookahead1W(105, $input, $state)    (: S^WhiteSpace | ('(' ':') | 'as' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 71) then                 (: 'as' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(80, $input, $state)     (: S^WhiteSpace | ('(' ':') | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 74) then                 (: 'at' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-PositionalVar($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(41, $input, $state)     (: S^WhiteSpace | ('(' ':') | 'in' :)
        let $state := p:consume(120, $input, $state)        (: 'in' :)
        let $state := p:lookahead1W(168, $input, $state)    (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(112, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WhiteSpace | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WhiteSpace | ('(' ':') | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'in' :)
  let $state := p:consume(120, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FLWORExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 112) then                    (: 'for' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ForClause($input, $state)
        return $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-LetClause($input, $state)
        return $state
    return
      if ($state[$p:l1] != 112                              (: 'for' :)
      and $state[$p:l1] != 132) then                        (: 'let' :)
        $state
      else
        p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 185) then                      (: 'where' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhereClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(112, $input, $state)          (: S^WhiteSpace | ('(' ':') | 'order' | 'return' | 'stable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 156) then                     (: 'return' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderByClause($input, $state)
      return $state
    else
      $state
  let $state := p:consume(156, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FLWORExpr", $count, $begin, $end)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 28) then                           (: '$' :)
      let $state := p:lookahead2W(160, $input, $state)      (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:lk] = (5148,                          (: '$' QName^Token :)
                             17180,                         (: '$' 'after' :)
                             17436,                         (: '$' 'ancestor' :)
                             17692,                         (: '$' 'ancestor-or-self' :)
                             17948,                         (: '$' 'and' :)
                             18204,                         (: '$' 'as' :)
                             18460,                         (: '$' 'ascending' :)
                             19228,                         (: '$' 'attribute' :)
                             19740,                         (: '$' 'before' :)
                             19996,                         (: '$' 'block' :)
                             20764,                         (: '$' 'case' :)
                             21020,                         (: '$' 'cast' :)
                             21276,                         (: '$' 'castable' :)
                             21532,                         (: '$' 'child' :)
                             21788,                         (: '$' 'collation' :)
                             22044,                         (: '$' 'comment' :)
                             22556,                         (: '$' 'copy' :)
                             23068,                         (: '$' 'declare' :)
                             23324,                         (: '$' 'default' :)
                             23580,                         (: '$' 'delete' :)
                             23836,                         (: '$' 'descendant' :)
                             24092,                         (: '$' 'descendant-or-self' :)
                             24348,                         (: '$' 'descending' :)
                             24604,                         (: '$' 'div' :)
                             24860,                         (: '$' 'document' :)
                             25116,                         (: '$' 'document-node' :)
                             25372,                         (: '$' 'element' :)
                             25628,                         (: '$' 'else' :)
                             25884,                         (: '$' 'empty' :)
                             26140,                         (: '$' 'empty-sequence' :)
                             26652,                         (: '$' 'eq' :)
                             26908,                         (: '$' 'every' :)
                             27164,                         (: '$' 'except' :)
                             27420,                         (: '$' 'exit' :)
                             27932,                         (: '$' 'first' :)
                             28188,                         (: '$' 'following' :)
                             28444,                         (: '$' 'following-sibling' :)
                             28700,                         (: '$' 'for' :)
                             29212,                         (: '$' 'ge' :)
                             29724,                         (: '$' 'gt' :)
                             29980,                         (: '$' 'idiv' :)
                             30236,                         (: '$' 'if' :)
                             30492,                         (: '$' 'import' :)
                             31260,                         (: '$' 'insert' :)
                             31516,                         (: '$' 'instance' :)
                             31772,                         (: '$' 'intersect' :)
                             32028,                         (: '$' 'into' :)
                             32284,                         (: '$' 'is' :)
                             32540,                         (: '$' 'item' :)
                             32796,                         (: '$' 'last' :)
                             33308,                         (: '$' 'le' :)
                             33820,                         (: '$' 'let' :)
                             34076,                         (: '$' 'lt' :)
                             34332,                         (: '$' 'mod' :)
                             34588,                         (: '$' 'modify' :)
                             34844,                         (: '$' 'module' :)
                             35356,                         (: '$' 'ne' :)
                             36124,                         (: '$' 'node' :)
                             37148,                         (: '$' 'or' :)
                             37404,                         (: '$' 'order' :)
                             37660,                         (: '$' 'ordered' :)
                             38172,                         (: '$' 'parent' :)
                             38428,                         (: '$' 'preceding' :)
                             38684,                         (: '$' 'preceding-sibling' :)
                             39196,                         (: '$' 'processing-instruction' :)
                             39452,                         (: '$' 'rename' :)
                             39708,                         (: '$' 'replace' :)
                             39964,                         (: '$' 'return' :)
                             40732,                         (: '$' 'satisfies' :)
                             41244,                         (: '$' 'schema-attribute' :)
                             41500,                         (: '$' 'schema-element' :)
                             41756,                         (: '$' 'self' :)
                             42780,                         (: '$' 'some' :)
                             43036,                         (: '$' 'stable' :)
                             43804,                         (: '$' 'text' :)
                             44316,                         (: '$' 'to' :)
                             44572,                         (: '$' 'treat' :)
                             44828,                         (: '$' 'typeswitch' :)
                             45340,                         (: '$' 'union' :)
                             45596,                         (: '$' 'unordered' :)
                             46108,                         (: '$' 'valid' :)
                             46364,                         (: '$' 'validate' :)
                             47388,                         (: '$' 'where' :)
                             47644,                         (: '$' 'while' :)
                             47900,                         (: '$' 'with' :)
                             48156)) then                   (: '$' 'xquery' :)
          let $state := p:lookahead3W(146, $input, $state)  (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':=' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 78) then                      (: 'block' :)
      let $state := p:lookahead2W(151, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] eq 107) then                     (: 'exit' :)
      let $state := p:lookahead2W(150, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'returning' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] eq 154) then                     (: 'rename' :)
      let $state := p:lookahead2W(149, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] eq 155) then                     (: 'replace' :)
      let $state := p:lookahead2W(156, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'value' | 'where' |
                                                               'with' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (92,                           (: 'delete' :)
                              122)) then                    (: 'insert' :)
      let $state := p:lookahead2W(155, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'nodes' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (118,                          (: 'if' :)
                              175,                          (: 'typeswitch' :)
                              186)) then                    (: 'while' :)
      let $state := p:lookahead2W(144, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (88,                           (: 'copy' :)
                              105,                          (: 'every' :)
                              112,                          (: 'for' :)
                              132,                          (: 'let' :)
                              167)) then                    (: 'some' :)
      let $state := p:lookahead2W(147, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7280                           (: 'for' '$' :)
          or $state[$p:lk] = 7300) then                     (: 'let' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7273                           (: 'every' '$' :)
          or $state[$p:lk] = 7335) then                     (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7855) then                     (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7798) then                     (: 'if' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 36218                          (: 'insert' 'node' :)
          or $state[$p:lk] = 36474) then                    (: 'insert' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 36188                          (: 'delete' 'node' :)
          or $state[$p:lk] = 36444) then                    (: 'delete' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 36250) then                    (: 'rename' 'node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 36251                          (: 'replace' 'node' :)
          or $state[$p:lk] = 46747) then                    (: 'replace' 'value' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7256) then                     (: 'copy' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TransformExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 48462) then                    (: 'block' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BlockExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 3150876                        (: '$' QName^Token ':=' :)
          or $state[$p:lk] = 3162908                        (: '$' 'after' ':=' :)
          or $state[$p:lk] = 3163164                        (: '$' 'ancestor' ':=' :)
          or $state[$p:lk] = 3163420                        (: '$' 'ancestor-or-self' ':=' :)
          or $state[$p:lk] = 3163676                        (: '$' 'and' ':=' :)
          or $state[$p:lk] = 3163932                        (: '$' 'as' ':=' :)
          or $state[$p:lk] = 3164188                        (: '$' 'ascending' ':=' :)
          or $state[$p:lk] = 3164956                        (: '$' 'attribute' ':=' :)
          or $state[$p:lk] = 3165468                        (: '$' 'before' ':=' :)
          or $state[$p:lk] = 3165724                        (: '$' 'block' ':=' :)
          or $state[$p:lk] = 3166492                        (: '$' 'case' ':=' :)
          or $state[$p:lk] = 3166748                        (: '$' 'cast' ':=' :)
          or $state[$p:lk] = 3167004                        (: '$' 'castable' ':=' :)
          or $state[$p:lk] = 3167260                        (: '$' 'child' ':=' :)
          or $state[$p:lk] = 3167516                        (: '$' 'collation' ':=' :)
          or $state[$p:lk] = 3167772                        (: '$' 'comment' ':=' :)
          or $state[$p:lk] = 3168284                        (: '$' 'copy' ':=' :)
          or $state[$p:lk] = 3168796                        (: '$' 'declare' ':=' :)
          or $state[$p:lk] = 3169052                        (: '$' 'default' ':=' :)
          or $state[$p:lk] = 3169308                        (: '$' 'delete' ':=' :)
          or $state[$p:lk] = 3169564                        (: '$' 'descendant' ':=' :)
          or $state[$p:lk] = 3169820                        (: '$' 'descendant-or-self' ':=' :)
          or $state[$p:lk] = 3170076                        (: '$' 'descending' ':=' :)
          or $state[$p:lk] = 3170332                        (: '$' 'div' ':=' :)
          or $state[$p:lk] = 3170588                        (: '$' 'document' ':=' :)
          or $state[$p:lk] = 3170844                        (: '$' 'document-node' ':=' :)
          or $state[$p:lk] = 3171100                        (: '$' 'element' ':=' :)
          or $state[$p:lk] = 3171356                        (: '$' 'else' ':=' :)
          or $state[$p:lk] = 3171612                        (: '$' 'empty' ':=' :)
          or $state[$p:lk] = 3171868                        (: '$' 'empty-sequence' ':=' :)
          or $state[$p:lk] = 3172380                        (: '$' 'eq' ':=' :)
          or $state[$p:lk] = 3172636                        (: '$' 'every' ':=' :)
          or $state[$p:lk] = 3172892                        (: '$' 'except' ':=' :)
          or $state[$p:lk] = 3173148                        (: '$' 'exit' ':=' :)
          or $state[$p:lk] = 3173660                        (: '$' 'first' ':=' :)
          or $state[$p:lk] = 3173916                        (: '$' 'following' ':=' :)
          or $state[$p:lk] = 3174172                        (: '$' 'following-sibling' ':=' :)
          or $state[$p:lk] = 3174428                        (: '$' 'for' ':=' :)
          or $state[$p:lk] = 3174940                        (: '$' 'ge' ':=' :)
          or $state[$p:lk] = 3175452                        (: '$' 'gt' ':=' :)
          or $state[$p:lk] = 3175708                        (: '$' 'idiv' ':=' :)
          or $state[$p:lk] = 3175964                        (: '$' 'if' ':=' :)
          or $state[$p:lk] = 3176220                        (: '$' 'import' ':=' :)
          or $state[$p:lk] = 3176988                        (: '$' 'insert' ':=' :)
          or $state[$p:lk] = 3177244                        (: '$' 'instance' ':=' :)
          or $state[$p:lk] = 3177500                        (: '$' 'intersect' ':=' :)
          or $state[$p:lk] = 3177756                        (: '$' 'into' ':=' :)
          or $state[$p:lk] = 3178012                        (: '$' 'is' ':=' :)
          or $state[$p:lk] = 3178268                        (: '$' 'item' ':=' :)
          or $state[$p:lk] = 3178524                        (: '$' 'last' ':=' :)
          or $state[$p:lk] = 3179036                        (: '$' 'le' ':=' :)
          or $state[$p:lk] = 3179548                        (: '$' 'let' ':=' :)
          or $state[$p:lk] = 3179804                        (: '$' 'lt' ':=' :)
          or $state[$p:lk] = 3180060                        (: '$' 'mod' ':=' :)
          or $state[$p:lk] = 3180316                        (: '$' 'modify' ':=' :)
          or $state[$p:lk] = 3180572                        (: '$' 'module' ':=' :)
          or $state[$p:lk] = 3181084                        (: '$' 'ne' ':=' :)
          or $state[$p:lk] = 3181852                        (: '$' 'node' ':=' :)
          or $state[$p:lk] = 3182876                        (: '$' 'or' ':=' :)
          or $state[$p:lk] = 3183132                        (: '$' 'order' ':=' :)
          or $state[$p:lk] = 3183388                        (: '$' 'ordered' ':=' :)
          or $state[$p:lk] = 3183900                        (: '$' 'parent' ':=' :)
          or $state[$p:lk] = 3184156                        (: '$' 'preceding' ':=' :)
          or $state[$p:lk] = 3184412                        (: '$' 'preceding-sibling' ':=' :)
          or $state[$p:lk] = 3184924                        (: '$' 'processing-instruction' ':=' :)
          or $state[$p:lk] = 3185180                        (: '$' 'rename' ':=' :)
          or $state[$p:lk] = 3185436                        (: '$' 'replace' ':=' :)
          or $state[$p:lk] = 3185692                        (: '$' 'return' ':=' :)
          or $state[$p:lk] = 3186460                        (: '$' 'satisfies' ':=' :)
          or $state[$p:lk] = 3186972                        (: '$' 'schema-attribute' ':=' :)
          or $state[$p:lk] = 3187228                        (: '$' 'schema-element' ':=' :)
          or $state[$p:lk] = 3187484                        (: '$' 'self' ':=' :)
          or $state[$p:lk] = 3188508                        (: '$' 'some' ':=' :)
          or $state[$p:lk] = 3188764                        (: '$' 'stable' ':=' :)
          or $state[$p:lk] = 3189532                        (: '$' 'text' ':=' :)
          or $state[$p:lk] = 3190044                        (: '$' 'to' ':=' :)
          or $state[$p:lk] = 3190300                        (: '$' 'treat' ':=' :)
          or $state[$p:lk] = 3190556                        (: '$' 'typeswitch' ':=' :)
          or $state[$p:lk] = 3191068                        (: '$' 'union' ':=' :)
          or $state[$p:lk] = 3191324                        (: '$' 'unordered' ':=' :)
          or $state[$p:lk] = 3191836                        (: '$' 'valid' ':=' :)
          or $state[$p:lk] = 3192092                        (: '$' 'validate' ':=' :)
          or $state[$p:lk] = 3193116                        (: '$' 'where' ':=' :)
          or $state[$p:lk] = 3193372                        (: '$' 'while' ':=' :)
          or $state[$p:lk] = 3193628                        (: '$' 'with' ':=' :)
          or $state[$p:lk] = 3193884) then                  (: '$' 'xquery' ':=' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AssignmentExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 40299) then                    (: 'exit' 'returning' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExitExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7866) then                     (: 'while' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhileExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExprSingle", $count, $begin, $end)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 61) then                       (: '?' :)
      let $state := p:consume(61, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:consume(35, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(37, $input, $state)           (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OccurrenceIndicator", $count, $begin, $end)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AtomicType", $count, $begin, $end)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(141, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyKindTest", $count, $begin, $end)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(171, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TextTest", $count, $begin, $end)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(86, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CommentTest", $count, $begin, $end)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(153, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(134, $input, $state)          (: StringLiteral | NCName^Token | S^WhiteSpace | ('(' ':') |
                                                               ')' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 11) then                   (: StringLiteral :)
          let $state := p:consume(11, $input, $state)       (: StringLiteral :)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PITest", $count, $begin, $end)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(161, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaAttributeTest", $count, $begin, $end)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeName", $count, $begin, $end)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '*' :)
      let $state := p:consume(34, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AttribNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(75, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(166, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | ')' | '*' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WhiteSpace | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: ',' :)
          let $state := p:consume(38, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(160, $input, $state)  (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeTest", $count, $begin, $end)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(162, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaElementTest", $count, $begin, $end)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeName", $count, $begin, $end)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementName", $count, $begin, $end)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '*' :)
      let $state := p:consume(34, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(99, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(166, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | ')' | '*' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WhiteSpace | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: ',' :)
          let $state := p:consume(38, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(160, $input, $state)  (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(69, $input, $state)   (: S^WhiteSpace | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 61) then               (: '?' :)
              let $state := p:consume(61, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementTest", $count, $begin, $end)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(98, $input, $state)               (: 'document-node' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WhiteSpace | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WhiteSpace | ('(' ':') | ')' | 'element' |
                                                               'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 99) then                   (: 'element' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: S^WhiteSpace | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DocumentTest", $count, $begin, $end)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TextTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyKindTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KindTest", $count, $begin, $end)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (75,                                (: 'attribute' :)
                         86,                                (: 'comment' :)
                         98,                                (: 'document-node' :)
                         99,                                (: 'element' :)
                         127,                               (: 'item' :)
                         141,                               (: 'node' :)
                         153,                               (: 'processing-instruction' :)
                         161,                               (: 'schema-attribute' :)
                         162,                               (: 'schema-element' :)
                         171)) then                         (: 'text' :)
      let $state := p:lookahead2W(154, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '*' | '+' | '+' | ',' | '-' | ':=' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | 'with' | '{' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7755                           (: 'attribute' '(' :)
          or $state[$p:lk] = 7766                           (: 'comment' '(' :)
          or $state[$p:lk] = 7778                           (: 'document-node' '(' :)
          or $state[$p:lk] = 7779                           (: 'element' '(' :)
          or $state[$p:lk] = 7821                           (: 'node' '(' :)
          or $state[$p:lk] = 7833                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 7841                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 7842                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 7851) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 7807) then                     (: 'item' '(' :)
      let $state := p:consume(127, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WhiteSpace | '(' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WhiteSpace | ('(' ':') | ')' :)
      let $state := p:consume(33, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AtomicType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ItemType", $count, $begin, $end)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 102) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(154, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '*' | '+' | '+' | ',' | '-' | ':=' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | 'with' | '{' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7782) then                     (: 'empty-sequence' '(' :)
      let $state := p:consume(102, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WhiteSpace | '(' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WhiteSpace | ('(' ':') | ')' :)
      let $state := p:consume(33, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(152, $input, $state)      (: EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '?' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | 'with' | '{' |
                                                               '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35                         (: '*' :)
              or $state[$p:l1] = 37                         (: '+' :)
              or $state[$p:l1] = 61) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceType", $count, $begin, $end)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(71, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 20) then                       (: QName^Token :)
      let $state := p:consume(20, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'after' :)
      let $state := p:consume(67, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'ancestor' :)
      let $state := p:consume(68, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(69, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'and' :)
      let $state := p:consume(70, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'as' :)
      let $state := p:consume(71, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ascending' :)
      let $state := p:consume(72, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'before' :)
      let $state := p:consume(77, $input, $state)           (: 'before' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'block' :)
      let $state := p:consume(78, $input, $state)           (: 'block' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'case' :)
      let $state := p:consume(81, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'cast' :)
      let $state := p:consume(82, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'castable' :)
      let $state := p:consume(83, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'child' :)
      let $state := p:consume(84, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'collation' :)
      let $state := p:consume(85, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'copy' :)
      let $state := p:consume(88, $input, $state)           (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'declare' :)
      let $state := p:consume(90, $input, $state)           (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'default' :)
      let $state := p:consume(91, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'delete' :)
      let $state := p:consume(92, $input, $state)           (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descendant' :)
      let $state := p:consume(93, $input, $state)           (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'descendant-or-self' :)
      let $state := p:consume(94, $input, $state)           (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'descending' :)
      let $state := p:consume(95, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'div' :)
      let $state := p:consume(96, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'document' :)
      let $state := p:consume(97, $input, $state)           (: 'document' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'else' :)
      let $state := p:consume(100, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'empty' :)
      let $state := p:consume(101, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'eq' :)
      let $state := p:consume(104, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'every' :)
      let $state := p:consume(105, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'except' :)
      let $state := p:consume(106, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'exit' :)
      let $state := p:consume(107, $input, $state)          (: 'exit' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'following' :)
      let $state := p:consume(110, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'following-sibling' :)
      let $state := p:consume(111, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'first' :)
      let $state := p:consume(109, $input, $state)          (: 'first' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'for' :)
      let $state := p:consume(112, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'ge' :)
      let $state := p:consume(114, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'gt' :)
      let $state := p:consume(116, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'idiv' :)
      let $state := p:consume(117, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'import' :)
      let $state := p:consume(119, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'insert' :)
      let $state := p:consume(122, $input, $state)          (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'instance' :)
      let $state := p:consume(123, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'intersect' :)
      let $state := p:consume(124, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'into' :)
      let $state := p:consume(125, $input, $state)          (: 'into' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'is' :)
      let $state := p:consume(126, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'last' :)
      let $state := p:consume(128, $input, $state)          (: 'last' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'le' :)
      let $state := p:consume(130, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'let' :)
      let $state := p:consume(132, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'lt' :)
      let $state := p:consume(133, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'mod' :)
      let $state := p:consume(134, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'modify' :)
      let $state := p:consume(135, $input, $state)          (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'module' :)
      let $state := p:consume(136, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'ne' :)
      let $state := p:consume(138, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'or' :)
      let $state := p:consume(145, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'order' :)
      let $state := p:consume(146, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'ordered' :)
      let $state := p:consume(147, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'parent' :)
      let $state := p:consume(149, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'preceding' :)
      let $state := p:consume(150, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'preceding-sibling' :)
      let $state := p:consume(151, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'rename' :)
      let $state := p:consume(154, $input, $state)          (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'replace' :)
      let $state := p:consume(155, $input, $state)          (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'return' :)
      let $state := p:consume(156, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'satisfies' :)
      let $state := p:consume(159, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'self' :)
      let $state := p:consume(163, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'some' :)
      let $state := p:consume(167, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'stable' :)
      let $state := p:consume(168, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'to' :)
      let $state := p:consume(173, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'treat' :)
      let $state := p:consume(174, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'union' :)
      let $state := p:consume(177, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'unordered' :)
      let $state := p:consume(178, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'valid' :)
      let $state := p:consume(180, $input, $state)          (: 'valid' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'validate' :)
      let $state := p:consume(181, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'where' :)
      let $state := p:consume(185, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'with' :)
      let $state := p:consume(187, $input, $state)          (: 'with' :)
      return $state
    else
      let $state := p:consume(188, $input, $state)          (: 'xquery' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionName", $count, $begin, $end)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(158, $input, $state)           (: QName^Token | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'block' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'exit' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'insert' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:consume(75, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'comment' :)
      let $state := p:consume(86, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'document-node' :)
      let $state := p:consume(98, $input, $state)           (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state := p:consume(99, $input, $state)           (: 'element' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'empty-sequence' :)
      let $state := p:consume(102, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'if' :)
      let $state := p:consume(118, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'item' :)
      let $state := p:consume(127, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'node' :)
      let $state := p:consume(141, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'processing-instruction' :)
      let $state := p:consume(153, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'schema-attribute' :)
      let $state := p:consume(161, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'schema-element' :)
      let $state := p:consume(162, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'text' :)
      let $state := p:consume(171, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'typeswitch' :)
      let $state := p:consume(175, $input, $state)          (: 'typeswitch' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'while' :)
      let $state := p:consume(186, $input, $state)          (: 'while' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QName", $count, $begin, $end)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(107, $input, $state)          (: S^WhiteSpace | ('(' ':') | 'assignable' |
                                                               'unassignable' | 'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'assignable' :)
      let $state := p:consume(73, $input, $state)           (: 'assignable' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 176) then                  (: 'unassignable' :)
          let $state := p:consume(176, $input, $state)      (: 'unassignable' :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(56, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'variable' :)
  let $state := p:consume(183, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WhiteSpace | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(160, $input, $state)          (: QName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'block' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WhiteSpace | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(75, $input, $state)           (: S^WhiteSpace | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: ':=' :)
      let $state := p:consume(48, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(168, $input, $state)      (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'external' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(70, $input, $state)         (: S^WhiteSpace | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WhiteSpace | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(119, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'module' :)
  let $state := p:consume(136, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(61, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace' :)
      let $state := p:consume(137, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(132, $input, $state)      (: NCName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WhiteSpace | ('(' ':') | '=' :)
      let $state := p:consume(57, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WhiteSpace | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'at' :)
      let $state := p:consume(74, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WhiteSpace | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleImport", $count, $begin, $end)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'namespace' :)
      let $state := p:consume(137, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(132, $input, $state)      (: NCName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WhiteSpace | ('(' ':') | '=' :)
      let $state := p:consume(57, $input, $state)           (: '=' :)
      return $state
    else
      let $state := p:consume(91, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'element' :)
      let $state := p:consume(99, $input, $state)           (: 'element' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'namespace' :)
      let $state := p:consume(137, $input, $state)          (: 'namespace' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaPrefix", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(70, $input, $state)         (: S^WhiteSpace | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WhiteSpace | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(119, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'schema' :)
  let $state := p:consume(160, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(98, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 11) then                      (: StringLiteral :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WhiteSpace | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'at' :)
      let $state := p:consume(74, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WhiteSpace | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaImport", $count, $begin, $end)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 119) then                          (: 'import' :)
      let $state := p:lookahead2W(89, $input, $state)       (: S^WhiteSpace | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 41079) then                    (: 'import' 'schema' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaImport($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ModuleImport($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Import", $count, $begin, $end)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'namespace' :)
  let $state := p:consume(137, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(132, $input, $state)          (: NCName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WhiteSpace | ('(' ':') | '=' :)
  let $state := p:consume(57, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 121) then                      (: 'inherit' :)
      let $state := p:consume(121, $input, $state)          (: 'inherit' :)
      return $state
    else
      let $state := p:consume(139, $input, $state)          (: 'no-inherit' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InheritMode", $count, $begin, $end)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'preserve' :)
      let $state := p:consume(152, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(140, $input, $state)          (: 'no-preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PreserveMode", $count, $begin, $end)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(89, $input, $state)               (: 'copy-namespaces' :)
  let $state := p:lookahead1W(90, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WhiteSpace | ('(' ':') | ',' :)
  let $state := p:consume(38, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InheritMode($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CopyNamespacesDecl", $count, $begin, $end)
};

(:~
 : Parse RevalidationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RevalidationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'revalidation' :)
  let $state := p:consume(158, $input, $state)              (: 'revalidation' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WhiteSpace | ('(' ':') | 'lax' | 'skip' | 'strict' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 169) then                      (: 'strict' :)
      let $state := p:consume(169, $input, $state)          (: 'strict' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'lax' :)
      let $state := p:consume(129, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(166, $input, $state)          (: 'skip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RevalidationDecl", $count, $begin, $end)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'default' :)
  let $state := p:consume(91, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'order' :)
  let $state := p:consume(146, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'empty' :)
  let $state := p:consume(101, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 115) then                      (: 'greatest' :)
      let $state := p:consume(115, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(131, $input, $state)          (: 'least' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyOrderDecl", $count, $begin, $end)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'ordering' :)
  let $state := p:consume(148, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(95, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 147) then                      (: 'ordered' :)
      let $state := p:consume(147, $input, $state)          (: 'ordered' :)
      return $state
    else
      let $state := p:consume(178, $input, $state)          (: 'unordered' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderingModeDecl", $count, $begin, $end)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'construction' :)
  let $state := p:consume(87, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 170) then                      (: 'strip' :)
      let $state := p:consume(170, $input, $state)          (: 'strip' :)
      return $state
    else
      let $state := p:consume(152, $input, $state)          (: 'preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConstructionDecl", $count, $begin, $end)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'base-uri' :)
  let $state := p:consume(76, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BaseURIDecl", $count, $begin, $end)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'default' :)
  let $state := p:consume(91, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'collation' :)
  let $state := p:consume(85, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultCollationDecl", $count, $begin, $end)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(79, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'preserve' :)
      let $state := p:consume(152, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(170, $input, $state)          (: 'strip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BoundarySpaceDecl", $count, $begin, $end)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 90) then                           (: 'declare' :)
      let $state := p:lookahead2W(124, $input, $state)      (: S^WhiteSpace | ('(' ':') | 'base-uri' |
                                                               'boundary-space' | 'construction' | 'copy-namespaces' |
                                                               'default' | 'ordering' | 'revalidation' :)
      let $state :=
        if ($state[$p:lk] eq 23386) then                    (: 'declare' 'default' :)
          let $state := p:lookahead3W(83, $input, $state)   (: S^WhiteSpace | ('(' ':') | 'collation' | 'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20314) then                    (: 'declare' 'boundary-space' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5593946) then                  (: 'declare' 'default' 'collation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 19546) then                    (: 'declare' 'base-uri' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 22362) then                    (: 'declare' 'construction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 37978) then                    (: 'declare' 'ordering' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 9591642) then                  (: 'declare' 'default' 'order' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 40538) then                    (: 'declare' 'revalidation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RevalidationDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyNamespacesDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Setter", $count, $begin, $end)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'default' :)
  let $state := p:consume(91, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 99) then                       (: 'element' :)
      let $state := p:consume(99, $input, $state)           (: 'element' :)
      return $state
    else
      let $state := p:consume(113, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'namespace' :)
  let $state := p:consume(137, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultNamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: EOF | Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 90) then                         (: 'declare' :)
        let $state := p:lookahead2W(137, $input, $state)    (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'assignable' |
                                                               'base-uri' | 'boundary-space' | 'cast' | 'castable' |
                                                               'construction' | 'copy-namespaces' | 'default' | 'div' |
                                                               'eq' | 'except' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'namespace' | 'ne' | 'option' | 'or' | 'ordering' |
                                                               'revalidation' | 'sequential' | 'simple' | 'to' |
                                                               'treat' | 'unassignable' | 'union' | 'updating' |
                                                               'variable' | '|' :)
        return $state
      else if ($state[$p:l1] eq 119) then                   (: 'import' :)
        let $state := p:lookahead2W(131, $input, $state)    (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'schema' | 'to' | 'treat' |
                                                               'union' | '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 19546                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 20314                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 22362                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 22874                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 23386                            (: 'declare' 'default' :)
      and $state[$p:lk] != 34935                            (: 'import' 'module' :)
      and $state[$p:lk] != 35162                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 37978                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 40538                            (: 'declare' 'revalidation' :)
      and $state[$p:lk] != 41079) then                      (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 90) then                     (: 'declare' :)
            let $state := p:lookahead2W(126, $input, $state) (: S^WhiteSpace | ('(' ':') | 'base-uri' |
                                                                'boundary-space' | 'construction' | 'copy-namespaces' |
                                                                'default' | 'namespace' | 'ordering' | 'revalidation' :)
            let $state :=
              if ($state[$p:lk] eq 23386) then              (: 'declare' 'default' :)
                let $state := p:lookahead3W(116, $input, $state) (: S^WhiteSpace | ('(' ':') | 'collation' | 'element' |
                                                                    'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 6511450                  (: 'declare' 'default' 'element' :)
                or $state[$p:lk] = 7428954) then            (: 'declare' 'default' 'function' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 35162) then              (: 'declare' 'namespace' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 119) then                (: 'import' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Import($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(26, $input, $state)     (: S^WhiteSpace | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: EOF | Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 90) then                         (: 'declare' :)
        let $state := p:lookahead2W(135, $input, $state)    (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'assignable' | 'cast' |
                                                               'castable' | 'div' | 'eq' | 'except' | 'function' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'option' | 'or' |
                                                               'sequential' | 'simple' | 'to' | 'treat' |
                                                               'unassignable' | 'union' | 'updating' | 'variable' | '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 18778                            (: 'declare' 'assignable' :)
      and $state[$p:lk] != 29018                            (: 'declare' 'function' :)
      and $state[$p:lk] != 36954                            (: 'declare' 'option' :)
      and $state[$p:lk] != 42074                            (: 'declare' 'sequential' :)
      and $state[$p:lk] != 42330                            (: 'declare' 'simple' :)
      and $state[$p:lk] != 45146                            (: 'declare' 'unassignable' :)
      and $state[$p:lk] != 45914                            (: 'declare' 'updating' :)
      and $state[$p:lk] != 46938) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 90) then                     (: 'declare' :)
            let $state := p:lookahead2W(125, $input, $state) (: S^WhiteSpace | ('(' ':') | 'assignable' | 'function' |
                                                                'option' | 'sequential' | 'simple' | 'unassignable' |
                                                                'updating' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 18778                    (: 'declare' 'assignable' :)
                or $state[$p:lk] = 45146                    (: 'declare' 'unassignable' :)
                or $state[$p:lk] = 46938) then              (: 'declare' 'variable' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 36954) then              (: 'declare' 'option' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-OptionDecl($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-FunctionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(26, $input, $state)     (: S^WhiteSpace | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prolog", $count, $begin, $end)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(11, $input, $state)               (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "URILiteral", $count, $begin, $end)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: NCName^Token :)
      let $state := p:consume(21, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'after' :)
      let $state := p:consume(67, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'and' :)
      let $state := p:consume(70, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'as' :)
      let $state := p:consume(71, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ascending' :)
      let $state := p:consume(72, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'before' :)
      let $state := p:consume(77, $input, $state)           (: 'before' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'case' :)
      let $state := p:consume(81, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'cast' :)
      let $state := p:consume(82, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'castable' :)
      let $state := p:consume(83, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'collation' :)
      let $state := p:consume(85, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'default' :)
      let $state := p:consume(91, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'descending' :)
      let $state := p:consume(95, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'div' :)
      let $state := p:consume(96, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'else' :)
      let $state := p:consume(100, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'empty' :)
      let $state := p:consume(101, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'eq' :)
      let $state := p:consume(104, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'except' :)
      let $state := p:consume(106, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'for' :)
      let $state := p:consume(112, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'ge' :)
      let $state := p:consume(114, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'gt' :)
      let $state := p:consume(116, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'idiv' :)
      let $state := p:consume(117, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'instance' :)
      let $state := p:consume(123, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'intersect' :)
      let $state := p:consume(124, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'into' :)
      let $state := p:consume(125, $input, $state)          (: 'into' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'is' :)
      let $state := p:consume(126, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'le' :)
      let $state := p:consume(130, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'let' :)
      let $state := p:consume(132, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'lt' :)
      let $state := p:consume(133, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'mod' :)
      let $state := p:consume(134, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'modify' :)
      let $state := p:consume(135, $input, $state)          (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'ne' :)
      let $state := p:consume(138, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'or' :)
      let $state := p:consume(145, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'order' :)
      let $state := p:consume(146, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'return' :)
      let $state := p:consume(156, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'satisfies' :)
      let $state := p:consume(159, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'stable' :)
      let $state := p:consume(168, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'to' :)
      let $state := p:consume(173, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'treat' :)
      let $state := p:consume(174, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'union' :)
      let $state := p:consume(177, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'where' :)
      let $state := p:consume(185, $input, $state)          (: 'where' :)
      return $state
    else
      let $state := p:consume(187, $input, $state)          (: 'with' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NCName", $count, $begin, $end)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(136, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'namespace' :)
  let $state := p:consume(137, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(132, $input, $state)          (: NCName^Token | S^WhiteSpace | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | 'with' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WhiteSpace | ('(' ':') | '=' :)
  let $state := p:consume(57, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WhiteSpace | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleDecl", $count, $begin, $end)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(97, $input, $state)           (: EOF | S^WhiteSpace | ('(' ':') | 'declare' | 'import' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LibraryModule", $count, $begin, $end)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(49, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Separator", $count, $begin, $end)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(188, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WhiteSpace | ('(' ':') | 'version' :)
  let $state := p:consume(184, $input, $state)              (: 'version' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WhiteSpace | ('(' ':') :)
  let $state := p:consume(11, $input, $state)               (: StringLiteral :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WhiteSpace | ('(' ':') | ';' | 'encoding' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 103) then                      (: 'encoding' :)
      let $state := p:consume(103, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WhiteSpace | ('(' ':') :)
      let $state := p:consume(11, $input, $state)           (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(26, $input, $state)           (: S^WhiteSpace | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VersionDecl", $count, $begin, $end)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 188) then                          (: 'xquery' :)
      let $state := p:lookahead2W(129, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | 'version' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 47292) then                    (: 'xquery' 'version' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'module' :)
      let $state := p:lookahead2W(128, $input, $state)      (: EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'namespace' | 'ne' | 'or' | 'to' | 'treat' | 'union' |
                                                               '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 35208) then                    (: 'module' 'namespace' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LibraryModule($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MainModule($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Module", $count, $begin, $end)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(168, $input, $state)          (: Wildcard | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token |
                                                               S^WhiteSpace | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'block' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'exit' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'valid' | 'validate' | 'where' |
                                                               'while' | 'with' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Module($input, $state)
  let $state := p:consume(2, $input, $state)                (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "XQuery", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 23) then                                (: S^WhiteSpace :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 32) then                           (: ('(' ':') :)
      let $state := p:try-WhiteSpace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:matchW($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:matchW($input, $state[$p:e2], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-XQuery($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : The input filename, or string, if surrounded by curly braces.
 :)
declare variable $input as xs:string external;

let $result :=
  if (matches($input, "^\{.*\}$")) then
    p:parse-XQuery(substring($input, 2, string-length($input) - 2))
  else
    p:parse-XQuery(unparsed-text($input, "utf-8"))
return
  if (empty($result/self::ERROR)) then
    $result
  else
    error(xs:QName("p:parse-XQuery"), concat("&#10;    ", replace($result, "&#10;", "&#10;    ")))

(: End :)
