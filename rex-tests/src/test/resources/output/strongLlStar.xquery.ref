xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sun Jun 6, 2021 17:04 (UTC+02) by REx v5.53 which is Copyright (c) 1979-2021 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q strongLlStar.ebnf -tree -main -xquery -ll 1 :)

declare namespace p="strongLlStar";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 7;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 8;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  41, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 3, 4,
  0, 5, 6, 7, 8, 9, 10, 0, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 13, 14, 15, 16, 0, 0, 17, 17, 17, 17, 17, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0, 0, 18, 19, 20, 21, 22,
  23, 17, 24, 25, 17, 26, 27, 28, 29, 30, 31, 17, 32, 33, 34, 35, 36, 37, 17, 17, 17, 38, 39, 40, 0, 0
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  54, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
  58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 90, 136, 167, 198,
  104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
  104, 104, 104, 104, 104, 104, 104, 104, 104, 41, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 3, 4, 0, 5, 6, 7, 8, 9, 10, 0, 11,
  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 13, 14, 15, 16, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0, 18, 19, 20, 21, 22, 23, 17, 24, 25, 17, 26, 27, 28, 29,
  30, 31, 17, 32, 33, 34, 35, 36, 37, 17, 17, 17, 38, 39, 40, 0, 0
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1344, 1344, 1347, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1355, 1365, 1377, 1465, 1376, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2334, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1695, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2237, 1377, 1377,
  1377, 1386, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2353, 1377, 2351, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1395, 1395, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1988, 1377, 1986, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2003, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2020, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 2368, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1484, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2385,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2037, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 2293, 1377, 1958, 1639, 1377, 1377, 1809, 1960, 1377, 1808, 1960, 1464, 1958,
  1807, 2160, 1806, 2156, 2159, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1405, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2137, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1663, 1377, 2173, 1377, 1377, 1377, 1417, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 2198, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2159, 1377, 1958, 1567, 1377,
  1377, 1809, 1960, 1377, 1808, 1960, 1464, 1958, 1807, 2160, 1806, 2156, 2159, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1378, 1866, 1377, 1958, 1823, 1377, 1377, 2079, 1960, 1377, 1590, 1960,
  2099, 1958, 1807, 2160, 1429, 2156, 1440, 1452, 1377, 1796, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 2159, 2337, 1958, 1567, 1377, 1377, 1809, 1960, 1377, 1808, 1960, 1464, 1958, 1807, 2160, 1806, 2156,
  2159, 2041, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1699, 1377, 1462, 1377, 1958, 1567,
  1377, 1377, 2250, 1960, 1377, 1808, 1960, 2114, 1958, 2389, 2062, 1473, 2156, 2159, 1483, 1377, 1667, 2177, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1492, 1377, 1958, 1567, 1377, 1377, 1809, 1960, 1729, 1808,
  1507, 1464, 1505, 2215, 2160, 1806, 2156, 1515, 1377, 1840, 1377, 2232, 1377, 1537, 1377, 1377, 1377, 1377, 1377,
  1377, 1368, 1377, 1547, 1387, 1522, 1877, 1377, 1580, 1872, 1960, 1598, 2202, 1960, 1606, 1615, 1623, 1629, 1529,
  1651, 1675, 2089, 1539, 1377, 1707, 2320, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1357, 1715, 1726, 1377, 2219,
  1567, 1377, 1377, 1809, 1960, 1377, 1808, 1960, 1464, 1958, 1807, 2160, 1737, 2156, 2159, 1750, 1377, 1377, 1377,
  1690, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1497, 2159, 1377, 1759, 1854, 2371, 1377, 1809, 1960, 1585,
  1808, 1960, 1464, 1958, 1807, 2160, 1770, 1783, 2159, 1794, 2141, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1804, 1377, 1918, 1567, 1377, 2296, 1809, 1817, 1377, 1808, 1960, 1837, 1958, 1807, 2160,
  1806, 2156, 2159, 1607, 1377, 2317, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2159, 1377,
  1958, 1848, 1377, 1377, 1809, 1960, 1377, 1808, 1885, 1464, 1958, 1807, 2160, 1806, 2156, 2159, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1908, 1377, 1775, 1567, 1377, 1377, 1809, 1891,
  1377, 1808, 1643, 1464, 1958, 1807, 2053, 1806, 2156, 2159, 1377, 1377, 1377, 1377, 1926, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 2159, 1377, 1958, 1567, 1377, 1454, 1809, 1960, 1377, 1808, 1960, 1464, 1958, 2077,
  2160, 1806, 2156, 2159, 1377, 1936, 1377, 1946, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2159,
  1377, 1958, 1567, 1377, 1377, 1956, 1762, 1377, 1808, 1897, 1969, 1958, 1807, 1829, 1806, 2311, 2159, 1377, 1981,
  1718, 1377, 1998, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2241, 1786, 2015, 1958, 1567, 1421, 2007, 1432,
  1960, 1377, 1808, 1960, 2032, 1958, 1807, 2160, 1806, 2049, 2061, 2070, 1377, 1685, 1377, 1751, 2087, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 2097, 1377, 1958, 1567, 1377, 1377, 1809, 1960, 1377, 2124, 2107, 1464, 1958,
  1807, 2122, 1806, 2156, 2159, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  2132, 1557, 1634, 1572, 2354, 1377, 1562, 2149, 1658, 1808, 1960, 1464, 2279, 1807, 2160, 1806, 2265, 2159, 1975,
  1680, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1397, 2168, 1377, 1958, 1567, 1377, 2185,
  1809, 1960, 2024, 1915, 1900, 1464, 1958, 1938, 1860, 1806, 2156, 2159, 1377, 2193, 2210, 1928, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 2227, 1377, 1958, 1567, 1377, 1377, 1809, 1960, 1377, 2249, 1960, 1464,
  1958, 1807, 2160, 2258, 2156, 2273, 1377, 1377, 2287, 1377, 1444, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 2159, 1377, 1958, 2304, 1377, 1377, 1809, 1961, 1377, 1808, 1960, 1464, 1742, 1807, 2160, 1806, 2156, 2159,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2159, 1377, 1958, 1567, 1377,
  1377, 1809, 1960, 1377, 1475, 1960, 1464, 1958, 1807, 2160, 1806, 2156, 2159, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2328, 1990, 1958, 1567, 1377, 1377, 1809, 1960, 1377, 1808, 1960,
  1464, 1958, 1807, 2160, 1806, 2156, 2159, 1409, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 2345, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1552, 1377, 1377, 1377,
  1948, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 2362, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 2379, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377,
  1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1377, 1301, 1301, 1301, 1301, 1301,
  1301, 1301, 1301, 0, 0, 0, 0, 138, 0, 0, 0, 0, 0, 0, 24, 25, 0, 138, 139, 0, 0, 0, 0, 0, 23, 0, 0, 161, 0, 0, 0, 0, 0,
  0, 0, 0, 33, 4352, 0, 0, 0, 0, 0, 0, 0, 66, 0, 139, 0, 0, 0, 0, 0, 0, 32, 0, 6400, 0, 0, 6400, 0, 0, 0, 0, 171, 0, 0,
  0, 0, 6912, 7424, 7936, 0, 0, 0, 0, 8960, 0, 0, 0, 547, 0, 146, 0, 0, 0, 0, 547, 607, 547, 547, 0, 547, 547, 159, 0,
  0, 0, 0, 19712, 0, 19968, 0, 0, 166, 0, 0, 0, 0, 0, 0, 88, 0, 0, 548, 547, 0, 0, 0, 0, 0, 0, 0, 160, 657, 0, 0, 0, 0,
  0, 0, 547, 547, 628, 162, 0, 0, 0, 0, 0, 0, 0, 161, 0, 549, 547, 53, 0, 0, 0, 0, 29, 0, 0, 0, 34, 0, 8192, 547, 547,
  547, 547, 547, 547, 13091, 547, 0, 547, 547, 0, 0, 8448, 160, 0, 68, 547, 547, 547, 547, 583, 547, 0, 0, 0, 0, 12288,
  0, 661, 0, 19456, 0, 0, 0, 0, 0, 0, 182, 18432, 0, 547, 547, 23, 0, 0, 0, 0, 55, 0, 0, 0, 0, 62, 0, 0, 0, 0, 93, 547,
  547, 547, 547, 0, 547, 547, 547, 547, 0, 547, 547, 547, 592, 0, 9984, 84, 85, 0, 0, 0, 0, 108, 0, 0, 0, 0, 114, 0,
  627, 547, 547, 106, 0, 9472, 0, 0, 0, 110, 11520, 14115, 0, 0, 0, 0, 0, 0, 0, 175, 13312, 0, 547, 640, 547, 14883,
  9763, 642, 131, 0, 133, 0, 0, 135, 547, 547, 0, 10240, 0, 0, 0, 547, 547, 582, 547, 547, 547, 812, 547, 547, 547, 547,
  630, 547, 547, 547, 662, 0, 152, 0, 547, 547, 156, 0, 107, 0, 0, 0, 0, 0, 0, 7168, 0, 0, 0, 0, 187, 0, 0, 190, 0, 547,
  547, 0, 160, 0, 0, 0, 179, 0, 0, 0, 0, 186, 0, 0, 0, 0, 200, 0, 0, 0, 0, 4096, 0, 0, 0, 0, 22, 0, 0, 0, 191, 0, 193,
  0, 0, 195, 0, 19200, 26, 27, 28, 0, 0, 0, 0, 0, 188, 0, 0, 0, 547, 557, 0, 0, 0, 0, 0, 10752, 0, 0, 547, 0, 0, 148, 0,
  0, 0, 547, 547, 641, 547, 547, 547, 163, 0, 0, 0, 0, 0, 0, 0, 201, 67, 0, 547, 547, 547, 547, 547, 547, 615, 616, 547,
  547, 0, 147, 0, 0, 0, 0, 547, 581, 547, 547, 547, 547, 547, 151, 0, 0, 547, 547, 0, 0, 0, 0, 58, 164, 0, 0, 0, 0, 0,
  0, 0, 189, 0, 0, 550, 547, 0, 0, 0, 0, 0, 0, 547, 547, 547, 547, 610, 547, 547, 613, 547, 547, 547, 547, 587, 0, 589,
  590, 547, 547, 0, 0, 141, 0, 143, 547, 547, 0, 121, 0, 0, 0, 0, 0, 17920, 0, 0, 585, 547, 547, 0, 547, 547, 547, 547,
  588, 0, 547, 547, 547, 547, 140, 0, 0, 0, 0, 547, 547, 0, 0, 56, 0, 0, 92, 0, 606, 547, 547, 547, 0, 547, 547, 591,
  547, 629, 547, 547, 14627, 547, 547, 547, 547, 612, 547, 614, 547, 547, 547, 14371, 547, 547, 547, 547, 547, 631, 547,
  632, 0, 551, 547, 0, 0, 0, 57, 0, 112, 113, 0, 0, 547, 547, 547, 547, 547, 584, 0, 198, 0, 0, 0, 0, 0, 0, 196, 0, 176,
  0, 0, 0, 0, 0, 0, 0, 648, 649, 0, 192, 0, 0, 0, 0, 0, 0, 15360, 0, 90, 91, 0, 0, 547, 547, 547, 547, 547, 547, 547,
  547, 617, 547, 13824, 0, 0, 0, 124, 0, 0, 168, 0, 0, 172, 0, 0, 178, 0, 0, 0, 0, 0, 4864, 0, 0, 0, 0, 0, 0, 65, 0,
  197, 0, 199, 0, 0, 0, 0, 0, 5120, 0, 0, 0, 0, 86, 0, 0, 0, 59, 60, 61, 0, 63, 0, 0, 0, 5376, 0, 0, 0, 0, 109, 0, 0, 0,
  547, 0, 0, 122, 0, 0, 0, 0, 6144, 0, 0, 0, 0, 170, 0, 0, 0, 547, 0, 0, 153, 547, 547, 0, 0, 0, 142, 0, 547, 158, 547,
  547, 0, 0, 0, 0, 0, 656, 165, 0, 167, 169, 0, 0, 174, 0, 132, 0, 0, 0, 0, 547, 547, 608, 547, 202, 0, 0, 0, 0, 0, 0,
  0, 19117, 0, 0, 552, 547, 0, 0, 0, 0, 0, 125, 0, 547, 13603, 547, 547, 547, 547, 547, 547, 0, 0, 0, 123, 0, 0, 126,
  12835, 547, 0, 0, 0, 0, 0, 547, 9251, 547, 0, 547, 558, 0, 0, 0, 0, 0, 6706, 0, 0, 0, 0, 180, 0, 0, 0, 547, 611, 547,
  547, 547, 547, 547, 547, 0, 0, 0, 547, 547, 0, 0, 0, 0, 0, 547, 0, 553, 559, 0, 0, 0, 0, 0, 7219, 0, 0, 0, 0, 194, 0,
  0, 0, 83, 0, 0, 0, 0, 0, 0, 89, 0, 177, 0, 0, 181, 0, 0, 0, 7732, 0, 0, 0, 0, 11264, 547, 547, 547, 0, 184, 0, 0, 0,
  0, 0, 0, 11008, 0, 0, 547, 547, 547, 11811, 547, 547, 0, 554, 560, 54, 0, 0, 0, 0, 18688, 0, 0, 0, 0, 49, 0, 0, 0, 0,
  30, 31, 0, 0, 111, 0, 0, 0, 0, 547, 547, 547, 609, 547, 0, 0, 0, 10496, 0, 12544, 547, 0, 0, 0, 547, 547, 0, 157, 0,
  8739, 12067, 0, 0, 0, 0, 0, 639, 547, 547, 547, 547, 547, 183, 0, 0, 0, 0, 0, 0, 0, 812, 0, 0, 0, 0, 0, 87, 0, 0, 547,
  586, 547, 0, 547, 547, 547, 547, 0, 0, 0, 666, 667, 0, 0, 185, 0, 0, 0, 0, 0, 18176, 0, 0, 0, 555, 547, 0, 0, 0, 0, 0,
  3840, 0, 0, 0, 0, 0, 64, 0, 0, 0, 15104, 0, 0, 0, 0, 0, 0, 4608, 0, 0, 0, 0, 0, 0, 0, 82, 15616, 0, 0, 15616, 0, 0, 0,
  0, 5632, 0, 0, 0, 0, 0, 81, 0, 0, 1024, 0, 0, 1024, 0, 0, 0, 0, 5888, 5888, 0, 0, 0, 0, 134, 0, 547, 547
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  4, 36, 68, 95, 100, 104, 104, 105, 109, 113, 131, 131, 119, 135, 136, 204, 126, 131, 131, 131, 115, 135, 135, 204,
  131, 131, 114, 134, 135, 203, 130, 131, 201, 203, 131, 133, 140, 132, 122, 132, 122, 121, 120, 146, 149, 157, 152,
  161, 153, 170, 168, 153, 165, 165, 174, 142, 211, 220, 180, 184, 210, 219, 223, 254, 230, 190, 198, 176, 208, 212,
  221, 225, 230, 235, 194, 216, 220, 224, 229, 234, 193, 245, 222, 239, 243, 247, 251, 258, 262, 186, 262, 266, 265,
  264, 131, 131, 131, 131, 131, 131, 131088, 262160, 2097168, 134217744, 16, 16, 16, 16, -2147483632, 16777240, 18,
  4358134, 2145222680, 16, 0, 0, 0, -2147483648, 0, -2147483648, 0, 2, 2, 16352, 16352, 0, 65536, 67108864, 268435456,
  1073741824, 2, 0, 0, 0, 0, 2, 2, 2, 2, 4, 2, 16354, 0, 0, 1, 16, 16352, 0, 16352, 16352, 2048, 5920, 128, 64, 8192,
  2048, 1024, 8256, 2048, 5664, 256, 5120, 32, 256, 128, 4096, 64, 8192, 2048, 1024, 4096, 256, 64, 8192, 2048, 2048, 0,
  0, 4, 2097152, 524288, 2048, 268435456, 127033354, 4456480, 404750356, 0, 1, 256, 32768, 50331648, 0, 32, 262144, 0,
  4194304, 2097152, 1, 0, 4194304, 0, 0, -2147483648, 2, 2, 2, 16354, 2, 134217728, 1, 16, 64, 128, 256, 512, 1024, 16,
  128, 256, 512, 1024, 4096, 32768, 65536, 524288, 0, 2048, 2, 8, 8, 16384, 131072, 1048576, 8388608, 8388608, 16777216,
  33554432, 32, 262144, 2, 16384, 131072, 33554432, 32, 0, 1, 128, 256, 1024, 32768, 65536, 2, 16384, 131072, 0, 2, 8,
  8192, 1, 128, 256, 32768, 65536, 2, 16384, 0, 0, 1, 2, 16384
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "Identifier",
  "Number",
  "Eof",
  "Whitespace",
  "FOOD",
  "OBSTACLE",
  "HOME",
  "FRIEND",
  "FOE",
  "FOEHOME",
  "CARRIESFOOD",
  "FOESCENT",
  "OWNSCENT",
  "'!'",
  "'%'",
  "'&amp;&amp;'",
  "'('",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'/'",
  "';'",
  "'<'",
  "'<='",
  "'='",
  "'=='",
  "'>'",
  "'>='",
  "'ahead'",
  "'carriesfood'",
  "'clearscent'",
  "'do'",
  "'drop'",
  "'else'",
  "'false'",
  "'foe'",
  "'foehome'",
  "'foescent'",
  "'food'",
  "'friend'",
  "'here'",
  "'home'",
  "'if'",
  "'leavescent'",
  "'obstacle'",
  "'ownscent'",
  "'pickup'",
  "'rand'",
  "'sense'",
  "'skip'",
  "'then'",
  "'true'",
  "'turn'",
  "'walk'",
  "'while'",
  "'{'",
  "'||'",
  "'}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 256,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 256
    let $end := if ($result idiv 64 ne 0) then $begin else $end
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 64 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 32
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 32 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        0
    let $current := $current + 1
    let $i0 := 256 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 8
    let $next-state := $p:TRANSITION[$i0 mod 8 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 255) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 256, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 1
    let $i0 := $t * 202 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 32
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 32 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Parse op1.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-op1($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(59, $input, $state)               (: '||' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "op1", $count, $begin, $end)
};

(:~
 : Parse op2.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-op2($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(16, $input, $state)               (: '&&' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "op2", $count, $begin, $end)
};

(:~
 : Parse op3.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-op3($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '==' :)
      let $state := p:consume(28, $input, $state)           (: '==' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '<=' :)
      let $state := p:consume(26, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '<' :)
      let $state := p:consume(25, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '=' :)
      let $state := p:consume(27, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '>=' :)
      let $state := p:consume(30, $input, $state)           (: '>=' :)
      return $state
    else
      let $state := p:consume(29, $input, $state)           (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "op3", $count, $begin, $end)
};

(:~
 : Parse op4.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-op4($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 20) then                       (: '+' :)
      let $state := p:consume(20, $input, $state)           (: '+' :)
      return $state
    else
      let $state := p:consume(22, $input, $state)           (: '-' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "op4", $count, $begin, $end)
};

(:~
 : Parse op5.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-op5($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: '*' :)
      let $state := p:consume(19, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '/' :)
      let $state := p:consume(23, $input, $state)           (: '/' :)
      return $state
    else
      let $state := p:consume(15, $input, $state)           (: '%' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "op5", $count, $begin, $end)
};

(:~
 : Parse Where.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Where($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: 'here' :)
      let $state := p:consume(43, $input, $state)           (: 'here' :)
      return $state
    else
      let $state := p:consume(31, $input, $state)           (: 'ahead' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Where", $count, $begin, $end)
};

(:~
 : Parse IExpAtom.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExpAtom($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: Identifier :)
      let $state := p:consume(1, $input, $state)            (: Identifier :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: Number :)
      let $state := p:consume(2, $input, $state)            (: Number :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'true' :)
      let $state := p:consume(54, $input, $state)           (: 'true' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'false' :)
      let $state := p:consume(37, $input, $state)           (: 'false' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: 'rand' :)
      let $state := p:consume(50, $input, $state)           (: 'rand' :)
      return $state
    else if ($state[$p:l1] = 5) then                        (: FOOD :)
      let $state := p:consume(5, $input, $state)            (: FOOD :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(9, $input, $state)        (: Whitespace^Token | 'food' :)
      let $state := p:consume(41, $input, $state)           (: 'food' :)
      let $state := p:lookahead1W(1, $input, $state)        (: Whitespace^Token | ')' :)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: OBSTACLE :)
      let $state := p:consume(6, $input, $state)            (: OBSTACLE :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(12, $input, $state)       (: Whitespace^Token | 'obstacle' :)
      let $state := p:consume(47, $input, $state)           (: 'obstacle' :)
      let $state := p:lookahead1W(1, $input, $state)        (: Whitespace^Token | ')' :)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: HOME :)
      let $state := p:consume(7, $input, $state)            (: HOME :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(11, $input, $state)       (: Whitespace^Token | 'home' :)
      let $state := p:consume(44, $input, $state)           (: 'home' :)
      let $state := p:lookahead1W(1, $input, $state)        (: Whitespace^Token | ')' :)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 8) then                        (: FRIEND :)
      let $state := p:consume(8, $input, $state)            (: FRIEND :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(10, $input, $state)       (: Whitespace^Token | 'friend' :)
      let $state := p:consume(42, $input, $state)           (: 'friend' :)
      let $state := p:lookahead1W(1, $input, $state)        (: Whitespace^Token | ')' :)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 9) then                        (: FOE :)
      let $state := p:consume(9, $input, $state)            (: FOE :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(6, $input, $state)        (: Whitespace^Token | 'foe' :)
      let $state := p:consume(38, $input, $state)           (: 'foe' :)
      let $state := p:lookahead1W(1, $input, $state)        (: Whitespace^Token | ')' :)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: FOEHOME :)
      let $state := p:consume(10, $input, $state)           (: FOEHOME :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(7, $input, $state)        (: Whitespace^Token | 'foehome' :)
      let $state := p:consume(39, $input, $state)           (: 'foehome' :)
      let $state := p:lookahead1W(1, $input, $state)        (: Whitespace^Token | ')' :)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: CARRIESFOOD :)
      let $state := p:consume(11, $input, $state)           (: CARRIESFOOD :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(4, $input, $state)        (: Whitespace^Token | 'carriesfood' :)
      let $state := p:consume(32, $input, $state)           (: 'carriesfood' :)
      let $state := p:lookahead1W(1, $input, $state)        (: Whitespace^Token | ')' :)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 12) then                       (: FOESCENT :)
      let $state := p:consume(12, $input, $state)           (: FOESCENT :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(8, $input, $state)        (: Whitespace^Token | 'foescent' :)
      let $state := p:consume(40, $input, $state)           (: 'foescent' :)
      let $state := p:lookahead1W(1, $input, $state)        (: Whitespace^Token | ')' :)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else
      let $state := p:consume(13, $input, $state)           (: OWNSCENT :)
      let $state := p:lookahead1W(14, $input, $state)       (: Whitespace^Token | 'sense' :)
      let $state := p:consume(51, $input, $state)           (: 'sense' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: Whitespace^Token | 'ahead' | 'here' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Where($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(13, $input, $state)       (: Whitespace^Token | 'ownscent' :)
      let $state := p:consume(48, $input, $state)           (: 'ownscent' :)
      let $state := p:lookahead1W(2, $input, $state)        (: Whitespace^Token | ',' :)
      let $state := p:consume(21, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp($input, $state)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IExpAtom", $count, $begin, $end)
};

(:~
 : Parse IExp6.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp6($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22) then                       (: '-' :)
      let $state := p:consume(22, $input, $state)           (: '-' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp6($input, $state)
      return $state
    else if ($state[$p:l1] = 14) then                       (: '!' :)
      let $state := p:consume(14, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp6($input, $state)
      return $state
    else if ($state[$p:l1] = 17) then                       (: '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp1($input, $state)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExpAtom($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IExp6", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IExp5 (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp5-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(19, $input, $state)         (: Eof | Whitespace^Token | '%' | '&&' | ')' | '*' | '+' |
                                                               '-' | '/' | ';' | '<' | '<=' | '=' | '==' | '>' | '>=' |
                                                               'do' | 'else' | 'then' | '||' | '}' :)
    return
      if ($state[$p:l1] != 15                               (: '%' :)
      and $state[$p:l1] != 19                               (: '*' :)
      and $state[$p:l1] != 23) then                         (: '/' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-op5($input, $state)
        let $state := p:lookahead1W(18, $input, $state)     (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-IExp6($input, $state)
        return p:parse-IExp5-1($input, $state)
};

(:~
 : Parse IExp5.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp5($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IExp6($input, $state)
  let $state := p:parse-IExp5-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IExp5", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IExp4 (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp4-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 20                                 (: '+' :)
    and $state[$p:l1] != 22) then                           (: '-' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-op4($input, $state)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp5($input, $state)
      return p:parse-IExp4-1($input, $state)
};

(:~
 : Parse IExp4.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp4($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IExp5($input, $state)
  let $state := p:parse-IExp4-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IExp4", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IExp3 (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp3-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25                                 (: '<' :)
    and $state[$p:l1] != 26                                 (: '<=' :)
    and $state[$p:l1] != 27                                 (: '=' :)
    and $state[$p:l1] != 28                                 (: '==' :)
    and $state[$p:l1] != 29                                 (: '>' :)
    and $state[$p:l1] != 30) then                           (: '>=' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-op3($input, $state)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp4($input, $state)
      return p:parse-IExp3-1($input, $state)
};

(:~
 : Parse IExp3.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp3($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IExp4($input, $state)
  let $state := p:parse-IExp3-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IExp3", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IExp2 (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp2-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 16) then                           (: '&&' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-op2($input, $state)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp3($input, $state)
      return p:parse-IExp2-1($input, $state)
};

(:~
 : Parse IExp2.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp2($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IExp3($input, $state)
  let $state := p:parse-IExp2-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IExp2", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IExp1 (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp1-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 59) then                           (: '||' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-op1($input, $state)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp2($input, $state)
      return p:parse-IExp1-1($input, $state)
};

(:~
 : Parse IExp1.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp1($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IExp2($input, $state)
  let $state := p:parse-IExp1-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IExp1", $count, $begin, $end)
};

(:~
 : Parse IExp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IExp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IExp1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IExp", $count, $begin, $end)
};

(:~
 : Parse PrgAtom.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrgAtom($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: 'skip' :)
      let $state := p:consume(52, $input, $state)           (: 'skip' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'walk' :)
      let $state := p:consume(56, $input, $state)           (: 'walk' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'turn' :)
      let $state := p:consume(55, $input, $state)           (: 'turn' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp($input, $state)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: 'pickup' :)
      let $state := p:consume(49, $input, $state)           (: 'pickup' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: 'drop' :)
      let $state := p:consume(35, $input, $state)           (: 'drop' :)
      return $state
    else if ($state[$p:l1] = 46) then                       (: 'leavescent' :)
      let $state := p:consume(46, $input, $state)           (: 'leavescent' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp($input, $state)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: 'clearscent' :)
      let $state := p:consume(33, $input, $state)           (: 'clearscent' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Whitespace^Token | '(' :)
      let $state := p:consume(17, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp($input, $state)
      let $state := p:consume(18, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 1) then                        (: Identifier :)
      let $state := p:consume(1, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(3, $input, $state)        (: Whitespace^Token | '=' :)
      let $state := p:consume(27, $input, $state)           (: '=' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp($input, $state)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '{' :)
      let $state := p:consume(58, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(17, $input, $state)       (: Identifier | Whitespace^Token | 'clearscent' | 'drop' |
                                                               'if' | 'leavescent' | 'pickup' | 'skip' | 'turn' |
                                                               'walk' | 'while' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrgSeq($input, $state)
      let $state := p:consume(60, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:l1] = 45) then                       (: 'if' :)
      let $state := p:consume(45, $input, $state)           (: 'if' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp($input, $state)
      let $state := p:consume(53, $input, $state)           (: 'then' :)
      let $state := p:lookahead1W(17, $input, $state)       (: Identifier | Whitespace^Token | 'clearscent' | 'drop' |
                                                               'if' | 'leavescent' | 'pickup' | 'skip' | 'turn' |
                                                               'walk' | 'while' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrgAtom($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: Whitespace^Token | 'else' :)
      let $state := p:consume(36, $input, $state)           (: 'else' :)
      let $state := p:lookahead1W(17, $input, $state)       (: Identifier | Whitespace^Token | 'clearscent' | 'drop' |
                                                               'if' | 'leavescent' | 'pickup' | 'skip' | 'turn' |
                                                               'walk' | 'while' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrgAtom($input, $state)
      return $state
    else
      let $state := p:consume(57, $input, $state)           (: 'while' :)
      let $state := p:lookahead1W(18, $input, $state)       (: Identifier | Number | Whitespace^Token | FOOD |
                                                               OBSTACLE | HOME | FRIEND | FOE | FOEHOME | CARRIESFOOD |
                                                               FOESCENT | OWNSCENT | '!' | '(' | '-' | 'false' |
                                                               'rand' | 'true' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IExp($input, $state)
      let $state := p:consume(34, $input, $state)           (: 'do' :)
      let $state := p:lookahead1W(17, $input, $state)       (: Identifier | Whitespace^Token | 'clearscent' | 'drop' |
                                                               'if' | 'leavescent' | 'pickup' | 'skip' | 'turn' |
                                                               'walk' | 'while' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrgAtom($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrgAtom", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PrgSeq (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrgSeq-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(16, $input, $state)         (: Eof | Whitespace^Token | ';' | '}' :)
    return
      if ($state[$p:l1] != 24) then                         (: ';' :)
        $state
      else
        let $state := p:consume(24, $input, $state)         (: ';' :)
        let $state := p:lookahead1W(17, $input, $state)     (: Identifier | Whitespace^Token | 'clearscent' | 'drop' |
                                                               'if' | 'leavescent' | 'pickup' | 'skip' | 'turn' |
                                                               'walk' | 'while' | '{' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-PrgAtom($input, $state)
        return p:parse-PrgSeq-1($input, $state)
};

(:~
 : Parse PrgSeq.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrgSeq($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrgAtom($input, $state)
  let $state := p:parse-PrgSeq-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PrgSeq", $count, $begin, $end)
};

(:~
 : Parse Prg.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prg($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(17, $input, $state)           (: Identifier | Whitespace^Token | 'clearscent' | 'drop' |
                                                               'if' | 'leavescent' | 'pickup' | 'skip' | 'turn' |
                                                               'walk' | 'while' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrgSeq($input, $state)
  let $state := p:consume(3, $input, $state)                (: Eof :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prg", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 3),
    0, 0, 0,
    subsequence($state, 7),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 4) then                                 (: Whitespace^Token :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
        p:matchW($input, $state[$p:e0], $set)
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 7)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse start symbol Prg from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Prg($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, false())
  let $state := p:parse-Prg($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : The input filename, or string, if surrounded by curly braces.
 :)
declare variable $input as xs:string external;

let $result :=
  if (matches($input, "^\{.*\}$")) then
    p:parse-Prg(substring($input, 2, string-length($input) - 2))
  else
    p:parse-Prg(unparsed-text($input, "utf-8"))
return
  if (empty($result/self::ERROR)) then
    $result
  else
    error(xs:QName("p:parse-Prg"), concat("&#10;    ", replace($result, "&#10;", "&#10;    ")))

(: End :)
