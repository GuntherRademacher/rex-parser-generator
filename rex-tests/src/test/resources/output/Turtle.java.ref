// This file was generated on Thu Dec 26, 2024 06:58 (UTC+01) by REx v6.1-SNAPSHOT which is Copyright (c) 1979-2024 by Gunther Rademacher <grd@gmx.net>
// REx command line: -q turtle.ebnf -java -tree -main -saxon -name Turtle

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import net.sf.saxon.Configuration;
import net.sf.saxon.event.Builder;
import net.sf.saxon.expr.XPathContext;
import net.sf.saxon.lib.ExtensionFunctionCall;
import net.sf.saxon.lib.ExtensionFunctionDefinition;
import net.sf.saxon.lib.Initializer;
import net.sf.saxon.om.AttributeInfo;
import net.sf.saxon.om.NoNamespaceName;
import net.sf.saxon.om.Sequence;
import net.sf.saxon.om.SmallAttributeMap;
import net.sf.saxon.om.StructuredQName;
import net.sf.saxon.trans.XPathException;
import net.sf.saxon.type.AnySimpleType;
import net.sf.saxon.type.AnyType;
import net.sf.saxon.value.SequenceType;
import net.sf.saxon.expr.parser.Loc;
import net.sf.saxon.om.AttributeMap;
import net.sf.saxon.om.EmptyAttributeMap;
import net.sf.saxon.om.NamespaceMap;
import net.sf.saxon.s9api.Location;
import net.sf.saxon.str.StringView;

public class Turtle
{
  public static void main(String args[]) throws Exception
  {
    if (args.length == 0)
    {
      System.out.println("Usage: java Turtle [-i] INPUT...");
      System.out.println();
      System.out.println("  parse INPUT, which is either a filename or literal text enclosed in curly braces");
      System.out.println();
      System.out.println("  Option:");
      System.out.println("    -i     indented parse tree");
    }
    else
    {
      boolean indent = false;
      for (String arg : args)
      {
        if (arg.equals("-i"))
        {
          indent = true;
          continue;
        }
        Writer w = new OutputStreamWriter(System.out, "UTF-8");
        XmlSerializer s = new XmlSerializer(w, indent);
        String input = read(arg);
        Turtle parser = new Turtle(input, s);
        try
        {
          parser.parse_turtleDoc();
        }
        catch (ParseException pe)
        {
          throw new RuntimeException("ParseException while processing " + arg + ":\n" + parser.getErrorMessage(pe));
        }
        finally
        {
          w.close();
        }
      }
    }
  }

  public static class ParseException extends RuntimeException
  {
    private static final long serialVersionUID = 1L;
    private int begin, end, offending, expected, state;

    public ParseException(int b, int e, int s, int o, int x)
    {
      begin = b;
      end = e;
      state = s;
      offending = o;
      expected = x;
    }

    @Override
    public String getMessage()
    {
      return offending < 0
           ? "lexical analysis failed"
           : "syntax error";
    }

    public void serialize(EventHandler eventHandler)
    {
    }

    public int getBegin() {return begin;}
    public int getEnd() {return end;}
    public int getState() {return state;}
    public int getOffending() {return offending;}
    public int getExpected() {return expected;}
    public boolean isAmbiguousInput() {return false;}
  }

  public interface EventHandler
  {
    public void reset(CharSequence string);
    public void startNonterminal(String name, int begin);
    public void endNonterminal(String name, int end);
    public void terminal(String name, int begin, int end);
    public void whitespace(int begin, int end);
  }

  public static class TopDownTreeBuilder implements EventHandler
  {
    private CharSequence input = null;
    private Nonterminal[] stack = new Nonterminal[64];
    private int top = -1;

    @Override
    public void reset(CharSequence input)
    {
      this.input = input;
      top = -1;
    }

    @Override
    public void startNonterminal(String name, int begin)
    {
      Nonterminal nonterminal = new Nonterminal(name, begin, begin, new Symbol[0]);
      if (top >= 0) addChild(nonterminal);
      if (++top >= stack.length) stack = Arrays.copyOf(stack, stack.length << 1);
      stack[top] = nonterminal;
    }

    @Override
    public void endNonterminal(String name, int end)
    {
      stack[top].end = end;
      if (top > 0) --top;
    }

    @Override
    public void terminal(String name, int begin, int end)
    {
      addChild(new Terminal(name, begin, end));
    }

    @Override
    public void whitespace(int begin, int end)
    {
    }

    private void addChild(Symbol s)
    {
      Nonterminal current = stack[top];
      current.children = Arrays.copyOf(current.children, current.children.length + 1);
      current.children[current.children.length - 1] = s;
    }

    public void serialize(EventHandler e)
    {
      e.reset(input);
      stack[0].send(e);
    }
  }

  public static abstract class Symbol
  {
    public String name;
    public int begin;
    public int end;

    protected Symbol(String name, int begin, int end)
    {
      this.name = name;
      this.begin = begin;
      this.end = end;
    }

    public abstract void send(EventHandler e);
  }

  public static class Terminal extends Symbol
  {
    public Terminal(String name, int begin, int end)
    {
      super(name, begin, end);
    }

    @Override
    public void send(EventHandler e)
    {
      e.terminal(name, begin, end);
    }
  }

  public static class Nonterminal extends Symbol
  {
    public Symbol[] children;

    public Nonterminal(String name, int begin, int end, Symbol[] children)
    {
      super(name, begin, end);
      this.children = children;
    }

    @Override
    public void send(EventHandler e)
    {
      e.startNonterminal(name, begin);
      int pos = begin;
      for (Symbol c : children)
      {
        if (pos < c.begin) e.whitespace(pos, c.begin);
        c.send(e);
        pos = c.end;
      }
      if (pos < end) e.whitespace(pos, end);
      e.endNonterminal(name, end);
    }
  }

  public static class XmlSerializer implements EventHandler
  {
    private CharSequence input;
    private String delayedTag;
    private Writer out;
    private boolean indent;
    private boolean hasChildElement;
    private int depth;

    public XmlSerializer(Writer w, boolean indent)
    {
      input = null;
      delayedTag = null;
      out = w;
      this.indent = indent;
    }

    @Override
    public void reset(CharSequence string)
    {
      writeOutput("<?xml version=\"1.0\" encoding=\"UTF-8\"?" + ">");
      input = string;
      delayedTag = null;
      hasChildElement = false;
      depth = 0;
    }

    @Override
    public void startNonterminal(String name, int begin)
    {
      if (delayedTag != null)
      {
        writeOutput("<");
        writeOutput(delayedTag);
        writeOutput(">");
      }
      delayedTag = name;
      if (indent)
      {
        writeOutput("\n");
        for (int i = 0; i < depth; ++i)
        {
          writeOutput("  ");
        }
      }
      hasChildElement = false;
      ++depth;
    }

    @Override
    public void endNonterminal(String name, int end)
    {
      --depth;
      if (delayedTag != null)
      {
        delayedTag = null;
        writeOutput("<");
        writeOutput(name);
        writeOutput("/>");
      }
      else
      {
        if (indent)
        {
          if (hasChildElement)
          {
            writeOutput("\n");
            for (int i = 0; i < depth; ++i)
            {
              writeOutput("  ");
            }
          }
        }
        writeOutput("</");
        writeOutput(name);
        writeOutput(">");
      }
      hasChildElement = true;
    }

    @Override
    public void terminal(String name, int begin, int end)
    {
      if (name.charAt(0) == '\'')
      {
        name = "TOKEN";
      }
      startNonterminal(name, begin);
      characters(begin, end);
      endNonterminal(name, end);
    }

    @Override
    public void whitespace(int begin, int end)
    {
      characters(begin, end);
    }

    private void characters(int begin, int end)
    {
      if (begin < end)
      {
        if (delayedTag != null)
        {
          writeOutput("<");
          writeOutput(delayedTag);
          writeOutput(">");
          delayedTag = null;
        }
        writeOutput(input.subSequence(begin, end)
                         .toString()
                         .replace("&", "&amp;")
                         .replace("<", "&lt;")
                         .replace(">", "&gt;"));
      }
    }

    public void writeOutput(String content)
    {
      try
      {
        out.write(content);
      }
      catch (IOException e)
      {
        throw new RuntimeException(e);
      }
    }
  }

  public static class SaxonTreeBuilder implements EventHandler
  {
    private CharSequence input;
    private Builder builder;
    private AnyType anyType;

    public SaxonTreeBuilder(Builder b)
    {
      input = null;
      builder = b;
      anyType = AnyType.getInstance();
    }

    @Override
    public void reset(CharSequence string)
    {
      input = string;
    }

    @Override
    public void startNonterminal(String name, int begin)
    {
      try
      {
        builder.startElement(new NoNamespaceName(name), anyType, NO_ATTRIBUTES, NO_NAMESPACES, LOCATION, 0);
      }
      catch (XPathException e)
      {
        throw new RuntimeException(e);
      }
    }

    @Override
    public void endNonterminal(String name, int end)
    {
      try
      {
        builder.endElement();
      }
      catch (XPathException e)
      {
        throw new RuntimeException(e);
      }
    }

    @Override
    public void terminal(String name, int begin, int end)
    {
      if (name.charAt(0) == '\'')
      {
        name = "TOKEN";
      }
      startNonterminal(name, begin);
      characters(begin, end);
      endNonterminal(name, end);
    }

    @Override
    public void whitespace(int begin, int end)
    {
      characters(begin, end);
    }

    private void characters(int begin, int end)
    {
      if (begin < end)
      {
        try
        {
          builder.characters(StringView.of(input.subSequence(begin, end).toString()), LOCATION, 0);
        }
        catch (XPathException e)
        {
          throw new RuntimeException(e);
        }
      }
    }
  }

  private static final AttributeMap NO_ATTRIBUTES = EmptyAttributeMap.getInstance();
  private static final NamespaceMap NO_NAMESPACES = NamespaceMap.emptyMap();
  private static final Location LOCATION = Loc.NONE;

  public static class SaxonInitializer implements Initializer
  {
    @Override
    public void initialize(Configuration conf)
    {
      conf.registerExtensionFunction(new SaxonDefinition_turtleDoc());
    }
  }

  public static Sequence parseTurtleDoc(XPathContext context, String input) throws XPathException
  {
    Builder builder = context.getController().makeBuilder();
    builder.open();
    Turtle parser = new Turtle(input, new SaxonTreeBuilder(builder));
    try
    {
      parser.parse_turtleDoc();
    }
    catch (ParseException pe)
    {
      buildError(parser, pe, builder);
    }
    return builder.getCurrentRoot();
  }

  public static class SaxonDefinition_turtleDoc extends SaxonDefinition
  {
    @Override
    public String functionName() {return "parse-turtleDoc";}
    @Override
    public Sequence execute(XPathContext context, String input) throws XPathException
    {
      return parseTurtleDoc(context, input);
    }
  }

  public static abstract class SaxonDefinition extends ExtensionFunctionDefinition
  {
    abstract String functionName();
    abstract Sequence execute(XPathContext context, String input) throws XPathException;

    @Override
    public StructuredQName getFunctionQName() {return new StructuredQName("p", "Turtle", functionName());}
    @Override
    public SequenceType[] getArgumentTypes() {return new SequenceType[] {SequenceType.SINGLE_STRING};}
    @Override
    public SequenceType getResultType(SequenceType[] suppliedArgumentTypes) {return SequenceType.SINGLE_NODE;}

    @Override
    public ExtensionFunctionCall makeCallExpression()
    {
      return new ExtensionFunctionCall()
      {
        @Override
        public Sequence call(XPathContext context, Sequence[] arguments) throws XPathException
        {
          return execute(context, arguments[0].iterate().next().getStringValue());
        }
      };
    }
  }

  private static void buildError(Turtle parser, ParseException pe, Builder builder) throws XPathException
  {
    builder.close();
    builder.reset();
    builder.open();
    List<AttributeInfo> attributes = new ArrayList<>();
    AnySimpleType anySimpleType = AnySimpleType.getInstance();
    attributes.add(new AttributeInfo(new NoNamespaceName("b"), anySimpleType, Integer.toString(pe.getBegin() + 1), LOCATION, 0));
    attributes.add(new AttributeInfo(new NoNamespaceName("e"), anySimpleType, Integer.toString(pe.getEnd() + 1), LOCATION, 0));
    if (pe.getOffending() < 0)
    {
      attributes.add(new AttributeInfo(new NoNamespaceName("s"), anySimpleType, Integer.toString(pe.getState()), LOCATION, 0));
    }
    else
    {
      attributes.add(new AttributeInfo(new NoNamespaceName("o"), anySimpleType, Integer.toString(pe.getOffending()), LOCATION, 0));
      attributes.add(new AttributeInfo(new NoNamespaceName("x"), anySimpleType, Integer.toString(pe.getExpected()), LOCATION, 0));
    }
    builder.startElement(new NoNamespaceName("ERROR"), AnyType.getInstance(), new SmallAttributeMap(attributes), NO_NAMESPACES, LOCATION, 0);
    builder.characters(StringView.of(parser.getErrorMessage(pe)), LOCATION, 0);
    builder.endElement();
  }

  private static String read(String input) throws Exception
  {
    if (input.startsWith("{") && input.endsWith("}"))
    {
      return input.substring(1, input.length() - 1);
    }
    else
    {
      byte buffer[] = new byte[(int) new java.io.File(input).length()];
      java.io.FileInputStream stream = new java.io.FileInputStream(input);
      stream.read(buffer);
      stream.close();
      String content = new String(buffer, System.getProperty("file.encoding"));
      return content.length() > 0 && content.charAt(0) == '\uFEFF'
           ? content.substring(1)
           : content;
    }
  }

  public Turtle(CharSequence string, EventHandler t)
  {
    initialize(string, t);
  }

  public void initialize(CharSequence source, EventHandler parsingEventHandler)
  {
    eventHandler = parsingEventHandler;
    input = source;
    size = source.length();
    reset(0, 0, 0);
  }

  public CharSequence getInput()
  {
    return input;
  }

  public int getTokenOffset()
  {
    return b0;
  }

  public int getTokenEnd()
  {
    return e0;
  }

  public final void reset(int l, int b, int e)
  {
            b0 = b; e0 = b;
    l1 = l; b1 = b; e1 = e;
    end = e;
    eventHandler.reset(input);
  }

  public void reset()
  {
    reset(0, 0, 0);
  }

  public static String getOffendingToken(ParseException e)
  {
    return e.getOffending() < 0 ? null : TOKEN[e.getOffending()];
  }

  public static String[] getExpectedTokenSet(ParseException e)
  {
    String[] expected;
    if (e.getExpected() >= 0)
    {
      expected = new String[]{TOKEN[e.getExpected()]};
    }
    else
    {
      expected = getTokenSet(- e.getState());
    }
    return expected;
  }

  public String getErrorMessage(ParseException e)
  {
    String message = e.getMessage();
    String[] tokenSet = getExpectedTokenSet(e);
    String found = getOffendingToken(e);
    int size = e.getEnd() - e.getBegin();
    message += (found == null ? "" : ", found " + found)
            + "\nwhile expecting "
            + (tokenSet.length == 1 ? tokenSet[0] : java.util.Arrays.toString(tokenSet))
            + "\n"
            + (size == 0 || found != null ? "" : "after successfully scanning " + size + " characters beginning ");
    String prefix = input.subSequence(0, e.getBegin()).toString();
    int line = prefix.replaceAll("[^\n]", "").length() + 1;
    int column = prefix.length() - prefix.lastIndexOf('\n');
    return message
         + "at line " + line + ", column " + column + ":\n..."
         + input.subSequence(e.getBegin(), Math.min(input.length(), e.getBegin() + 64))
         + "...";
  }

  public void parse_turtleDoc()
  {
    eventHandler.startNonterminal("turtleDoc", e0);
    for (;;)
    {
      lookahead1W(8);               // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | ANON | EOF | '(' |
                                    // '@base' | '@prefix' | 'BASE' | 'PREFIX' | '['
      if (l1 == 15)                 // EOF
      {
        break;
      }
      whitespace();
      parse_statement();
    }
    consume(15);                    // EOF
    eventHandler.endNonterminal("turtleDoc", e0);
  }

  private void parse_statement()
  {
    eventHandler.startNonterminal("statement", e0);
    switch (l1)
    {
    case 21:                        // '@base'
    case 22:                        // '@prefix'
    case 23:                        // 'BASE'
    case 24:                        // 'PREFIX'
      parse_directive();
      break;
    default:
      parse_triples();
      consume(19);                  // '.'
    }
    eventHandler.endNonterminal("statement", e0);
  }

  private void parse_directive()
  {
    eventHandler.startNonterminal("directive", e0);
    switch (l1)
    {
    case 22:                        // '@prefix'
      parse_prefixID();
      break;
    case 21:                        // '@base'
      parse_base();
      break;
    case 24:                        // 'PREFIX'
      parse_sparqlPrefix();
      break;
    default:
      parse_sparqlBase();
    }
    eventHandler.endNonterminal("directive", e0);
  }

  private void parse_prefixID()
  {
    eventHandler.startNonterminal("prefixID", e0);
    consume(22);                    // '@prefix'
    lookahead1W(1);                 // WhiteSpace | PNAME_NS
    consume(3);                     // PNAME_NS
    lookahead1W(0);                 // WhiteSpace | IRIREF
    consume(2);                     // IRIREF
    lookahead1W(2);                 // WhiteSpace | '.'
    consume(19);                    // '.'
    eventHandler.endNonterminal("prefixID", e0);
  }

  private void parse_base()
  {
    eventHandler.startNonterminal("base", e0);
    consume(21);                    // '@base'
    lookahead1W(0);                 // WhiteSpace | IRIREF
    consume(2);                     // IRIREF
    lookahead1W(2);                 // WhiteSpace | '.'
    consume(19);                    // '.'
    eventHandler.endNonterminal("base", e0);
  }

  private void parse_sparqlBase()
  {
    eventHandler.startNonterminal("sparqlBase", e0);
    consume(23);                    // 'BASE'
    lookahead1W(0);                 // WhiteSpace | IRIREF
    consume(2);                     // IRIREF
    eventHandler.endNonterminal("sparqlBase", e0);
  }

  private void parse_sparqlPrefix()
  {
    eventHandler.startNonterminal("sparqlPrefix", e0);
    consume(24);                    // 'PREFIX'
    lookahead1W(1);                 // WhiteSpace | PNAME_NS
    consume(3);                     // PNAME_NS
    lookahead1W(0);                 // WhiteSpace | IRIREF
    consume(2);                     // IRIREF
    eventHandler.endNonterminal("sparqlPrefix", e0);
  }

  private void parse_triples()
  {
    eventHandler.startNonterminal("triples", e0);
    switch (l1)
    {
    case 25:                        // '['
      parse_blankNodePropertyList();
      lookahead1W(6);               // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | '.' | 'a'
      if (l1 != 19)                 // '.'
      {
        whitespace();
        parse_predicateObjectList();
      }
      break;
    default:
      parse_subject();
      lookahead1W(4);               // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | 'a'
      whitespace();
      parse_predicateObjectList();
    }
    eventHandler.endNonterminal("triples", e0);
  }

  private void parse_predicateObjectList()
  {
    eventHandler.startNonterminal("predicateObjectList", e0);
    parse_verb();
    lookahead1W(9);                 // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | INTEGER |
                                    // DECIMAL | DOUBLE | STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE |
                                    // STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE | ANON | '(' | '[' |
                                    // 'false' | 'true'
    whitespace();
    parse_objectList();
    for (;;)
    {
      if (l1 != 20)                 // ';'
      {
        break;
      }
      consume(20);                  // ';'
      lookahead1W(7);               // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | '.' | ';' | ']' | 'a'
      if (l1 != 19                  // '.'
       && l1 != 20                  // ';'
       && l1 != 26)                 // ']'
      {
        whitespace();
        parse_verb();
        lookahead1W(9);             // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | INTEGER |
                                    // DECIMAL | DOUBLE | STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE |
                                    // STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE | ANON | '(' | '[' |
                                    // 'false' | 'true'
        whitespace();
        parse_objectList();
      }
    }
    eventHandler.endNonterminal("predicateObjectList", e0);
  }

  private void parse_objectList()
  {
    eventHandler.startNonterminal("objectList", e0);
    parse_object();
    for (;;)
    {
      lookahead1W(5);               // WhiteSpace | ',' | '.' | ';' | ']'
      if (l1 != 18)                 // ','
      {
        break;
      }
      consume(18);                  // ','
      lookahead1W(9);               // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | INTEGER |
                                    // DECIMAL | DOUBLE | STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE |
                                    // STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE | ANON | '(' | '[' |
                                    // 'false' | 'true'
      whitespace();
      parse_object();
    }
    eventHandler.endNonterminal("objectList", e0);
  }

  private void parse_verb()
  {
    eventHandler.startNonterminal("verb", e0);
    switch (l1)
    {
    case 28:                        // 'a'
      consume(28);                  // 'a'
      break;
    default:
      parse_predicate();
    }
    eventHandler.endNonterminal("verb", e0);
  }

  private void parse_subject()
  {
    eventHandler.startNonterminal("subject", e0);
    switch (l1)
    {
    case 5:                         // BLANK_NODE_LABEL
    case 14:                        // ANON
      parse_BlankNode();
      break;
    case 16:                        // '('
      parse_collection();
      break;
    default:
      parse_iri();
    }
    eventHandler.endNonterminal("subject", e0);
  }

  private void parse_predicate()
  {
    eventHandler.startNonterminal("predicate", e0);
    parse_iri();
    eventHandler.endNonterminal("predicate", e0);
  }

  private void parse_object()
  {
    eventHandler.startNonterminal("object", e0);
    switch (l1)
    {
    case 2:                         // IRIREF
    case 3:                         // PNAME_NS
    case 4:                         // PNAME_LN
      parse_iri();
      break;
    case 5:                         // BLANK_NODE_LABEL
    case 14:                        // ANON
      parse_BlankNode();
      break;
    case 16:                        // '('
      parse_collection();
      break;
    case 25:                        // '['
      parse_blankNodePropertyList();
      break;
    default:
      parse_literal();
    }
    eventHandler.endNonterminal("object", e0);
  }

  private void parse_literal()
  {
    eventHandler.startNonterminal("literal", e0);
    switch (l1)
    {
    case 7:                         // INTEGER
    case 8:                         // DECIMAL
    case 9:                         // DOUBLE
      parse_NumericLiteral();
      break;
    case 29:                        // 'false'
    case 30:                        // 'true'
      parse_BooleanLiteral();
      break;
    default:
      parse_RDFLiteral();
    }
    eventHandler.endNonterminal("literal", e0);
  }

  private void parse_blankNodePropertyList()
  {
    eventHandler.startNonterminal("blankNodePropertyList", e0);
    consume(25);                    // '['
    lookahead1W(4);                 // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | 'a'
    whitespace();
    parse_predicateObjectList();
    consume(26);                    // ']'
    eventHandler.endNonterminal("blankNodePropertyList", e0);
  }

  private void parse_collection()
  {
    eventHandler.startNonterminal("collection", e0);
    consume(16);                    // '('
    for (;;)
    {
      lookahead1W(10);              // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | INTEGER |
                                    // DECIMAL | DOUBLE | STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE |
                                    // STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE | ANON | '(' | ')' |
                                    // '[' | 'false' | 'true'
      if (l1 == 17)                 // ')'
      {
        break;
      }
      whitespace();
      parse_object();
    }
    consume(17);                    // ')'
    eventHandler.endNonterminal("collection", e0);
  }

  private void parse_NumericLiteral()
  {
    eventHandler.startNonterminal("NumericLiteral", e0);
    switch (l1)
    {
    case 7:                         // INTEGER
      consume(7);                   // INTEGER
      break;
    case 8:                         // DECIMAL
      consume(8);                   // DECIMAL
      break;
    default:
      consume(9);                   // DOUBLE
    }
    eventHandler.endNonterminal("NumericLiteral", e0);
  }

  private void parse_RDFLiteral()
  {
    eventHandler.startNonterminal("RDFLiteral", e0);
    parse_String();
    lookahead1W(11);                // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | LANGTAG |
                                    // INTEGER | DECIMAL | DOUBLE | STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE |
                                    // STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE | ANON | '(' | ')' |
                                    // ',' | '.' | ';' | '[' | ']' | '^^' | 'false' | 'true'
    if (l1 == 6                     // LANGTAG
     || l1 == 27)                   // '^^'
    {
      switch (l1)
      {
      case 6:                       // LANGTAG
        consume(6);                 // LANGTAG
        break;
      default:
        consume(27);                // '^^'
        lookahead1W(3);             // WhiteSpace | IRIREF | PNAME_NS | PNAME_LN
        whitespace();
        parse_iri();
      }
    }
    eventHandler.endNonterminal("RDFLiteral", e0);
  }

  private void parse_BooleanLiteral()
  {
    eventHandler.startNonterminal("BooleanLiteral", e0);
    switch (l1)
    {
    case 30:                        // 'true'
      consume(30);                  // 'true'
      break;
    default:
      consume(29);                  // 'false'
    }
    eventHandler.endNonterminal("BooleanLiteral", e0);
  }

  private void parse_String()
  {
    eventHandler.startNonterminal("String", e0);
    switch (l1)
    {
    case 10:                        // STRING_LITERAL_QUOTE
      consume(10);                  // STRING_LITERAL_QUOTE
      break;
    case 11:                        // STRING_LITERAL_SINGLE_QUOTE
      consume(11);                  // STRING_LITERAL_SINGLE_QUOTE
      break;
    case 12:                        // STRING_LITERAL_LONG_SINGLE_QUOTE
      consume(12);                  // STRING_LITERAL_LONG_SINGLE_QUOTE
      break;
    default:
      consume(13);                  // STRING_LITERAL_LONG_QUOTE
    }
    eventHandler.endNonterminal("String", e0);
  }

  private void parse_iri()
  {
    eventHandler.startNonterminal("iri", e0);
    switch (l1)
    {
    case 2:                         // IRIREF
      consume(2);                   // IRIREF
      break;
    default:
      parse_PrefixedName();
    }
    eventHandler.endNonterminal("iri", e0);
  }

  private void parse_PrefixedName()
  {
    eventHandler.startNonterminal("PrefixedName", e0);
    switch (l1)
    {
    case 4:                         // PNAME_LN
      consume(4);                   // PNAME_LN
      break;
    default:
      consume(3);                   // PNAME_NS
    }
    eventHandler.endNonterminal("PrefixedName", e0);
  }

  private void parse_BlankNode()
  {
    eventHandler.startNonterminal("BlankNode", e0);
    switch (l1)
    {
    case 5:                         // BLANK_NODE_LABEL
      consume(5);                   // BLANK_NODE_LABEL
      break;
    default:
      consume(14);                  // ANON
    }
    eventHandler.endNonterminal("BlankNode", e0);
  }

  private void consume(int t)
  {
    if (l1 == t)
    {
      whitespace();
      eventHandler.terminal(TOKEN[l1], b1, e1);
      b0 = b1; e0 = e1; l1 = 0;
    }
    else
    {
      error(b1, e1, 0, l1, t);
    }
  }

  private void whitespace()
  {
    if (e0 != b1)
    {
      eventHandler.whitespace(e0, b1);
      e0 = b1;
    }
  }

  private int matchW(int tokenSetId)
  {
    int code;
    for (;;)
    {
      code = match(tokenSetId);
      if (code != 1)                // WhiteSpace
      {
        break;
      }
    }
    return code;
  }

  private void lookahead1W(int tokenSetId)
  {
    if (l1 == 0)
    {
      l1 = matchW(tokenSetId);
      b1 = begin;
      e1 = end;
    }
  }

  private int error(int b, int e, int s, int l, int t)
  {
    throw new ParseException(b, e, s, l, t);
  }

  private int     b0, e0;
  private int l1, b1, e1;
  private EventHandler eventHandler = null;
  private CharSequence input = null;
  private int size = 0;
  private int begin = 0;
  private int end = 0;

  private int match(int tokenSetId)
  {
    begin = end;
    int current = end;
    int result = INITIAL[tokenSetId];
    int state = 0;

    for (int code = result & 127; code != 0; )
    {
      int charclass;
      int c0 = current < size ? input.charAt(current) : 0;
      ++current;
      if (c0 < 0x80)
      {
        charclass = MAP0[c0];
      }
      else if (c0 < 0xd800)
      {
        int c1 = c0 >> 4;
        charclass = MAP1[(c0 & 15) + MAP1[(c1 & 31) + MAP1[c1 >> 5]]];
      }
      else
      {
        if (c0 < 0xdc00)
        {
          int c1 = current < size ? input.charAt(current) : 0;
          if (c1 >= 0xdc00 && c1 < 0xe000)
          {
            ++current;
            c0 = ((c0 & 0x3ff) << 10) + (c1 & 0x3ff) + 0x10000;
          }
        }

        int lo = 0, hi = 5;
        for (int m = 3; ; m = (hi + lo) >> 1)
        {
          if (MAP2[m] > c0) {hi = m - 1;}
          else if (MAP2[6 + m] < c0) {lo = m + 1;}
          else {charclass = MAP2[12 + m]; break;}
          if (lo > hi) {charclass = 0; break;}
        }
      }

      state = code;
      int i0 = (charclass << 7) + code - 1;
      code = TRANSITION[(i0 & 7) + TRANSITION[i0 >> 3]];

      if (code > 127)
      {
        result = code;
        code &= 127;
        end = current;
      }
    }

    result >>= 7;
    if (result == 0)
    {
      end = current - 1;
      int c1 = end < size ? input.charAt(end) : 0;
      if (c1 >= 0xdc00 && c1 < 0xe000)
      {
        --end;
      }
      return error(begin, end, state, -1, -1);
    }

    if (end > size) end = size;
    return (result & 31) - 1;
  }

  private static String[] getTokenSet(int tokenSetId)
  {
    java.util.ArrayList<String> expected = new java.util.ArrayList<>();
    int s = tokenSetId < 0 ? - tokenSetId : INITIAL[tokenSetId] & 127;
    for (int i = 0; i < 31; i += 32)
    {
      int j = i;
      int i0 = (i >> 5) * 120 + s - 1;
      int f = EXPECTED[(i0 & 3) + EXPECTED[i0 >> 2]];
      for ( ; f != 0; f >>>= 1, ++j)
      {
        if ((f & 1) != 0)
        {
          expected.add(TOKEN[j]);
        }
      }
    }
    return expected.toArray(new String[]{});
  }

  private static final int[] MAP0 =
  {
    /*   0 */ 54, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 4,
    /*  35 */ 5, 3, 6, 3, 7, 8, 9, 3, 10, 11, 12, 13, 3, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 16, 17, 3, 18, 3,
    /*  64 */ 19, 20, 21, 22, 22, 23, 24, 25, 25, 26, 25, 25, 25, 25, 25, 25, 27, 25, 28, 29, 25, 30, 25, 25, 31, 25,
    /*  90 */ 25, 32, 33, 34, 35, 36, 37, 38, 39, 22, 22, 40, 41, 25, 25, 42, 25, 25, 43, 25, 44, 25, 45, 25, 46, 47,
    /* 116 */ 48, 49, 25, 25, 50, 25, 25, 37, 37, 37, 3, 51
  };

  private static final int[] MAP1 =
  {
    /*   0 */ 108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181,
    /*  21 */ 181, 214, 215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    /*  42 */ 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    /*  63 */ 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    /*  84 */ 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    /* 105 */ 214, 214, 214, 247, 261, 277, 293, 309, 325, 341, 357, 394, 394, 394, 386, 442, 434, 442, 434, 442, 442,
    /* 126 */ 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 411, 411, 411, 411, 411, 411, 411,
    /* 147 */ 427, 442, 442, 442, 442, 442, 442, 442, 442, 372, 394, 394, 395, 393, 394, 394, 442, 442, 442, 442, 442,
    /* 168 */ 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 394, 394, 394, 394, 394, 394, 394, 394,
    /* 189 */ 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394,
    /* 210 */ 394, 394, 394, 441, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442,
    /* 231 */ 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 394, 54, 0, 0, 0, 0, 0, 0, 0,
    /* 255 */ 0, 1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 4, 5, 3, 6, 3, 7, 8, 9, 3, 10, 11,
    /* 290 */ 12, 13, 3, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 16, 17, 3, 18, 3, 19, 20, 21, 22, 22, 23, 24, 25,
    /* 317 */ 25, 26, 25, 25, 25, 25, 25, 25, 27, 25, 28, 29, 25, 30, 25, 25, 31, 25, 25, 32, 33, 34, 35, 36, 37, 38,
    /* 343 */ 39, 22, 22, 40, 41, 25, 25, 42, 25, 25, 43, 25, 44, 25, 45, 25, 46, 47, 48, 49, 25, 25, 50, 25, 25, 37,
    /* 369 */ 37, 37, 3, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 53, 53, 51, 51, 51, 51, 51, 51, 51, 52, 51, 51,
    /* 396 */ 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
    /* 422 */ 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 51, 53, 53, 53, 53, 53, 53,
    /* 448 */ 53, 53, 53, 53, 53, 53, 53, 53, 53, 53
  };

  private static final int[] MAP2 =
  {
    /*  0 */ 57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 51, 53, 51, 53, 53,
    /* 17 */ 51
  };

  private static final int[] INITIAL =
  {
    /*  0 */ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
  };

  private static final int[] TRANSITION =
  {
    /*    0 */ 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 880, 891,
    /*   18 */ 1093, 1052, 1053, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 880, 883, 1021, 1053,
    /*   36 */ 1053, 1053, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053, 1384, 1054, 1052, 1265, 961,
    /*   54 */ 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053, 921, 913, 1052, 1053, 1046, 1052, 1010,
    /*   72 */ 911, 1988, 935, 1380, 912, 1053, 1053, 1053, 945, 949, 1054, 1052, 1265, 961, 1053, 999, 911, 1000, 911,
    /*   91 */ 1919, 912, 1053, 1053, 1053, 1053, 1384, 957, 1052, 1673, 961, 1053, 999, 911, 1000, 911, 1919, 912,
    /*  109 */ 1053, 1053, 1053, 1053, 969, 1054, 997, 1265, 1720, 1052, 999, 1008, 1757, 1018, 1919, 1029, 1053, 1053,
    /*  127 */ 1053, 1053, 1039, 1054, 1052, 1265, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053,
    /*  145 */ 1373, 1054, 1052, 1265, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053, 1062, 1054,
    /*  163 */ 1052, 1265, 961, 1090, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 897, 1069, 1054, 1052, 1265,
    /*  181 */ 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053, 1101, 1109, 1280, 1848, 1122, 1137,
    /*  199 */ 1883, 1117, 987, 1130, 989, 912, 1053, 1053, 1053, 1351, 1151, 1159, 1167, 1181, 1197, 1213, 1631, 1211,
    /*  217 */ 1187, 1221, 1189, 912, 1053, 1053, 1053, 1053, 1243, 1251, 1259, 1877, 1274, 1289, 1297, 1305, 1313,
    /*  234 */ 1321, 1329, 1366, 1337, 1359, 1053, 1392, 1413, 1421, 1616, 1266, 1398, 1617, 1431, 1429, 1233, 1439,
    /*  251 */ 1235, 912, 1053, 1053, 1053, 903, 1076, 1054, 1052, 1265, 961, 1053, 999, 911, 1000, 911, 1919, 912,
    /*  269 */ 1053, 1053, 1053, 975, 981, 1054, 1052, 1053, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053,
    /*  287 */ 1053, 1053, 1833, 1054, 1052, 1053, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053,
    /*  305 */ 1453, 1054, 1052, 1265, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1549, 1555, 1472,
    /*  323 */ 1404, 1877, 1274, 1445, 1297, 1480, 1313, 1321, 1329, 1366, 1337, 1359, 1053, 1549, 1488, 1251, 1404,
    /*  340 */ 1877, 1274, 1445, 1297, 1480, 1313, 1321, 1329, 1366, 1337, 1359, 1053, 1549, 1555, 1251, 1404, 1877,
    /*  357 */ 1274, 1445, 1297, 1480, 1313, 1321, 1329, 1366, 1337, 1359, 1053, 1549, 1555, 1251, 1344, 1877, 1496,
    /*  374 */ 1510, 1518, 1480, 1313, 1321, 1329, 1366, 1337, 1359, 1053, 1549, 1555, 1251, 1404, 1877, 1274, 1445,
    /*  391 */ 1526, 1480, 1313, 1321, 1329, 1366, 1337, 1359, 1053, 1549, 1555, 1251, 1404, 1661, 1274, 1405, 1883,
    /*  408 */ 1534, 987, 1542, 989, 912, 1053, 1053, 1053, 1549, 1555, 1251, 1404, 1661, 1274, 1405, 1883, 1534, 1227,
    /*  426 */ 1542, 989, 912, 1053, 1053, 1053, 1549, 1563, 1251, 1404, 1661, 1274, 1405, 1883, 1534, 987, 1542, 989,
    /*  444 */ 912, 1053, 1053, 1053, 1549, 1555, 1571, 1404, 1661, 1274, 1405, 1883, 1534, 987, 1542, 989, 912, 1053,
    /*  462 */ 1053, 1053, 1549, 1555, 1251, 1404, 1661, 1579, 1405, 1883, 1534, 987, 1542, 989, 912, 1053, 1053, 1053,
    /*  480 */ 1549, 1555, 1251, 1404, 1593, 1610, 1625, 1883, 1534, 1143, 1639, 989, 912, 1053, 1053, 1053, 1549, 1555,
    /*  498 */ 1251, 1404, 1661, 1274, 1405, 1883, 1534, 987, 1542, 1460, 912, 1053, 1053, 1053, 1053, 1654, 1054, 1052,
    /*  516 */ 1053, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053, 1955, 1602, 1754, 1599, 1748,
    /*  534 */ 1052, 1031, 1686, 1698, 1695, 1951, 1687, 1053, 1053, 1053, 927, 1083, 1678, 1052, 1053, 961, 1053, 999,
    /*  552 */ 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053, 1667, 1054, 1203, 1053, 961, 1053, 999, 911, 1000,
    /*  570 */ 911, 1919, 912, 1053, 1053, 1053, 1053, 1706, 1251, 1280, 1848, 1274, 1281, 1883, 1117, 987, 1714, 989,
    /*  588 */ 912, 1053, 1053, 1053, 1053, 1923, 1054, 1052, 1053, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053,
    /*  606 */ 1053, 1053, 1646, 1555, 1251, 1585, 1970, 1274, 1445, 1297, 1480, 1313, 1321, 1329, 1366, 1337, 1359,
    /*  623 */ 1053, 1549, 1555, 1728, 1404, 1877, 1736, 1937, 1297, 1480, 1765, 1773, 1329, 1366, 1337, 1359, 1053,
    /*  640 */ 1549, 1555, 1251, 1344, 1877, 1274, 1510, 1781, 1789, 1797, 1805, 1329, 1366, 1337, 1359, 1053, 1549,
    /*  657 */ 1813, 1251, 1404, 1877, 1736, 1937, 1297, 1480, 1821, 1773, 1329, 1366, 1337, 1359, 1053, 1549, 1555,
    /*  674 */ 1251, 1404, 1661, 1274, 1405, 1883, 1534, 987, 1542, 1829, 912, 1053, 1053, 1053, 1549, 1555, 1251, 1404,
    /*  692 */ 1661, 1274, 1913, 1883, 1534, 987, 1542, 989, 912, 1053, 1053, 1053, 1549, 1555, 1251, 1404, 1661, 1736,
    /*  710 */ 1742, 1883, 1534, 1854, 1841, 989, 912, 1053, 1053, 1053, 1549, 1555, 1862, 1404, 1661, 1274, 1405, 1883,
    /*  728 */ 1534, 987, 1542, 989, 912, 1053, 1053, 1053, 1549, 1555, 1251, 1502, 1977, 1736, 1742, 1883, 1534, 1854,
    /*  746 */ 1841, 989, 912, 1053, 1053, 1053, 1549, 1555, 1251, 1404, 1661, 1274, 1405, 1870, 1891, 987, 1542, 989,
    /*  764 */ 912, 1053, 1053, 1053, 1549, 1899, 1251, 1404, 1661, 1736, 1742, 1883, 1534, 1854, 1841, 989, 912, 1053,
    /*  782 */ 1053, 1053, 1549, 1555, 1251, 1404, 1907, 1931, 1945, 1883, 1534, 1173, 1963, 989, 912, 1053, 1053, 1053,
    /*  800 */ 1549, 1555, 1251, 1404, 1661, 1274, 1405, 1883, 1534, 987, 1542, 989, 937, 1053, 1053, 1053, 1053, 1384,
    /*  818 */ 1054, 1052, 1053, 961, 1053, 999, 911, 1000, 911, 1919, 912, 1053, 1053, 1053, 1053, 1464, 1109, 1280,
    /*  836 */ 1661, 1122, 1281, 1883, 1117, 987, 1714, 989, 912, 1053, 1053, 1053, 1549, 1555, 1251, 1280, 1661, 1274,
    /*  854 */ 1281, 1883, 1117, 987, 1714, 989, 912, 1053, 1053, 1053, 1053, 1985, 1053, 1053, 1053, 1053, 1053, 1053,
    /*  872 */ 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 269, 269, 269, 269, 269, 269, 269, 269, 0, 0, 0, 269,
    /*  892 */ 269, 269, 269, 269, 270, 0, 0, 0, 0, 0, 2432, 0, 0, 0, 0, 0, 2688, 0, 2688, 0, 66, 0, 0, 0, 0, 0, 0, 0,
    /*  920 */ 1453, 0, 24, 24, 24, 0, 270, 0, 0, 0, 0, 0, 3456, 0, 3456, 0, 66, 66, 0, 0, 0, 0, 0, 0, 2944, 270, 270,
    /*  947 */ 270, 270, 270, 270, 270, 270, 0, 270, 15, 0, 35, 0, 0, 0, 0, 0, 0, 44, 0, 0, 47, 0, 0, 25, 25, 25, 0,
    /*  974 */ 270, 15, 0, 0, 15, 15, 0, 15, 15, 15, 15, 0, 270, 0, 0, 0, 0, 18, 63, 0, 0, 0, 0, 1584, 0, 0, 0, 0, 0, 0,
    /* 1004 */ 0, 63, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 78, 0, 0, 97, 66, 0, 0, 0, 0, 0, 22, 0, 0, 1664, 0, 0, 0, 0, 0, 0,
    /* 1036 */ 0, 79, 0, 2176, 2176, 2176, 2176, 0, 270, 15, 0, 0, 0, 1408, 63, 44, 47, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0,
    /* 1063 */ 26, 26, 26, 0, 270, 15, 0, 0, 0, 2432, 0, 270, 15, 0, 0, 0, 2688, 0, 270, 15, 0, 0, 0, 3456, 0, 270, 15,
    /* 1090 */ 0, 0, 69, 0, 0, 0, 0, 0, 22, 0, 44, 0, 26, 26, 26, 0, 270, 15, 16, 0, 18, 0, 18, 18, 0, 0, 44, 0, 66, 0,
    /* 1120 */ 0, 0, 18, 18, 0, 44, 0, 0, 47, 0, 0, 66, 0, 0, 0, 18, 72, 0, 0, 69, 18, 18, 72, 0, 0, 0, 0, 18, 63, 93,
    /* 1150 */ 0, 0, 27, 27, 2587, 0, 270, 15, 34, 0, 38, 0, 38, 38, 0, 0, 44, 47, 27, 0, 50, 38, 38, 0, 0, 0, 0, 18,
    /* 1178 */ 63, 94, 0, 0, 34, 0, 36, 676, 38, 0, 0, 0, 0, 38, 63, 0, 0, 0, 0, 38, 38, 0, 44, 0, 0, 47, 0, 0, 0, 0, 0,
    /* 1209 */ 0, 3584, 0, 66, 0, 0, 0, 38, 38, 0, 0, 0, 0, 66, 0, 0, 0, 38, 0, 0, 0, 0, 91, 63, 0, 0, 0, 0, 529, 63, 0,
    /* 1240 */ 0, 0, 0, 0, 1052, 1052, 1052, 0, 270, 15, 16, 676, 18, 0, 18, 18, 0, 0, 44, 47, 1052, 1202, 1052, 18, 18,
    /* 1265 */ 0, 0, 0, 0, 676, 0, 0, 0, 0, 18, 18, 830, 44, 0, 0, 47, 0, 0, 0, 18, 18, 0, 0, 0, 0, 1202, 1349, 18, 18,
    /* 1294 */ 0, 73, 74, 676, 0, 0, 18, 18, 830, 63, 80, 81, 66, 84, 85, 1349, 18, 18, 983, 88, 89, 0, 0, 18, 63, 0,
    /* 1320 */ 95, 96, 66, 0, 100, 101, 18, 983, 102, 103, 0, 18, 63, 105, 106, 107, 108, 113, 114, 65, 44, 115, 116,
    /* 1343 */ 68, 47, 0, 0, 51, 18, 18, 950, 0, 0, 2560, 0, 0, 2560, 2560, 2560, 117, 118, 119, 120, 94, 63, 99, 66,
    /* 1367 */ 109, 110, 111, 112, 56, 15, 0, 0, 2304, 2304, 0, 270, 15, 0, 0, 0, 1792, 0, 0, 0, 0, 0, 270, 15, 0, 0,
    /* 1393 */ 512, 0, 529, 529, 0, 529, 529, 0, 44, 0, 0, 47, 0, 0, 0, 18, 18, 950, 0, 0, 529, 529, 529, 529, 0, 270,
    /* 1419 */ 15, 512, 676, 529, 0, 529, 529, 0, 43, 44, 0, 66, 0, 0, 0, 529, 529, 0, 63, 0, 0, 66, 0, 0, 0, 529, 0, 0,
    /* 1447 */ 0, 18, 18, 950, 73, 74, 19, 0, 0, 31, 0, 270, 15, 0, 0, 3218, 63, 0, 0, 0, 0, 0, 270, 15, 16, 676, 18, 0,
    /* 1475 */ 41, 18, 0, 0, 44, 81, 66, 84, 85, 0, 18, 18, 983, 20, 18, 18, 18, 0, 270, 15, 16, 18, 61, 830, 44, 0, 0,
    /* 1502 */ 47, 0, 0, 0, 18, 53, 950, 0, 0, 51, 0, 18, 18, 950, 73, 74, 676, 0, 0, 3090, 18, 830, 63, 80, 676, 0, 0,
    /* 1529 */ 18, 77, 830, 63, 80, 0, 66, 0, 0, 0, 18, 18, 983, 0, 66, 0, 0, 0, 18, 983, 0, 16, 0, 18, 18, 0, 18, 18,
    /* 1557 */ 18, 18, 0, 270, 15, 16, 21, 18, 18, 18, 0, 270, 15, 16, 676, 18, 0, 18, 42, 0, 0, 44, 60, 18, 830, 44, 0,
    /* 1584 */ 0, 47, 0, 0, 0, 52, 18, 950, 0, 55, 16, 0, 676, 0, 18, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 46, 18, 18, 830,
    /* 1613 */ 44, 0, 64, 47, 0, 0, 0, 529, 529, 0, 0, 0, 67, 0, 0, 18, 18, 950, 0, 0, 0, 38, 38, 62, 63, 0, 0, 66, 98,
    /* 1642 */ 0, 0, 18, 983, 0, 16, 0, 18, 3730, 0, 3730, 3730, 3350, 3350, 3350, 3350, 0, 270, 15, 0, 16, 0, 676, 0,
    /* 1666 */ 18, 0, 0, 0, 32, 0, 270, 0, 0, 0, 35, 676, 0, 0, 0, 0, 0, 1920, 0, 44, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 83,
    /* 1697 */ 66, 0, 0, 0, 0, 0, 79, 63, 0, 23, 23, 23, 23, 0, 270, 15, 16, 0, 66, 0, 0, 0, 18, 0, 0, 0, 44, 0, 44,
    /* 1726 */ 1536, 66, 676, 18, 39, 18, 18, 0, 0, 44, 18, 18, 830, 44, 0, 44, 47, 0, 0, 18, 18, 950, 0, 0, 0, 46, 0,
    /* 1753 */ 44, 49, 0, 0, 0, 0, 0, 0, 0, 63, 63, 0, 88, 89, 0, 0, 18, 63, 63, 95, 96, 66, 66, 100, 101, 18, 983, 102,
    /* 1781 */ 676, 0, 76, 18, 18, 830, 63, 80, 81, 66, 84, 85, 0, 18, 3986, 983, 88, 89, 2816, 0, 18, 63, 0, 95, 96,
    /* 1806 */ 66, 0, 100, 101, 3858, 983, 102, 18, 29, 29, 29, 0, 270, 15, 16, 88, 89, 0, 90, 18, 63, 63, 95, 0, 104,
    /* 1831 */ 18, 63, 0, 0, 0, 0, 0, 270, 384, 0, 0, 66, 66, 0, 0, 18, 983, 0, 16, 0, 676, 676, 18, 0, 0, 0, 0, 18, 63,
    /* 1860 */ 63, 0, 676, 18, 40, 18, 18, 0, 0, 44, 0, 75, 0, 18, 18, 830, 63, 0, 16, 57, 676, 0, 18, 0, 0, 0, 18, 18,
    /* 1888 */ 830, 63, 0, 0, 66, 0, 0, 0, 86, 18, 983, 18, 30, 30, 30, 0, 270, 15, 16, 56, 16, 0, 676, 0, 18, 0, 0, 0,
    /* 1916 */ 70, 18, 950, 0, 0, 0, 63, 0, 0, 0, 0, 0, 270, 0, 0, 18, 18, 830, 44, 0, 65, 47, 0, 0, 18, 18, 950, 73,
    /* 1944 */ 74, 68, 0, 0, 18, 71, 950, 0, 0, 0, 79, 0, 0, 0, 0, 0, 270, 33, 0, 0, 66, 99, 0, 0, 18, 983, 0, 16, 57,
    /* 1973 */ 676, 0, 18, 58, 0, 16, 0, 676, 0, 18, 0, 59, 2048, 0, 0, 0, 0, 0, 0, 0, 92, 63, 0
  };

  private static final int[] EXPECTED =
  {
    /*   0 */ 30, 34, 38, 42, 48, 66, 70, 81, 44, 74, 51, 97, 78, 85, 91, 95, 54, 80, 87, 61, 101, 106, 59, 62, 112, 57,
    /*  26 */ 62, 102, 110, 110, 6, 10, 524290, 30, 268435486, 68943874, 268959774, 337117214, 65126462, 1644265406,
    /*  40 */ 1644396478, 1847558142, 2, 2, 4, 8, 16, 16, 16, 24, 6291456, 8388632, 16777240, 32, 1024, 4096, 2048,
    /*  57 */ 2048, 4, 4, 4194304, 16777240, 8192, 8192, 1024, 1024, 16777240, 16384, 32, 9216, 6144, 896, 768, 896, 16,
    /*  75 */ 24, 2097152, 4194304, 2048, 768, 512, 536870936, 1073741848, 64, 134217728, 1073741848, 64, 4, 4, 2097152,
    /*  90 */ 4194304, 16, 2097152, 4194304, 8388632, 16777240, 32, 8192, 1024, 2048, 4096, 1024, 4096, 4096, 2048,
    /* 105 */ 2048, 2048, 536870936, 64, 4, 8192, 8192, 4096, 4096, 4096, 2048
  };

  private static final String[] TOKEN =
  {
    "%ERROR",
    "WhiteSpace",
    "IRIREF",
    "PNAME_NS",
    "PNAME_LN",
    "BLANK_NODE_LABEL",
    "LANGTAG",
    "INTEGER",
    "DECIMAL",
    "DOUBLE",
    "STRING_LITERAL_QUOTE",
    "STRING_LITERAL_SINGLE_QUOTE",
    "STRING_LITERAL_LONG_SINGLE_QUOTE",
    "STRING_LITERAL_LONG_QUOTE",
    "'[]'",
    "EOF",
    "'('",
    "')'",
    "','",
    "'.'",
    "';'",
    "'@base'",
    "'@prefix'",
    "'BASE'",
    "'PREFIX'",
    "'['",
    "']'",
    "'^^'",
    "'a'",
    "'false'",
    "'true'"
  };
}

// End
