xquery version "1.0" encoding "UTF-8";

(: This file was generated on Fri Oct 24, 2025 23:25 (UTC+02) by REx v6.2-SNAPSHOT which is Copyright (c) 1979-2025 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q Java.ebnf -backtrack -ll 2 -tree -main -xquery :)

declare namespace p="Java";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 11;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 12;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  68, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21, 21, 22, 22, 22, 22, 23, 23, 24, 25, 26, 27, 28, 29, 30, 31, 31, 31,
  32, 33, 32, 8, 8, 8, 8, 8, 34, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 35, 8, 8, 36, 37, 38, 39, 8, 7, 40, 41, 42, 43, 44,
  45, 46, 47, 48, 8, 49, 50, 51, 52, 53, 54, 8, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 7
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 195, 195, 195, 195, 195, 195, 195,
  195, 170, 211, 124, 124, 124, 124, 138, 195, 195, 195, 195, 195, 195, 195, 195, 124, 124, 124, 124, 124, 124, 124,
  124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124,
  124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195,
  195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 243, 257, 273, 289, 305, 344, 390,
  360, 375, 375, 375, 375, 326, 318, 326, 318, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326,
  326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 328, 375, 375, 375, 375,
  375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326,
  326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375,
  375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 326, 326, 326,
  326, 326, 326, 326, 326, 375, 375, 375, 375, 375, 375, 375, 375, 68, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 4, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21, 21, 22,
  22, 22, 22, 23, 23, 24, 25, 26, 27, 28, 29, 30, 31, 31, 31, 32, 33, 32, 8, 8, 8, 8, 8, 34, 8, 8, 8, 8, 8, 8, 8, 7, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 35, 8, 8, 36, 37, 38, 39, 8, 54, 8, 55, 56,
  57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 40, 41, 42, 43, 44, 45,
  46, 47, 48, 8, 49, 50, 51, 52, 53
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64256, 65536, 63743, 64255, 65533, 1114111, 7, 8, 7, 7
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
  62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
  91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115,
  116, 117, 118, 119, 120, 121
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4416, 4416, 4416, 4416, 4416, 4416, 4416, 4439, 5640, 4838, 4785, 4929,
  5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068,
  4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801,
  4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4416, 4416, 4416, 4416, 4416,
  4416, 4416, 4439, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 4875, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4872,
  4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784,
  5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4416, 4416, 4416, 4416, 4416, 4416, 4416, 4423, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4416, 4416, 4416, 4416, 4416, 4416, 4416, 4439, 5640, 4838,
  4785, 4929, 5548, 4624, 5634, 5473, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578,
  6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739,
  4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4891, 4903, 4919, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626,
  5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646,
  4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4945, 4957, 4979, 5640, 4838, 4785, 5042, 5548, 4624, 5634,
  5790, 4656, 4744, 4831, 5668, 5645, 4776, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816,
  4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4630,
  5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618,
  4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479,
  5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085,
  6816, 10735, 8095, 7117, 11751, 8732, 13527, 7009, 12876, 10692, 5968, 8730, 8370, 6827, 9975, 6832, 6832, 7889, 8871,
  6857, 10591, 6080, 7826, 6832, 6832, 7887, 8869, 8846, 10586, 11732, 6832, 6832, 13122, 6823, 9564, 11747, 6832, 7007,
  9931, 6823, 12976, 6832, 13127, 11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 7398, 13256, 5032, 5640, 4838, 4785, 4929,
  5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068,
  4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801,
  4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  6203, 9906, 5058, 5640, 4838, 4785, 4929, 5084, 5129, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465,
  4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784,
  5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 5156, 5168, 5191, 5640, 4838, 4785, 4449, 5548, 4624, 5634, 5790, 4656,
  4744, 4831, 5668, 5645, 5537, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 4488, 5068, 4740, 4744, 4816, 4550, 4605,
  4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 5217, 5175, 6446, 5312, 5218, 5234, 5246, 5262, 5640, 4838,
  4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578,
  6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739,
  4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 5309, 6274, 6272,
  4855, 5299, 5113, 5288, 5328, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626,
  5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646,
  4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 6442, 6442, 4855, 4855, 4855, 6437, 13447, 5355, 5640, 4838, 4785, 4929, 5548, 5140, 5634,
  4534, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 5382, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816,
  4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 14006, 5412, 5428,
  5640, 4838, 4785, 4929, 5455, 4624, 5467, 5790, 4656, 4744, 4831, 5668, 5645, 4686, 5554, 4465, 4746, 4744, 4618,
  4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479,
  5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  8961, 4856, 10193, 5489, 4855, 10179, 10206, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668,
  5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272,
  5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 14118, 5507, 5523, 5640, 4838, 4785, 4929, 4516,
  4624, 4528, 5790, 4656, 4744, 4831, 5668, 5645, 4686, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740,
  4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10730, 5825, 13308, 14158, 4855, 5570,
  5582, 5598, 5640, 4838, 4785, 4929, 5661, 13955, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 4700, 5366, 4465, 4746,
  4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396,
  4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 5684, 5684, 5684, 5684, 5684, 5692, 5708, 5724, 5640, 4838, 4785, 4929, 5548, 13966, 5634, 5790, 4656, 4744,
  4831, 5668, 5645, 5626, 5554, 5769, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565,
  6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 5806, 5818, 5841, 7009, 12876, 10692,
  8593, 5876, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857, 5896, 6080, 7826, 6832, 6832, 7887, 8869, 8846, 5860,
  5908, 6832, 6832, 13122, 6823, 9564, 5932, 6832, 7007, 9931, 6823, 5959, 6832, 13127, 11696, 6831, 11376, 5016, 12114,
  5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 5984, 5996, 6020, 7009, 12876, 10692, 8593, 5876, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857, 5896, 6080,
  7826, 6832, 6832, 7887, 8869, 8846, 5860, 5908, 6832, 6832, 13122, 6823, 9564, 5932, 6832, 7007, 9931, 6823, 5959,
  6832, 13127, 11696, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 5984, 5996, 6020, 7009, 12876, 10692, 8593, 5876, 8370, 6827, 9975,
  6832, 6832, 7889, 8871, 6857, 6046, 6080, 7826, 6832, 6832, 7887, 8869, 8846, 5860, 5908, 6832, 6832, 13122, 6823,
  9564, 5932, 6832, 7007, 9931, 6823, 5959, 6832, 13127, 11696, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 5984, 5996, 6020, 7009,
  12876, 10692, 8593, 6074, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857, 11676, 6080, 7826, 6832, 6832, 7887, 8869,
  8846, 13180, 5908, 6832, 6832, 13122, 6823, 9564, 5932, 6832, 7007, 9931, 6823, 5959, 6832, 13127, 11696, 6831, 11376,
  5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 7390, 4855,
  4855, 4855, 4855, 4855, 11075, 11089, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645,
  5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612,
  4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 12041, 12034, 6110, 6096, 6111, 6127, 6168, 6179, 5640, 4838, 4785, 4929, 5548, 4624,
  5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744,
  4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 8953, 7991, 8957, 7998, 6195, 8942, 13692,
  6219, 5640, 4838, 4785, 4929, 4711, 4589, 6235, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744,
  4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727,
  4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  11955, 4855, 11959, 10086, 6270, 11946, 12375, 6290, 5640, 4838, 4785, 4929, 6306, 6322, 6338, 5790, 4656, 4744, 4831,
  5668, 5645, 5626, 5339, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5201, 4740, 4744, 4816, 4550, 4605, 4565, 6245,
  5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 9848, 4855, 4855, 9847, 9840, 11937, 12554, 6354, 5640, 4838, 4785, 4929,
  5548, 6370, 12952, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5439, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068,
  4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801,
  4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 11928,
  11928, 13662, 6386, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465,
  4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784,
  5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 5105, 4855, 5097, 4963, 6402, 6429, 6413, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656,
  4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605,
  4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095, 7117, 11751, 8732, 13527, 7009, 12876,
  10692, 5968, 8730, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857, 12819, 6080, 7826, 6832, 6832, 7887, 8869, 8846,
  11299, 5908, 6832, 6832, 13122, 6823, 9564, 5932, 6832, 7007, 9931, 6823, 5959, 6832, 13127, 11696, 6831, 11376, 5016,
  12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735,
  8095, 7117, 11751, 8732, 13527, 7009, 12876, 10692, 5968, 6462, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857, 7295,
  6080, 7826, 6832, 6832, 7887, 8869, 8846, 9688, 5908, 6832, 6832, 13122, 6823, 9564, 5932, 6832, 7007, 9931, 6823,
  5959, 6832, 13127, 11696, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095, 7117, 11751, 8732, 13527, 7009, 12876, 10692, 5968, 6484, 8370,
  6827, 9975, 6832, 6832, 7889, 8871, 6857, 8536, 6080, 7826, 6832, 6832, 7887, 8869, 8846, 11299, 5908, 6832, 6832,
  13122, 6823, 9564, 5932, 6832, 7007, 9931, 6823, 5959, 6832, 13127, 11696, 6831, 11376, 5016, 12114, 5005, 10085,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095, 7117, 11751,
  8732, 13527, 7009, 12876, 10692, 5968, 6506, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857, 6806, 6080, 7826, 6832,
  6832, 7887, 8869, 8846, 10586, 6528, 6832, 6832, 13122, 6823, 9564, 11747, 6832, 7007, 9931, 6823, 12976, 6832, 13127,
  11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 10085, 6816, 10735, 8095, 7117, 11751, 8732, 13527, 7009, 12876, 10692, 5968, 6552, 8370, 6827, 9975, 6832,
  6832, 7889, 8871, 6857, 10591, 6080, 7826, 6832, 6832, 7887, 8869, 8846, 10586, 11732, 6832, 6832, 13122, 6823, 9564,
  11747, 6832, 7007, 9931, 6823, 12976, 6832, 13127, 11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 13417, 6574, 6605, 7041, 7034, 6621, 6633, 5640,
  4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504,
  4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753,
  5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4630, 5640, 4838, 4785, 4989, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645,
  4776, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612,
  4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 7047, 4855, 4855, 4855, 4855, 7044, 6649, 6678, 5640, 4838, 4785, 4929, 5548, 4624,
  5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744,
  4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 11919, 6694,
  6710, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744,
  4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727,
  4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  6771, 6763, 6776, 11116, 6726, 6741, 6752, 6792, 6852, 6873, 12405, 6910, 6952, 9443, 10878, 6975, 7003, 8506, 7025,
  7063, 6490, 7094, 7110, 8274, 7133, 6832, 7170, 10642, 7225, 11299, 6058, 13836, 7241, 13122, 6823, 11147, 7266,
  10356, 7007, 11546, 7324, 5959, 7648, 7351, 11696, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 7445, 7437, 7450, 7209, 7376, 7414, 7426, 7466, 7009, 12876,
  8987, 7502, 8730, 8370, 7641, 7555, 6832, 9968, 7889, 8871, 10699, 7583, 6080, 7826, 10577, 6832, 7887, 12422, 7631,
  11299, 5908, 6832, 6832, 13122, 6823, 9564, 5932, 6832, 7007, 9931, 6823, 5959, 6832, 13127, 11696, 6831, 11376, 5016,
  12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 7710, 7702, 7197,
  13069, 7664, 7679, 7691, 7726, 7009, 12876, 10692, 5968, 8730, 8370, 6827, 9975, 6832, 12084, 7889, 8871, 10377, 7760,
  6080, 7826, 8652, 13631, 8568, 8869, 8846, 11299, 11688, 11290, 7779, 13122, 6823, 9679, 7795, 7822, 8434, 7842,
  13096, 5959, 11635, 12209, 7868, 7905, 7926, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 8045, 8037, 7949, 12649, 7977, 8014, 8026, 8066, 7009, 12876, 10692, 5968, 6462, 8370,
  6827, 9975, 6832, 6832, 7889, 8871, 6857, 7295, 6080, 7826, 6832, 6832, 8092, 8869, 11987, 9688, 5908, 6832, 6832,
  13122, 6823, 9564, 5932, 9291, 7007, 10682, 6823, 5959, 6832, 13127, 11696, 6831, 11376, 5016, 8111, 8137, 10085,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 8228, 8220, 13880, 8153, 8183, 8198,
  8209, 8167, 8249, 8290, 10672, 5968, 8324, 8370, 11569, 9274, 6832, 6832, 7889, 8871, 6857, 8536, 6468, 7826, 8348,
  9522, 7308, 8405, 8359, 13846, 8421, 8549, 8460, 9875, 8486, 7539, 8522, 7773, 7007, 10133, 6823, 8584, 10233, 7360,
  8609, 8673, 13210, 10991, 12114, 8710, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 8796, 8788, 13783, 7961, 8748, 8763, 8777, 8817, 8843, 8862, 9143, 9101, 6462, 9165, 9175, 9183, 13033, 6832,
  11016, 8871, 6857, 8887, 6080, 9617, 6832, 6832, 7887, 8869, 8846, 9688, 5908, 6832, 6832, 13122, 6823, 9564, 5932,
  6832, 8928, 8977, 6823, 5959, 8657, 13127, 9003, 6831, 11376, 5016, 7852, 9038, 10085, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095, 7117, 11751, 8732, 13527, 7009, 12876,
  10692, 5968, 8730, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857, 10591, 6080, 7826, 6833, 6832, 7887, 8308, 9065,
  10586, 11732, 6832, 6832, 13122, 6823, 9564, 11747, 6832, 12738, 9931, 9246, 9092, 6832, 13127, 11740, 6831, 11376,
  5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816,
  10735, 8095, 7117, 11751, 8732, 7281, 7567, 9117, 9199, 8076, 9237, 8370, 11593, 9262, 6832, 6832, 7889, 8871, 6857,
  10591, 6080, 7826, 6832, 6832, 7887, 8869, 8846, 10586, 11732, 6835, 13363, 9154, 6823, 9564, 10962, 10298, 7007,
  9931, 6823, 12976, 9290, 13127, 11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 9315, 9307, 6004, 6662, 9331, 9346, 9358, 9374, 9409, 8301, 6936, 9428,
  9469, 9132, 11322, 9503, 6832, 8912, 9538, 9561, 12921, 10591, 9580, 13005, 6832, 9607, 7887, 8869, 9412, 10076, 8722,
  9654, 7744, 9210, 6823, 10503, 11747, 9633, 10826, 9931, 6823, 11723, 6832, 13127, 11740, 6831, 11376, 5943, 10481,
  5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095,
  7117, 11751, 8732, 13527, 7009, 12876, 10692, 5968, 8730, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857, 10591, 6080,
  7826, 6832, 9651, 7887, 8869, 8846, 9670, 11732, 6836, 6832, 13122, 6823, 9564, 11747, 9704, 7007, 9931, 6823, 12976,
  6832, 13127, 11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 9792, 9784, 8050, 13795, 9721, 9761, 9773, 9813, 9829, 13586, 9864, 9891, 9922, 7517, 11346, 9956,
  8496, 9991, 7889, 8871, 10002, 11161, 10024, 7826, 10051, 10102, 10124, 10149, 5880, 13746, 10222, 10249, 10270,
  13718, 12523, 10288, 11747, 7486, 9487, 10324, 9478, 12976, 10350, 13127, 5916, 6831, 11376, 5016, 12114, 5005, 10085,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095, 7117, 11751,
  8732, 13527, 10372, 10393, 7528, 6030, 8730, 9076, 6886, 6894, 6832, 6832, 7889, 8871, 6857, 10591, 6080, 7826, 6832,
  6832, 7887, 8869, 8470, 10418, 11732, 6832, 6832, 13122, 6823, 9564, 11747, 6832, 10439, 12579, 6823, 13610, 6832,
  13127, 11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 10550, 10542, 8233, 10451, 10467, 10519, 10531, 10566, 10607, 10635, 10658, 10715, 8730, 10751, 8262,
  10767, 11510, 10795, 13755, 6959, 10842, 10870, 10894, 12316, 6832, 9705, 7887, 8869, 8846, 10586, 9384, 6832, 10910,
  13563, 6823, 9564, 11747, 12089, 10927, 9931, 6823, 9221, 6832, 12138, 11740, 12188, 10955, 10978, 12114, 5005, 10085,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095, 7117, 11751,
  8732, 8624, 11007, 9545, 11032, 11060, 11105, 6925, 12163, 11132, 10108, 13171, 7889, 12725, 11177, 10591, 6080, 7826,
  10254, 12837, 9022, 8869, 8846, 7145, 9393, 11193, 6832, 13122, 6823, 9564, 11747, 6832, 7007, 9931, 6823, 12976,
  11829, 13127, 6536, 6831, 11376, 7806, 12782, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 11258, 11250, 8801, 10619, 11212, 11228, 11239, 11279, 7009, 12876, 10692, 5968, 8730, 8370, 6827,
  9975, 10272, 13343, 10164, 11315, 6857, 11338, 6558, 7826, 6832, 6832, 7887, 8869, 8846, 10586, 11732, 6832, 6832,
  13122, 6823, 9564, 11747, 6832, 7007, 9931, 6823, 12976, 6832, 13127, 11740, 11451, 11623, 11362, 12114, 5005, 10085,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 11407, 11399, 9797, 10939, 11428, 11472,
  11481, 11497, 8686, 8694, 6589, 9591, 11537, 8370, 9453, 9975, 6836, 10308, 7154, 11562, 6512, 11585, 6080, 11609,
  6832, 13335, 7887, 11662, 11712, 10586, 11732, 12619, 7596, 11767, 6823, 11783, 11810, 11826, 10492, 9931, 6823,
  11442, 6832, 13127, 11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 11845, 11910, 11856, 11044, 11872, 11887, 11899, 11975, 7009, 12876, 10692, 12019, 8730,
  8370, 11997, 12003, 12057, 6832, 13388, 8871, 12071, 12105, 11646, 11521, 10820, 6835, 12130, 12154, 8846, 10586,
  12179, 6832, 10911, 12204, 12225, 9564, 7933, 6832, 7615, 12245, 6823, 12976, 12854, 12271, 11740, 6831, 11376, 5016,
  12114, 12299, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 12469, 12461,
  12332, 12360, 12391, 12438, 12450, 12485, 7880, 12512, 10334, 12539, 12570, 8370, 12229, 10064, 12595, 12611, 12635,
  6987, 12665, 12687, 12712, 12798, 10854, 13824, 8332, 8869, 13499, 12814, 13537, 12835, 12853, 12870, 8444, 9564,
  11383, 6832, 11794, 9931, 12892, 12908, 13039, 12937, 12968, 7736, 12992, 9049, 13021, 5005, 10085, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095, 7117, 11751, 8732, 13527, 13055,
  13085, 12255, 10035, 13112, 8370, 10008, 8900, 9515, 9635, 7889, 10402, 7335, 13143, 13159, 13196, 6832, 7608, 7887,
  8869, 8846, 10586, 11732, 13226, 6832, 12771, 6823, 9564, 11747, 7478, 7007, 9931, 6823, 12976, 7909, 13127, 11740,
  12311, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  13303, 13295, 11263, 12283, 13242, 13272, 13284, 13324, 7009, 12876, 10692, 5968, 8730, 8370, 6827, 9975, 6832, 6832,
  7889, 8871, 6857, 10591, 6080, 7826, 6832, 13359, 7887, 8869, 7250, 13379, 11732, 6832, 7910, 13122, 6823, 9564, 9940,
  6832, 7007, 9931, 6823, 12976, 6832, 13127, 11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 13412, 13404, 11412, 12344, 13433, 13463, 13472, 13488, 8561,
  13515, 12760, 8121, 13553, 8370, 12671, 10808, 6832, 12853, 13579, 13602, 6857, 10591, 6080, 7826, 6832, 6832, 7887,
  8869, 8846, 10586, 11732, 6832, 11196, 12749, 6823, 9564, 11747, 13626, 7007, 9931, 6823, 12976, 6832, 13127, 11740,
  6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  10085, 6816, 10735, 8095, 7117, 11751, 8732, 7078, 7009, 12415, 10692, 13647, 6552, 8370, 6827, 12496, 6832, 6832,
  7889, 8871, 6857, 10591, 6080, 7826, 6832, 6832, 7887, 8869, 8846, 10586, 11732, 6832, 6832, 13122, 6823, 9564, 11747,
  6832, 7007, 9931, 6823, 12976, 6832, 13127, 11740, 6831, 11376, 5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816, 10735, 8095, 7117, 11751, 8732, 8639, 9015, 13678,
  7185, 8827, 13708, 8370, 8380, 8389, 6832, 6834, 7889, 8871, 6857, 10423, 13734, 10779, 6832, 6832, 7887, 8869, 8846,
  10586, 11732, 6832, 6832, 13122, 6823, 9564, 11747, 6832, 7007, 9931, 6823, 12976, 11456, 13771, 11740, 5851, 11376,
  5016, 12114, 5005, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 10085, 6816,
  10735, 8095, 7117, 11751, 8732, 13527, 7009, 12876, 10692, 5968, 8730, 8370, 6827, 9975, 6832, 6832, 7889, 8871, 6857,
  10591, 6080, 7826, 6832, 6832, 7887, 8869, 8846, 10586, 11732, 6832, 6832, 13122, 6823, 9564, 11747, 6832, 7007, 9931,
  6823, 12976, 6832, 13127, 11740, 6831, 11376, 5016, 12696, 13811, 10085, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 9744, 9735, 6152, 9745, 6140, 13862, 13896, 5640, 4838, 4785, 4929, 5548,
  4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740,
  4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 13871,
  13912, 13928, 5640, 4838, 4785, 4929, 5548, 13944, 13982, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746,
  4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396,
  4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 14056, 14030, 14066, 13998, 14022, 14046, 14082, 5640, 4838, 4785, 4929, 5548, 4624, 5634, 5790, 4656,
  4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578, 6254, 5068, 4740, 4744, 4816, 4550, 4605,
  4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739, 4762, 4801, 4854, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 14098, 14110, 14134, 5640, 4838,
  4785, 4929, 5548, 4624, 5634, 5790, 4656, 4744, 4831, 5668, 5645, 5626, 5554, 4465, 4746, 4744, 4618, 4504, 4578,
  6254, 5068, 4740, 4744, 4816, 4550, 4605, 4565, 6245, 5272, 5612, 4646, 4672, 5784, 5396, 4727, 4479, 5753, 5739,
  4762, 4801, 4854, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 5491, 14150, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855, 4855,
  4855, 4855, 4855, 4855, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264,
  11264, 11264, 11264, 0, 0, 0, 0, 0, 0, 0, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 141312, 0,
  141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 141312, 141312, 141312, 141312, 190, 0, 0, 199680, 141312,
  208896, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 251, 0, 141312, 141312,
  140288, 141312, 223232, 228352, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 212992,
  0, 6144, 6144, 0, 0, 0, 0, 0, 217088, 141312, 141312, 141312, 0, 0, 0, 0, 0, 212992, 0, 0, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 31744, 0, 0, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 141312, 382, 252, 141312, 141312, 141312, 141312, 230400, 141312, 0, 192512, 195584,
  0, 0, 215040, 0, 141312, 192512, 195584, 141312, 141312, 215040, 141312, 0, 0, 0, 0, 141312, 218112, 234496, 141312,
  141312, 141312, 141312, 0, 141312, 141312, 141312, 212992, 141312, 141312, 141312, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0,
  0, 0, 0, 0, 0, 0, 361, 0, 0, 141312, 236544, 0, 139264, 0, 0, 0, 0, 0, 0, 141312, 141312, 139264, 141312, 141312,
  141312, 141312, 0, 0, 217088, 0, 0, 0, 0, 141312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312,
  141312, 141312, 206848, 224256, 0, 204800, 0, 0, 0, 0, 0, 204800, 141312, 141312, 141312, 141312, 141312, 141312, 0,
  141312, 141312, 141312, 141312, 141312, 141312, 0, 141312, 141312, 0, 0, 0, 0, 203776, 141312, 141312, 141312, 141312,
  0, 141312, 141312, 141312, 191488, 141312, 141312, 0, 0, 141312, 0, 0, 0, 0, 0, 0, 479, 0, 141312, 141312, 141312, 0,
  0, 141312, 0, 0, 0, 0, 5465, 5465, 0, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0,
  0, 0, 40960, 225280, 0, 141312, 141312, 141312, 141312, 222208, 141312, 210944, 0, 0, 0, 216064, 141312, 141312,
  141312, 235520, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 0, 141312, 0, 189440, 0, 226304, 189440, 141312, 226304, 141312, 141312, 237568, 0,
  141312, 141312, 197632, 141312, 141312, 0, 0, 141312, 190, 0, 343, 0, 0, 0, 0, 0, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 0, 0, 0, 0, 214016, 214016, 0, 221184, 221184, 141312, 233472, 0, 141312, 141312,
  209920, 141312, 211968, 209920, 211968, 141312, 0, 0, 0, 230400, 0, 141312, 141312, 0, 0, 0, 0, 0, 0, 193536, 141312,
  0, 0, 0, 0, 0, 0, 141312, 141312, 0, 0, 0, 0, 0, 0, 0, 141312, 141312, 141312, 141312, 0, 0, 0, 229376, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29696, 199680, 141312, 208896, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 251, 13312, 141312, 141312, 141312, 141312, 0, 0, 15360, 0, 0, 0, 0, 0, 204, 15360, 0,
  15360, 15360, 15360, 15360, 15360, 204, 15360, 0, 204, 204, 204, 204, 204, 204, 204, 204, 204, 15360, 204, 204, 204,
  15360, 15360, 15360, 15360, 15360, 141312, 0, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 141312, 141312,
  141312, 141312, 190, 343, 0, 0, 0, 190, 0, 0, 0, 0, 0, 0, 190, 0, 190, 190, 190, 190, 190, 0, 190, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 53248, 53248, 53248, 53248, 53248, 53248, 190, 0, 0, 0, 190, 190, 190, 190, 190, 141312, 0, 141312,
  141312, 141312, 141312, 141312, 141312, 0, 0, 141312, 141312, 141312, 141312, 342, 344, 0, 0, 122, 0, 0, 122, 122,
  122, 0, 122, 122, 0, 122, 0, 122, 122, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122, 0, 122, 0, 17622, 17622, 17622,
  0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 141312, 141312, 141312, 141312, 7168,
  343, 0, 0, 19671, 19671, 19671, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0,
  0, 141312, 141312, 141312, 141312, 141312, 207872, 0, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 0, 20480, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23552, 0, 0,
  23552, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0,
  141312, 0, 0, 191, 0, 0, 0, 0, 0, 0, 191, 0, 191, 191, 191, 191, 191, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528,
  22528, 22528, 0, 0, 0, 0, 191, 0, 0, 0, 191, 191, 191, 191, 191, 141312, 0, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 0, 51200, 141312, 141312, 141312, 141312, 141312, 207872, 0, 22528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 22528, 0, 0, 0, 0, 0, 22528, 22528, 0, 22528, 22528, 22528, 22528, 22528, 0, 22528, 22528, 22528,
  22528, 0, 22528, 22528, 0, 22528, 22528, 22528, 22528, 0, 22528, 0, 22528, 22528, 22528, 22528, 22528, 141312, 0,
  141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 141312, 196608, 0, 227328, 238592, 0,
  23552, 0, 0, 23552, 0, 23552, 23552, 23552, 0, 23552, 0, 23552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23552, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 22528, 0, 22528, 0, 23552, 23552, 23552, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312,
  141312, 141312, 0, 0, 0, 41984, 49152, 141312, 49152, 141312, 141312, 141312, 141312, 0, 24792, 24792, 24792, 0, 0, 0,
  0, 0, 141312, 251, 141312, 141312, 141312, 141312, 141312, 0, 0, 34816, 0, 0, 141312, 0, 141312, 141312, 141312,
  141312, 199680, 141312, 208896, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 382,
  0, 141312, 225280, 0, 232448, 0, 0, 0, 0, 200704, 141312, 200704, 0, 0, 0, 222208, 26830, 26830, 26830, 26830, 217,
  26830, 0, 217, 217, 26850, 26850, 26850, 26841, 26850, 26850, 26850, 26830, 26850, 26850, 26850, 26830, 26830, 26830,
  26830, 26830, 141312, 0, 141312, 141312, 141312, 141312, 141312, 50176, 0, 0, 0, 490, 141312, 50666, 141312, 141312,
  141312, 141312, 0, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 27648, 0, 0, 0,
  141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 251, 383, 141312, 141312,
  141312, 141312, 29696, 29696, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14336, 14336, 30927, 30927, 30927, 30927, 218,
  30927, 0, 218, 218, 30947, 30947, 30947, 30938, 30947, 30947, 30947, 30927, 30947, 30947, 30947, 30927, 30927, 30927,
  30927, 30927, 141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 0, 141312, 190, 6144, 343, 0, 0, 0, 0, 0, 141312,
  141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312,
  141312, 0, 0, 192, 0, 0, 0, 0, 0, 33792, 192, 0, 192, 192, 192, 192, 192, 219, 192, 33792, 34011, 34011, 33792, 33792,
  33792, 0, 33792, 33792, 33792, 192, 33792, 33792, 33792, 192, 192, 192, 192, 192, 141312, 0, 141312, 141312, 141312,
  141312, 141312, 0, 0, 194560, 0, 0, 0, 227328, 196608, 0, 0, 206848, 224256, 141312, 141312, 0, 0, 141312, 0, 0, 0, 0,
  0, 0, 0, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 0, 0, 0,
  141312, 141312, 141312, 141312, 141312, 5465, 5465, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 141312, 141312, 0, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
  123, 123, 123, 123, 35963, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 220, 123, 123, 220, 220, 36060,
  36060, 36060, 36060, 36060, 36060, 36060, 123, 36060, 36060, 36060, 123, 123, 123, 123, 123, 141312, 252, 141312,
  141312, 141312, 141312, 141312, 219136, 141312, 141312, 141312, 0, 141312, 141312, 141312, 198656, 205824, 141312,
  141312, 141312, 0, 141312, 198656, 205824, 202752, 0, 190464, 190464, 0, 220160, 0, 0, 141312, 219136, 220160, 141312,
  199680, 141312, 208896, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 12288, 0,
  141312, 231424, 238592, 141312, 194560, 204800, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 251, 252, 141312, 141312, 141312, 141312, 0, 0, 3265, 0, 0, 0, 0, 0, 0, 3265, 0, 3265, 3265, 3265,
  3265, 3265, 0, 3265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33792, 0, 0, 0, 0, 0, 33792, 3265, 0, 0, 0, 3265, 3265, 3265, 3265,
  3265, 122, 0, 122, 122, 122, 122, 122, 122, 122, 763, 122, 122, 122, 122, 122, 122, 122, 0, 0, 122, 580, 477, 343,
  581, 5600, 5600, 4442, 3266, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 567, 0, 0, 122, 122, 122, 0,
  0, 122, 190, 0, 476, 5465, 4442, 347, 5600, 2529, 122, 122, 122, 122, 122, 122, 122, 0, 0, 122, 122, 122, 122, 122,
  122, 0, 0, 0, 0, 122, 122, 122, 757, 122, 0, 0, 659, 660, 122, 122, 122, 122, 122, 122, 122, 0, 122, 122, 122, 0, 122,
  122, 122, 122, 122, 122, 122, 784, 0, 122, 0, 0, 715, 716, 122, 122, 122, 122, 122, 0, 122, 122, 122, 122, 122, 122,
  0, 0, 122, 122, 122, 122, 190, 343, 0, 0, 0, 3266, 0, 0, 0, 0, 0, 0, 3266, 0, 3266, 3266, 3266, 3266, 3266, 0, 3266,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 152, 0, 0, 130, 0, 0, 0, 0, 3266, 0, 0, 0, 3266, 3266, 3266, 3266, 3266, 122, 0, 122,
  122, 122, 122, 122, 122, 339, 0, 122, 271, 122, 122, 190, 343, 0, 122, 122, 0, 0, 122, 190, 0, 477, 5465, 4442, 347,
  5600, 2529, 122, 122, 122, 122, 122, 122, 588, 0, 0, 122, 122, 122, 593, 122, 122, 347, 3266, 122, 122, 122, 122, 122,
  122, 122, 122, 122, 0, 0, 0, 0, 0, 122, 0, 122, 122, 122, 122, 0, 38912, 38912, 0, 0, 0, 38912, 0, 38912, 38912, 0,
  38912, 0, 0, 38912, 38912, 38912, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38912, 38912, 38912, 0, 0, 0, 38912, 0, 0,
  38912, 0, 0, 38912, 0, 38912, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 108544, 0, 0, 0, 108544, 108544, 0, 108544, 0, 0,
  108544, 108544, 0, 108544, 108544, 0, 0, 0, 0, 0, 38912, 0, 38912, 0, 38912, 38912, 38912, 38912, 0, 38912, 38912,
  38912, 38912, 38912, 38912, 38912, 38912, 38912, 141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 0, 39936,
  39936, 0, 0, 39936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19661, 0, 0, 0, 0, 0, 0, 0, 0, 40164, 40164, 40164, 0, 39936, 0, 0, 0,
  141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 41321, 0, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 141312, 193536, 141312, 201728, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 0, 0, 212992, 0, 0, 0, 0, 0, 0, 0, 44032, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23552, 0, 0, 0, 0, 44241,
  44241, 44241, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 0, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 141312, 16384, 0, 0, 0, 43008, 45056, 47104, 0, 0, 141312, 18432, 21504, 25600, 28672,
  32768, 0, 36864, 0, 0, 57344, 141312, 110592, 28672, 32768, 43008, 47104, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 141312, 141312, 0, 46309, 46309, 46309, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312,
  141312, 141312, 141312, 0, 48486, 0, 0, 141312, 0, 0, 0, 0, 0, 0, 0, 0, 362, 0, 141312, 0, 52224, 52224, 52224, 0, 0,
  0, 0, 0, 141312, 0, 141312, 141312, 141312, 141312, 141312, 53248, 53248, 0, 53248, 53248, 53248, 53248, 53248, 0, 0,
  53248, 0, 0, 0, 0, 53248, 53248, 53248, 53248, 53248, 141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 53248,
  53248, 53248, 0, 53248, 53248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 22528, 0,
  0, 5120, 5120, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 122, 0, 122, 122, 494, 122, 348, 348, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 462, 122, 122, 122, 122, 122, 3072, 3072, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 463, 122, 122, 122, 122, 122, 2048, 122, 122, 122, 122, 122, 122, 122, 0, 0,
  122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 122, 755, 122, 122, 349, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0,
  0, 0, 0, 0, 491, 0, 122, 122, 122, 122, 0, 0, 0, 0, 54272, 54272, 0, 0, 0, 0, 0, 54272, 54272, 54272, 54272, 0, 0, 0,
  0, 256, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 329, 0, 54272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54272, 0, 54272, 0,
  54272, 0, 0, 0, 0, 54272, 0, 0, 54272, 54272, 54272, 54272, 54272, 0, 54272, 54272, 54272, 0, 0, 0, 0, 0, 141312, 0,
  141312, 141312, 141312, 141312, 141312, 0, 0, 0, 0, 55296, 0, 0, 55296, 55296, 0, 0, 0, 55296, 0, 0, 0, 0, 0, 152,
  130, 130, 0, 0, 0, 0, 152, 130, 130, 0, 0, 55296, 55296, 55296, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312,
  141312, 141312, 0, 0, 0, 0, 56543, 0, 0, 56543, 56543, 56543, 56543, 56543, 56543, 56543, 56543, 56543, 0, 56543,
  56543, 56543, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 124, 0, 124, 124, 124, 124,
  124, 173, 124, 124, 179, 173, 173, 179, 124, 179, 179, 179, 179, 179, 0, 124, 179, 124, 124, 124, 124, 124, 124, 179,
  124, 124, 0, 0, 0, 0, 0, 124, 124, 124, 124, 124, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124, 0, 0, 0, 0,
  231, 0, 0, 0, 241, 241, 241, 241, 241, 122, 0, 122, 122, 258, 122, 122, 0, 0, 122, 0, 0, 0, 0, 4096, 0, 0, 0, 122,
  122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 122, 270, 122, 122, 122, 266, 122, 122, 274, 277, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 122, 122, 122, 122,
  122, 122, 122, 0, 0, 300, 0, 0, 0, 304, 274, 122, 122, 258, 0, 0, 0, 0, 0, 271, 122, 122, 122, 122, 122, 271, 122,
  122, 122, 122, 122, 122, 251, 252, 122, 122, 122, 122, 0, 266, 122, 122, 266, 335, 122, 0, 340, 258, 122, 277, 122,
  190, 343, 0, 0, 0, 0, 269, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 267, 122, 122, 122, 122, 0, 0, 328, 0, 0, 0,
  350, 274, 122, 122, 353, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 445, 0, 122, 122, 122, 122, 122, 258, 350, 122, 122,
  377, 122, 122, 380, 350, 251, 252, 122, 122, 122, 122, 0, 440, 0, 0, 0, 444, 0, 0, 122, 448, 122, 122, 122, 122, 269,
  390, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 122, 420, 0, 0, 0, 0, 0, 122, 427,
  0, 0, 0, 0, 0, 0, 0, 0, 54272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55296, 0, 0, 0, 0, 0, 122, 122, 122, 438, 0,
  0, 441, 0, 0, 0, 0, 0, 122, 122, 449, 122, 0, 0, 0, 122, 122, 122, 122, 122, 122, 0, 122, 122, 122, 122, 265, 122,
  427, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0, 2529, 122, 122, 416, 122, 122, 487, 122, 122, 0, 0, 0, 0, 0, 122, 0, 122, 122,
  122, 122, 122, 0, 122, 122, 122, 0, 0, 122, 122, 509, 122, 122, 122, 122, 512, 122, 122, 514, 515, 122, 122, 122, 122,
  122, 122, 122, 578, 0, 122, 0, 0, 0, 0, 0, 0, 122, 410, 0, 429, 0, 0, 0, 0, 0, 122, 529, 122, 0, 0, 0, 0, 0, 0, 122,
  122, 537, 0, 0, 540, 0, 0, 0, 0, 318, 122, 122, 122, 122, 122, 285, 122, 0, 0, 0, 0, 0, 0, 149, 0, 0, 0, 0, 126, 0, 0,
  0, 0, 0, 0, 125, 125, 0, 0, 0, 0, 0, 125, 125, 0, 122, 122, 558, 122, 122, 122, 122, 0, 0, 564, 0, 0, 0, 0, 0, 570,
  122, 122, 122, 122, 611, 122, 122, 613, 257, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 565, 0, 0, 0, 0, 122, 122, 0,
  658, 659, 660, 122, 122, 122, 122, 122, 122, 122, 666, 122, 668, 122, 0, 0, 0, 122, 122, 122, 122, 122, 122, 0, 122,
  122, 259, 122, 122, 0, 0, 122, 0, 0, 0, 5120, 5120, 5120, 0, 2529, 122, 122, 122, 0, 531, 0, 532, 0, 0, 535, 122, 0,
  0, 0, 0, 541, 122, 122, 701, 0, 0, 0, 0, 0, 0, 122, 707, 122, 122, 122, 122, 122, 0, 457, 0, 0, 0, 0, 122, 122, 466,
  122, 122, 737, 738, 122, 0, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 742, 0, 0, 122, 122, 0, 746, 0, 0, 0, 0, 0, 125,
  158, 165, 165, 165, 165, 165, 0, 165, 165, 125, 0, 0, 0, 0, 0, 37888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17408, 0, 0, 0, 0,
  0, 0, 0, 0, 165, 165, 165, 165, 165, 165, 165, 0, 165, 165, 165, 165, 165, 165, 165, 125, 165, 165, 125, 125, 0, 0, 0,
  0, 0, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125, 0, 0, 0, 0, 232, 0, 0, 0, 232,
  232, 232, 232, 232, 122, 0, 253, 122, 122, 122, 122, 122, 122, 122, 676, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 678, 122, 122, 122, 515, 122, 0, 122, 333, 122, 122, 122, 122, 0, 0, 122, 122, 122, 122, 190, 343, 0, 0, 0, 0,
  321, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 122, 271, 122, 122, 122, 0, 0, 0, 0, 646, 0, 0, 0, 122, 122, 122,
  122, 122, 654, 122, 333, 122, 122, 122, 122, 122, 122, 122, 122, 122, 251, 252, 122, 122, 122, 122, 122, 122, 281,
  286, 122, 289, 0, 0, 0, 0, 294, 295, 470, 122, 0, 0, 122, 190, 0, 343, 0, 0, 0, 0, 2529, 122, 122, 122, 122, 122, 612,
  122, 122, 122, 122, 122, 616, 122, 122, 122, 122, 122, 122, 524, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  270, 122, 0, 0, 0, 0, 122, 557, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 0, 0, 122, 253, 122, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 732, 122, 122, 122, 122, 0, 0, 139, 157, 159, 166, 166, 166, 166, 166, 139, 166, 166,
  157, 139, 139, 186, 166, 186, 186, 186, 186, 186, 0, 166, 186, 166, 166, 166, 166, 166, 126, 166, 186, 126, 126, 0, 0,
  0, 0, 0, 126, 126, 126, 126, 126, 126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 233, 0, 0, 0, 242, 242, 246,
  246, 249, 122, 0, 122, 122, 122, 122, 122, 122, 762, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 615, 122, 122,
  122, 122, 122, 122, 122, 0, 473, 122, 0, 0, 0, 0, 0, 0, 0, 2529, 122, 122, 122, 122, 122, 675, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 617, 122, 122, 122, 656, 0, 0, 659, 660, 122, 122, 122, 122, 122, 122, 122, 0,
  122, 122, 122, 0, 122, 122, 122, 122, 122, 122, 783, 122, 0, 122, 122, 122, 122, 673, 122, 122, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 251, 0, 122, 122, 691, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 122, 122, 122, 122,
  122, 122, 0, 122, 122, 122, 270, 122, 0, 0, 749, 122, 122, 122, 122, 122, 0, 0, 190, 343, 122, 122, 122, 122, 122,
  122, 282, 122, 122, 122, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 0, 0, 0, 758, 122, 760, 122, 122, 122, 122, 122, 122,
  122, 122, 388, 122, 122, 122, 122, 122, 122, 122, 122, 122, 767, 768, 0, 0, 0, 0, 0, 122, 0, 0, 0, 0, 122, 122, 122,
  122, 122, 664, 122, 0, 122, 122, 122, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 129, 129, 0, 0, 0, 0,
  0, 129, 129, 0, 0, 0, 0, 127, 160, 167, 167, 167, 167, 167, 0, 167, 167, 127, 0, 0, 0, 0, 0, 39936, 0, 0, 0, 0, 39936,
  0, 0, 0, 0, 0, 0, 0, 0, 39936, 39936, 0, 0, 0, 167, 167, 167, 167, 167, 167, 167, 0, 167, 167, 167, 167, 167, 167,
  167, 127, 167, 167, 127, 127, 0, 0, 0, 0, 0, 127, 127, 127, 127, 127, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 131, 0, 0, 0, 0, 234, 0, 0, 0, 234, 234, 247, 247, 247, 122, 0, 122, 122, 122, 122, 122, 281, 0, 0, 319, 122, 122,
  324, 190, 343, 0, 270, 122, 122, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 788, 0, 122, 789, 122,
  122, 122, 122, 0, 122, 122, 122, 122, 122, 284, 0, 0, 122, 122, 122, 284, 190, 343, 0, 0, 122, 0, 0, 122, 122, 122, 0,
  122, 122, 0, 122, 0, 122, 122, 801, 151, 0, 0, 151, 0, 151, 128, 128, 0, 0, 151, 0, 151, 128, 128, 0, 0, 0, 180, 180,
  180, 248, 248, 122, 0, 122, 122, 122, 262, 122, 0, 0, 0, 128, 0, 128, 128, 128, 128, 128, 174, 128, 128, 180, 174,
  174, 180, 128, 180, 180, 180, 180, 180, 0, 128, 180, 128, 128, 128, 128, 128, 128, 180, 128, 128, 0, 0, 0, 0, 0, 128,
  128, 128, 128, 128, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132, 0, 0, 0, 0, 122, 122, 122, 275, 122, 280,
  122, 122, 122, 122, 0, 0, 292, 0, 0, 0, 0, 0, 365, 122, 122, 122, 122, 122, 322, 122, 122, 122, 122, 122, 122, 416,
  122, 122, 122, 122, 122, 122, 251, 0, 122, 122, 122, 298, 0, 0, 0, 0, 0, 0, 305, 122, 122, 122, 0, 0, 0, 301, 0, 0, 0,
  122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 552, 0, 122, 122, 348, 348, 122, 305, 122, 122, 275, 122, 122, 122, 122, 0, 0,
  0, 0, 0, 0, 122, 536, 0, 0, 0, 0, 0, 408, 122, 122, 270, 122, 122, 122, 122, 122, 513, 122, 122, 122, 122, 518, 122,
  122, 122, 0, 0, 0, 0, 0, 0, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 318, 122, 122, 122, 122, 122, 354, 122,
  122, 122, 122, 122, 251, 252, 122, 122, 122, 122, 0, 543, 122, 544, 122, 122, 0, 548, 0, 0, 0, 0, 0, 0, 122, 555,
  2529, 122, 122, 584, 122, 122, 122, 122, 0, 0, 122, 122, 592, 122, 122, 122, 122, 122, 685, 270, 122, 122, 122, 122,
  122, 0, 0, 0, 0, 637, 0, 638, 122, 122, 122, 122, 641, 122, 642, 122, 122, 122, 610, 122, 122, 122, 122, 122, 614,
  122, 122, 122, 122, 122, 122, 122, 0, 563, 0, 0, 0, 0, 0, 0, 122, 122, 122, 635, 0, 0, 0, 0, 0, 0, 639, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 264, 122, 122, 122, 122, 122, 122, 122, 122, 122, 409, 122, 122, 122, 122, 416, 122,
  122, 0, 0, 659, 660, 661, 122, 122, 122, 122, 122, 122, 0, 667, 122, 122, 0, 0, 122, 0, 0, 0, 348, 348, 348, 0, 2529,
  122, 122, 122, 122, 122, 599, 122, 601, 122, 122, 122, 605, 122, 122, 122, 122, 122, 122, 284, 122, 122, 122, 0, 0, 0,
  0, 0, 0, 122, 122, 0, 0, 539, 0, 0, 0, 0, 715, 716, 122, 717, 122, 122, 122, 0, 122, 122, 122, 122, 122, 122, 0, 0,
  122, 122, 122, 122, 190, 343, 5465, 0, 0, 122, 750, 751, 122, 122, 122, 0, 754, 190, 343, 122, 122, 756, 122, 0, 0, 0,
  122, 122, 122, 122, 122, 122, 0, 122, 255, 261, 263, 122, 0, 0, 0, 122, 122, 122, 122, 122, 122, 0, 122, 257, 122,
  122, 122, 122, 510, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 734, 122, 122, 0, 759, 122, 122,
  122, 122, 122, 122, 122, 122, 765, 122, 417, 122, 122, 122, 122, 278, 122, 122, 287, 122, 122, 0, 0, 0, 0, 0, 0, 0,
  122, 122, 287, 122, 0, 0, 0, 0, 122, 0, 0, 122, 122, 122, 0, 122, 122, 0, 800, 0, 122, 122, 122, 585, 122, 122, 122,
  0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 129, 161, 168, 168, 168, 168,
  168, 175, 178, 178, 181, 175, 175, 178, 195, 178, 178, 178, 178, 178, 0, 195, 178, 195, 195, 195, 195, 195, 213, 195,
  129, 195, 178, 129, 129, 0, 0, 0, 0, 0, 129, 129, 129, 129, 129, 129, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  133, 0, 0, 0, 0, 235, 0, 0, 0, 243, 243, 243, 243, 250, 122, 0, 122, 122, 122, 122, 122, 285, 0, 0, 122, 122, 122,
  285, 190, 343, 0, 122, 270, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 0, 0, 122, 270, 122, 0, 0, 0, 0,
  0, 0, 0, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 0, 0, 122, 190, 0, 343, 5120, 5120,
  5120, 0, 2529, 122, 122, 122, 122, 306, 122, 122, 122, 122, 122, 251, 252, 122, 122, 122, 122, 122, 404, 122, 122,
  122, 122, 122, 412, 122, 414, 122, 417, 122, 122, 122, 684, 122, 122, 122, 122, 122, 122, 122, 122, 0, 689, 0, 0, 0,
  0, 0, 39936, 39936, 39936, 40144, 0, 39936, 0, 0, 0, 0, 0, 0, 0, 39936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29696,
  29696, 29696, 0, 690, 122, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 326, 0, 0,
  0, 0, 748, 122, 122, 122, 122, 122, 753, 0, 0, 190, 343, 122, 122, 122, 122, 122, 122, 285, 122, 122, 122, 0, 0, 0, 0,
  0, 0, 122, 122, 0, 538, 0, 0, 0, 0, 122, 0, 0, 122, 122, 122, 797, 122, 799, 0, 122, 0, 122, 122, 122, 0, 122, 122,
  122, 122, 122, 414, 122, 122, 0, 122, 122, 122, 122, 122, 559, 122, 122, 0, 0, 0, 0, 0, 0, 0, 0, 122, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 363, 0, 714, 0, 0, 122, 122, 122, 122, 122, 0, 122, 122, 122, 122, 122, 122, 0, 0, 122, 270, 122, 122,
  190, 343, 0, 122, 281, 0, 299, 0, 0, 0, 0, 0, 122, 281, 307, 259, 0, 311, 0, 0, 0, 0, 332, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 122, 122, 122, 122, 270, 122, 122, 122, 0, 0, 0, 0, 0, 122, 122, 0, 0, 629, 0, 0, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 270, 122, 122, 122, 122, 122, 371, 122, 122, 122, 122, 122, 122, 251, 252, 122, 122, 122, 122, 0, 0, 0, 316,
  122, 319, 122, 122, 122, 122, 324, 122, 0, 0, 0, 0, 0, 122, 626, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 122, 122, 721,
  122, 723, 122, 122, 725, 726, 0, 0, 122, 122, 324, 307, 122, 324, 286, 122, 122, 0, 0, 0, 0, 0, 0, 0, 122, 122, 708,
  122, 122, 122, 122, 122, 319, 122, 122, 324, 319, 122, 122, 319, 122, 251, 252, 122, 122, 122, 122, 122, 122, 378,
  122, 122, 122, 251, 252, 122, 122, 122, 387, 727, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 122, 414, 0, 0, 0, 130, 130, 130, 130, 145, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140, 0, 0, 0, 0, 0, 0, 130,
  162, 169, 169, 169, 169, 169, 140, 169, 169, 145, 140, 184, 187, 169, 187, 187, 187, 187, 187, 211, 169, 187, 169,
  169, 169, 169, 169, 224, 169, 187, 224, 224, 211, 211, 211, 211, 211, 230, 230, 236, 211, 211, 211, 244, 244, 244,
  244, 244, 122, 0, 122, 122, 122, 122, 122, 587, 122, 0, 0, 122, 122, 122, 122, 122, 122, 122, 0, 0, 408, 122, 122,
  122, 122, 122, 267, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 0, 569, 122, 0, 332, 122, 122, 332,
  122, 122, 0, 0, 122, 122, 122, 122, 190, 343, 0, 0, 0, 0, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 367, 122, 122,
  122, 122, 122, 122, 375, 122, 0, 0, 267, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 0, 681, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 122, 122, 332, 122, 122, 122, 122, 122, 122, 381, 251, 252,
  122, 122, 122, 122, 122, 122, 393, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 269, 122, 122, 122, 122, 122,
  419, 0, 0, 0, 0, 424, 425, 122, 122, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 261, 309, 0, 312, 122, 122, 437, 122, 0, 0,
  0, 0, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 417, 455, 0, 0, 0, 0, 0, 122, 0, 122, 122, 122,
  122, 336, 122, 0, 329, 122, 122, 336, 122, 190, 343, 0, 519, 122, 122, 122, 122, 122, 122, 122, 122, 525, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 503, 122, 122, 122, 251, 0, 122, 122, 671, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 388, 122, 122, 122, 520, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 122, 606, 122, 122, 122, 573, 122, 122, 122, 122, 0, 579, 122, 0, 0, 0, 0, 0, 0, 0, 649, 122, 122, 122, 122, 122,
  122, 122, 0, 0, 122, 580, 0, 0, 581, 0, 5120, 670, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 122, 528, 0, 0, 0, 131, 163, 170, 170, 170, 170, 170, 0, 170, 170, 131, 0, 0, 0, 0, 0, 108544, 0, 108544, 108544,
  0, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 170, 170, 170, 170, 170, 170, 0, 170, 170, 170, 170,
  170, 170, 170, 131, 170, 170, 131, 131, 0, 0, 0, 0, 0, 131, 131, 131, 131, 131, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 134, 0, 0, 0, 0, 170, 0, 0, 0, 170, 170, 170, 170, 170, 122, 0, 122, 122, 260, 122, 264, 268, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 290, 0, 0, 0, 0, 0, 0, 0, 46080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46080, 0, 0, 0, 0, 0,
  0, 313, 0, 0, 0, 122, 260, 122, 321, 122, 122, 122, 122, 0, 0, 0, 0, 624, 122, 122, 0, 0, 0, 0, 0, 632, 0, 122, 0,
  321, 122, 264, 268, 122, 122, 0, 0, 308, 122, 122, 122, 190, 343, 0, 0, 0, 0, 19671, 0, 0, 19671, 19671, 19671, 19671,
  19671, 19671, 19671, 19671, 19671, 3072, 3072, 321, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 122,
  122, 0, 0, 0, 0, 122, 122, 122, 662, 122, 122, 122, 0, 122, 122, 122, 122, 308, 321, 122, 122, 308, 122, 379, 308,
  321, 251, 252, 122, 122, 122, 122, 122, 122, 406, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 251, 252, 122,
  122, 122, 122, 122, 122, 122, 402, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 418, 0, 0, 0, 0, 0, 0, 122,
  122, 122, 122, 122, 122, 122, 122, 306, 122, 122, 122, 122, 122, 488, 488, 0, 0, 0, 0, 0, 122, 0, 122, 122, 122, 122,
  337, 283, 0, 330, 122, 122, 337, 283, 190, 343, 0, 122, 508, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 516,
  122, 122, 122, 122, 338, 122, 122, 122, 122, 122, 251, 252, 122, 122, 122, 122, 122, 122, 577, 0, 0, 122, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44032, 122, 270, 122, 122, 122, 523, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 122, 396, 122, 122, 122, 122, 122, 122, 388, 0, 0, 0, 0, 0, 534, 122, 122, 0, 0, 0, 0, 0, 0, 122, 122, 0, 698, 0,
  0, 122, 700, 542, 0, 122, 122, 122, 122, 547, 0, 0, 0, 0, 0, 0, 0, 554, 122, 0, 0, 0, 423, 0, 0, 122, 122, 0, 0, 0, 0,
  0, 433, 0, 0, 0, 0, 29696, 29696, 29696, 29696, 29696, 0, 0, 0, 29696, 0, 29696, 0, 0, 0, 0, 0, 0, 0, 29696, 29696,
  29696, 0, 0, 0, 29696, 29696, 29696, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312, 141312, 141312, 2048, 122, 583,
  122, 122, 122, 122, 122, 0, 0, 590, 122, 122, 122, 122, 122, 122, 122, 122, 122, 730, 122, 122, 122, 122, 122, 736,
  122, 122, 122, 122, 598, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 408, 122, 122, 122, 122, 609,
  122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 397, 122, 122, 0, 0, 644, 0, 0, 0, 0, 0, 650,
  122, 122, 122, 122, 122, 122, 122, 122, 122, 677, 122, 122, 122, 122, 122, 122, 122, 122, 122, 410, 122, 122, 122,
  415, 122, 122, 122, 122, 692, 0, 0, 694, 0, 0, 122, 122, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 282, 122, 0, 0, 0,
  0, 122, 122, 122, 728, 122, 729, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 679, 616, 122, 122, 122, 122,
  271, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 122, 122, 122, 467, 122, 271, 122, 0, 0, 0, 0, 0, 303,
  0, 122, 122, 122, 122, 0, 0, 0, 442, 0, 0, 0, 0, 122, 122, 122, 450, 122, 572, 122, 122, 122, 122, 122, 0, 0, 122, 0,
  0, 0, 0, 0, 0, 0, 0, 122, 122, 270, 122, 682, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 132,
  154, 0, 0, 0, 0, 0, 132, 132, 0, 0, 0, 141, 154, 0, 132, 132, 132, 132, 132, 0, 132, 132, 132, 0, 0, 0, 0, 122, 122,
  122, 790, 122, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 687, 122, 122, 0, 0, 0, 0, 0, 647, 648, 0, 122,
  122, 122, 122, 122, 122, 655, 0, 132, 196, 199, 199, 199, 199, 199, 0, 196, 199, 196, 196, 196, 196, 196, 132, 196,
  199, 132, 132, 0, 0, 0, 0, 0, 132, 132, 132, 132, 132, 132, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 0, 0, 196, 0, 0,
  0, 196, 196, 196, 196, 196, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122, 419, 122, 122, 122, 122, 122, 122, 122, 0,
  0, 122, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 122, 272, 122, 122, 122, 122, 122, 122, 122, 122, 0, 291, 0, 0, 0, 0,
  0, 0, 133, 133, 0, 0, 0, 0, 0, 133, 133, 0, 296, 122, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 122, 0, 0, 0, 0, 551, 0, 0,
  0, 122, 122, 0, 314, 0, 0, 122, 122, 122, 122, 322, 122, 122, 122, 0, 327, 0, 0, 0, 0, 122, 122, 262, 122, 122, 122,
  122, 122, 0, 0, 0, 0, 695, 0, 122, 122, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 461, 0, 122,
  122, 122, 122, 122, 0, 122, 122, 334, 122, 122, 122, 291, 0, 122, 341, 122, 122, 190, 343, 0, 0, 0, 0, 33792, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 122, 0, 0, 0, 0, 0, 0, 359, 0, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 122, 122, 122, 341,
  122, 122, 122, 334, 122, 122, 251, 252, 122, 122, 122, 122, 122, 122, 500, 122, 122, 122, 122, 122, 122, 251, 0, 122,
  400, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 413, 122, 122, 122, 122, 373, 122, 122, 122, 122, 122,
  251, 252, 122, 122, 122, 122, 122, 414, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 688, 0, 0, 0, 0, 122,
  122, 453, 122, 122, 0, 0, 458, 0, 0, 0, 464, 122, 122, 122, 122, 122, 122, 511, 122, 122, 122, 122, 122, 122, 517,
  122, 122, 122, 122, 0, 0, 122, 190, 0, 343, 0, 0, 0, 0, 0, 122, 122, 122, 258, 122, 350, 122, 122, 122, 122, 122, 122,
  486, 122, 122, 122, 0, 0, 0, 0, 0, 122, 0, 122, 122, 122, 495, 608, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 620, 122, 122, 683, 122, 122, 122, 122, 270, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 134, 134,
  0, 0, 0, 0, 0, 134, 134, 0, 0, 122, 0, 0, 0, 769, 0, 122, 0, 0, 0, 0, 122, 122, 122, 122, 663, 122, 122, 0, 122, 122,
  122, 122, 0, 776, 777, 122, 0, 780, 122, 122, 122, 122, 122, 122, 122, 0, 122, 122, 778, 779, 122, 781, 782, 122, 122,
  122, 122, 122, 785, 786, 269, 122, 273, 122, 122, 122, 122, 122, 288, 122, 0, 0, 0, 0, 0, 0, 122, 122, 428, 0, 0, 0,
  0, 0, 0, 0, 0, 315, 0, 317, 261, 320, 269, 122, 323, 122, 325, 0, 0, 0, 0, 0, 0, 135, 155, 0, 0, 142, 0, 0, 135, 135,
  0, 0, 269, 122, 122, 269, 122, 122, 0, 0, 261, 122, 122, 122, 190, 343, 0, 0, 0, 0, 37888, 0, 0, 37888, 37888, 0, 0,
  0, 37888, 37888, 0, 37888, 37888, 37888, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 0, 269,
  122, 122, 122, 122, 122, 122, 356, 357, 0, 0, 0, 0, 0, 0, 124, 124, 0, 0, 0, 0, 0, 124, 124, 0, 122, 368, 370, 122,
  122, 368, 369, 122, 368, 370, 251, 252, 122, 122, 386, 122, 0, 0, 0, 645, 0, 0, 0, 0, 122, 122, 122, 652, 653, 122,
  122, 0, 0, 122, 0, 0, 0, 0, 4096, 0, 0, 0, 482, 483, 122, 451, 122, 122, 454, 122, 0, 0, 0, 460, 0, 0, 122, 122, 122,
  122, 469, 122, 122, 597, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 619, 122, 0, 0, 0, 133,
  0, 133, 133, 133, 133, 133, 176, 133, 133, 182, 176, 176, 185, 188, 133, 188, 188, 188, 188, 188, 0, 133, 188, 133,
  133, 133, 133, 133, 133, 182, 133, 133, 0, 0, 0, 0, 0, 133, 133, 133, 133, 133, 133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 137, 0, 0, 0, 0, 133, 0, 0, 0, 188, 188, 188, 188, 188, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122,
  602, 122, 122, 122, 122, 122, 122, 122, 0, 0, 122, 580, 0, 0, 581, 0, 0, 122, 436, 122, 122, 0, 0, 0, 0, 0, 0, 0, 0,
  122, 122, 122, 122, 122, 267, 122, 122, 122, 122, 122, 122, 122, 472, 0, 122, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122,
  260, 122, 321, 122, 122, 122, 122, 122, 775, 0, 122, 122, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122, 0, 122, 0,
  0, 0, 0, 0, 122, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 665, 0, 122, 122, 122, 0, 0, 0, 134, 134, 134, 134, 134,
  134, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 0, 0, 0, 0, 0, 0, 134, 0, 134, 134, 134, 134, 134, 0, 134,
  134, 134, 0, 0, 0, 0, 122, 122, 718, 122, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 270,
  122, 122, 122, 122, 122, 122, 122, 0, 134, 134, 134, 134, 134, 134, 134, 0, 134, 134, 134, 134, 134, 134, 134, 134,
  134, 0, 0, 0, 0, 0, 134, 134, 237, 0, 0, 0, 237, 237, 237, 237, 237, 122, 0, 122, 256, 122, 122, 122, 122, 391, 122,
  122, 122, 122, 122, 395, 122, 122, 122, 122, 122, 122, 122, 122, 502, 122, 504, 502, 122, 251, 0, 122, 0, 0, 122, 122,
  122, 352, 122, 122, 355, 122, 122, 0, 0, 0, 0, 0, 0, 122, 122, 697, 0, 0, 0, 699, 122, 122, 122, 415, 122, 0, 0, 0, 0,
  0, 0, 0, 0, 122, 122, 122, 122, 262, 122, 122, 372, 122, 122, 122, 122, 471, 0, 0, 122, 190, 0, 343, 0, 0, 0, 0, 0,
  122, 122, 122, 319, 122, 122, 122, 122, 324, 374, 376, 122, 496, 122, 122, 122, 499, 122, 122, 122, 122, 122, 122,
  122, 251, 0, 122, 0, 0, 0, 0, 0, 122, 0, 0, 0, 772, 122, 122, 122, 122, 122, 122, 515, 122, 122, 122, 731, 122, 122,
  122, 122, 122, 0, 489, 0, 0, 0, 122, 0, 492, 493, 122, 122, 0, 0, 122, 122, 122, 122, 0, 0, 549, 0, 0, 0, 0, 553, 122,
  122, 0, 0, 122, 0, 0, 0, 5465, 347, 347, 5600, 2529, 122, 122, 122, 122, 586, 122, 122, 0, 0, 122, 122, 122, 122, 122,
  122, 0, 0, 190, 343, 122, 122, 122, 122, 556, 122, 122, 122, 122, 560, 122, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122,
  719, 720, 0, 122, 122, 122, 122, 122, 122, 122, 0, 0, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 122, 122, 122, 122,
  122, 122, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122, 0, 622, 623, 0, 0, 625, 122, 0, 0, 0, 0, 0, 0, 0, 633, 122,
  643, 0, 0, 0, 0, 0, 0, 0, 122, 651, 122, 122, 122, 122, 122, 122, 122, 122, 686, 122, 122, 122, 0, 0, 0, 0, 122, 657,
  0, 0, 0, 122, 122, 122, 122, 122, 122, 122, 0, 122, 122, 669, 122, 122, 672, 122, 122, 122, 122, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 735, 122, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 0, 0, 0, 0, 0, 142, 0, 135,
  0, 0, 0, 0, 0, 0, 142, 155, 164, 171, 171, 171, 171, 171, 177, 171, 171, 183, 177, 177, 189, 197, 200, 200, 200, 200,
  200, 0, 197, 200, 197, 197, 197, 197, 197, 135, 197, 200, 135, 135, 0, 0, 0, 0, 0, 135, 135, 135, 135, 135, 146, 0, 0,
  0, 0, 0, 0, 0, 0, 56320, 0, 0, 0, 0, 0, 0, 0, 0, 52224, 0, 0, 0, 0, 0, 0, 0, 0, 46290, 0, 0, 0, 0, 0, 0, 0, 0, 44241,
  0, 0, 0, 0, 0, 0, 0, 0, 44032, 0, 0, 0, 0, 0, 0, 0, 0, 44032, 0, 0, 238, 0, 0, 0, 245, 245, 245, 245, 245, 122, 0,
  254, 122, 122, 122, 122, 122, 122, 561, 0, 0, 0, 0, 0, 0, 0, 0, 122, 366, 122, 122, 122, 122, 122, 122, 122, 122, 122,
  251, 252, 384, 385, 122, 122, 0, 122, 254, 122, 122, 122, 122, 0, 0, 122, 122, 122, 122, 190, 343, 0, 0, 0, 0, 38912,
  0, 0, 0, 0, 0, 0, 0, 0, 38912, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 388, 122, 122, 122, 122, 122, 388, 122, 122, 122, 122,
  122, 122, 122, 398, 122, 122, 122, 456, 0, 0, 0, 0, 0, 122, 465, 122, 122, 122, 122, 403, 122, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 680, 122, 122, 122, 122, 0, 0, 398, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122,
  122, 122, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122, 530, 0, 0, 0, 533, 0, 122, 122, 0, 0, 0, 0, 0, 743, 0, 744,
  122, 0, 0, 0, 0, 0, 0, 122, 122, 545, 546, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 317, 368, 369, 370, 122, 122, 122, 122,
  122, 0, 582, 122, 122, 122, 122, 122, 122, 0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 764, 122, 122, 122, 122, 766,
  515, 122, 621, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 0, 0, 0, 122, 122, 745, 0, 0, 0, 122, 634, 0, 0, 0, 0, 0, 0, 0, 122,
  122, 122, 122, 122, 122, 122, 122, 282, 122, 122, 122, 122, 0, 693, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 122, 122, 122,
  122, 122, 122, 283, 122, 0, 0, 0, 330, 0, 122, 122, 0, 0, 0, 741, 0, 0, 0, 122, 122, 0, 0, 0, 0, 0, 0, 137, 137, 0, 0,
  0, 0, 0, 137, 137, 0, 0, 122, 795, 0, 122, 122, 122, 0, 798, 122, 0, 122, 0, 122, 122, 122, 761, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 506, 251, 0, 122, 0, 148, 0, 0, 0, 0, 0, 0, 0, 143, 148, 136, 0, 0, 0, 0, 0,
  0, 138, 138, 0, 0, 0, 0, 0, 138, 138, 0, 0, 148, 148, 0, 0, 0, 136, 156, 0, 0, 0, 148, 0, 136, 136, 0, 0, 0, 0, 44241,
  0, 0, 44241, 44241, 44241, 44241, 44241, 44241, 44241, 44241, 44241, 0, 0, 143, 156, 0, 136, 136, 136, 136, 136, 0,
  136, 136, 136, 0, 0, 0, 0, 122, 258, 122, 266, 122, 122, 122, 122, 0, 0, 0, 0, 302, 0, 0, 122, 122, 122, 122, 0, 0, 0,
  550, 0, 0, 0, 0, 122, 122, 0, 136, 198, 201, 201, 201, 201, 201, 0, 198, 201, 198, 198, 198, 198, 198, 136, 198, 201,
  136, 136, 0, 0, 0, 0, 0, 136, 136, 136, 136, 136, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 239, 0, 0, 0,
  239, 239, 239, 239, 239, 122, 0, 122, 122, 122, 122, 122, 122, 122, 265, 122, 122, 251, 252, 122, 122, 122, 122, 122,
  297, 0, 0, 0, 0, 0, 0, 0, 122, 282, 122, 122, 0, 0, 0, 636, 0, 0, 0, 122, 122, 122, 640, 122, 122, 122, 331, 122, 122,
  122, 122, 122, 338, 0, 0, 122, 122, 122, 338, 190, 343, 0, 0, 0, 0, 46302, 0, 0, 46302, 46302, 46309, 46309, 46309,
  46309, 46309, 46309, 46309, 0, 0, 122, 122, 282, 122, 122, 338, 122, 122, 122, 0, 0, 0, 0, 0, 696, 122, 122, 0, 0, 0,
  0, 122, 122, 388, 389, 122, 122, 122, 122, 122, 122, 394, 122, 122, 122, 122, 122, 122, 399, 122, 401, 122, 122, 122,
  122, 122, 407, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 604, 122, 122, 122, 122, 122, 122, 0, 421, 0, 0, 0,
  0, 426, 122, 0, 0, 430, 0, 432, 0, 0, 0, 0, 147, 0, 127, 127, 0, 0, 0, 0, 0, 127, 127, 0, 122, 452, 122, 122, 122, 0,
  0, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 373, 122, 122, 122, 122, 0, 0, 474, 190, 0, 343, 0, 0, 0, 0, 0,
  122, 122, 122, 122, 122, 122, 0, 122, 122, 122, 122, 733, 485, 122, 122, 122, 122, 0, 0, 0, 0, 0, 122, 0, 399, 122,
  122, 122, 122, 439, 0, 0, 0, 443, 0, 0, 446, 447, 122, 122, 122, 122, 388, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0,
  0, 0, 122, 122, 0, 628, 0, 0, 0, 0, 0, 122, 122, 122, 122, 122, 122, 284, 122, 0, 0, 0, 0, 0, 122, 122, 627, 0, 0, 0,
  0, 0, 0, 122, 122, 122, 122, 122, 122, 792, 122, 794, 122, 122, 122, 122, 122, 122, 497, 122, 122, 122, 122, 389, 122,
  122, 505, 122, 251, 0, 507, 571, 122, 122, 122, 575, 122, 122, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0, 2529, 122, 122, 122,
  122, 596, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 527, 122, 122, 122, 270, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 289, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 0, 0, 0, 122,
  122, 122, 122, 0, 0, 0, 122, 122, 0, 0, 702, 0, 0, 0, 706, 122, 122, 122, 709, 122, 122, 712, 713, 0, 0, 0, 122, 122,
  122, 122, 122, 0, 122, 122, 724, 122, 122, 122, 122, 455, 0, 0, 0, 459, 0, 0, 122, 122, 122, 122, 468, 0, 122, 122,
  739, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 747, 0, 0, 0, 0, 48492, 141312, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 0, 0, 122, 122, 122, 752, 122, 122, 0, 0, 0, 0, 122, 122, 122, 122, 122, 0, 122, 122,
  122, 122, 122, 122, 0, 122, 0, 0, 0, 0, 0, 122, 770, 0, 0, 0, 773, 122, 122, 122, 122, 498, 437, 122, 501, 122, 122,
  122, 122, 122, 251, 0, 122, 787, 0, 0, 0, 122, 122, 122, 122, 791, 122, 0, 793, 122, 122, 122, 122, 122, 392, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 733, 122, 122, 122, 122, 122, 122, 276, 279, 122, 283, 122,
  122, 122, 0, 0, 0, 293, 0, 0, 0, 0, 153, 0, 126, 126, 0, 0, 0, 0, 0, 126, 126, 0, 122, 283, 0, 0, 0, 0, 0, 0, 0, 276,
  306, 122, 122, 0, 0, 0, 703, 704, 705, 0, 122, 122, 122, 122, 710, 711, 122, 0, 0, 122, 351, 306, 122, 276, 283, 122,
  122, 122, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 122, 122, 0, 0, 122, 475, 0, 478, 0, 0,
  0, 0, 0, 122, 122, 484, 122, 122, 388, 122, 122, 0, 0, 0, 0, 0, 122, 0, 122, 122, 122, 122, 122, 405, 122, 122, 408,
  122, 122, 122, 122, 122, 122, 122, 0, 0, 122, 580, 0, 0, 581, 5600, 5600, 450, 122, 122, 122, 122, 122, 484, 122, 122,
  122, 122, 122, 122, 251, 0, 122, 0, 0, 0, 0, 0, 122, 0, 0, 771, 0, 122, 122, 122, 774, 595, 122, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 122, 607, 0, 0, 0, 137, 0, 137, 137, 137, 137, 172, 0, 137, 137, 137, 0, 0, 0,
  0, 214, 0, 0, 214, 214, 17622, 17622, 17622, 17622, 17622, 17622, 17622, 0, 137, 172, 202, 202, 203, 203, 203, 0, 172,
  203, 172, 172, 172, 172, 172, 137, 172, 203, 137, 137, 0, 0, 0, 0, 0, 137, 137, 137, 137, 137, 137, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 33792, 33792, 0, 33792, 0, 172, 0, 0, 0, 172, 172, 172, 172, 172, 122, 0, 122, 122, 122,
  122, 122, 122, 122, 515, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 411, 122, 122, 122, 122, 122, 122, 122,
  122, 521, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 618, 122, 122, 122, 122, 122, 574, 122,
  122, 122, 0, 0, 122, 0, 0, 0, 0, 0, 0, 398, 122, 0, 0, 0, 0, 0, 0, 434, 144, 0, 0, 138, 138, 138, 138, 138, 138, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54272, 0, 0, 0, 54272, 0, 0, 0, 138, 0, 138, 138, 138, 138, 138, 0, 138, 138,
  138, 0, 0, 0, 0, 216, 0, 0, 216, 216, 24792, 24792, 24792, 24792, 24792, 24792, 24792, 0, 138, 138, 138, 138, 138,
  138, 138, 0, 138, 138, 138, 138, 138, 138, 138, 138, 138, 0, 0, 0, 0, 0, 138, 138, 240, 0, 0, 0, 240, 240, 240, 240,
  240, 122, 0, 122, 122, 122, 122, 122, 122, 122, 562, 0, 0, 0, 566, 0, 568, 0, 122, 122, 284, 0, 0, 0, 0, 0, 0, 0, 122,
  284, 122, 122, 0, 0, 0, 122, 122, 122, 122, 122, 122, 0, 122, 122, 122, 122, 122, 122, 122, 589, 0, 122, 591, 122,
  122, 594, 122, 0, 0, 122, 122, 284, 122, 122, 284, 122, 122, 122, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 631, 0, 0, 122,
  122, 0, 0, 422, 0, 0, 0, 122, 122, 0, 0, 0, 0, 0, 0, 0, 122, 122, 122, 308, 0, 0, 0, 435, 122, 122, 122, 0, 0, 0, 0,
  0, 0, 0, 0, 122, 122, 122, 122, 122, 0, 722, 122, 122, 122, 122, 122, 122, 122, 122, 122, 674, 122, 122, 122, 122,
  122, 122, 122, 122, 122, 122, 122, 122, 526, 122, 122, 122, 0, 122, 122, 265, 122, 122, 122, 0, 0, 122, 122, 122, 122,
  190, 343, 0, 0, 0, 0, 52224, 0, 0, 52224, 52224, 52224, 52224, 52224, 52224, 52224, 52224, 52224, 122, 285, 0, 0, 0,
  0, 0, 0, 0, 122, 285, 122, 122, 310, 0, 0, 0, 0, 221, 0, 39936, 221, 40157, 40164, 40164, 40164, 40164, 40164, 40164,
  40164, 0, 0, 122, 122, 285, 122, 122, 354, 122, 122, 122, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0, 630, 0, 0, 0, 122, 122,
  122, 270, 122, 122, 0, 0, 0, 0, 0, 122, 0, 122, 122, 122, 122, 122, 576, 122, 0, 0, 122, 0, 0, 0, 0, 0, 0, 122, 122,
  0, 0, 0, 431, 0, 0, 0, 0, 122, 122, 0, 0, 740, 0, 0, 0, 0, 122, 122, 0, 0, 0, 0, 0, 0, 150, 0, 0, 0, 0, 129, 0, 0, 0,
  0, 0, 0, 131, 131, 0, 0, 0, 0, 0, 131, 131, 0, 0, 122, 0, 0, 122, 796, 122, 0, 122, 122, 0, 122, 0, 122, 122, 122,
  122, 522, 122, 122, 122, 523, 122, 122, 389, 122, 122, 122, 122, 122, 122, 600, 122, 122, 603, 122, 122, 122, 122,
  122, 122, 122, 0, 0, 535, 580, 0, 0, 581, 0, 0, 108544, 108544, 0, 108544, 108544, 108544, 0, 108544, 108544, 0, 0, 0,
  0, 0, 0, 0, 0, 109780, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 128, 0, 0, 0, 0, 108544, 0, 0, 108544, 108544, 108544,
  108544, 108544, 108544, 141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 0, 109793, 0, 0, 109793, 109793,
  109793, 109793, 109793, 109793, 109793, 109793, 109793, 0, 109793, 109793, 109793, 0, 0, 0, 0, 0, 141312, 0, 141312,
  141312, 141312, 141312, 141312, 0, 0, 0, 111616, 141312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 0, 0, 0, 360, 0,
  0, 0, 0, 141312, 0, 0, 0, 0, 0, 0, 252, 0, 0, 0, 141312, 111616, 0, 0, 0, 0, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 141312, 141312, 112640, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26830, 26830, 0,
  26830, 26830, 26830, 26830, 26830, 0, 0, 0, 112640, 112640, 0, 0, 112640, 0, 0, 112640, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 112640, 112640, 0, 0, 112640, 112640, 112640, 112640, 112640, 112640, 0, 0, 0, 112640, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 112640, 0, 112640, 0, 0, 112640, 0, 0, 0, 0, 112640, 0, 0, 112640, 112640, 112640, 112640, 112640, 112640,
  112640, 112640, 141312, 0, 141312, 141312, 141312, 141312, 141312, 0, 0, 113664, 0, 0, 0, 0, 0, 0, 113664, 0, 113664,
  113664, 113664, 113664, 113664, 0, 113664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30927, 30927, 0, 30927, 30927, 30927, 30927,
  30927, 113664, 0, 0, 0, 113664, 113664, 113664, 113664, 113664, 141312, 0, 141312, 141312, 141312, 141312, 141312,
  14336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33792, 0, 0, 0, 0, 33792, 0, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  201, 207, 203, 211, 215, 219, 223, 227, 284, 237, 334, 244, 248, 480, 252, 281, 315, 315, 262, 256, 230, 275, 290,
  316, 315, 315, 294, 323, 307, 233, 278, 315, 315, 300, 286, 304, 311, 315, 254, 320, 286, 328, 315, 296, 326, 314,
  332, 338, 258, 342, 240, 577, 346, 350, 354, 358, 362, 366, 724, 395, 271, 432, 517, 378, 369, 382, 517, 517, 389,
  399, 403, 517, 385, 441, 517, 517, 407, 411, 415, 453, 555, 268, 517, 422, 426, 430, 517, 436, 683, 418, 445, 518,
  439, 598, 447, 517, 702, 517, 452, 517, 448, 392, 458, 465, 461, 469, 473, 477, 627, 484, 488, 492, 539, 553, 496,
  500, 517, 517, 503, 507, 509, 513, 522, 526, 517, 517, 542, 530, 532, 536, 546, 550, 517, 559, 563, 567, 571, 581,
  454, 585, 588, 592, 596, 602, 606, 574, 610, 614, 618, 622, 626, 631, 637, 641, 645, 649, 653, 657, 517, 667, 678,
  517, 730, 671, 677, 682, 517, 517, 689, 687, 515, 517, 693, 699, 517, 517, 673, 706, 695, 517, 663, 372, 517, 711,
  707, 516, 662, 265, 517, 715, 517, 717, 660, 722, 517, 728, 517, 718, 374, 633, 265, 734, 745, 745, 745, 746, 777,
  738, 749, 775, 742, 744, 747, 753, 766, 769, 748, 772, 781, 784, 787, 791, 797, 795, 801, 804, 808, 812, 816, 819,
  1387, 822, 1287, 833, 1388, 883, 845, 1389, 1395, 1386, 1390, 1160, 892, 1394, 831, 1388, 1386, 884, 840, 1387, 879,
  1217, 853, 867, 1387, 1387, 1387, 1395, 1395, 1387, 1384, 1387, 1390, 1287, 1390, 1395, 825, 1225, 1395, 859, 1075,
  1395, 1003, 1395, 1285, 1389, 843, 874, 878, 1387, 1382, 869, 870, 835, 1387, 1387, 1389, 1395, 1386, 1387, 1387,
  1390, 1288, 868, 1388, 1395, 1383, 1395, 1382, 1395, 1390, 1382, 1395, 1287, 822, 1395, 831, 1387, 1388, 824, 1287,
  1290, 1163, 1387, 888, 1387, 1387, 1387, 1387, 836, 1389, 1395, 1389, 1382, 1389, 1395, 1382, 1387, 1078, 1387, 1385,
  869, 1289, 1287, 1395, 1387, 1387, 823, 1385, 1385, 1387, 1384, 1289, 1388, 1384, 1386, 925, 910, 1395, 922, 928, 932,
  1364, 936, 940, 943, 947, 951, 954, 961, 965, 957, 969, 973, 977, 981, 985, 988, 991, 1395, 1025, 1031, 1395, 1049,
  1395, 1395, 1298, 824, 1154, 1395, 825, 1015, 1037, 1027, 856, 1395, 1064, 1046, 1053, 1392, 1395, 1395, 1076, 1395,
  1094, 1395, 1075, 860, 1220, 861, 995, 1395, 1228, 1395, 1284, 1395, 1285, 1395, 1394, 1395, 1074, 859, 993, 997,
  1226, 997, 1395, 1286, 1395, 1075, 993, 1226, 1392, 1395, 1073, 858, 993, 997, 1227, 1032, 1284, 1395, 1283, 1395,
  999, 1395, 1055, 858, 1074, 1395, 1075, 1395, 1395, 860, 1062, 1283, 1395, 1283, 1395, 1395, 1395, 1180, 1284, 1285,
  1395, 1395, 1395, 1063, 826, 1075, 1315, 1395, 1098, 1100, 1104, 1265, 1199, 1082, 1088, 1108, 1120, 1122, 1112, 1113,
  1117, 1126, 1134, 1136, 1140, 1144, 1395, 1169, 849, 1287, 1093, 917, 1366, 1076, 1441, 1409, 1442, 1056, 1151, 863,
  1173, 1189, 1374, 1057, 1325, 1232, 1396, 1236, 1246, 1395, 1182, 914, 1275, 1367, 1395, 1441, 1409, 1250, 1339, 1336,
  1021, 1395, 1077, 1395, 1395, 1395, 1395, 1054, 1254, 1395, 1129, 1322, 1326, 1258, 825, 1042, 1277, 1183, 1298, 1443,
  862, 1009, 1263, 1008, 1020, 1395, 1196, 1203, 1395, 1180, 1184, 916, 1077, 1254, 1058, 1128, 1269, 1395, 1041, 1395,
  1211, 1395, 1395, 903, 1054, 1395, 1273, 915, 1276, 1075, 1298, 1408, 1440, 1409, 1453, 1011, 1006, 1018, 895, 1254,
  1347, 1308, 1223, 1395, 1214, 1084, 900, 1324, 1259, 1040, 1282, 913, 917, 1316, 1192, 1453, 1011, 1007, 1019, 896,
  1346, 1128, 1310, 827, 1395, 1395, 1068, 1285, 1185, 1304, 1278, 1147, 1010, 1007, 1019, 906, 1185, 1314, 1130, 1333,
  1455, 1346, 1350, 1225, 1320, 1330, 1345, 1349, 1185, 1357, 1348, 1354, 1361, 1395, 1395, 1395, 1181, 1205, 1380,
  1395, 1395, 1091, 1395, 1242, 1371, 1385, 1239, 1241, 1378, 1166, 1405, 1402, 1157, 1395, 1293, 1395, 1413, 1417,
  1421, 1424, 1431, 1427, 756, 1435, 759, 762, 1395, 1224, 1395, 1395, 1341, 1300, 1395, 1206, 1295, 1395, 1397, 1395,
  1373, 1395, 1395, 1205, 1294, 1033, 1395, 1395, 1395, 1291, 1450, 1395, 1395, 1395, 1393, 1395, 1398, 1395, 1395,
  1207, 1296, 1341, 1176, 1395, 1395, 1292, 1395, 1395, 1395, 1447, 1395, 1226, 1071, 1285, 1395, 1396, 1395, 1395,
  1395, 1395, 1396, 1225, 1297, 918, 1295, 1395, 1395, 1299, 1395, 1395, 1395, 1294, 1395, 1395, 1391, 1395, 1300, 1395,
  1395, 1395, 1439, 1178, 7680, 2104320, 4201472, 8395776, 7168, 7168, 7168, 8396288, 272636928, 268442624, 268442624,
  7168, 7168, 7168, 7168, 7680, 7680, 7680, 7680, 268442624, 268442624, 268442624, 7168, 7168, 7168, 15360, 15360,
  15872, 25459, 25459, 25459, 25459, 7168, 2104832, 268443136, 270539776, 272636928, 7168, 7680, 7680, 7296, 7680,
  2104320, 2104320, 2104320, 4201472, 268442624, 4201984, 7808, 15488, 15488, 7808, 2121342, 7808, 7808, 7808, 7808,
  1726848000, 1713397374, 7808, 1717591678, 1713397374, 1717591678, 1713397374, 1713397374, 1713397374, 1713397374,
  -1721852416, 1981832830, 274734720, -1719755264, -274752512, -268461056, -272655360, -1142973440, -272655360,
  -4219392, -272654848, 1713397630, -2122752, -25600, -2122752, 1713397758, 1713397758, 1713397758, 1713397758, 512,
  6144, 512, 0, 128, 0, 0, 0, 2, 0, 384, 0, 512, 512, 640, 512, 512, 2048, 4096, 512, 30, 20, 512, 512, 64, 32, 32, 16,
  16, 134217728, -2147483648, 0, 6144, 0, 201326592, -1073741824, 0, -268435456, 0, 0, 0, 268435456, 0, 0, 0, 128,
  31457280, 0, 512, 768, 512, 512, 512, 640, 16, 24, 16, 16, 2, 512, 512, 512, 32768, 0, 512, 64, 32, 16, 0, 512, 512,
  768, 64, 1024, 4096, 2097152, 0, 0, 64, 262144, 1048576, 0, 32, 0, 0, 131072, 0, 0, 262144, -2147483648, 64, 1049600,
  1048576, 536870912, 0, 65536, 134217728, 2, 0, 0, 256, 0, 1048577, 1048577, 1049600, 1048577, 32, 32, 32, 4096,
  1048608, 32, 64, 268435456, 0, 524320, 1048608, 64, 1048641, 524320, 1049632, 32, 1049632, -2147483584, 1241513984,
  1241513984, 1241514048, 1241518080, 1241776128, 1241513984, -2130182144, 1242038272, 1242038272, -2130182144,
  -2130182112, -2130182112, -888668160, 1241513984, 1241514016, 1243611136, 1241513984, -888668160, -888668128,
  -888668096, -888668096, -888668064, 5603013, 1241513984, -888668064, 1242038272, 1241513984, 1242038272, 1242038304,
  1242038272, 16162106, 1242038272, -888668063, 16162107, 16162171, 14155757, 14155725, 14155757, 15204348, 14155773,
  14155757, 14155773, 1308622880, 16252925, 16252925, -821559264, -821559200, -553123808, -16252896, 0, 0, -2147483648,
  33554432, 134217728, 1073741824, 0, 0, -1073741824, 0, 0, 167772160, 1073741824, 0, 0, 2097152, 4194304, 8388608,
  16777216, 134217728, 268435456, 128, 8, 256, 163840, 8388608, 16777216, 268435456, 8192, 2097152, 98304, 0, 896,
  253952, 0, 0, -805306368, 0, 234881024, 1073741824, 0, 0, 0, 6144, 0, 16777216, -1073741824, 0, 2, 16, 0, 384, 0, 2,
  256, 163840, 0, 2, 32, 256, 229376, 0, 0, 67108864, 0, 0, 0, 16384, 0, 805306368, 0, 0, 0, 65536, 0, 0, 33554432, 0,
  33554432, 16777216, 0, 0, 0, 536870912, 0, 0, 0, 64, 32, 0, 537395200, 0, 0, 1, 64, 536870944, 0, 4128, 0, 8, 0, 0,
  65536, 134217728, 0, 537395200, 537395200, 67273224, 67273224, 67273224, 67273224, 432078976, 67273352, 67273352,
  434176128, 432078976, 432087168, 434184320, 499352200, -1647869304, 605717064, 605717064, 605717064, 605717064,
  605717192, 605717064, 4096, 605717064, -1647869304, -1647869304, -1647869304, 16384, 605717064, -1645772152, 4096,
  4096, 16384, 0, 0, 0, 4194304, 16384, 16384, 16384, 16384, -434467251, 16384, 16384, 16384, -2388275, -2388275,
  -2388273, -2388257, -2388001, 0, 8, 0, 4194304, 128, 29360128, 402653184, 640, 2048, 90112, 0, 1, 1, 0, 1, 16, 32,
  512, 512, 512, 8192, 1, 512, 131072, 1572864, 16777216, 402653184, 73728, 31457280, 0, 8, 128, 192, 0, 0, 65536,
  524288, 536870912, 0, 0, 65536, 65536, 98304, 29360128, 469762048, 0, 8, 512, 67108864, 576, 1572864, 603979776, 0,
  32, 2, 4128, 262144, -1677721600, 0, 0, 1, 256, 0, 0, 16384, 0, 704, 0, 32, 64, 524288, 67108864, 1073741824, 0,
  -2147483648, 167772160, 1073741824, 2, 256, 0, 0, 0, 33554432, 134217728, 1073741824, 1600, 34816, 33554432,
  -469762048, 1728, 100352, -67108864, 1, 516, 0, 0, 8192, 0, 0, 14, 16, 1, 1984, 0, 128, 12582912, 16777216, 1048576,
  0, 262144, -2147483648, 2048, 33554432, 1073741824, 0, 0, 268435456, 128, 0, 0, 32, 0, 1, 1024, 33554432, 1073741824,
  65536, 536870912, 0, 0, 256, 32, 4096, 0, 8, 384, 0, 0, 0, 16777216, 0, 0, 0, 512, 0, 0, 64, 0, 0, 0, 4, 0, 0, 0, 8,
  128, 0, 134217728, 2, 0, 256, 16384, 0, 1, 33554432, 1073741824, 0, 2, 256, 32, 4096, 536870912, 0, 65536, 65536,
  4096, 0, 16384, 0, 0, 1, 12, 1024, 8388608, 268435456, 0, 8388608, 268435456, 0, 2097152, 12582912, 16777216,
  402653184, 128, 0, 0, 16, 0, 268435456, -2147483648, 0, 0, 16384, 4096, 16384, 1, 2, 4096, -2147483648, 16384, 4096,
  8388608, 8388608, -2147483648, 16384, -2147483648, -2147483648, 0, 33, 32, 4096, 0, 524288, 536870912, 4, 8192, 0, 0,
  4096, 0, 0, 4, 516, 512, 8192, 0, 0, 512, 512, 0, 512, 512, 512, 512, 0, 0, 0, -2147483648, 0, 0, 0, 0, 1, 0, 0, 0,
  8192, 0, 8704, 0, 516, 512, 131072, 67108864, 0, 0, 0, 16465, 8328, 8328, 200, 712, 8392, 5120, 16465, 8904, 16465,
  16465, 16977, 16977, 25169, 8392, 15872, 15872, 16977, 16465, 25169, 15872, 7168, 7168, 7168, 17267, 17, 0, 0, 8, 512,
  32768, 131072, 67108864, 3, 48, 256, 0, 51, 256, 0, 128, 4194304, 8388608, 268435456, 2097152
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "%ERROR",
  "HexLiteral",
  "DecimalLiteral",
  "OctalLiteral",
  "FloatingPointLiteral",
  "CharacterLiteral",
  "StringLiteral",
  "'enum'",
  "'assert'",
  "Identifier",
  "WS",
  "COMMENT",
  "LINE_COMMENT",
  "EOF",
  "'!'",
  "'!='",
  "'%'",
  "'%='",
  "'&amp;'",
  "'&amp;&amp;'",
  "'&amp;='",
  "'('",
  "')'",
  "'*'",
  "'*='",
  "'+'",
  "'++'",
  "'+='",
  "','",
  "'-'",
  "'--'",
  "'-='",
  "'.'",
  "'...'",
  "'/'",
  "'/='",
  "':'",
  "';'",
  "'<'",
  "'<<'",
  "'<<='",
  "'<='",
  "'='",
  "'=='",
  "'>'",
  "'>='",
  "'>>'",
  "'>>='",
  "'>>>'",
  "'>>>='",
  "'?'",
  "'@'",
  "'['",
  "']'",
  "'^'",
  "'^='",
  "'abstract'",
  "'boolean'",
  "'break'",
  "'byte'",
  "'case'",
  "'catch'",
  "'char'",
  "'class'",
  "'continue'",
  "'default'",
  "'do'",
  "'double'",
  "'else'",
  "'extends'",
  "'false'",
  "'final'",
  "'finally'",
  "'float'",
  "'for'",
  "'if'",
  "'implements'",
  "'import'",
  "'instanceof'",
  "'int'",
  "'interface'",
  "'long'",
  "'native'",
  "'new'",
  "'null'",
  "'package'",
  "'private'",
  "'protected'",
  "'public'",
  "'return'",
  "'short'",
  "'static'",
  "'strictfp'",
  "'super'",
  "'switch'",
  "'synchronized'",
  "'this'",
  "'throw'",
  "'throws'",
  "'transient'",
  "'true'",
  "'try'",
  "'void'",
  "'volatile'",
  "'while'",
  "'{'",
  "'|'",
  "'|='",
  "'||'",
  "'}'",
  "'~'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 1024,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 1024
    let $end := $end - $result idiv 128
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 128 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 4)
    let $current := $current + 1
    let $i0 := 1024 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 1023) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 3
    let $i0 := $t * 801 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[4 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[8 + $m]
};

(:~
 : Parse typeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classOrInterfaceDeclaration($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "typeDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing typeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classOrInterfaceDeclaration($input, $state)
      return $state
  return $state
};

(:~
 : Parse importDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-importDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(77, $input, $state)               (: 'import' :)
  let $state := p:lookahead1W(24, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | 'static' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'static' :)
      let $state := p:consume(91, $input, $state)           (: 'static' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-qualifiedName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 32) then                       (: '.' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(3, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '*' :)
      let $state := p:consume(23, $input, $state)           (: '*' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(6, $input, $state)            (: WS | COMMENT | LINE_COMMENT | ';' :)
  let $state := p:consume(37, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "importDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing importDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-importDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(77, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(24, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | 'static' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'static' :)
      let $state := p:consumeT(91, $input, $state)          (: 'static' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-qualifiedName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 32) then                       (: '.' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(3, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '*' :)
      let $state := p:consumeT(23, $input, $state)          (: '*' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(6, $input, $state)            (: WS | COMMENT | LINE_COMMENT | ';' :)
  let $state := p:consumeT(37, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse packageDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-packageDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(85, $input, $state)               (: 'package' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-qualifiedName($input, $state)
  let $state := p:consume(37, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "packageDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing packageDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-packageDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(85, $input, $state)              (: 'package' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-qualifiedName($input, $state)
  let $state := p:consumeT(37, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse the 1st loop of production elementValueArrayInitializer (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementValueArrayInitializer-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 28) then                         (: ',' :)
        let $state := p:lookahead2W(99, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '@' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '{' | '}' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 109                               (: '}' :)
       or $state[$p:lk] = 13980) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consume(28, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(95, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '@' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-elementValue($input, $state)
        return p:parse-elementValueArrayInitializer-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production elementValueArrayInitializer (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementValueArrayInitializer-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 28) then                         (: ',' :)
        let $state := p:lookahead2W(99, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '@' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '{' | '}' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 109                               (: '}' :)
       or $state[$p:lk] = 13980) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consumeT(28, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(95, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '@' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '{' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-elementValue($input, $state)
        return p:try-elementValueArrayInitializer-1($input, $state)
};

(:~
 : Parse elementValueArrayInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementValueArrayInitializer($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(101, $input, $state)          (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | ',' | '-' | '--' | '@' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'false' | 'float' | 'int' |
                                                               'long' | 'new' | 'null' | 'short' | 'super' | 'this' |
                                                               'true' | 'void' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 28                            (: ',' :)
         and $state[$p:l1] != 109) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-elementValue($input, $state)
      let $state := p:parse-elementValueArrayInitializer-1($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: ',' :)
      let $state := p:consume(28, $input, $state)           (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(18, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '}' :)
  let $state := p:consume(109, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "elementValueArrayInitializer", $count, $begin, $end)
};

(:~
 : Try parsing elementValueArrayInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementValueArrayInitializer($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(105, $input, $state)             (: '{' :)
  let $state := p:lookahead1W(101, $input, $state)          (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | ',' | '-' | '--' | '@' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'false' | 'float' | 'int' |
                                                               'long' | 'new' | 'null' | 'short' | 'super' | 'this' |
                                                               'true' | 'void' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 28                            (: ',' :)
         and $state[$p:l1] != 109) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-elementValue($input, $state)
      let $state := p:try-elementValueArrayInitializer-1($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: ',' :)
      let $state := p:consumeT(28, $input, $state)          (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(18, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '}' :)
  let $state := p:consumeT(109, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse relationalOp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-relationalOp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 41) then                       (: '<=' :)
      let $state := p:consume(41, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 45) then                       (: '>=' :)
      let $state := p:consume(45, $input, $state)           (: '>=' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state := p:consume(38, $input, $state)           (: '<' :)
      return $state
    else
      let $state := p:consume(44, $input, $state)           (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "relationalOp", $count, $begin, $end)
};

(:~
 : Try parsing relationalOp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-relationalOp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 41) then                       (: '<=' :)
      let $state := p:consumeT(41, $input, $state)          (: '<=' :)
      return $state
    else if ($state[$p:l1] = 45) then                       (: '>=' :)
      let $state := p:consumeT(45, $input, $state)          (: '>=' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state := p:consumeT(38, $input, $state)          (: '<' :)
      return $state
    else
      let $state := p:consumeT(44, $input, $state)          (: '>' :)
      return $state
  return $state
};

(:~
 : Parse shiftOp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-shiftOp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39) then                       (: '<<' :)
      let $state := p:consume(39, $input, $state)           (: '<<' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: '>>>' :)
      let $state := p:consume(48, $input, $state)           (: '>>>' :)
      return $state
    else
      let $state := p:consume(46, $input, $state)           (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "shiftOp", $count, $begin, $end)
};

(:~
 : Try parsing shiftOp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-shiftOp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39) then                       (: '<<' :)
      let $state := p:consumeT(39, $input, $state)          (: '<<' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: '>>>' :)
      let $state := p:consumeT(48, $input, $state)          (: '>>>' :)
      return $state
    else
      let $state := p:consumeT(46, $input, $state)          (: '>>' :)
      return $state
  return $state
};

(:~
 : Parse selector.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-selector($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 32) then                           (: '.' :)
      let $state := p:lookahead2W(55, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'new' |
                                                               'super' | 'this' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1184) then                     (: '.' Identifier :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(114, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: '(' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-arguments($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:lk] = 12320) then                    (: '.' 'this' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(15, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'this' :)
      let $state := p:consume(96, $input, $state)           (: 'this' :)
      return $state
    else if ($state[$p:lk] = 11936) then                    (: '.' 'super' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(14, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'super' :)
      let $state := p:consume(93, $input, $state)           (: 'super' :)
      let $state := p:lookahead1W(25, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-superSuffix($input, $state)
      return $state
    else if ($state[$p:lk] = 10656) then                    (: '.' 'new' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(13, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'new' :)
      let $state := p:consume(83, $input, $state)           (: 'new' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-innerCreator($input, $state)
      return $state
    else
      let $state := p:consume(52, $input, $state)           (: '[' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      let $state := p:consume(53, $input, $state)           (: ']' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "selector", $count, $begin, $end)
};

(:~
 : Try parsing selector.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-selector($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 32) then                           (: '.' :)
      let $state := p:lookahead2W(55, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'new' |
                                                               'super' | 'this' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1184) then                     (: '.' Identifier :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:lookahead1W(114, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-arguments($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:lk] = 12320) then                    (: '.' 'this' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(15, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'this' :)
      let $state := p:consumeT(96, $input, $state)          (: 'this' :)
      return $state
    else if ($state[$p:lk] = 11936) then                    (: '.' 'super' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(14, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'super' :)
      let $state := p:consumeT(93, $input, $state)          (: 'super' :)
      let $state := p:lookahead1W(25, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-superSuffix($input, $state)
      return $state
    else if ($state[$p:lk] = 10656) then                    (: '.' 'new' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(13, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'new' :)
      let $state := p:consumeT(83, $input, $state)          (: 'new' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-innerCreator($input, $state)
      return $state
    else
      let $state := p:consumeT(52, $input, $state)          (: '[' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      let $state := p:consumeT(53, $input, $state)          (: ']' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production arrayCreatorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-arrayCreatorRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: WS | COMMENT | LINE_COMMENT | '[' | '{' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-arrayCreatorRest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production arrayCreatorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-arrayCreatorRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: WS | COMMENT | LINE_COMMENT | '[' | '{' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-arrayCreatorRest-1($input, $state)
};

(:~
 : Parse the 2nd loop of production arrayCreatorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-arrayCreatorRest-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 52) then                         (: '[' :)
        let $state := p:lookahead2W(93, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 180                          (: '[' HexLiteral :)
            or $state[$p:lk] = 308                          (: '[' DecimalLiteral :)
            or $state[$p:lk] = 436                          (: '[' OctalLiteral :)
            or $state[$p:lk] = 564                          (: '[' FloatingPointLiteral :)
            or $state[$p:lk] = 692                          (: '[' CharacterLiteral :)
            or $state[$p:lk] = 820                          (: '[' StringLiteral :)
            or $state[$p:lk] = 1204                         (: '[' Identifier :)
            or $state[$p:lk] = 1844                         (: '[' '!' :)
            or $state[$p:lk] = 2740                         (: '[' '(' :)
            or $state[$p:lk] = 3252                         (: '[' '+' :)
            or $state[$p:lk] = 3380                         (: '[' '++' :)
            or $state[$p:lk] = 3764                         (: '[' '-' :)
            or $state[$p:lk] = 3892                         (: '[' '--' :)
            or $state[$p:lk] = 7348                         (: '[' 'boolean' :)
            or $state[$p:lk] = 7604                         (: '[' 'byte' :)
            or $state[$p:lk] = 7988                         (: '[' 'char' :)
            or $state[$p:lk] = 8628                         (: '[' 'double' :)
            or $state[$p:lk] = 9012                         (: '[' 'false' :)
            or $state[$p:lk] = 9396                         (: '[' 'float' :)
            or $state[$p:lk] = 10164                        (: '[' 'int' :)
            or $state[$p:lk] = 10420                        (: '[' 'long' :)
            or $state[$p:lk] = 10676                        (: '[' 'new' :)
            or $state[$p:lk] = 10804                        (: '[' 'null' :)
            or $state[$p:lk] = 11572                        (: '[' 'short' :)
            or $state[$p:lk] = 11956                        (: '[' 'super' :)
            or $state[$p:lk] = 12340                        (: '[' 'this' :)
            or $state[$p:lk] = 12852                        (: '[' 'true' :)
            or $state[$p:lk] = 13108                        (: '[' 'void' :)
            or $state[$p:lk] = 14132) then                  (: '[' '~' :)
        let $state := p:memoized($state, 20)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(52, $input, $state)    (: '[' :)
            let $state := p:lookahead1W(89, $input, $state) (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-expression($input, $state)
            let $state := p:consumeT(53, $input, $state)    (: ']' :)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(89, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-expression($input, $state)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-arrayCreatorRest-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production arrayCreatorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-arrayCreatorRest-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 52) then                         (: '[' :)
        let $state := p:lookahead2W(93, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 180                          (: '[' HexLiteral :)
            or $state[$p:lk] = 308                          (: '[' DecimalLiteral :)
            or $state[$p:lk] = 436                          (: '[' OctalLiteral :)
            or $state[$p:lk] = 564                          (: '[' FloatingPointLiteral :)
            or $state[$p:lk] = 692                          (: '[' CharacterLiteral :)
            or $state[$p:lk] = 820                          (: '[' StringLiteral :)
            or $state[$p:lk] = 1204                         (: '[' Identifier :)
            or $state[$p:lk] = 1844                         (: '[' '!' :)
            or $state[$p:lk] = 2740                         (: '[' '(' :)
            or $state[$p:lk] = 3252                         (: '[' '+' :)
            or $state[$p:lk] = 3380                         (: '[' '++' :)
            or $state[$p:lk] = 3764                         (: '[' '-' :)
            or $state[$p:lk] = 3892                         (: '[' '--' :)
            or $state[$p:lk] = 7348                         (: '[' 'boolean' :)
            or $state[$p:lk] = 7604                         (: '[' 'byte' :)
            or $state[$p:lk] = 7988                         (: '[' 'char' :)
            or $state[$p:lk] = 8628                         (: '[' 'double' :)
            or $state[$p:lk] = 9012                         (: '[' 'false' :)
            or $state[$p:lk] = 9396                         (: '[' 'float' :)
            or $state[$p:lk] = 10164                        (: '[' 'int' :)
            or $state[$p:lk] = 10420                        (: '[' 'long' :)
            or $state[$p:lk] = 10676                        (: '[' 'new' :)
            or $state[$p:lk] = 10804                        (: '[' 'null' :)
            or $state[$p:lk] = 11572                        (: '[' 'short' :)
            or $state[$p:lk] = 11956                        (: '[' 'super' :)
            or $state[$p:lk] = 12340                        (: '[' 'this' :)
            or $state[$p:lk] = 12852                        (: '[' 'true' :)
            or $state[$p:lk] = 13108                        (: '[' 'void' :)
            or $state[$p:lk] = 14132) then                  (: '[' '~' :)
        let $state := p:memoized($state, 20)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(52, $input, $state)    (: '[' :)
            let $state := p:lookahead1W(89, $input, $state) (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-expression($input, $state)
            let $state := p:consumeT(53, $input, $state)    (: ']' :)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 20, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-arrayCreatorRest-2($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(89, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-expression($input, $state)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-arrayCreatorRest-2($input, $state)
};

(:~
 : Parse the 3rd loop of production arrayCreatorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-arrayCreatorRest-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 52) then                         (: '[' :)
        let $state := p:lookahead2W(93, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 6836) then                       (: '[' ']' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-arrayCreatorRest-3($input, $state)
};

(:~
 : Try parsing the 3rd loop of production arrayCreatorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-arrayCreatorRest-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 52) then                         (: '[' :)
        let $state := p:lookahead2W(93, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 6836) then                       (: '[' ']' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-arrayCreatorRest-3($input, $state)
};

(:~
 : Parse arrayCreatorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-arrayCreatorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(52, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(93, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: ']' :)
      let $state := p:consume(53, $input, $state)           (: ']' :)
      let $state := p:parse-arrayCreatorRest-1($input, $state)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-arrayInitializer($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      let $state := p:consume(53, $input, $state)           (: ']' :)
      let $state := p:parse-arrayCreatorRest-2($input, $state)
      let $state := p:parse-arrayCreatorRest-3($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "arrayCreatorRest", $count, $begin, $end)
};

(:~
 : Try parsing arrayCreatorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-arrayCreatorRest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(52, $input, $state)              (: '[' :)
  let $state := p:lookahead1W(93, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: ']' :)
      let $state := p:consumeT(53, $input, $state)          (: ']' :)
      let $state := p:try-arrayCreatorRest-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-arrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      let $state := p:consumeT(53, $input, $state)          (: ']' :)
      let $state := p:try-arrayCreatorRest-2($input, $state)
      let $state := p:try-arrayCreatorRest-3($input, $state)
      return $state
  return $state
};

(:~
 : Parse createdName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-createdName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9) then                        (: Identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classOrInterfaceType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-primitiveType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "createdName", $count, $begin, $end)
};

(:~
 : Try parsing createdName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-createdName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9) then                        (: Identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classOrInterfaceType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-primitiveType($input, $state)
      return $state
  return $state
};

(:~
 : Parse creator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-creator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-nonWildcardTypeArguments($input, $state)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-createdName($input, $state)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classCreatorRest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-createdName($input, $state)
      let $state := p:lookahead1W(27, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 52) then                   (: '[' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-arrayCreatorRest($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-classCreatorRest($input, $state)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "creator", $count, $begin, $end)
};

(:~
 : Try parsing creator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-creator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-nonWildcardTypeArguments($input, $state)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-createdName($input, $state)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classCreatorRest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-createdName($input, $state)
      let $state := p:lookahead1W(27, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 52) then                   (: '[' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-arrayCreatorRest($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-classCreatorRest($input, $state)
          return $state
      return $state
  return $state
};

(:~
 : Parse booleanLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-booleanLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 100) then                      (: 'true' :)
      let $state := p:consume(100, $input, $state)          (: 'true' :)
      return $state
    else
      let $state := p:consume(70, $input, $state)           (: 'false' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "booleanLiteral", $count, $begin, $end)
};

(:~
 : Try parsing booleanLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-booleanLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 100) then                      (: 'true' :)
      let $state := p:consumeT(100, $input, $state)         (: 'true' :)
      return $state
    else
      let $state := p:consumeT(70, $input, $state)          (: 'false' :)
      return $state
  return $state
};

(:~
 : Parse integerLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-integerLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: HexLiteral :)
      let $state := p:consume(1, $input, $state)            (: HexLiteral :)
      return $state
    else if ($state[$p:l1] = 3) then                        (: OctalLiteral :)
      let $state := p:consume(3, $input, $state)            (: OctalLiteral :)
      return $state
    else
      let $state := p:consume(2, $input, $state)            (: DecimalLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "integerLiteral", $count, $begin, $end)
};

(:~
 : Try parsing integerLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-integerLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: HexLiteral :)
      let $state := p:consumeT(1, $input, $state)           (: HexLiteral :)
      return $state
    else if ($state[$p:l1] = 3) then                        (: OctalLiteral :)
      let $state := p:consumeT(3, $input, $state)           (: OctalLiteral :)
      return $state
    else
      let $state := p:consumeT(2, $input, $state)           (: DecimalLiteral :)
      return $state
  return $state
};

(:~
 : Parse literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: FloatingPointLiteral :)
      let $state := p:consume(4, $input, $state)            (: FloatingPointLiteral :)
      return $state
    else if ($state[$p:l1] = 5) then                        (: CharacterLiteral :)
      let $state := p:consume(5, $input, $state)            (: CharacterLiteral :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: StringLiteral :)
      let $state := p:consume(6, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 70                             (: 'false' :)
          or $state[$p:l1] = 100) then                      (: 'true' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-booleanLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'null' :)
      let $state := p:consume(84, $input, $state)           (: 'null' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-integerLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "literal", $count, $begin, $end)
};

(:~
 : Try parsing literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: FloatingPointLiteral :)
      let $state := p:consumeT(4, $input, $state)           (: FloatingPointLiteral :)
      return $state
    else if ($state[$p:l1] = 5) then                        (: CharacterLiteral :)
      let $state := p:consumeT(5, $input, $state)           (: CharacterLiteral :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: StringLiteral :)
      let $state := p:consumeT(6, $input, $state)           (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 70                             (: 'false' :)
          or $state[$p:l1] = 100) then                      (: 'true' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-booleanLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'null' :)
      let $state := p:consumeT(84, $input, $state)          (: 'null' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-integerLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse superSuffix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-superSuffix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-arguments($input, $state)
      return $state
    else
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(114, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: '(' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-arguments($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "superSuffix", $count, $begin, $end)
};

(:~
 : Try parsing superSuffix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-superSuffix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-arguments($input, $state)
      return $state
    else
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:lookahead1W(114, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-arguments($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse voidMethodDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-voidMethodDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-formalParameters($input, $state)
  let $state := p:lookahead1W(50, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ';' | 'throws' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consume(98, $input, $state)           (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-methodBody($input, $state)
      return $state
    else
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "voidMethodDeclaratorRest", $count, $begin, $end)
};

(:~
 : Try parsing voidMethodDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-voidMethodDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-formalParameters($input, $state)
  let $state := p:lookahead1W(50, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ';' | 'throws' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consumeT(98, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-methodBody($input, $state)
      return $state
    else
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse fieldDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-fieldDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableDeclarators($input, $state)
  let $state := p:consume(37, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "fieldDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing fieldDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-fieldDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableDeclarators($input, $state)
  let $state := p:consumeT(37, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse methodDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-methodDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-methodDeclaratorRest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "methodDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing methodDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-methodDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-methodDeclaratorRest($input, $state)
  return $state
};

(:~
 : Parse memberDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-memberDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-type($input, $state)
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(63, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | ',' | ';' | '=' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2697) then                     (: Identifier '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-methodDeclaration($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-fieldDeclaration($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "memberDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing memberDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-memberDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-type($input, $state)
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(63, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | ',' | ';' | '=' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2697) then                     (: Identifier '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-methodDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-fieldDeclaration($input, $state)
      return $state
  return $state
};

(:~
 : Parse explicitConstructorInvocation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-explicitConstructorInvocation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 93) then                           (: 'super' :)
      let $state := p:lookahead2W(25, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' :)
      return $state
    else if ($state[$p:l1] eq 96) then                      (: 'this' :)
      let $state := p:lookahead2W(44, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2781                           (: 'super' '(' :)
          or $state[$p:lk] = 2784) then                     (: 'this' '(' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 38) then               (: '<' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-nonWildcardTypeArguments($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(41, $input, $state)   (: WS | COMMENT | LINE_COMMENT | 'super' | 'this' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 96) then               (: 'this' :)
              let $state := p:consumeT(96, $input, $state)  (: 'this' :)
              return $state
            else
              let $state := p:consumeT(93, $input, $state)  (: 'super' :)
              return $state
          let $state := p:lookahead1W(1, $input, $state)    (: WS | COMMENT | LINE_COMMENT | '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-arguments($input, $state)
          let $state := p:lookahead1W(6, $input, $state)    (: WS | COMMENT | LINE_COMMENT | ';' :)
          let $state := p:consumeT(37, $input, $state)      (: ';' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 38) then                            (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '<' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-nonWildcardTypeArguments($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(41, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'super' | 'this' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 96) then                   (: 'this' :)
          let $state := p:consume(96, $input, $state)       (: 'this' :)
          return $state
        else
          let $state := p:consume(93, $input, $state)       (: 'super' :)
          return $state
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-arguments($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-primary($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '.' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(35, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '<' | 'super' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '<' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-nonWildcardTypeArguments($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(14, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'super' :)
      let $state := p:consume(93, $input, $state)           (: 'super' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-arguments($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "explicitConstructorInvocation", $count, $begin, $end)
};

(:~
 : Try parsing explicitConstructorInvocation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-explicitConstructorInvocation($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 93) then                           (: 'super' :)
      let $state := p:lookahead2W(25, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' :)
      return $state
    else if ($state[$p:l1] eq 96) then                      (: 'this' :)
      let $state := p:lookahead2W(44, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2781                           (: 'super' '(' :)
          or $state[$p:lk] = 2784) then                     (: 'this' '(' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 38) then               (: '<' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-nonWildcardTypeArguments($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(41, $input, $state)   (: WS | COMMENT | LINE_COMMENT | 'super' | 'this' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 96) then               (: 'this' :)
              let $state := p:consumeT(96, $input, $state)  (: 'this' :)
              return $state
            else
              let $state := p:consumeT(93, $input, $state)  (: 'super' :)
              return $state
          let $state := p:lookahead1W(1, $input, $state)    (: WS | COMMENT | LINE_COMMENT | '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-arguments($input, $state)
          let $state := p:lookahead1W(6, $input, $state)    (: WS | COMMENT | LINE_COMMENT | ';' :)
          let $state := p:consumeT(37, $input, $state)      (: ';' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 38) then                            (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '<' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-nonWildcardTypeArguments($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(41, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'super' | 'this' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 96) then                   (: 'this' :)
          let $state := p:consumeT(96, $input, $state)      (: 'this' :)
          return $state
        else
          let $state := p:consumeT(93, $input, $state)      (: 'super' :)
          return $state
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-arguments($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-primary($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '.' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(35, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '<' | 'super' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '<' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-nonWildcardTypeArguments($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(14, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'super' :)
      let $state := p:consumeT(93, $input, $state)          (: 'super' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-arguments($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production constructorBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constructorBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(116, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'new' | 'null' | 'private' |
                                                               'protected' | 'public' | 'return' | 'short' | 'static' |
                                                               'strictfp' | 'super' | 'switch' | 'synchronized' |
                                                               'this' | 'throw' | 'true' | 'try' | 'void' | 'while' |
                                                               '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-blockStatement($input, $state)
        return p:parse-constructorBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production constructorBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constructorBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(116, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'new' | 'null' | 'private' |
                                                               'protected' | 'public' | 'return' | 'short' | 'static' |
                                                               'strictfp' | 'super' | 'switch' | 'synchronized' |
                                                               'this' | 'throw' | 'true' | 'try' | 'void' | 'while' |
                                                               '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-blockStatement($input, $state)
        return p:try-constructorBody-1($input, $state)
};

(:~
 : Parse constructorBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constructorBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(117, $input, $state)          (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '<' | '@' | 'abstract' | 'boolean' | 'break' |
                                                               'byte' | 'char' | 'class' | 'continue' | 'do' |
                                                               'double' | 'false' | 'final' | 'float' | 'for' | 'if' |
                                                               'int' | 'interface' | 'long' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(111, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | '-' | '--' | '-=' | '.' | '/' | '/=' |
                                                               ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                               '>' | '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] eq 21) then                      (: '(' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else if ($state[$p:l1] eq 83) then                      (: 'new' :)
      let $state := p:lookahead2W(70, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      return $state
    else if ($state[$p:l1] eq 93) then                      (: 'super' :)
      let $state := p:lookahead2W(25, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' :)
      return $state
    else if ($state[$p:l1] eq 96) then                      (: 'this' :)
      let $state := p:lookahead2W(107, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | '*' | '*=' | '+' | '++' | '+=' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ';' | '<' | '<<' |
                                                               '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' |
                                                               '>>>' | '>>>=' | '?' | '[' | '^' | '^=' | 'instanceof' |
                                                               '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] eq 102) then                     (: 'void' :)
      let $state := p:lookahead2W(4, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '.' :)
      return $state
    else if ($state[$p:l1] = (57,                           (: 'boolean' :)
                              59,                           (: 'byte' :)
                              62,                           (: 'char' :)
                              67,                           (: 'double' :)
                              73,                           (: 'float' :)
                              79,                           (: 'int' :)
                              81,                           (: 'long' :)
                              90)) then                     (: 'short' :)
      let $state := p:lookahead2W(43, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '.' | '[' :)
      return $state
    else if ($state[$p:l1] = (1,                            (: HexLiteral :)
                              2,                            (: DecimalLiteral :)
                              3,                            (: OctalLiteral :)
                              4,                            (: FloatingPointLiteral :)
                              5,                            (: CharacterLiteral :)
                              6,                            (: StringLiteral :)
                              70,                           (: 'false' :)
                              84,                           (: 'null' :)
                              100)) then                    (: 'true' :)
      let $state := p:lookahead2W(105, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '*' | '*=' | '+' | '++' | '+=' | '-' |
                                                               '--' | '-=' | '.' | '/' | '/=' | ';' | '<' | '<<' |
                                                               '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' |
                                                               '>>>' | '>>>=' | '?' | '[' | '^' | '^=' | 'instanceof' |
                                                               '|' | '|=' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 149                            (: '(' HexLiteral :)
          or $state[$p:lk] = 277                            (: '(' DecimalLiteral :)
          or $state[$p:lk] = 405                            (: '(' OctalLiteral :)
          or $state[$p:lk] = 533                            (: '(' FloatingPointLiteral :)
          or $state[$p:lk] = 661                            (: '(' CharacterLiteral :)
          or $state[$p:lk] = 789                            (: '(' StringLiteral :)
          or $state[$p:lk] = 1173                           (: '(' Identifier :)
          or $state[$p:lk] = 1235                           (: 'new' Identifier :)
          or $state[$p:lk] = 1813                           (: '(' '!' :)
          or $state[$p:lk] = 2697                           (: Identifier '(' :)
          or $state[$p:lk] = 2709                           (: '(' '(' :)
          or $state[$p:lk] = 2781                           (: 'super' '(' :)
          or $state[$p:lk] = 2784                           (: 'this' '(' :)
          or $state[$p:lk] = 3221                           (: '(' '+' :)
          or $state[$p:lk] = 3349                           (: '(' '++' :)
          or $state[$p:lk] = 3733                           (: '(' '-' :)
          or $state[$p:lk] = 3861                           (: '(' '--' :)
          or $state[$p:lk] = 4097                           (: HexLiteral '.' :)
          or $state[$p:lk] = 4098                           (: DecimalLiteral '.' :)
          or $state[$p:lk] = 4099                           (: OctalLiteral '.' :)
          or $state[$p:lk] = 4100                           (: FloatingPointLiteral '.' :)
          or $state[$p:lk] = 4101                           (: CharacterLiteral '.' :)
          or $state[$p:lk] = 4102                           (: StringLiteral '.' :)
          or $state[$p:lk] = 4105                           (: Identifier '.' :)
          or $state[$p:lk] = 4153                           (: 'boolean' '.' :)
          or $state[$p:lk] = 4155                           (: 'byte' '.' :)
          or $state[$p:lk] = 4158                           (: 'char' '.' :)
          or $state[$p:lk] = 4163                           (: 'double' '.' :)
          or $state[$p:lk] = 4166                           (: 'false' '.' :)
          or $state[$p:lk] = 4169                           (: 'float' '.' :)
          or $state[$p:lk] = 4175                           (: 'int' '.' :)
          or $state[$p:lk] = 4177                           (: 'long' '.' :)
          or $state[$p:lk] = 4180                           (: 'null' '.' :)
          or $state[$p:lk] = 4186                           (: 'short' '.' :)
          or $state[$p:lk] = 4189                           (: 'super' '.' :)
          or $state[$p:lk] = 4192                           (: 'this' '.' :)
          or $state[$p:lk] = 4196                           (: 'true' '.' :)
          or $state[$p:lk] = 4198                           (: 'void' '.' :)
          or $state[$p:lk] = 4947                           (: 'new' '<' :)
          or $state[$p:lk] = 6665                           (: Identifier '[' :)
          or $state[$p:lk] = 6713                           (: 'boolean' '[' :)
          or $state[$p:lk] = 6715                           (: 'byte' '[' :)
          or $state[$p:lk] = 6718                           (: 'char' '[' :)
          or $state[$p:lk] = 6723                           (: 'double' '[' :)
          or $state[$p:lk] = 6729                           (: 'float' '[' :)
          or $state[$p:lk] = 6735                           (: 'int' '[' :)
          or $state[$p:lk] = 6737                           (: 'long' '[' :)
          or $state[$p:lk] = 6746                           (: 'short' '[' :)
          or $state[$p:lk] = 6752                           (: 'this' '[' :)
          or $state[$p:lk] = 7317                           (: '(' 'boolean' :)
          or $state[$p:lk] = 7379                           (: 'new' 'boolean' :)
          or $state[$p:lk] = 7573                           (: '(' 'byte' :)
          or $state[$p:lk] = 7635                           (: 'new' 'byte' :)
          or $state[$p:lk] = 7957                           (: '(' 'char' :)
          or $state[$p:lk] = 8019                           (: 'new' 'char' :)
          or $state[$p:lk] = 8597                           (: '(' 'double' :)
          or $state[$p:lk] = 8659                           (: 'new' 'double' :)
          or $state[$p:lk] = 8981                           (: '(' 'false' :)
          or $state[$p:lk] = 9365                           (: '(' 'float' :)
          or $state[$p:lk] = 9427                           (: 'new' 'float' :)
          or $state[$p:lk] = 10133                          (: '(' 'int' :)
          or $state[$p:lk] = 10195                          (: 'new' 'int' :)
          or $state[$p:lk] = 10389                          (: '(' 'long' :)
          or $state[$p:lk] = 10451                          (: 'new' 'long' :)
          or $state[$p:lk] = 10645                          (: '(' 'new' :)
          or $state[$p:lk] = 10773                          (: '(' 'null' :)
          or $state[$p:lk] = 11541                          (: '(' 'short' :)
          or $state[$p:lk] = 11603                          (: 'new' 'short' :)
          or $state[$p:lk] = 11925                          (: '(' 'super' :)
          or $state[$p:lk] = 12309                          (: '(' 'this' :)
          or $state[$p:lk] = 12821                          (: '(' 'true' :)
          or $state[$p:lk] = 13077                          (: '(' 'void' :)
          or $state[$p:lk] = 14101) then                    (: '(' '~' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-explicitConstructorInvocation($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 38) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-explicitConstructorInvocation($input, $state)
      return $state
    else
      $state
  let $state := p:parse-constructorBody-1($input, $state)
  let $state := p:consume(109, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "constructorBody", $count, $begin, $end)
};

(:~
 : Try parsing constructorBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constructorBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(105, $input, $state)             (: '{' :)
  let $state := p:lookahead1W(117, $input, $state)          (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '<' | '@' | 'abstract' | 'boolean' | 'break' |
                                                               'byte' | 'char' | 'class' | 'continue' | 'do' |
                                                               'double' | 'false' | 'final' | 'float' | 'for' | 'if' |
                                                               'int' | 'interface' | 'long' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(111, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | '-' | '--' | '-=' | '.' | '/' | '/=' |
                                                               ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                               '>' | '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] eq 21) then                      (: '(' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else if ($state[$p:l1] eq 83) then                      (: 'new' :)
      let $state := p:lookahead2W(70, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      return $state
    else if ($state[$p:l1] eq 93) then                      (: 'super' :)
      let $state := p:lookahead2W(25, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' :)
      return $state
    else if ($state[$p:l1] eq 96) then                      (: 'this' :)
      let $state := p:lookahead2W(107, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | '*' | '*=' | '+' | '++' | '+=' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ';' | '<' | '<<' |
                                                               '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' |
                                                               '>>>' | '>>>=' | '?' | '[' | '^' | '^=' | 'instanceof' |
                                                               '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] eq 102) then                     (: 'void' :)
      let $state := p:lookahead2W(4, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '.' :)
      return $state
    else if ($state[$p:l1] = (57,                           (: 'boolean' :)
                              59,                           (: 'byte' :)
                              62,                           (: 'char' :)
                              67,                           (: 'double' :)
                              73,                           (: 'float' :)
                              79,                           (: 'int' :)
                              81,                           (: 'long' :)
                              90)) then                     (: 'short' :)
      let $state := p:lookahead2W(43, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '.' | '[' :)
      return $state
    else if ($state[$p:l1] = (1,                            (: HexLiteral :)
                              2,                            (: DecimalLiteral :)
                              3,                            (: OctalLiteral :)
                              4,                            (: FloatingPointLiteral :)
                              5,                            (: CharacterLiteral :)
                              6,                            (: StringLiteral :)
                              70,                           (: 'false' :)
                              84,                           (: 'null' :)
                              100)) then                    (: 'true' :)
      let $state := p:lookahead2W(105, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '*' | '*=' | '+' | '++' | '+=' | '-' |
                                                               '--' | '-=' | '.' | '/' | '/=' | ';' | '<' | '<<' |
                                                               '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' |
                                                               '>>>' | '>>>=' | '?' | '[' | '^' | '^=' | 'instanceof' |
                                                               '|' | '|=' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 149                            (: '(' HexLiteral :)
          or $state[$p:lk] = 277                            (: '(' DecimalLiteral :)
          or $state[$p:lk] = 405                            (: '(' OctalLiteral :)
          or $state[$p:lk] = 533                            (: '(' FloatingPointLiteral :)
          or $state[$p:lk] = 661                            (: '(' CharacterLiteral :)
          or $state[$p:lk] = 789                            (: '(' StringLiteral :)
          or $state[$p:lk] = 1173                           (: '(' Identifier :)
          or $state[$p:lk] = 1235                           (: 'new' Identifier :)
          or $state[$p:lk] = 1813                           (: '(' '!' :)
          or $state[$p:lk] = 2697                           (: Identifier '(' :)
          or $state[$p:lk] = 2709                           (: '(' '(' :)
          or $state[$p:lk] = 2781                           (: 'super' '(' :)
          or $state[$p:lk] = 2784                           (: 'this' '(' :)
          or $state[$p:lk] = 3221                           (: '(' '+' :)
          or $state[$p:lk] = 3349                           (: '(' '++' :)
          or $state[$p:lk] = 3733                           (: '(' '-' :)
          or $state[$p:lk] = 3861                           (: '(' '--' :)
          or $state[$p:lk] = 4097                           (: HexLiteral '.' :)
          or $state[$p:lk] = 4098                           (: DecimalLiteral '.' :)
          or $state[$p:lk] = 4099                           (: OctalLiteral '.' :)
          or $state[$p:lk] = 4100                           (: FloatingPointLiteral '.' :)
          or $state[$p:lk] = 4101                           (: CharacterLiteral '.' :)
          or $state[$p:lk] = 4102                           (: StringLiteral '.' :)
          or $state[$p:lk] = 4105                           (: Identifier '.' :)
          or $state[$p:lk] = 4153                           (: 'boolean' '.' :)
          or $state[$p:lk] = 4155                           (: 'byte' '.' :)
          or $state[$p:lk] = 4158                           (: 'char' '.' :)
          or $state[$p:lk] = 4163                           (: 'double' '.' :)
          or $state[$p:lk] = 4166                           (: 'false' '.' :)
          or $state[$p:lk] = 4169                           (: 'float' '.' :)
          or $state[$p:lk] = 4175                           (: 'int' '.' :)
          or $state[$p:lk] = 4177                           (: 'long' '.' :)
          or $state[$p:lk] = 4180                           (: 'null' '.' :)
          or $state[$p:lk] = 4186                           (: 'short' '.' :)
          or $state[$p:lk] = 4189                           (: 'super' '.' :)
          or $state[$p:lk] = 4192                           (: 'this' '.' :)
          or $state[$p:lk] = 4196                           (: 'true' '.' :)
          or $state[$p:lk] = 4198                           (: 'void' '.' :)
          or $state[$p:lk] = 4947                           (: 'new' '<' :)
          or $state[$p:lk] = 6665                           (: Identifier '[' :)
          or $state[$p:lk] = 6713                           (: 'boolean' '[' :)
          or $state[$p:lk] = 6715                           (: 'byte' '[' :)
          or $state[$p:lk] = 6718                           (: 'char' '[' :)
          or $state[$p:lk] = 6723                           (: 'double' '[' :)
          or $state[$p:lk] = 6729                           (: 'float' '[' :)
          or $state[$p:lk] = 6735                           (: 'int' '[' :)
          or $state[$p:lk] = 6737                           (: 'long' '[' :)
          or $state[$p:lk] = 6746                           (: 'short' '[' :)
          or $state[$p:lk] = 6752                           (: 'this' '[' :)
          or $state[$p:lk] = 7317                           (: '(' 'boolean' :)
          or $state[$p:lk] = 7379                           (: 'new' 'boolean' :)
          or $state[$p:lk] = 7573                           (: '(' 'byte' :)
          or $state[$p:lk] = 7635                           (: 'new' 'byte' :)
          or $state[$p:lk] = 7957                           (: '(' 'char' :)
          or $state[$p:lk] = 8019                           (: 'new' 'char' :)
          or $state[$p:lk] = 8597                           (: '(' 'double' :)
          or $state[$p:lk] = 8659                           (: 'new' 'double' :)
          or $state[$p:lk] = 8981                           (: '(' 'false' :)
          or $state[$p:lk] = 9365                           (: '(' 'float' :)
          or $state[$p:lk] = 9427                           (: 'new' 'float' :)
          or $state[$p:lk] = 10133                          (: '(' 'int' :)
          or $state[$p:lk] = 10195                          (: 'new' 'int' :)
          or $state[$p:lk] = 10389                          (: '(' 'long' :)
          or $state[$p:lk] = 10451                          (: 'new' 'long' :)
          or $state[$p:lk] = 10645                          (: '(' 'new' :)
          or $state[$p:lk] = 10773                          (: '(' 'null' :)
          or $state[$p:lk] = 11541                          (: '(' 'short' :)
          or $state[$p:lk] = 11603                          (: 'new' 'short' :)
          or $state[$p:lk] = 11925                          (: '(' 'super' :)
          or $state[$p:lk] = 12309                          (: '(' 'this' :)
          or $state[$p:lk] = 12821                          (: '(' 'true' :)
          or $state[$p:lk] = 13077                          (: '(' 'void' :)
          or $state[$p:lk] = 14101) then                    (: '(' '~' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-explicitConstructorInvocation($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-explicitConstructorInvocation($input, $state)
      return $state
    else
      $state
  let $state := p:try-constructorBody-1($input, $state)
  let $state := p:consumeT(109, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse constructorDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constructorDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-formalParameters($input, $state)
  let $state := p:lookahead1W(42, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'throws' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consume(98, $input, $state)           (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-constructorBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "constructorDeclaratorRest", $count, $begin, $end)
};

(:~
 : Try parsing constructorDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constructorDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-formalParameters($input, $state)
  let $state := p:lookahead1W(42, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'throws' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consumeT(98, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-constructorBody($input, $state)
  return $state
};

(:~
 : Parse methodBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-methodBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "methodBody", $count, $begin, $end)
};

(:~
 : Try parsing methodBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-methodBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-block($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production methodDeclaratorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-methodDeclaratorRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(59, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ';' | '[' | 'throws' | '{' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-methodDeclaratorRest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production methodDeclaratorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-methodDeclaratorRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(59, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ';' | '[' | 'throws' | '{' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-methodDeclaratorRest-1($input, $state)
};

(:~
 : Parse methodDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-methodDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-formalParameters($input, $state)
  let $state := p:parse-methodDeclaratorRest-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consume(98, $input, $state)           (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-methodBody($input, $state)
      return $state
    else
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "methodDeclaratorRest", $count, $begin, $end)
};

(:~
 : Try parsing methodDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-methodDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-formalParameters($input, $state)
  let $state := p:try-methodDeclaratorRest-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consumeT(98, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-methodBody($input, $state)
      return $state
    else
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse genericMethodOrConstructorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-genericMethodOrConstructorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(61, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '(' | '.' |
                                                               '<' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2697) then                     (: Identifier '(' :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-constructorDeclaratorRest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 102) then                  (: 'void' :)
          let $state := p:consume(102, $input, $state)      (: 'void' :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-type($input, $state)
          return $state
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-methodDeclaratorRest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "genericMethodOrConstructorRest", $count, $begin, $end)
};

(:~
 : Try parsing genericMethodOrConstructorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-genericMethodOrConstructorRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(61, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '(' | '.' |
                                                               '<' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2697) then                     (: Identifier '(' :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-constructorDeclaratorRest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 102) then                  (: 'void' :)
          let $state := p:consumeT(102, $input, $state)     (: 'void' :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-type($input, $state)
          return $state
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-methodDeclaratorRest($input, $state)
      return $state
  return $state
};

(:~
 : Parse genericMethodOrConstructorDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-genericMethodOrConstructorDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-typeParameters($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' | 'void' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-genericMethodOrConstructorRest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "genericMethodOrConstructorDecl", $count, $begin, $end)
};

(:~
 : Try parsing genericMethodOrConstructorDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-genericMethodOrConstructorDecl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-typeParameters($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' | 'void' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-genericMethodOrConstructorRest($input, $state)
  return $state
};

(:~
 : Parse memberDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-memberDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(61, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '(' | '.' |
                                                               '<' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-genericMethodOrConstructorDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 102) then                      (: 'void' :)
      let $state := p:consume(102, $input, $state)          (: 'void' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-voidMethodDeclaratorRest($input, $state)
      return $state
    else if ($state[$p:lk] = 2697) then                     (: Identifier '(' :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-constructorDeclaratorRest($input, $state)
      return $state
    else if ($state[$p:lk] = 51                             (: '@' :)
          or $state[$p:lk] = 80) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-interfaceDeclaration($input, $state)
      return $state
    else if ($state[$p:lk] = 7                              (: ENUM :)
          or $state[$p:lk] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-memberDeclaration($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "memberDecl", $count, $begin, $end)
};

(:~
 : Try parsing memberDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-memberDecl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(61, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '(' | '.' |
                                                               '<' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-genericMethodOrConstructorDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 102) then                      (: 'void' :)
      let $state := p:consumeT(102, $input, $state)         (: 'void' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-voidMethodDeclaratorRest($input, $state)
      return $state
    else if ($state[$p:lk] = 2697) then                     (: Identifier '(' :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-constructorDeclaratorRest($input, $state)
      return $state
    else if ($state[$p:lk] = 51                             (: '@' :)
          or $state[$p:lk] = 80) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-interfaceDeclaration($input, $state)
      return $state
    else if ($state[$p:lk] = 7                              (: ENUM :)
          or $state[$p:lk] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-memberDeclaration($input, $state)
      return $state
  return $state
};

(:~
 : Parse statementExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-statementExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-expression($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "statementExpression", $count, $begin, $end)
};

(:~
 : Try parsing statementExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-statementExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-expression($input, $state)
  return $state
};

(:~
 : Parse enumConstantName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enumConstantName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $end := $state[$p:e0]
  return p:reduce($state, "enumConstantName", $count, $begin, $end)
};

(:~
 : Try parsing enumConstantName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enumConstantName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  return $state
};

(:~
 : Parse constantExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constantExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-expression($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "constantExpression", $count, $begin, $end)
};

(:~
 : Try parsing constantExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constantExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-expression($input, $state)
  return $state
};

(:~
 : Parse switchLabel.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-switchLabel($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 60) then                           (: 'case' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1212) then                     (: 'case' Identifier :)
      let $state := p:memoized($state, 8)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(60, $input, $state)      (: 'case' :)
          let $state := p:lookahead1W(89, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-constantExpression($input, $state)
          let $state := p:consumeT(36, $input, $state)      (: ':' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2) then
      let $state := p:consume(60, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-enumConstantName($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ':' :)
      let $state := p:consume(36, $input, $state)           (: ':' :)
      return $state
    else if ($state[$p:lk] = 65) then                       (: 'default' :)
      let $state := p:consume(65, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(5, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ':' :)
      let $state := p:consume(36, $input, $state)           (: ':' :)
      return $state
    else
      let $state := p:consume(60, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-constantExpression($input, $state)
      let $state := p:consume(36, $input, $state)           (: ':' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "switchLabel", $count, $begin, $end)
};

(:~
 : Try parsing switchLabel.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-switchLabel($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 60) then                           (: 'case' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1212) then                     (: 'case' Identifier :)
      let $state := p:memoized($state, 8)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(60, $input, $state)      (: 'case' :)
          let $state := p:lookahead1W(89, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-constantExpression($input, $state)
          let $state := p:consumeT(36, $input, $state)      (: ':' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2) then
      let $state := p:consumeT(60, $input, $state)          (: 'case' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-enumConstantName($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ':' :)
      let $state := p:consumeT(36, $input, $state)          (: ':' :)
      return $state
    else if ($state[$p:lk] = 65) then                       (: 'default' :)
      let $state := p:consumeT(65, $input, $state)          (: 'default' :)
      let $state := p:lookahead1W(5, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ':' :)
      let $state := p:consumeT(36, $input, $state)          (: ':' :)
      return $state
    else
      let $state := p:consumeT(60, $input, $state)          (: 'case' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-constantExpression($input, $state)
      let $state := p:consumeT(36, $input, $state)          (: ':' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production switchBlockStatementGroup (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-switchBlockStatementGroup-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-switchLabel($input, $state)
    let $state := p:lookahead1W(118, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'false' | 'final' | 'float' | 'for' |
                                                               'if' | 'int' | 'interface' | 'long' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' | '}' | '~' :)
    let $state :=
      if ($state[$p:l1] eq 60) then                         (: 'case' :)
        let $state := p:lookahead2W(89, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
        return $state
      else if ($state[$p:l1] eq 65) then                    (: 'default' :)
        let $state := p:lookahead2W(5, $input, $state)      (: WS | COMMENT | LINE_COMMENT | ':' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 188                          (: 'case' HexLiteral :)
            or $state[$p:lk] = 316                          (: 'case' DecimalLiteral :)
            or $state[$p:lk] = 444                          (: 'case' OctalLiteral :)
            or $state[$p:lk] = 572                          (: 'case' FloatingPointLiteral :)
            or $state[$p:lk] = 700                          (: 'case' CharacterLiteral :)
            or $state[$p:lk] = 828                          (: 'case' StringLiteral :)
            or $state[$p:lk] = 1212                         (: 'case' Identifier :)
            or $state[$p:lk] = 1852                         (: 'case' '!' :)
            or $state[$p:lk] = 2748                         (: 'case' '(' :)
            or $state[$p:lk] = 3260                         (: 'case' '+' :)
            or $state[$p:lk] = 3388                         (: 'case' '++' :)
            or $state[$p:lk] = 3772                         (: 'case' '-' :)
            or $state[$p:lk] = 3900                         (: 'case' '--' :)
            or $state[$p:lk] = 4673                         (: 'default' ':' :)
            or $state[$p:lk] = 7356                         (: 'case' 'boolean' :)
            or $state[$p:lk] = 7612                         (: 'case' 'byte' :)
            or $state[$p:lk] = 7996                         (: 'case' 'char' :)
            or $state[$p:lk] = 8636                         (: 'case' 'double' :)
            or $state[$p:lk] = 9020                         (: 'case' 'false' :)
            or $state[$p:lk] = 9404                         (: 'case' 'float' :)
            or $state[$p:lk] = 10172                        (: 'case' 'int' :)
            or $state[$p:lk] = 10428                        (: 'case' 'long' :)
            or $state[$p:lk] = 10684                        (: 'case' 'new' :)
            or $state[$p:lk] = 10812                        (: 'case' 'null' :)
            or $state[$p:lk] = 11580                        (: 'case' 'short' :)
            or $state[$p:lk] = 11964                        (: 'case' 'super' :)
            or $state[$p:lk] = 12348                        (: 'case' 'this' :)
            or $state[$p:lk] = 12860                        (: 'case' 'true' :)
            or $state[$p:lk] = 13116                        (: 'case' 'void' :)
            or $state[$p:lk] = 14140) then                  (: 'case' '~' :)
        let $state := p:memoized($state, 7)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-switchLabel($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        p:parse-switchBlockStatementGroup-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production switchBlockStatementGroup (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-switchBlockStatementGroup-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-switchLabel($input, $state)
    let $state := p:lookahead1W(118, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'false' | 'final' | 'float' | 'for' |
                                                               'if' | 'int' | 'interface' | 'long' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' | '}' | '~' :)
    let $state :=
      if ($state[$p:l1] eq 60) then                         (: 'case' :)
        let $state := p:lookahead2W(89, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
        return $state
      else if ($state[$p:l1] eq 65) then                    (: 'default' :)
        let $state := p:lookahead2W(5, $input, $state)      (: WS | COMMENT | LINE_COMMENT | ':' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 188                          (: 'case' HexLiteral :)
            or $state[$p:lk] = 316                          (: 'case' DecimalLiteral :)
            or $state[$p:lk] = 444                          (: 'case' OctalLiteral :)
            or $state[$p:lk] = 572                          (: 'case' FloatingPointLiteral :)
            or $state[$p:lk] = 700                          (: 'case' CharacterLiteral :)
            or $state[$p:lk] = 828                          (: 'case' StringLiteral :)
            or $state[$p:lk] = 1212                         (: 'case' Identifier :)
            or $state[$p:lk] = 1852                         (: 'case' '!' :)
            or $state[$p:lk] = 2748                         (: 'case' '(' :)
            or $state[$p:lk] = 3260                         (: 'case' '+' :)
            or $state[$p:lk] = 3388                         (: 'case' '++' :)
            or $state[$p:lk] = 3772                         (: 'case' '-' :)
            or $state[$p:lk] = 3900                         (: 'case' '--' :)
            or $state[$p:lk] = 4673                         (: 'default' ':' :)
            or $state[$p:lk] = 7356                         (: 'case' 'boolean' :)
            or $state[$p:lk] = 7612                         (: 'case' 'byte' :)
            or $state[$p:lk] = 7996                         (: 'case' 'char' :)
            or $state[$p:lk] = 8636                         (: 'case' 'double' :)
            or $state[$p:lk] = 9020                         (: 'case' 'false' :)
            or $state[$p:lk] = 9404                         (: 'case' 'float' :)
            or $state[$p:lk] = 10172                        (: 'case' 'int' :)
            or $state[$p:lk] = 10428                        (: 'case' 'long' :)
            or $state[$p:lk] = 10684                        (: 'case' 'new' :)
            or $state[$p:lk] = 10812                        (: 'case' 'null' :)
            or $state[$p:lk] = 11580                        (: 'case' 'short' :)
            or $state[$p:lk] = 11964                        (: 'case' 'super' :)
            or $state[$p:lk] = 12348                        (: 'case' 'this' :)
            or $state[$p:lk] = 12860                        (: 'case' 'true' :)
            or $state[$p:lk] = 13116                        (: 'case' 'void' :)
            or $state[$p:lk] = 14140) then                  (: 'case' '~' :)
        let $state := p:memoized($state, 7)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-switchLabel($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 7, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-switchBlockStatementGroup-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        p:try-switchBlockStatementGroup-1($input, $state)
};

(:~
 : Parse the 2nd loop of production switchBlockStatementGroup (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-switchBlockStatementGroup-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(118, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'false' | 'final' | 'float' | 'for' |
                                                               'if' | 'int' | 'interface' | 'long' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 60                                (: 'case' :)
       or $state[$p:l1] = 65                                (: 'default' :)
       or $state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-blockStatement($input, $state)
        return p:parse-switchBlockStatementGroup-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production switchBlockStatementGroup (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-switchBlockStatementGroup-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(118, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'false' | 'final' | 'float' | 'for' |
                                                               'if' | 'int' | 'interface' | 'long' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 60                                (: 'case' :)
       or $state[$p:l1] = 65                                (: 'default' :)
       or $state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-blockStatement($input, $state)
        return p:try-switchBlockStatementGroup-2($input, $state)
};

(:~
 : Parse switchBlockStatementGroup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-switchBlockStatementGroup($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-switchBlockStatementGroup-1($input, $state)
  let $state := p:parse-switchBlockStatementGroup-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "switchBlockStatementGroup", $count, $begin, $end)
};

(:~
 : Try parsing switchBlockStatementGroup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-switchBlockStatementGroup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-switchBlockStatementGroup-1($input, $state)
  let $state := p:try-switchBlockStatementGroup-2($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production switchBlockStatementGroups (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-switchBlockStatementGroups-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] = 109) then                           (: '}' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-switchBlockStatementGroup($input, $state)
      return p:parse-switchBlockStatementGroups-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production switchBlockStatementGroups (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-switchBlockStatementGroups-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] = 109) then                           (: '}' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-switchBlockStatementGroup($input, $state)
      return p:try-switchBlockStatementGroups-1($input, $state)
};

(:~
 : Parse switchBlockStatementGroups.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-switchBlockStatementGroups($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-switchBlockStatementGroups-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "switchBlockStatementGroups", $count, $begin, $end)
};

(:~
 : Try parsing switchBlockStatementGroups.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-switchBlockStatementGroups($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-switchBlockStatementGroups-1($input, $state)
  return $state
};

(:~
 : Parse formalParameter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-formalParameter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableModifiers($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-type($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableDeclaratorId($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "formalParameter", $count, $begin, $end)
};

(:~
 : Try parsing formalParameter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-formalParameter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableModifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-type($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableDeclaratorId($input, $state)
  return $state
};

(:~
 : Parse catchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-catchClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(61, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(75, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-formalParameter($input, $state)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(17, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "catchClause", $count, $begin, $end)
};

(:~
 : Try parsing catchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-catchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(61, $input, $state)              (: 'catch' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(75, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-formalParameter($input, $state)
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(17, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-block($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production catches (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-catches-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(120, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'catch' | 'char' | 'class' | 'continue' |
                                                               'default' | 'do' | 'double' | 'else' | 'false' |
                                                               'final' | 'finally' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'new' | 'null' | 'private' |
                                                               'protected' | 'public' | 'return' | 'short' | 'static' |
                                                               'strictfp' | 'super' | 'switch' | 'synchronized' |
                                                               'this' | 'throw' | 'true' | 'try' | 'void' | 'while' |
                                                               '{' | '}' | '~' :)
    return
      if ($state[$p:l1] != 61) then                         (: 'catch' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-catchClause($input, $state)
        return p:parse-catches-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production catches (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-catches-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(120, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'catch' | 'char' | 'class' | 'continue' |
                                                               'default' | 'do' | 'double' | 'else' | 'false' |
                                                               'final' | 'finally' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'new' | 'null' | 'private' |
                                                               'protected' | 'public' | 'return' | 'short' | 'static' |
                                                               'strictfp' | 'super' | 'switch' | 'synchronized' |
                                                               'this' | 'throw' | 'true' | 'try' | 'void' | 'while' |
                                                               '{' | '}' | '~' :)
    return
      if ($state[$p:l1] != 61) then                         (: 'catch' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-catchClause($input, $state)
        return p:try-catches-1($input, $state)
};

(:~
 : Parse catches.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-catches($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-catchClause($input, $state)
  let $state := p:parse-catches-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "catches", $count, $begin, $end)
};

(:~
 : Try parsing catches.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-catches($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-catchClause($input, $state)
  let $state := p:try-catches-1($input, $state)
  return $state
};

(:~
 : Parse forUpdate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-forUpdate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-expressionList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "forUpdate", $count, $begin, $end)
};

(:~
 : Try parsing forUpdate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-forUpdate($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-expressionList($input, $state)
  return $state
};

(:~
 : Parse forInit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-forInit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(110, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                               '>' | '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] = (57,                           (: 'boolean' :)
                              59,                           (: 'byte' :)
                              62,                           (: 'char' :)
                              67,                           (: 'double' :)
                              73,                           (: 'float' :)
                              79,                           (: 'int' :)
                              81,                           (: 'long' :)
                              90)) then                     (: 'short' :)
      let $state := p:lookahead2W(43, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '.' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 4105                           (: Identifier '.' :)
          or $state[$p:lk] = 4873                           (: Identifier '<' :)
          or $state[$p:lk] = 6665                           (: Identifier '[' :)
          or $state[$p:lk] = 6713                           (: 'boolean' '[' :)
          or $state[$p:lk] = 6715                           (: 'byte' '[' :)
          or $state[$p:lk] = 6718                           (: 'char' '[' :)
          or $state[$p:lk] = 6723                           (: 'double' '[' :)
          or $state[$p:lk] = 6729                           (: 'float' '[' :)
          or $state[$p:lk] = 6735                           (: 'int' '[' :)
          or $state[$p:lk] = 6737                           (: 'long' '[' :)
          or $state[$p:lk] = 6746) then                     (: 'short' '[' :)
      let $state := p:memoized($state, 10)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-localVariableDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 51                                  (: '@' :)
     or $state[$p:lk] = 71                                  (: 'final' :)
     or $state[$p:lk] = 1161                                (: Identifier Identifier :)
     or $state[$p:lk] = 1209                                (: 'boolean' Identifier :)
     or $state[$p:lk] = 1211                                (: 'byte' Identifier :)
     or $state[$p:lk] = 1214                                (: 'char' Identifier :)
     or $state[$p:lk] = 1219                                (: 'double' Identifier :)
     or $state[$p:lk] = 1225                                (: 'float' Identifier :)
     or $state[$p:lk] = 1231                                (: 'int' Identifier :)
     or $state[$p:lk] = 1233                                (: 'long' Identifier :)
     or $state[$p:lk] = 1242) then                          (: 'short' Identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-localVariableDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expressionList($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "forInit", $count, $begin, $end)
};

(:~
 : Try parsing forInit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-forInit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(110, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                               '>' | '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] = (57,                           (: 'boolean' :)
                              59,                           (: 'byte' :)
                              62,                           (: 'char' :)
                              67,                           (: 'double' :)
                              73,                           (: 'float' :)
                              79,                           (: 'int' :)
                              81,                           (: 'long' :)
                              90)) then                     (: 'short' :)
      let $state := p:lookahead2W(43, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '.' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 4105                           (: Identifier '.' :)
          or $state[$p:lk] = 4873                           (: Identifier '<' :)
          or $state[$p:lk] = 6665                           (: Identifier '[' :)
          or $state[$p:lk] = 6713                           (: 'boolean' '[' :)
          or $state[$p:lk] = 6715                           (: 'byte' '[' :)
          or $state[$p:lk] = 6718                           (: 'char' '[' :)
          or $state[$p:lk] = 6723                           (: 'double' '[' :)
          or $state[$p:lk] = 6729                           (: 'float' '[' :)
          or $state[$p:lk] = 6735                           (: 'int' '[' :)
          or $state[$p:lk] = 6737                           (: 'long' '[' :)
          or $state[$p:lk] = 6746) then                     (: 'short' '[' :)
      let $state := p:memoized($state, 10)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-localVariableDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 51                                  (: '@' :)
     or $state[$p:lk] = 71                                  (: 'final' :)
     or $state[$p:lk] = 1161                                (: Identifier Identifier :)
     or $state[$p:lk] = 1209                                (: 'boolean' Identifier :)
     or $state[$p:lk] = 1211                                (: 'byte' Identifier :)
     or $state[$p:lk] = 1214                                (: 'char' Identifier :)
     or $state[$p:lk] = 1219                                (: 'double' Identifier :)
     or $state[$p:lk] = 1225                                (: 'float' Identifier :)
     or $state[$p:lk] = 1231                                (: 'int' Identifier :)
     or $state[$p:lk] = 1233                                (: 'long' Identifier :)
     or $state[$p:lk] = 1242) then                          (: 'short' Identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-localVariableDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expressionList($input, $state)
      return $state
  return $state
};

(:~
 : Parse enhancedForControl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enhancedForControl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableModifiers($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-type($input, $state)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(5, $input, $state)            (: WS | COMMENT | LINE_COMMENT | ':' :)
  let $state := p:consume(36, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(89, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-expression($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "enhancedForControl", $count, $begin, $end)
};

(:~
 : Try parsing enhancedForControl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enhancedForControl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableModifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-type($input, $state)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(5, $input, $state)            (: WS | COMMENT | LINE_COMMENT | ':' :)
  let $state := p:consumeT(36, $input, $state)              (: ':' :)
  let $state := p:lookahead1W(89, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-expression($input, $state)
  return $state
};

(:~
 : Parse forControl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-forControl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(110, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                               '>' | '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] eq 51) then                      (: '@' :)
      let $state := p:lookahead2W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      return $state
    else if ($state[$p:l1] eq 71) then                      (: 'final' :)
      let $state := p:lookahead2W(75, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
      return $state
    else if ($state[$p:l1] = (57,                           (: 'boolean' :)
                              59,                           (: 'byte' :)
                              62,                           (: 'char' :)
                              67,                           (: 'double' :)
                              73,                           (: 'float' :)
                              79,                           (: 'int' :)
                              81,                           (: 'long' :)
                              90)) then                     (: 'short' :)
      let $state := p:lookahead2W(43, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '.' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1161                           (: Identifier Identifier :)
          or $state[$p:lk] = 1203                           (: '@' Identifier :)
          or $state[$p:lk] = 1209                           (: 'boolean' Identifier :)
          or $state[$p:lk] = 1211                           (: 'byte' Identifier :)
          or $state[$p:lk] = 1214                           (: 'char' Identifier :)
          or $state[$p:lk] = 1219                           (: 'double' Identifier :)
          or $state[$p:lk] = 1223                           (: 'final' Identifier :)
          or $state[$p:lk] = 1225                           (: 'float' Identifier :)
          or $state[$p:lk] = 1231                           (: 'int' Identifier :)
          or $state[$p:lk] = 1233                           (: 'long' Identifier :)
          or $state[$p:lk] = 1242                           (: 'short' Identifier :)
          or $state[$p:lk] = 4105                           (: Identifier '.' :)
          or $state[$p:lk] = 4873                           (: Identifier '<' :)
          or $state[$p:lk] = 6599                           (: 'final' '@' :)
          or $state[$p:lk] = 6665                           (: Identifier '[' :)
          or $state[$p:lk] = 6713                           (: 'boolean' '[' :)
          or $state[$p:lk] = 6715                           (: 'byte' '[' :)
          or $state[$p:lk] = 6718                           (: 'char' '[' :)
          or $state[$p:lk] = 6723                           (: 'double' '[' :)
          or $state[$p:lk] = 6729                           (: 'float' '[' :)
          or $state[$p:lk] = 6735                           (: 'int' '[' :)
          or $state[$p:lk] = 6737                           (: 'long' '[' :)
          or $state[$p:lk] = 6746                           (: 'short' '[' :)
          or $state[$p:lk] = 7367                           (: 'final' 'boolean' :)
          or $state[$p:lk] = 7623                           (: 'final' 'byte' :)
          or $state[$p:lk] = 8007                           (: 'final' 'char' :)
          or $state[$p:lk] = 8647                           (: 'final' 'double' :)
          or $state[$p:lk] = 9159                           (: 'final' 'final' :)
          or $state[$p:lk] = 9415                           (: 'final' 'float' :)
          or $state[$p:lk] = 10183                          (: 'final' 'int' :)
          or $state[$p:lk] = 10439                          (: 'final' 'long' :)
          or $state[$p:lk] = 11591) then                    (: 'final' 'short' :)
      let $state := p:memoized($state, 9)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-enhancedForControl($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-enhancedForControl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 37) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-forInit($input, $state)
          return $state
        else
          $state
      let $state := p:consume(37, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(92, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 37) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(37, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(91, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 22) then                  (: ')' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-forUpdate($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "forControl", $count, $begin, $end)
};

(:~
 : Try parsing forControl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-forControl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(110, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                               '>' | '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] eq 51) then                      (: '@' :)
      let $state := p:lookahead2W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      return $state
    else if ($state[$p:l1] eq 71) then                      (: 'final' :)
      let $state := p:lookahead2W(75, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
      return $state
    else if ($state[$p:l1] = (57,                           (: 'boolean' :)
                              59,                           (: 'byte' :)
                              62,                           (: 'char' :)
                              67,                           (: 'double' :)
                              73,                           (: 'float' :)
                              79,                           (: 'int' :)
                              81,                           (: 'long' :)
                              90)) then                     (: 'short' :)
      let $state := p:lookahead2W(43, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '.' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1161                           (: Identifier Identifier :)
          or $state[$p:lk] = 1203                           (: '@' Identifier :)
          or $state[$p:lk] = 1209                           (: 'boolean' Identifier :)
          or $state[$p:lk] = 1211                           (: 'byte' Identifier :)
          or $state[$p:lk] = 1214                           (: 'char' Identifier :)
          or $state[$p:lk] = 1219                           (: 'double' Identifier :)
          or $state[$p:lk] = 1223                           (: 'final' Identifier :)
          or $state[$p:lk] = 1225                           (: 'float' Identifier :)
          or $state[$p:lk] = 1231                           (: 'int' Identifier :)
          or $state[$p:lk] = 1233                           (: 'long' Identifier :)
          or $state[$p:lk] = 1242                           (: 'short' Identifier :)
          or $state[$p:lk] = 4105                           (: Identifier '.' :)
          or $state[$p:lk] = 4873                           (: Identifier '<' :)
          or $state[$p:lk] = 6599                           (: 'final' '@' :)
          or $state[$p:lk] = 6665                           (: Identifier '[' :)
          or $state[$p:lk] = 6713                           (: 'boolean' '[' :)
          or $state[$p:lk] = 6715                           (: 'byte' '[' :)
          or $state[$p:lk] = 6718                           (: 'char' '[' :)
          or $state[$p:lk] = 6723                           (: 'double' '[' :)
          or $state[$p:lk] = 6729                           (: 'float' '[' :)
          or $state[$p:lk] = 6735                           (: 'int' '[' :)
          or $state[$p:lk] = 6737                           (: 'long' '[' :)
          or $state[$p:lk] = 6746                           (: 'short' '[' :)
          or $state[$p:lk] = 7367                           (: 'final' 'boolean' :)
          or $state[$p:lk] = 7623                           (: 'final' 'byte' :)
          or $state[$p:lk] = 8007                           (: 'final' 'char' :)
          or $state[$p:lk] = 8647                           (: 'final' 'double' :)
          or $state[$p:lk] = 9159                           (: 'final' 'final' :)
          or $state[$p:lk] = 9415                           (: 'final' 'float' :)
          or $state[$p:lk] = 10183                          (: 'final' 'int' :)
          or $state[$p:lk] = 10439                          (: 'final' 'long' :)
          or $state[$p:lk] = 11591) then                    (: 'final' 'short' :)
      let $state := p:memoized($state, 9)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-enhancedForControl($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-enhancedForControl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 37) then                  (: ';' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-forInit($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      let $state := p:lookahead1W(92, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 37) then                  (: ';' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      let $state := p:lookahead1W(91, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 22) then                  (: ')' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-forUpdate($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse statement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-statement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(109, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | '*' | '*=' | '+' | '++' | '+=' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' |
                                                               '>>=' | '>>>' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-block($input, $state)
      return $state
    else if ($state[$p:lk] = 8) then                        (: ASSERT :)
      let $state := p:consume(8, $input, $state)            (: ASSERT :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 36) then                   (: ':' :)
          let $state := p:consume(36, $input, $state)       (: ':' :)
          let $state := p:lookahead1W(89, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 75) then                       (: 'if' :)
      let $state := p:consume(75, $input, $state)           (: 'if' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-parExpression($input, $state)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-statement($input, $state)
      let $state := p:lookahead1W(119, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'else' | 'false' | 'final' | 'float' |
                                                               'for' | 'if' | 'int' | 'interface' | 'long' | 'new' |
                                                               'null' | 'private' | 'protected' | 'public' | 'return' |
                                                               'short' | 'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' | '}' | '~' :)
      let $state :=
        if ($state[$p:l1] eq 68) then                       (: 'else' :)
          let $state := p:lookahead2W(112, $input, $state)  (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 196                        (: 'else' HexLiteral :)
              or $state[$p:lk] = 324                        (: 'else' DecimalLiteral :)
              or $state[$p:lk] = 452                        (: 'else' OctalLiteral :)
              or $state[$p:lk] = 580                        (: 'else' FloatingPointLiteral :)
              or $state[$p:lk] = 708                        (: 'else' CharacterLiteral :)
              or $state[$p:lk] = 836                        (: 'else' StringLiteral :)
              or $state[$p:lk] = 1092                       (: 'else' ASSERT :)
              or $state[$p:lk] = 1220                       (: 'else' Identifier :)
              or $state[$p:lk] = 1860                       (: 'else' '!' :)
              or $state[$p:lk] = 2756                       (: 'else' '(' :)
              or $state[$p:lk] = 3268                       (: 'else' '+' :)
              or $state[$p:lk] = 3396                       (: 'else' '++' :)
              or $state[$p:lk] = 3780                       (: 'else' '-' :)
              or $state[$p:lk] = 3908                       (: 'else' '--' :)
              or $state[$p:lk] = 4804                       (: 'else' ';' :)
              or $state[$p:lk] = 7364                       (: 'else' 'boolean' :)
              or $state[$p:lk] = 7492                       (: 'else' 'break' :)
              or $state[$p:lk] = 7620                       (: 'else' 'byte' :)
              or $state[$p:lk] = 8004                       (: 'else' 'char' :)
              or $state[$p:lk] = 8260                       (: 'else' 'continue' :)
              or $state[$p:lk] = 8516                       (: 'else' 'do' :)
              or $state[$p:lk] = 8644                       (: 'else' 'double' :)
              or $state[$p:lk] = 9028                       (: 'else' 'false' :)
              or $state[$p:lk] = 9412                       (: 'else' 'float' :)
              or $state[$p:lk] = 9540                       (: 'else' 'for' :)
              or $state[$p:lk] = 9668                       (: 'else' 'if' :)
              or $state[$p:lk] = 10180                      (: 'else' 'int' :)
              or $state[$p:lk] = 10436                      (: 'else' 'long' :)
              or $state[$p:lk] = 10692                      (: 'else' 'new' :)
              or $state[$p:lk] = 10820                      (: 'else' 'null' :)
              or $state[$p:lk] = 11460                      (: 'else' 'return' :)
              or $state[$p:lk] = 11588                      (: 'else' 'short' :)
              or $state[$p:lk] = 11972                      (: 'else' 'super' :)
              or $state[$p:lk] = 12100                      (: 'else' 'switch' :)
              or $state[$p:lk] = 12228                      (: 'else' 'synchronized' :)
              or $state[$p:lk] = 12356                      (: 'else' 'this' :)
              or $state[$p:lk] = 12484                      (: 'else' 'throw' :)
              or $state[$p:lk] = 12868                      (: 'else' 'true' :)
              or $state[$p:lk] = 12996                      (: 'else' 'try' :)
              or $state[$p:lk] = 13124                      (: 'else' 'void' :)
              or $state[$p:lk] = 13380                      (: 'else' 'while' :)
              or $state[$p:lk] = 13508                      (: 'else' '{' :)
              or $state[$p:lk] = 14148) then                (: 'else' '~' :)
          let $state := p:memoized($state, 5)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state := p:consumeT(68, $input, $state)  (: 'else' :)
              let $state := p:lookahead1W(112, $input, $state) (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                                  FloatingPointLiteral | CharacterLiteral |
                                                                  StringLiteral | ASSERT | Identifier | WS | COMMENT |
                                                                  LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                                  ';' | 'boolean' | 'break' | 'byte' | 'char' |
                                                                  'continue' | 'do' | 'double' | 'false' | 'float' |
                                                                  'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                                  'return' | 'short' | 'super' | 'switch' |
                                                                  'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                                  'void' | 'while' | '{' | '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-statement($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1) then
          let $state := p:consume(68, $input, $state)       (: 'else' :)
          let $state := p:lookahead1W(112, $input, $state)  (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-statement($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:lk] = 74) then                       (: 'for' :)
      let $state := p:consume(74, $input, $state)           (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:consume(21, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(98, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '@' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'false' | 'final' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-forControl($input, $state)
      let $state := p:consume(22, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-statement($input, $state)
      return $state
    else if ($state[$p:lk] = 104) then                      (: 'while' :)
      let $state := p:consume(104, $input, $state)          (: 'while' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-parExpression($input, $state)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-statement($input, $state)
      return $state
    else if ($state[$p:lk] = 66) then                       (: 'do' :)
      let $state := p:consume(66, $input, $state)           (: 'do' :)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-statement($input, $state)
      let $state := p:lookahead1W(16, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'while' :)
      let $state := p:consume(104, $input, $state)          (: 'while' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-parExpression($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 101) then                      (: 'try' :)
      let $state := p:consume(101, $input, $state)          (: 'try' :)
      let $state := p:lookahead1W(17, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-block($input, $state)
      let $state := p:lookahead1W(38, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'catch' | 'finally' :)
      let $state :=
        if ($state[$p:l1] eq 61) then                       (: 'catch' :)
          let $state := p:lookahead2W(1, $input, $state)    (: WS | COMMENT | LINE_COMMENT | '(' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 2749) then                 (: 'catch' '(' :)
          let $state := p:memoized($state, 6)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-catches($input, $state)
              let $state := p:consumeT(72, $input, $state)  (: 'finally' :)
              let $state := p:lookahead1W(17, $input, $state) (: WS | COMMENT | LINE_COMMENT | '{' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-block($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1) then
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-catches($input, $state)
          let $state := p:consume(72, $input, $state)       (: 'finally' :)
          let $state := p:lookahead1W(17, $input, $state)   (: WS | COMMENT | LINE_COMMENT | '{' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-block($input, $state)
          return $state
        else if ($state[$p:lk] = -2) then
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-catches($input, $state)
          return $state
        else
          let $state := p:consume(72, $input, $state)       (: 'finally' :)
          let $state := p:lookahead1W(17, $input, $state)   (: WS | COMMENT | LINE_COMMENT | '{' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-block($input, $state)
          return $state
      return $state
    else if ($state[$p:lk] = 94) then                       (: 'switch' :)
      let $state := p:consume(94, $input, $state)           (: 'switch' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-parExpression($input, $state)
      let $state := p:lookahead1W(17, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '{' :)
      let $state := p:consume(105, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(52, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'case' | 'default' | '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-switchBlockStatementGroups($input, $state)
      let $state := p:consume(109, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:lk] = 95) then                       (: 'synchronized' :)
      let $state := p:consume(95, $input, $state)           (: 'synchronized' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-parExpression($input, $state)
      let $state := p:lookahead1W(17, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-block($input, $state)
      return $state
    else if ($state[$p:lk] = 89) then                       (: 'return' :)
      let $state := p:consume(89, $input, $state)           (: 'return' :)
      let $state := p:lookahead1W(92, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 37) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 97) then                       (: 'throw' :)
      let $state := p:consume(97, $input, $state)           (: 'throw' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 58) then                       (: 'break' :)
      let $state := p:consume(58, $input, $state)           (: 'break' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 9) then                    (: Identifier :)
          let $state := p:consume(9, $input, $state)        (: Identifier :)
          return $state
        else
          $state
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 64) then                       (: 'continue' :)
      let $state := p:consume(64, $input, $state)           (: 'continue' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 9) then                    (: Identifier :)
          let $state := p:consume(9, $input, $state)        (: Identifier :)
          return $state
        else
          $state
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 37) then                       (: ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 4617) then                     (: Identifier ':' :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(5, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ':' :)
      let $state := p:consume(36, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-statement($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-statementExpression($input, $state)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "statement", $count, $begin, $end)
};

(:~
 : Try parsing statement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-statement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(109, $input, $state)      (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | '*' | '*=' | '+' | '++' | '+=' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' |
                                                               '>>=' | '>>>' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-block($input, $state)
      return $state
    else if ($state[$p:lk] = 8) then                        (: ASSERT :)
      let $state := p:consumeT(8, $input, $state)           (: ASSERT :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 36) then                   (: ':' :)
          let $state := p:consumeT(36, $input, $state)      (: ':' :)
          let $state := p:lookahead1W(89, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 75) then                       (: 'if' :)
      let $state := p:consumeT(75, $input, $state)          (: 'if' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-parExpression($input, $state)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-statement($input, $state)
      let $state := p:lookahead1W(119, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'else' | 'false' | 'final' | 'float' |
                                                               'for' | 'if' | 'int' | 'interface' | 'long' | 'new' |
                                                               'null' | 'private' | 'protected' | 'public' | 'return' |
                                                               'short' | 'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' | '}' | '~' :)
      let $state :=
        if ($state[$p:l1] eq 68) then                       (: 'else' :)
          let $state := p:lookahead2W(112, $input, $state)  (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 196                        (: 'else' HexLiteral :)
              or $state[$p:lk] = 324                        (: 'else' DecimalLiteral :)
              or $state[$p:lk] = 452                        (: 'else' OctalLiteral :)
              or $state[$p:lk] = 580                        (: 'else' FloatingPointLiteral :)
              or $state[$p:lk] = 708                        (: 'else' CharacterLiteral :)
              or $state[$p:lk] = 836                        (: 'else' StringLiteral :)
              or $state[$p:lk] = 1092                       (: 'else' ASSERT :)
              or $state[$p:lk] = 1220                       (: 'else' Identifier :)
              or $state[$p:lk] = 1860                       (: 'else' '!' :)
              or $state[$p:lk] = 2756                       (: 'else' '(' :)
              or $state[$p:lk] = 3268                       (: 'else' '+' :)
              or $state[$p:lk] = 3396                       (: 'else' '++' :)
              or $state[$p:lk] = 3780                       (: 'else' '-' :)
              or $state[$p:lk] = 3908                       (: 'else' '--' :)
              or $state[$p:lk] = 4804                       (: 'else' ';' :)
              or $state[$p:lk] = 7364                       (: 'else' 'boolean' :)
              or $state[$p:lk] = 7492                       (: 'else' 'break' :)
              or $state[$p:lk] = 7620                       (: 'else' 'byte' :)
              or $state[$p:lk] = 8004                       (: 'else' 'char' :)
              or $state[$p:lk] = 8260                       (: 'else' 'continue' :)
              or $state[$p:lk] = 8516                       (: 'else' 'do' :)
              or $state[$p:lk] = 8644                       (: 'else' 'double' :)
              or $state[$p:lk] = 9028                       (: 'else' 'false' :)
              or $state[$p:lk] = 9412                       (: 'else' 'float' :)
              or $state[$p:lk] = 9540                       (: 'else' 'for' :)
              or $state[$p:lk] = 9668                       (: 'else' 'if' :)
              or $state[$p:lk] = 10180                      (: 'else' 'int' :)
              or $state[$p:lk] = 10436                      (: 'else' 'long' :)
              or $state[$p:lk] = 10692                      (: 'else' 'new' :)
              or $state[$p:lk] = 10820                      (: 'else' 'null' :)
              or $state[$p:lk] = 11460                      (: 'else' 'return' :)
              or $state[$p:lk] = 11588                      (: 'else' 'short' :)
              or $state[$p:lk] = 11972                      (: 'else' 'super' :)
              or $state[$p:lk] = 12100                      (: 'else' 'switch' :)
              or $state[$p:lk] = 12228                      (: 'else' 'synchronized' :)
              or $state[$p:lk] = 12356                      (: 'else' 'this' :)
              or $state[$p:lk] = 12484                      (: 'else' 'throw' :)
              or $state[$p:lk] = 12868                      (: 'else' 'true' :)
              or $state[$p:lk] = 12996                      (: 'else' 'try' :)
              or $state[$p:lk] = 13124                      (: 'else' 'void' :)
              or $state[$p:lk] = 13380                      (: 'else' 'while' :)
              or $state[$p:lk] = 13508                      (: 'else' '{' :)
              or $state[$p:lk] = 14148) then                (: 'else' '~' :)
          let $state := p:memoized($state, 5)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state := p:consumeT(68, $input, $state)  (: 'else' :)
              let $state := p:lookahead1W(112, $input, $state) (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                                  FloatingPointLiteral | CharacterLiteral |
                                                                  StringLiteral | ASSERT | Identifier | WS | COMMENT |
                                                                  LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                                  ';' | 'boolean' | 'break' | 'byte' | 'char' |
                                                                  'continue' | 'do' | 'double' | 'false' | 'float' |
                                                                  'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                                  'return' | 'short' | 'super' | 'switch' |
                                                                  'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                                  'void' | 'while' | '{' | '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-statement($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1) then
          let $state := p:consumeT(68, $input, $state)      (: 'else' :)
          let $state := p:lookahead1W(112, $input, $state)  (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-statement($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:lk] = 74) then                       (: 'for' :)
      let $state := p:consumeT(74, $input, $state)          (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:consumeT(21, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(98, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '@' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'false' | 'final' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-forControl($input, $state)
      let $state := p:consumeT(22, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-statement($input, $state)
      return $state
    else if ($state[$p:lk] = 104) then                      (: 'while' :)
      let $state := p:consumeT(104, $input, $state)         (: 'while' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-parExpression($input, $state)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-statement($input, $state)
      return $state
    else if ($state[$p:lk] = 66) then                       (: 'do' :)
      let $state := p:consumeT(66, $input, $state)          (: 'do' :)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-statement($input, $state)
      let $state := p:lookahead1W(16, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'while' :)
      let $state := p:consumeT(104, $input, $state)         (: 'while' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-parExpression($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 101) then                      (: 'try' :)
      let $state := p:consumeT(101, $input, $state)         (: 'try' :)
      let $state := p:lookahead1W(17, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-block($input, $state)
      let $state := p:lookahead1W(38, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'catch' | 'finally' :)
      let $state :=
        if ($state[$p:l1] eq 61) then                       (: 'catch' :)
          let $state := p:lookahead2W(1, $input, $state)    (: WS | COMMENT | LINE_COMMENT | '(' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 2749) then                 (: 'catch' '(' :)
          let $state := p:memoized($state, 6)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-catches($input, $state)
              let $state := p:consumeT(72, $input, $state)  (: 'finally' :)
              let $state := p:lookahead1W(17, $input, $state) (: WS | COMMENT | LINE_COMMENT | '{' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-block($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1) then
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-catches($input, $state)
          let $state := p:consumeT(72, $input, $state)      (: 'finally' :)
          let $state := p:lookahead1W(17, $input, $state)   (: WS | COMMENT | LINE_COMMENT | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-block($input, $state)
          return $state
        else if ($state[$p:lk] = -2) then
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-catches($input, $state)
          return $state
        else
          let $state := p:consumeT(72, $input, $state)      (: 'finally' :)
          let $state := p:lookahead1W(17, $input, $state)   (: WS | COMMENT | LINE_COMMENT | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-block($input, $state)
          return $state
      return $state
    else if ($state[$p:lk] = 94) then                       (: 'switch' :)
      let $state := p:consumeT(94, $input, $state)          (: 'switch' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-parExpression($input, $state)
      let $state := p:lookahead1W(17, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '{' :)
      let $state := p:consumeT(105, $input, $state)         (: '{' :)
      let $state := p:lookahead1W(52, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'case' | 'default' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-switchBlockStatementGroups($input, $state)
      let $state := p:consumeT(109, $input, $state)         (: '}' :)
      return $state
    else if ($state[$p:lk] = 95) then                       (: 'synchronized' :)
      let $state := p:consumeT(95, $input, $state)          (: 'synchronized' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-parExpression($input, $state)
      let $state := p:lookahead1W(17, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-block($input, $state)
      return $state
    else if ($state[$p:lk] = 89) then                       (: 'return' :)
      let $state := p:consumeT(89, $input, $state)          (: 'return' :)
      let $state := p:lookahead1W(92, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 37) then                  (: ';' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 97) then                       (: 'throw' :)
      let $state := p:consumeT(97, $input, $state)          (: 'throw' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 58) then                       (: 'break' :)
      let $state := p:consumeT(58, $input, $state)          (: 'break' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 9) then                    (: Identifier :)
          let $state := p:consumeT(9, $input, $state)       (: Identifier :)
          return $state
        else
          $state
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 64) then                       (: 'continue' :)
      let $state := p:consumeT(64, $input, $state)          (: 'continue' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 9) then                    (: Identifier :)
          let $state := p:consumeT(9, $input, $state)       (: Identifier :)
          return $state
        else
          $state
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 37) then                       (: ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 4617) then                     (: Identifier ':' :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:lookahead1W(5, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ':' :)
      let $state := p:consumeT(36, $input, $state)          (: ':' :)
      let $state := p:lookahead1W(112, $input, $state)      (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ASSERT | Identifier | WS | COMMENT | LINE_COMMENT | '!' |
                                                               '(' | '+' | '++' | '-' | '--' | ';' | 'boolean' |
                                                               'break' | 'byte' | 'char' | 'continue' | 'do' |
                                                               'double' | 'false' | 'float' | 'for' | 'if' | 'int' |
                                                               'long' | 'new' | 'null' | 'return' | 'short' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' | 'true' |
                                                               'try' | 'void' | 'while' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-statement($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-statementExpression($input, $state)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse annotationConstantRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationConstantRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableDeclarators($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationConstantRest", $count, $begin, $end)
};

(:~
 : Try parsing annotationConstantRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationConstantRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableDeclarators($input, $state)
  return $state
};

(:~
 : Parse defaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-defaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(65, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(95, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '@' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-elementValue($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "defaultValue", $count, $begin, $end)
};

(:~
 : Try parsing defaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-defaultValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(65, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(95, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '@' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-elementValue($input, $state)
  return $state
};

(:~
 : Parse annotationMethodRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationMethodRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WS | COMMENT | LINE_COMMENT | ')' :)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(32, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ';' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: 'default' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-defaultValue($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationMethodRest", $count, $begin, $end)
};

(:~
 : Try parsing annotationMethodRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationMethodRest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WS | COMMENT | LINE_COMMENT | ')' :)
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(32, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ';' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-defaultValue($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse annotationMethodOrConstantRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationMethodOrConstantRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(63, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | ',' | ';' | '=' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2697) then                     (: Identifier '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotationMethodRest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotationConstantRest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationMethodOrConstantRest", $count, $begin, $end)
};

(:~
 : Try parsing annotationMethodOrConstantRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationMethodOrConstantRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(63, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | ',' | ';' | '=' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2697) then                     (: Identifier '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotationMethodRest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotationConstantRest($input, $state)
      return $state
  return $state
};

(:~
 : Parse annotationTypeElementRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationTypeElementRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-normalClassDeclaration($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ';' :)
          let $state := p:consume(37, $input, $state)       (: ';' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-normalInterfaceDeclaration($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ';' :)
          let $state := p:consume(37, $input, $state)       (: ';' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 7) then                        (: ENUM :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-enumDeclaration($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ';' :)
          let $state := p:consume(37, $input, $state)       (: ';' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotationTypeDeclaration($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ';' :)
          let $state := p:consume(37, $input, $state)       (: ';' :)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-type($input, $state)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotationMethodOrConstantRest($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationTypeElementRest", $count, $begin, $end)
};

(:~
 : Try parsing annotationTypeElementRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationTypeElementRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-normalClassDeclaration($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ';' :)
          let $state := p:consumeT(37, $input, $state)      (: ';' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-normalInterfaceDeclaration($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ';' :)
          let $state := p:consumeT(37, $input, $state)      (: ';' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 7) then                        (: ENUM :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-enumDeclaration($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ';' :)
          let $state := p:consumeT(37, $input, $state)      (: ';' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotationTypeDeclaration($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: ';' :)
          let $state := p:consumeT(37, $input, $state)      (: ';' :)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-type($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotationMethodOrConstantRest($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse annotationTypeElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationTypeElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-modifiers($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotationTypeElementRest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationTypeElementDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing annotationTypeElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationTypeElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-modifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotationTypeElementRest($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production annotationTypeBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationTypeBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(83, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'abstract' | 'boolean' | 'byte' | 'char' | 'class' |
                                                               'double' | 'final' | 'float' | 'int' | 'interface' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' | '}' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-annotationTypeElementDeclaration($input, $state)
        return p:parse-annotationTypeBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production annotationTypeBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationTypeBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(83, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'abstract' | 'boolean' | 'byte' | 'char' | 'class' |
                                                               'double' | 'final' | 'float' | 'int' | 'interface' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' | '}' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-annotationTypeElementDeclaration($input, $state)
        return p:try-annotationTypeBody-1($input, $state)
};

(:~
 : Parse annotationTypeBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationTypeBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: '{' :)
  let $state := p:parse-annotationTypeBody-1($input, $state)
  let $state := p:consume(109, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationTypeBody", $count, $begin, $end)
};

(:~
 : Try parsing annotationTypeBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationTypeBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(105, $input, $state)             (: '{' :)
  let $state := p:try-annotationTypeBody-1($input, $state)
  let $state := p:consumeT(109, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse annotationTypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationTypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(51, $input, $state)               (: '@' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'interface' :)
  let $state := p:consume(80, $input, $state)               (: 'interface' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(17, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotationTypeBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationTypeDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing annotationTypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationTypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(51, $input, $state)              (: '@' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'interface' :)
  let $state := p:consumeT(80, $input, $state)              (: 'interface' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(17, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotationTypeBody($input, $state)
  return $state
};

(:~
 : Parse voidInterfaceMethodDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-voidInterfaceMethodDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-formalParameters($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ';' | 'throws' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consume(98, $input, $state)           (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "voidInterfaceMethodDeclaratorRest", $count, $begin, $end)
};

(:~
 : Try parsing voidInterfaceMethodDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-voidInterfaceMethodDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-formalParameters($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ';' | 'throws' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consumeT(98, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(37, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse interfaceGenericMethodDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceGenericMethodDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-typeParameters($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' | 'void' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 102) then                      (: 'void' :)
      let $state := p:consume(102, $input, $state)          (: 'void' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-type($input, $state)
      return $state
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-interfaceMethodDeclaratorRest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "interfaceGenericMethodDecl", $count, $begin, $end)
};

(:~
 : Try parsing interfaceGenericMethodDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceGenericMethodDecl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-typeParameters($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' | 'void' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 102) then                      (: 'void' :)
      let $state := p:consumeT(102, $input, $state)         (: 'void' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-type($input, $state)
      return $state
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-interfaceMethodDeclaratorRest($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production qualifiedName (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-qualifiedName-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | '.' | ';' | '{' :)
    let $state :=
      if ($state[$p:l1] eq 32) then                         (: '.' :)
        let $state := p:lookahead2W(19, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | '*' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1184) then                       (: '.' Identifier :)
        $state
      else
        let $state := p:consume(32, $input, $state)         (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consume(9, $input, $state)          (: Identifier :)
        return p:parse-qualifiedName-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production qualifiedName (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-qualifiedName-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | '.' | ';' | '{' :)
    let $state :=
      if ($state[$p:l1] eq 32) then                         (: '.' :)
        let $state := p:lookahead2W(19, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | '*' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1184) then                       (: '.' Identifier :)
        $state
      else
        let $state := p:consumeT(32, $input, $state)        (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consumeT(9, $input, $state)         (: Identifier :)
        return p:try-qualifiedName-1($input, $state)
};

(:~
 : Parse qualifiedName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-qualifiedName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:parse-qualifiedName-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "qualifiedName", $count, $begin, $end)
};

(:~
 : Try parsing qualifiedName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-qualifiedName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:try-qualifiedName-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production qualifiedNameList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-qualifiedNameList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consume(28, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-qualifiedName($input, $state)
      return p:parse-qualifiedNameList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production qualifiedNameList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-qualifiedNameList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(28, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-qualifiedName($input, $state)
      return p:try-qualifiedNameList-1($input, $state)
};

(:~
 : Parse qualifiedNameList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-qualifiedNameList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-qualifiedName($input, $state)
  let $state := p:parse-qualifiedNameList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "qualifiedNameList", $count, $begin, $end)
};

(:~
 : Try parsing qualifiedNameList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-qualifiedNameList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-qualifiedName($input, $state)
  let $state := p:try-qualifiedNameList-1($input, $state)
  return $state
};

(:~
 : Parse formalParameterDeclsRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-formalParameterDeclsRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9) then                        (: Identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-variableDeclaratorId($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: ',' :)
          let $state := p:consume(28, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(75, $input, $state)   (: Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-formalParameterDecls($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state := p:consume(33, $input, $state)           (: '...' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-variableDeclaratorId($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "formalParameterDeclsRest", $count, $begin, $end)
};

(:~
 : Try parsing formalParameterDeclsRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-formalParameterDeclsRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9) then                        (: Identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-variableDeclaratorId($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: ',' :)
          let $state := p:consumeT(28, $input, $state)      (: ',' :)
          let $state := p:lookahead1W(75, $input, $state)   (: Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-formalParameterDecls($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state := p:consumeT(33, $input, $state)          (: '...' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-variableDeclaratorId($input, $state)
      return $state
  return $state
};

(:~
 : Parse formalParameterDecls.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-formalParameterDecls($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableModifiers($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-type($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-formalParameterDeclsRest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "formalParameterDecls", $count, $begin, $end)
};

(:~
 : Try parsing formalParameterDecls.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-formalParameterDecls($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableModifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-type($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-formalParameterDeclsRest($input, $state)
  return $state
};

(:~
 : Parse formalParameters.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-formalParameters($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(76, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | ')' | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 22) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-formalParameterDecls($input, $state)
      return $state
    else
      $state
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "formalParameters", $count, $begin, $end)
};

(:~
 : Try parsing formalParameters.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-formalParameters($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(76, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | ')' | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 22) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-formalParameterDecls($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse the 1st loop of production interfaceMethodDeclaratorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceMethodDeclaratorRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(49, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ';' | '[' | 'throws' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-interfaceMethodDeclaratorRest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production interfaceMethodDeclaratorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceMethodDeclaratorRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(49, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ';' | '[' | 'throws' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-interfaceMethodDeclaratorRest-1($input, $state)
};

(:~
 : Parse interfaceMethodDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceMethodDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-formalParameters($input, $state)
  let $state := p:parse-interfaceMethodDeclaratorRest-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consume(98, $input, $state)           (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "interfaceMethodDeclaratorRest", $count, $begin, $end)
};

(:~
 : Try parsing interfaceMethodDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceMethodDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-formalParameters($input, $state)
  let $state := p:try-interfaceMethodDeclaratorRest-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'throws' :)
      let $state := p:consumeT(98, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-qualifiedNameList($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(37, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse constantDeclarator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constantDeclarator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(36, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '=' | '[' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-constantDeclaratorRest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "constantDeclarator", $count, $begin, $end)
};

(:~
 : Try parsing constantDeclarator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constantDeclarator($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(36, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '=' | '[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-constantDeclaratorRest($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production constantDeclaratorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constantDeclaratorRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: WS | COMMENT | LINE_COMMENT | '=' | '[' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-constantDeclaratorRest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production constantDeclaratorRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constantDeclaratorRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: WS | COMMENT | LINE_COMMENT | '=' | '[' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-constantDeclaratorRest-1($input, $state)
};

(:~
 : Parse constantDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constantDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-constantDeclaratorRest-1($input, $state)
  let $state := p:consume(42, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(94, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableInitializer($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "constantDeclaratorRest", $count, $begin, $end)
};

(:~
 : Try parsing constantDeclaratorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constantDeclaratorRest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-constantDeclaratorRest-1($input, $state)
  let $state := p:consumeT(42, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(94, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableInitializer($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production constantDeclaratorsRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constantDeclaratorsRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(29, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | ';' :)
    return
      if ($state[$p:l1] != 28) then                         (: ',' :)
        $state
      else
        let $state := p:consume(28, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-constantDeclarator($input, $state)
        return p:parse-constantDeclaratorsRest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production constantDeclaratorsRest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constantDeclaratorsRest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(29, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | ';' :)
    return
      if ($state[$p:l1] != 28) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(28, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-constantDeclarator($input, $state)
        return p:try-constantDeclaratorsRest-1($input, $state)
};

(:~
 : Parse constantDeclaratorsRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-constantDeclaratorsRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-constantDeclaratorRest($input, $state)
  let $state := p:parse-constantDeclaratorsRest-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "constantDeclaratorsRest", $count, $begin, $end)
};

(:~
 : Try parsing constantDeclaratorsRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-constantDeclaratorsRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-constantDeclaratorRest($input, $state)
  let $state := p:try-constantDeclaratorsRest-1($input, $state)
  return $state
};

(:~
 : Parse interfaceMethodOrFieldRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceMethodOrFieldRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-interfaceMethodDeclaratorRest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-constantDeclaratorsRest($input, $state)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "interfaceMethodOrFieldRest", $count, $begin, $end)
};

(:~
 : Try parsing interfaceMethodOrFieldRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceMethodOrFieldRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-interfaceMethodDeclaratorRest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-constantDeclaratorsRest($input, $state)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse interfaceMethodOrFieldDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceMethodOrFieldDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-type($input, $state)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(45, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '(' | '=' | '[' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-interfaceMethodOrFieldRest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "interfaceMethodOrFieldDecl", $count, $begin, $end)
};

(:~
 : Try parsing interfaceMethodOrFieldDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceMethodOrFieldDecl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-type($input, $state)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(45, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '(' | '=' | '[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-interfaceMethodOrFieldRest($input, $state)
  return $state
};

(:~
 : Parse interfaceMemberDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceMemberDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-interfaceGenericMethodDecl($input, $state)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'void' :)
      let $state := p:consume(102, $input, $state)          (: 'void' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-voidInterfaceMethodDeclaratorRest($input, $state)
      return $state
    else if ($state[$p:l1] = 51                             (: '@' :)
          or $state[$p:l1] = 80) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-interfaceDeclaration($input, $state)
      return $state
    else if ($state[$p:l1] = 7                              (: ENUM :)
          or $state[$p:l1] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-interfaceMethodOrFieldDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "interfaceMemberDecl", $count, $begin, $end)
};

(:~
 : Try parsing interfaceMemberDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceMemberDecl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-interfaceGenericMethodDecl($input, $state)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'void' :)
      let $state := p:consumeT(102, $input, $state)         (: 'void' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-voidInterfaceMethodDeclaratorRest($input, $state)
      return $state
    else if ($state[$p:l1] = 51                             (: '@' :)
          or $state[$p:l1] = 80) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-interfaceDeclaration($input, $state)
      return $state
    else if ($state[$p:l1] = 7                              (: ENUM :)
          or $state[$p:l1] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-interfaceMethodOrFieldDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse modifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-modifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotation($input, $state)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'public' :)
      let $state := p:consume(88, $input, $state)           (: 'public' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'protected' :)
      let $state := p:consume(87, $input, $state)           (: 'protected' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'private' :)
      let $state := p:consume(86, $input, $state)           (: 'private' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'static' :)
      let $state := p:consume(91, $input, $state)           (: 'static' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'abstract' :)
      let $state := p:consume(56, $input, $state)           (: 'abstract' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'final' :)
      let $state := p:consume(71, $input, $state)           (: 'final' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'native' :)
      let $state := p:consume(82, $input, $state)           (: 'native' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'synchronized' :)
      let $state := p:consume(95, $input, $state)           (: 'synchronized' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'transient' :)
      let $state := p:consume(99, $input, $state)           (: 'transient' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'volatile' :)
      let $state := p:consume(103, $input, $state)          (: 'volatile' :)
      return $state
    else
      let $state := p:consume(92, $input, $state)           (: 'strictfp' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "modifier", $count, $begin, $end)
};

(:~
 : Try parsing modifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-modifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotation($input, $state)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'public' :)
      let $state := p:consumeT(88, $input, $state)          (: 'public' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'protected' :)
      let $state := p:consumeT(87, $input, $state)          (: 'protected' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'private' :)
      let $state := p:consumeT(86, $input, $state)          (: 'private' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'static' :)
      let $state := p:consumeT(91, $input, $state)          (: 'static' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'abstract' :)
      let $state := p:consumeT(56, $input, $state)          (: 'abstract' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'final' :)
      let $state := p:consumeT(71, $input, $state)          (: 'final' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'native' :)
      let $state := p:consumeT(82, $input, $state)          (: 'native' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'synchronized' :)
      let $state := p:consumeT(95, $input, $state)          (: 'synchronized' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'transient' :)
      let $state := p:consumeT(99, $input, $state)          (: 'transient' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'volatile' :)
      let $state := p:consumeT(103, $input, $state)         (: 'volatile' :)
      return $state
    else
      let $state := p:consumeT(92, $input, $state)          (: 'strictfp' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production modifiers (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-modifiers-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(85, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' :)
    let $state :=
      if ($state[$p:l1] eq 51) then                         (: '@' :)
        let $state := p:lookahead2W(23, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 56                               (: 'abstract' :)
      and $state[$p:lk] != 71                               (: 'final' :)
      and $state[$p:lk] != 82                               (: 'native' :)
      and $state[$p:lk] != 86                               (: 'private' :)
      and $state[$p:lk] != 87                               (: 'protected' :)
      and $state[$p:lk] != 88                               (: 'public' :)
      and $state[$p:lk] != 91                               (: 'static' :)
      and $state[$p:lk] != 92                               (: 'strictfp' :)
      and $state[$p:lk] != 95                               (: 'synchronized' :)
      and $state[$p:lk] != 99                               (: 'transient' :)
      and $state[$p:lk] != 103                              (: 'volatile' :)
      and $state[$p:lk] != 1203) then                       (: '@' Identifier :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-modifier($input, $state)
        return p:parse-modifiers-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production modifiers (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-modifiers-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(85, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' :)
    let $state :=
      if ($state[$p:l1] eq 51) then                         (: '@' :)
        let $state := p:lookahead2W(23, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 56                               (: 'abstract' :)
      and $state[$p:lk] != 71                               (: 'final' :)
      and $state[$p:lk] != 82                               (: 'native' :)
      and $state[$p:lk] != 86                               (: 'private' :)
      and $state[$p:lk] != 87                               (: 'protected' :)
      and $state[$p:lk] != 88                               (: 'public' :)
      and $state[$p:lk] != 91                               (: 'static' :)
      and $state[$p:lk] != 92                               (: 'strictfp' :)
      and $state[$p:lk] != 95                               (: 'synchronized' :)
      and $state[$p:lk] != 99                               (: 'transient' :)
      and $state[$p:lk] != 103                              (: 'volatile' :)
      and $state[$p:lk] != 1203) then                       (: '@' Identifier :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-modifier($input, $state)
        return p:try-modifiers-1($input, $state)
};

(:~
 : Parse modifiers.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-modifiers($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-modifiers-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "modifiers", $count, $begin, $end)
};

(:~
 : Try parsing modifiers.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-modifiers($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-modifiers-1($input, $state)
  return $state
};

(:~
 : Parse interfaceBodyDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceBodyDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-modifiers($input, $state)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-interfaceMemberDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "interfaceBodyDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing interfaceBodyDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceBodyDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-modifiers($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-interfaceMemberDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production interfaceBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(87, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '<' | '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '}' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-interfaceBodyDeclaration($input, $state)
        return p:parse-interfaceBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production interfaceBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(87, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '<' | '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '}' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-interfaceBodyDeclaration($input, $state)
        return p:try-interfaceBody-1($input, $state)
};

(:~
 : Parse interfaceBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: '{' :)
  let $state := p:parse-interfaceBody-1($input, $state)
  let $state := p:consume(109, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "interfaceBody", $count, $begin, $end)
};

(:~
 : Try parsing interfaceBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(105, $input, $state)             (: '{' :)
  let $state := p:try-interfaceBody-1($input, $state)
  let $state := p:consumeT(109, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse normalInterfaceDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-normalInterfaceDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(80, $input, $state)               (: 'interface' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(51, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '<' | 'extends' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(39, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'extends' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'extends' :)
      let $state := p:consume(69, $input, $state)           (: 'extends' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeList($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-interfaceBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "normalInterfaceDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing normalInterfaceDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-normalInterfaceDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(80, $input, $state)              (: 'interface' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(51, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '<' | 'extends' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(39, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'extends' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'extends' :)
      let $state := p:consumeT(69, $input, $state)          (: 'extends' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-interfaceBody($input, $state)
  return $state
};

(:~
 : Parse interfaceDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-interfaceDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-normalInterfaceDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotationTypeDeclaration($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "interfaceDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing interfaceDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-interfaceDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-normalInterfaceDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotationTypeDeclaration($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production enumBodyDeclarations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enumBodyDeclarations-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(90, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '<' | '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' | '}' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-classBodyDeclaration($input, $state)
        return p:parse-enumBodyDeclarations-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production enumBodyDeclarations (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enumBodyDeclarations-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(90, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '<' | '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' | '}' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-classBodyDeclaration($input, $state)
        return p:try-enumBodyDeclarations-1($input, $state)
};

(:~
 : Parse enumBodyDeclarations.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enumBodyDeclarations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(37, $input, $state)               (: ';' :)
  let $state := p:parse-enumBodyDeclarations-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "enumBodyDeclarations", $count, $begin, $end)
};

(:~
 : Try parsing enumBodyDeclarations.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enumBodyDeclarations($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(37, $input, $state)              (: ';' :)
  let $state := p:try-enumBodyDeclarations-1($input, $state)
  return $state
};

(:~
 : Parse enumConstant.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enumConstant($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotations($input, $state)
      return $state
    else
      $state
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(64, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '(' | ',' | ';' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-arguments($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(57, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ',' | ';' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classBody($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "enumConstant", $count, $begin, $end)
};

(:~
 : Try parsing enumConstant.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enumConstant($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotations($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(64, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '(' | ',' | ';' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-arguments($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(57, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ',' | ';' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classBody($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production enumConstants (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enumConstants-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(47, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | ';' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 28) then                         (: ',' :)
        let $state := p:lookahead2W(54, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | ';' | '@' |
                                                               '}' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1180                             (: ',' Identifier :)
      and $state[$p:lk] != 6556) then                       (: ',' '@' :)
        $state
      else
        let $state := p:consume(28, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | '@' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-enumConstant($input, $state)
        return p:parse-enumConstants-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production enumConstants (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enumConstants-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(47, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | ';' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 28) then                         (: ',' :)
        let $state := p:lookahead2W(54, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | ';' | '@' |
                                                               '}' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1180                             (: ',' Identifier :)
      and $state[$p:lk] != 6556) then                       (: ',' '@' :)
        $state
      else
        let $state := p:consumeT(28, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | '@' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-enumConstant($input, $state)
        return p:try-enumConstants-1($input, $state)
};

(:~
 : Parse enumConstants.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enumConstants($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-enumConstant($input, $state)
  let $state := p:parse-enumConstants-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "enumConstants", $count, $begin, $end)
};

(:~
 : Try parsing enumConstants.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enumConstants($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-enumConstant($input, $state)
  let $state := p:try-enumConstants-1($input, $state)
  return $state
};

(:~
 : Parse enumBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enumBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(62, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | ',' | ';' |
                                                               '@' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9                              (: Identifier :)
          or $state[$p:l1] = 51) then                       (: '@' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-enumConstants($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: ',' :)
      let $state := p:consume(28, $input, $state)           (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(34, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ';' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: ';' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-enumBodyDeclarations($input, $state)
      return $state
    else
      $state
  let $state := p:consume(109, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "enumBody", $count, $begin, $end)
};

(:~
 : Try parsing enumBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enumBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(105, $input, $state)             (: '{' :)
  let $state := p:lookahead1W(62, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | ',' | ';' |
                                                               '@' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9                              (: Identifier :)
          or $state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-enumConstants($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: ',' :)
      let $state := p:consumeT(28, $input, $state)          (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(34, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ';' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-enumBodyDeclarations($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(109, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse enumDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-enumDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(7, $input, $state)                (: ENUM :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(40, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'implements' :)
      let $state := p:consume(76, $input, $state)           (: 'implements' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeList($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-enumBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "enumDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing enumDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-enumDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(7, $input, $state)               (: ENUM :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(40, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'implements' :)
      let $state := p:consumeT(76, $input, $state)          (: 'implements' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-enumBody($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production typeBound (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeBound-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 18) then                           (: '&' :)
      $state
    else
      let $state := p:consume(18, $input, $state)           (: '&' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-type($input, $state)
      return p:parse-typeBound-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production typeBound (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeBound-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 18) then                           (: '&' :)
      $state
    else
      let $state := p:consumeT(18, $input, $state)          (: '&' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-type($input, $state)
      return p:try-typeBound-1($input, $state)
};

(:~
 : Parse typeBound.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeBound($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-type($input, $state)
  let $state := p:parse-typeBound-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "typeBound", $count, $begin, $end)
};

(:~
 : Try parsing typeBound.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeBound($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-type($input, $state)
  let $state := p:try-typeBound-1($input, $state)
  return $state
};

(:~
 : Parse typeParameter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeParameter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(48, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ',' | '>' | 'extends' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'extends' :)
      let $state := p:consume(69, $input, $state)           (: 'extends' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeBound($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "typeParameter", $count, $begin, $end)
};

(:~
 : Try parsing typeParameter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeParameter($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(48, $input, $state)           (: WS | COMMENT | LINE_COMMENT | ',' | '>' | 'extends' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'extends' :)
      let $state := p:consumeT(69, $input, $state)          (: 'extends' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeBound($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production typeParameters (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeParameters-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consume(28, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeParameter($input, $state)
      return p:parse-typeParameters-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production typeParameters (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeParameters-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(28, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeParameter($input, $state)
      return p:try-typeParameters-1($input, $state)
};

(:~
 : Parse typeParameters.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeParameters($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(38, $input, $state)               (: '<' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-typeParameter($input, $state)
  let $state := p:parse-typeParameters-1($input, $state)
  let $state := p:consume(44, $input, $state)               (: '>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "typeParameters", $count, $begin, $end)
};

(:~
 : Try parsing typeParameters.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeParameters($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(38, $input, $state)              (: '<' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-typeParameter($input, $state)
  let $state := p:try-typeParameters-1($input, $state)
  let $state := p:consumeT(44, $input, $state)              (: '>' :)
  return $state
};

(:~
 : Parse normalClassDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-normalClassDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(63, $input, $state)               (: 'class' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(60, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '<' | 'extends' |
                                                               'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(53, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'extends' | 'implements' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'extends' :)
      let $state := p:consume(69, $input, $state)           (: 'extends' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-type($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'implements' :)
      let $state := p:consume(76, $input, $state)           (: 'implements' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeList($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-classBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "normalClassDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing normalClassDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-normalClassDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(63, $input, $state)              (: 'class' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(60, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '<' | 'extends' |
                                                               'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(53, $input, $state)           (: WS | COMMENT | LINE_COMMENT | 'extends' | 'implements' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'extends' :)
      let $state := p:consumeT(69, $input, $state)          (: 'extends' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-type($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'implements' :)
      let $state := p:consumeT(76, $input, $state)          (: 'implements' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-classBody($input, $state)
  return $state
};

(:~
 : Parse classDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-normalClassDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-enumDeclaration($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "classDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing classDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-normalClassDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-enumDeclaration($input, $state)
      return $state
  return $state
};

(:~
 : Parse classOrInterfaceModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classOrInterfaceModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotation($input, $state)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'public' :)
      let $state := p:consume(88, $input, $state)           (: 'public' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'protected' :)
      let $state := p:consume(87, $input, $state)           (: 'protected' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'private' :)
      let $state := p:consume(86, $input, $state)           (: 'private' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'abstract' :)
      let $state := p:consume(56, $input, $state)           (: 'abstract' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'static' :)
      let $state := p:consume(91, $input, $state)           (: 'static' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'final' :)
      let $state := p:consume(71, $input, $state)           (: 'final' :)
      return $state
    else
      let $state := p:consume(92, $input, $state)           (: 'strictfp' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "classOrInterfaceModifier", $count, $begin, $end)
};

(:~
 : Try parsing classOrInterfaceModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classOrInterfaceModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotation($input, $state)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'public' :)
      let $state := p:consumeT(88, $input, $state)          (: 'public' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'protected' :)
      let $state := p:consumeT(87, $input, $state)          (: 'protected' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'private' :)
      let $state := p:consumeT(86, $input, $state)          (: 'private' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'abstract' :)
      let $state := p:consumeT(56, $input, $state)          (: 'abstract' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'static' :)
      let $state := p:consumeT(91, $input, $state)          (: 'static' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'final' :)
      let $state := p:consumeT(71, $input, $state)          (: 'final' :)
      return $state
    else
      let $state := p:consumeT(92, $input, $state)          (: 'strictfp' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production classOrInterfaceModifiers (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classOrInterfaceModifiers-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(74, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | '@' | 'abstract' |
                                                               'class' | 'final' | 'interface' | 'private' |
                                                               'protected' | 'public' | 'static' | 'strictfp' :)
    let $state :=
      if ($state[$p:l1] eq 51) then                         (: '@' :)
        let $state := p:lookahead2W(23, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 7                                 (: ENUM :)
       or $state[$p:lk] = 63                                (: 'class' :)
       or $state[$p:lk] = 80                                (: 'interface' :)
       or $state[$p:lk] = 10291) then                       (: '@' 'interface' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-classOrInterfaceModifier($input, $state)
        return p:parse-classOrInterfaceModifiers-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production classOrInterfaceModifiers (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classOrInterfaceModifiers-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(74, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | '@' | 'abstract' |
                                                               'class' | 'final' | 'interface' | 'private' |
                                                               'protected' | 'public' | 'static' | 'strictfp' :)
    let $state :=
      if ($state[$p:l1] eq 51) then                         (: '@' :)
        let $state := p:lookahead2W(23, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 7                                 (: ENUM :)
       or $state[$p:lk] = 63                                (: 'class' :)
       or $state[$p:lk] = 80                                (: 'interface' :)
       or $state[$p:lk] = 10291) then                       (: '@' 'interface' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-classOrInterfaceModifier($input, $state)
        return p:try-classOrInterfaceModifiers-1($input, $state)
};

(:~
 : Parse classOrInterfaceModifiers.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classOrInterfaceModifiers($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-classOrInterfaceModifiers-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "classOrInterfaceModifiers", $count, $begin, $end)
};

(:~
 : Try parsing classOrInterfaceModifiers.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classOrInterfaceModifiers($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-classOrInterfaceModifiers-1($input, $state)
  return $state
};

(:~
 : Parse classOrInterfaceDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classOrInterfaceDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-classOrInterfaceModifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7                              (: ENUM :)
          or $state[$p:l1] = 63) then                       (: 'class' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classDeclaration($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-interfaceDeclaration($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "classOrInterfaceDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing classOrInterfaceDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classOrInterfaceDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-classOrInterfaceModifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7                              (: ENUM :)
          or $state[$p:l1] = 63) then                       (: 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-interfaceDeclaration($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production arrayInitializer (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-arrayInitializer-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 28) then                         (: ',' :)
        let $state := p:lookahead2W(96, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '}' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 109                               (: '}' :)
       or $state[$p:lk] = 13980) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consume(28, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(94, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-variableInitializer($input, $state)
        return p:parse-arrayInitializer-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production arrayInitializer (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-arrayInitializer-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 28) then                         (: ',' :)
        let $state := p:lookahead2W(96, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '}' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 109                               (: '}' :)
       or $state[$p:lk] = 13980) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consumeT(28, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(94, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-variableInitializer($input, $state)
        return p:try-arrayInitializer-1($input, $state)
};

(:~
 : Parse arrayInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-arrayInitializer($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(96, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 109) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-variableInitializer($input, $state)
      let $state := p:parse-arrayInitializer-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: ',' :)
          let $state := p:consume(28, $input, $state)       (: ',' :)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(18, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '}' :)
  let $state := p:consume(109, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "arrayInitializer", $count, $begin, $end)
};

(:~
 : Try parsing arrayInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-arrayInitializer($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(105, $input, $state)             (: '{' :)
  let $state := p:lookahead1W(96, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 109) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-variableInitializer($input, $state)
      let $state := p:try-arrayInitializer-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: ',' :)
          let $state := p:consumeT(28, $input, $state)      (: ',' :)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(18, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '}' :)
  let $state := p:consumeT(109, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse variableInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableInitializer($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-arrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "variableInitializer", $count, $begin, $end)
};

(:~
 : Try parsing variableInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableInitializer($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-arrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production variableDeclaratorId (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableDeclaratorId-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(65, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ')' | ',' | ';' | '=' | '[' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-variableDeclaratorId-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production variableDeclaratorId (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableDeclaratorId-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(65, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ')' | ',' | ';' | '=' | '[' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-variableDeclaratorId-1($input, $state)
};

(:~
 : Parse variableDeclaratorId.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableDeclaratorId($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:parse-variableDeclaratorId-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "variableDeclaratorId", $count, $begin, $end)
};

(:~
 : Try parsing variableDeclaratorId.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableDeclaratorId($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:try-variableDeclaratorId-1($input, $state)
  return $state
};

(:~
 : Parse variableDeclarator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableDeclarator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableDeclaratorId($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 42) then                       (: '=' :)
      let $state := p:consume(42, $input, $state)           (: '=' :)
      let $state := p:lookahead1W(94, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-variableInitializer($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "variableDeclarator", $count, $begin, $end)
};

(:~
 : Try parsing variableDeclarator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableDeclarator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableDeclaratorId($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 42) then                       (: '=' :)
      let $state := p:consumeT(42, $input, $state)          (: '=' :)
      let $state := p:lookahead1W(94, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-variableInitializer($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production variableDeclarators (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableDeclarators-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(29, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | ';' :)
    return
      if ($state[$p:l1] != 28) then                         (: ',' :)
        $state
      else
        let $state := p:consume(28, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-variableDeclarator($input, $state)
        return p:parse-variableDeclarators-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production variableDeclarators (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableDeclarators-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(29, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ',' | ';' :)
    return
      if ($state[$p:l1] != 28) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(28, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-variableDeclarator($input, $state)
        return p:try-variableDeclarators-1($input, $state)
};

(:~
 : Parse variableDeclarators.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableDeclarators($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableDeclarator($input, $state)
  let $state := p:parse-variableDeclarators-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "variableDeclarators", $count, $begin, $end)
};

(:~
 : Try parsing variableDeclarators.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableDeclarators($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableDeclarator($input, $state)
  let $state := p:try-variableDeclarators-1($input, $state)
  return $state
};

(:~
 : Parse variableModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'final' :)
      let $state := p:consume(71, $input, $state)           (: 'final' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotation($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "variableModifier", $count, $begin, $end)
};

(:~
 : Try parsing variableModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'final' :)
      let $state := p:consumeT(71, $input, $state)          (: 'final' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotation($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production variableModifiers (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableModifiers-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(75, $input, $state)         (: Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
    return
      if ($state[$p:l1] != 51                               (: '@' :)
      and $state[$p:l1] != 71) then                         (: 'final' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-variableModifier($input, $state)
        return p:parse-variableModifiers-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production variableModifiers (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableModifiers-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(75, $input, $state)         (: Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'short' :)
    return
      if ($state[$p:l1] != 51                               (: '@' :)
      and $state[$p:l1] != 71) then                         (: 'final' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-variableModifier($input, $state)
        return p:try-variableModifiers-1($input, $state)
};

(:~
 : Parse variableModifiers.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-variableModifiers($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-variableModifiers-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "variableModifiers", $count, $begin, $end)
};

(:~
 : Try parsing variableModifiers.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-variableModifiers($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-variableModifiers-1($input, $state)
  return $state
};

(:~
 : Parse localVariableDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-localVariableDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableModifiers($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-type($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-variableDeclarators($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "localVariableDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing localVariableDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-localVariableDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableModifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-type($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-variableDeclarators($input, $state)
  return $state
};

(:~
 : Parse localVariableDeclarationStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-localVariableDeclarationStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-localVariableDeclaration($input, $state)
  let $state := p:consume(37, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "localVariableDeclarationStatement", $count, $begin, $end)
};

(:~
 : Try parsing localVariableDeclarationStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-localVariableDeclarationStatement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-localVariableDeclaration($input, $state)
  let $state := p:consumeT(37, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse blockStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-blockStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(111, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | '-' | '--' | '-=' | '.' | '/' | '/=' |
                                                               ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                               '>' | '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] eq 51) then                      (: '@' :)
      let $state := p:lookahead2W(23, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
      return $state
    else if ($state[$p:l1] eq 71) then                      (: 'final' :)
      let $state := p:lookahead2W(81, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'abstract' | 'boolean' | 'byte' | 'char' | 'class' |
                                                               'double' | 'final' | 'float' | 'int' | 'interface' |
                                                               'long' | 'private' | 'protected' | 'public' | 'short' |
                                                               'static' | 'strictfp' :)
      return $state
    else if ($state[$p:l1] = (57,                           (: 'boolean' :)
                              59,                           (: 'byte' :)
                              62,                           (: 'char' :)
                              67,                           (: 'double' :)
                              73,                           (: 'float' :)
                              79,                           (: 'int' :)
                              81,                           (: 'long' :)
                              90)) then                     (: 'short' :)
      let $state := p:lookahead2W(43, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '.' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1203                           (: '@' Identifier :)
          or $state[$p:lk] = 4105                           (: Identifier '.' :)
          or $state[$p:lk] = 4873                           (: Identifier '<' :)
          or $state[$p:lk] = 6599                           (: 'final' '@' :)
          or $state[$p:lk] = 6665                           (: Identifier '[' :)
          or $state[$p:lk] = 6713                           (: 'boolean' '[' :)
          or $state[$p:lk] = 6715                           (: 'byte' '[' :)
          or $state[$p:lk] = 6718                           (: 'char' '[' :)
          or $state[$p:lk] = 6723                           (: 'double' '[' :)
          or $state[$p:lk] = 6729                           (: 'float' '[' :)
          or $state[$p:lk] = 6735                           (: 'int' '[' :)
          or $state[$p:lk] = 6737                           (: 'long' '[' :)
          or $state[$p:lk] = 6746                           (: 'short' '[' :)
          or $state[$p:lk] = 9159) then                     (: 'final' 'final' :)
      let $state := p:memoized($state, 4)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-localVariableDeclarationStatement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -1, -1)
            else
              let $state := p:restore($backtrack, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-classOrInterfaceDeclaration($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
                else
                  p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -3, -3)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 1161                                (: Identifier Identifier :)
     or $state[$p:lk] = 1209                                (: 'boolean' Identifier :)
     or $state[$p:lk] = 1211                                (: 'byte' Identifier :)
     or $state[$p:lk] = 1214                                (: 'char' Identifier :)
     or $state[$p:lk] = 1219                                (: 'double' Identifier :)
     or $state[$p:lk] = 1223                                (: 'final' Identifier :)
     or $state[$p:lk] = 1225                                (: 'float' Identifier :)
     or $state[$p:lk] = 1231                                (: 'int' Identifier :)
     or $state[$p:lk] = 1233                                (: 'long' Identifier :)
     or $state[$p:lk] = 1242                                (: 'short' Identifier :)
     or $state[$p:lk] = 7367                                (: 'final' 'boolean' :)
     or $state[$p:lk] = 7623                                (: 'final' 'byte' :)
     or $state[$p:lk] = 8007                                (: 'final' 'char' :)
     or $state[$p:lk] = 8647                                (: 'final' 'double' :)
     or $state[$p:lk] = 9415                                (: 'final' 'float' :)
     or $state[$p:lk] = 10183                               (: 'final' 'int' :)
     or $state[$p:lk] = 10439                               (: 'final' 'long' :)
     or $state[$p:lk] = 11591) then                         (: 'final' 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-localVariableDeclarationStatement($input, $state)
      return $state
    else if ($state[$p:lk] = -2
     or $state[$p:lk] = 7                                   (: ENUM :)
     or $state[$p:lk] = 56                                  (: 'abstract' :)
     or $state[$p:lk] = 63                                  (: 'class' :)
     or $state[$p:lk] = 80                                  (: 'interface' :)
     or $state[$p:lk] = 86                                  (: 'private' :)
     or $state[$p:lk] = 87                                  (: 'protected' :)
     or $state[$p:lk] = 88                                  (: 'public' :)
     or $state[$p:lk] = 91                                  (: 'static' :)
     or $state[$p:lk] = 92                                  (: 'strictfp' :)
     or $state[$p:lk] = 967                                 (: 'final' ENUM :)
     or $state[$p:lk] = 7239                                (: 'final' 'abstract' :)
     or $state[$p:lk] = 8135                                (: 'final' 'class' :)
     or $state[$p:lk] = 10291                               (: '@' 'interface' :)
     or $state[$p:lk] = 10311                               (: 'final' 'interface' :)
     or $state[$p:lk] = 11079                               (: 'final' 'private' :)
     or $state[$p:lk] = 11207                               (: 'final' 'protected' :)
     or $state[$p:lk] = 11335                               (: 'final' 'public' :)
     or $state[$p:lk] = 11719                               (: 'final' 'static' :)
     or $state[$p:lk] = 11847) then                         (: 'final' 'strictfp' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classOrInterfaceDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-statement($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "blockStatement", $count, $begin, $end)
};

(:~
 : Try parsing blockStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-blockStatement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 9) then                            (: Identifier :)
      let $state := p:lookahead2W(111, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | '-' | '--' | '-=' | '.' | '/' | '/=' |
                                                               ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                               '>' | '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' :)
      return $state
    else if ($state[$p:l1] eq 51) then                      (: '@' :)
      let $state := p:lookahead2W(23, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
      return $state
    else if ($state[$p:l1] eq 71) then                      (: 'final' :)
      let $state := p:lookahead2W(81, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'abstract' | 'boolean' | 'byte' | 'char' | 'class' |
                                                               'double' | 'final' | 'float' | 'int' | 'interface' |
                                                               'long' | 'private' | 'protected' | 'public' | 'short' |
                                                               'static' | 'strictfp' :)
      return $state
    else if ($state[$p:l1] = (57,                           (: 'boolean' :)
                              59,                           (: 'byte' :)
                              62,                           (: 'char' :)
                              67,                           (: 'double' :)
                              73,                           (: 'float' :)
                              79,                           (: 'int' :)
                              81,                           (: 'long' :)
                              90)) then                     (: 'short' :)
      let $state := p:lookahead2W(43, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '.' | '[' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1203                           (: '@' Identifier :)
          or $state[$p:lk] = 4105                           (: Identifier '.' :)
          or $state[$p:lk] = 4873                           (: Identifier '<' :)
          or $state[$p:lk] = 6599                           (: 'final' '@' :)
          or $state[$p:lk] = 6665                           (: Identifier '[' :)
          or $state[$p:lk] = 6713                           (: 'boolean' '[' :)
          or $state[$p:lk] = 6715                           (: 'byte' '[' :)
          or $state[$p:lk] = 6718                           (: 'char' '[' :)
          or $state[$p:lk] = 6723                           (: 'double' '[' :)
          or $state[$p:lk] = 6729                           (: 'float' '[' :)
          or $state[$p:lk] = 6735                           (: 'int' '[' :)
          or $state[$p:lk] = 6737                           (: 'long' '[' :)
          or $state[$p:lk] = 6746                           (: 'short' '[' :)
          or $state[$p:lk] = 9159) then                     (: 'final' 'final' :)
      let $state := p:memoized($state, 4)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-localVariableDeclarationStatement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -1, -1)
            else
              let $state := p:restore($backtrack, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-classOrInterfaceDeclaration($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
                else
                  p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -3, -3)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 1161                                (: Identifier Identifier :)
     or $state[$p:lk] = 1209                                (: 'boolean' Identifier :)
     or $state[$p:lk] = 1211                                (: 'byte' Identifier :)
     or $state[$p:lk] = 1214                                (: 'char' Identifier :)
     or $state[$p:lk] = 1219                                (: 'double' Identifier :)
     or $state[$p:lk] = 1223                                (: 'final' Identifier :)
     or $state[$p:lk] = 1225                                (: 'float' Identifier :)
     or $state[$p:lk] = 1231                                (: 'int' Identifier :)
     or $state[$p:lk] = 1233                                (: 'long' Identifier :)
     or $state[$p:lk] = 1242                                (: 'short' Identifier :)
     or $state[$p:lk] = 7367                                (: 'final' 'boolean' :)
     or $state[$p:lk] = 7623                                (: 'final' 'byte' :)
     or $state[$p:lk] = 8007                                (: 'final' 'char' :)
     or $state[$p:lk] = 8647                                (: 'final' 'double' :)
     or $state[$p:lk] = 9415                                (: 'final' 'float' :)
     or $state[$p:lk] = 10183                               (: 'final' 'int' :)
     or $state[$p:lk] = 10439                               (: 'final' 'long' :)
     or $state[$p:lk] = 11591) then                         (: 'final' 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-localVariableDeclarationStatement($input, $state)
      return $state
    else if ($state[$p:lk] = -2
     or $state[$p:lk] = 7                                   (: ENUM :)
     or $state[$p:lk] = 56                                  (: 'abstract' :)
     or $state[$p:lk] = 63                                  (: 'class' :)
     or $state[$p:lk] = 80                                  (: 'interface' :)
     or $state[$p:lk] = 86                                  (: 'private' :)
     or $state[$p:lk] = 87                                  (: 'protected' :)
     or $state[$p:lk] = 88                                  (: 'public' :)
     or $state[$p:lk] = 91                                  (: 'static' :)
     or $state[$p:lk] = 92                                  (: 'strictfp' :)
     or $state[$p:lk] = 967                                 (: 'final' ENUM :)
     or $state[$p:lk] = 7239                                (: 'final' 'abstract' :)
     or $state[$p:lk] = 8135                                (: 'final' 'class' :)
     or $state[$p:lk] = 10291                               (: '@' 'interface' :)
     or $state[$p:lk] = 10311                               (: 'final' 'interface' :)
     or $state[$p:lk] = 11079                               (: 'final' 'private' :)
     or $state[$p:lk] = 11207                               (: 'final' 'protected' :)
     or $state[$p:lk] = 11335                               (: 'final' 'public' :)
     or $state[$p:lk] = 11719                               (: 'final' 'static' :)
     or $state[$p:lk] = 11847) then                         (: 'final' 'strictfp' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classOrInterfaceDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-statement($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production block (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-block-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(116, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'new' | 'null' | 'private' |
                                                               'protected' | 'public' | 'return' | 'short' | 'static' |
                                                               'strictfp' | 'super' | 'switch' | 'synchronized' |
                                                               'this' | 'throw' | 'true' | 'try' | 'void' | 'while' |
                                                               '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-blockStatement($input, $state)
        return p:parse-block-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production block (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-block-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(116, $input, $state)        (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               ENUM | ASSERT | Identifier | WS | COMMENT |
                                                               LINE_COMMENT | '!' | '(' | '+' | '++' | '-' | '--' |
                                                               ';' | '@' | 'abstract' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'new' | 'null' | 'private' |
                                                               'protected' | 'public' | 'return' | 'short' | 'static' |
                                                               'strictfp' | 'super' | 'switch' | 'synchronized' |
                                                               'this' | 'throw' | 'true' | 'try' | 'void' | 'while' |
                                                               '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-blockStatement($input, $state)
        return p:try-block-1($input, $state)
};

(:~
 : Parse block.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-block($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: '{' :)
  let $state := p:parse-block-1($input, $state)
  let $state := p:consume(109, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "block", $count, $begin, $end)
};

(:~
 : Try parsing block.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-block($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(105, $input, $state)             (: '{' :)
  let $state := p:try-block-1($input, $state)
  let $state := p:consumeT(109, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse classBodyDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classBodyDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 91) then                           (: 'static' :)
      let $state := p:lookahead2W(86, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 37) then                       (: ';' :)
      let $state := p:consume(37, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 105                            (: '{' :)
          or $state[$p:lk] = 13531) then                    (: 'static' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 91) then                   (: 'static' :)
          let $state := p:consume(91, $input, $state)       (: 'static' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(17, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-block($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-modifiers($input, $state)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-memberDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "classBodyDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing classBodyDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classBodyDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 91) then                           (: 'static' :)
      let $state := p:lookahead2W(86, $input, $state)       (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 37) then                       (: ';' :)
      let $state := p:consumeT(37, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 105                            (: '{' :)
          or $state[$p:lk] = 13531) then                    (: 'static' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 91) then                   (: 'static' :)
          let $state := p:consumeT(91, $input, $state)      (: 'static' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(17, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-block($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-modifiers($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-memberDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production classBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(90, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '<' | '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' | '}' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-classBodyDeclaration($input, $state)
        return p:parse-classBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production classBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(90, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | ';' |
                                                               '<' | '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' | '}' :)
    return
      if ($state[$p:l1] = 109) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-classBodyDeclaration($input, $state)
        return p:try-classBody-1($input, $state)
};

(:~
 : Parse classBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: '{' :)
  let $state := p:parse-classBody-1($input, $state)
  let $state := p:consume(109, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "classBody", $count, $begin, $end)
};

(:~
 : Try parsing classBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(105, $input, $state)             (: '{' :)
  let $state := p:try-classBody-1($input, $state)
  let $state := p:consumeT(109, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse classCreatorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classCreatorRest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-arguments($input, $state)
  let $state := p:lookahead1W(115, $input, $state)          (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '{' | '|' | '|=' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classBody($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "classCreatorRest", $count, $begin, $end)
};

(:~
 : Try parsing classCreatorRest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classCreatorRest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-arguments($input, $state)
  let $state := p:lookahead1W(115, $input, $state)          (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '{' | '|' | '|=' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classBody($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse nonWildcardTypeArgumentsOrDiamond.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-nonWildcardTypeArgumentsOrDiamond($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 38) then                           (: '<' :)
      let $state := p:lookahead2W(71, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '>' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 5670) then                     (: '<' '>' :)
      let $state := p:consume(38, $input, $state)           (: '<' :)
      let $state := p:lookahead1W(9, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '>' :)
      let $state := p:consume(44, $input, $state)           (: '>' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-nonWildcardTypeArguments($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "nonWildcardTypeArgumentsOrDiamond", $count, $begin, $end)
};

(:~
 : Try parsing nonWildcardTypeArgumentsOrDiamond.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-nonWildcardTypeArgumentsOrDiamond($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 38) then                           (: '<' :)
      let $state := p:lookahead2W(71, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '>' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 5670) then                     (: '<' '>' :)
      let $state := p:consumeT(38, $input, $state)          (: '<' :)
      let $state := p:lookahead1W(9, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '>' :)
      let $state := p:consumeT(44, $input, $state)          (: '>' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-nonWildcardTypeArguments($input, $state)
      return $state
  return $state
};

(:~
 : Parse innerCreator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-innerCreator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-nonWildcardTypeArguments($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(26, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '(' | '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-nonWildcardTypeArgumentsOrDiamond($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-classCreatorRest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "innerCreator", $count, $begin, $end)
};

(:~
 : Try parsing innerCreator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-innerCreator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-nonWildcardTypeArguments($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(26, $input, $state)           (: WS | COMMENT | LINE_COMMENT | '(' | '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-nonWildcardTypeArgumentsOrDiamond($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-classCreatorRest($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production typeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consume(28, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-type($input, $state)
      return p:parse-typeList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production typeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(28, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-type($input, $state)
      return p:try-typeList-1($input, $state)
};

(:~
 : Parse typeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-type($input, $state)
  let $state := p:parse-typeList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "typeList", $count, $begin, $end)
};

(:~
 : Try parsing typeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-type($input, $state)
  let $state := p:try-typeList-1($input, $state)
  return $state
};

(:~
 : Parse nonWildcardTypeArguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-nonWildcardTypeArguments($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(38, $input, $state)               (: '<' :)
  let $state := p:lookahead1W(69, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-typeList($input, $state)
  let $state := p:consume(44, $input, $state)               (: '>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "nonWildcardTypeArguments", $count, $begin, $end)
};

(:~
 : Try parsing nonWildcardTypeArguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-nonWildcardTypeArguments($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(38, $input, $state)              (: '<' :)
  let $state := p:lookahead1W(69, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-typeList($input, $state)
  let $state := p:consumeT(44, $input, $state)              (: '>' :)
  return $state
};

(:~
 : Parse explicitGenericInvocation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-explicitGenericInvocation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-nonWildcardTypeArguments($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-arguments($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "explicitGenericInvocation", $count, $begin, $end)
};

(:~
 : Try parsing explicitGenericInvocation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-explicitGenericInvocation($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-nonWildcardTypeArguments($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-arguments($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production expressionList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expressionList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consume(28, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      return p:parse-expressionList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production expressionList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expressionList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(28, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      return p:try-expressionList-1($input, $state)
};

(:~
 : Parse expressionList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expressionList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-expression($input, $state)
  let $state := p:parse-expressionList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "expressionList", $count, $begin, $end)
};

(:~
 : Try parsing expressionList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expressionList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-expression($input, $state)
  let $state := p:try-expressionList-1($input, $state)
  return $state
};

(:~
 : Parse arguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-arguments($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(91, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 22) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expressionList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "arguments", $count, $begin, $end)
};

(:~
 : Try parsing arguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-arguments($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(91, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 22) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expressionList($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse the 1st loop of production identifierSuffix (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-identifierSuffix-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(52, $input, $state)             (: '[' :)
    let $state := p:lookahead1W(10, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ']' :)
    let $state := p:consume(53, $input, $state)             (: ']' :)
    let $state := p:lookahead1W(31, $input, $state)         (: WS | COMMENT | LINE_COMMENT | '.' | '[' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        p:parse-identifierSuffix-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production identifierSuffix (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-identifierSuffix-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consumeT(52, $input, $state)            (: '[' :)
    let $state := p:lookahead1W(10, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ']' :)
    let $state := p:consumeT(53, $input, $state)            (: ']' :)
    let $state := p:lookahead1W(31, $input, $state)         (: WS | COMMENT | LINE_COMMENT | '.' | '[' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        p:try-identifierSuffix-1($input, $state)
};

(:~
 : Parse the 2nd loop of production identifierSuffix (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-identifierSuffix-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(52, $input, $state)             (: '[' :)
    let $state := p:lookahead1W(89, $input, $state)         (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-expression($input, $state)
    let $state := p:consume(53, $input, $state)             (: ']' :)
    let $state := p:lookahead1W(113, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 52) then                         (: '[' :)
        let $state := p:lookahead2W(89, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 180                          (: '[' HexLiteral :)
            or $state[$p:lk] = 308                          (: '[' DecimalLiteral :)
            or $state[$p:lk] = 436                          (: '[' OctalLiteral :)
            or $state[$p:lk] = 564                          (: '[' FloatingPointLiteral :)
            or $state[$p:lk] = 692                          (: '[' CharacterLiteral :)
            or $state[$p:lk] = 820                          (: '[' StringLiteral :)
            or $state[$p:lk] = 1204                         (: '[' Identifier :)
            or $state[$p:lk] = 1844                         (: '[' '!' :)
            or $state[$p:lk] = 2740                         (: '[' '(' :)
            or $state[$p:lk] = 3252                         (: '[' '+' :)
            or $state[$p:lk] = 3380                         (: '[' '++' :)
            or $state[$p:lk] = 3764                         (: '[' '-' :)
            or $state[$p:lk] = 3892                         (: '[' '--' :)
            or $state[$p:lk] = 7348                         (: '[' 'boolean' :)
            or $state[$p:lk] = 7604                         (: '[' 'byte' :)
            or $state[$p:lk] = 7988                         (: '[' 'char' :)
            or $state[$p:lk] = 8628                         (: '[' 'double' :)
            or $state[$p:lk] = 9012                         (: '[' 'false' :)
            or $state[$p:lk] = 9396                         (: '[' 'float' :)
            or $state[$p:lk] = 10164                        (: '[' 'int' :)
            or $state[$p:lk] = 10420                        (: '[' 'long' :)
            or $state[$p:lk] = 10676                        (: '[' 'new' :)
            or $state[$p:lk] = 10804                        (: '[' 'null' :)
            or $state[$p:lk] = 11572                        (: '[' 'short' :)
            or $state[$p:lk] = 11956                        (: '[' 'super' :)
            or $state[$p:lk] = 12340                        (: '[' 'this' :)
            or $state[$p:lk] = 12852                        (: '[' 'true' :)
            or $state[$p:lk] = 13108                        (: '[' 'void' :)
            or $state[$p:lk] = 14132) then                  (: '[' '~' :)
        let $state := p:memoized($state, 19)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(52, $input, $state)    (: '[' :)
            let $state := p:lookahead1W(89, $input, $state) (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-expression($input, $state)
            let $state := p:consumeT(53, $input, $state)    (: ']' :)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        p:parse-identifierSuffix-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production identifierSuffix (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-identifierSuffix-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consumeT(52, $input, $state)            (: '[' :)
    let $state := p:lookahead1W(89, $input, $state)         (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-expression($input, $state)
    let $state := p:consumeT(53, $input, $state)            (: ']' :)
    let $state := p:lookahead1W(113, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 52) then                         (: '[' :)
        let $state := p:lookahead2W(89, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 180                          (: '[' HexLiteral :)
            or $state[$p:lk] = 308                          (: '[' DecimalLiteral :)
            or $state[$p:lk] = 436                          (: '[' OctalLiteral :)
            or $state[$p:lk] = 564                          (: '[' FloatingPointLiteral :)
            or $state[$p:lk] = 692                          (: '[' CharacterLiteral :)
            or $state[$p:lk] = 820                          (: '[' StringLiteral :)
            or $state[$p:lk] = 1204                         (: '[' Identifier :)
            or $state[$p:lk] = 1844                         (: '[' '!' :)
            or $state[$p:lk] = 2740                         (: '[' '(' :)
            or $state[$p:lk] = 3252                         (: '[' '+' :)
            or $state[$p:lk] = 3380                         (: '[' '++' :)
            or $state[$p:lk] = 3764                         (: '[' '-' :)
            or $state[$p:lk] = 3892                         (: '[' '--' :)
            or $state[$p:lk] = 7348                         (: '[' 'boolean' :)
            or $state[$p:lk] = 7604                         (: '[' 'byte' :)
            or $state[$p:lk] = 7988                         (: '[' 'char' :)
            or $state[$p:lk] = 8628                         (: '[' 'double' :)
            or $state[$p:lk] = 9012                         (: '[' 'false' :)
            or $state[$p:lk] = 9396                         (: '[' 'float' :)
            or $state[$p:lk] = 10164                        (: '[' 'int' :)
            or $state[$p:lk] = 10420                        (: '[' 'long' :)
            or $state[$p:lk] = 10676                        (: '[' 'new' :)
            or $state[$p:lk] = 10804                        (: '[' 'null' :)
            or $state[$p:lk] = 11572                        (: '[' 'short' :)
            or $state[$p:lk] = 11956                        (: '[' 'super' :)
            or $state[$p:lk] = 12340                        (: '[' 'this' :)
            or $state[$p:lk] = 12852                        (: '[' 'true' :)
            or $state[$p:lk] = 13108                        (: '[' 'void' :)
            or $state[$p:lk] = 14132) then                  (: '[' '~' :)
        let $state := p:memoized($state, 19)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(52, $input, $state)    (: '[' :)
            let $state := p:lookahead1W(89, $input, $state) (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-expression($input, $state)
            let $state := p:consumeT(53, $input, $state)    (: ']' :)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 19, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-identifierSuffix-2($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        p:try-identifierSuffix-2($input, $state)
};

(:~
 : Parse identifierSuffix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-identifierSuffix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 32) then                           (: '.' :)
      let $state := p:lookahead2W(66, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '<' | 'class' | 'new' |
                                                               'super' | 'this' :)
      return $state
    else if ($state[$p:l1] eq 52) then                      (: '[' :)
      let $state := p:lookahead2W(93, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 6836) then                     (: '[' ']' :)
      let $state := p:parse-identifierSuffix-1($input, $state)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(11, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'class' :)
      let $state := p:consume(63, $input, $state)           (: 'class' :)
      return $state
    else if ($state[$p:lk] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-arguments($input, $state)
      return $state
    else if ($state[$p:lk] = 8096) then                     (: '.' 'class' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(11, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'class' :)
      let $state := p:consume(63, $input, $state)           (: 'class' :)
      return $state
    else if ($state[$p:lk] = 4896) then                     (: '.' '<' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(7, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-explicitGenericInvocation($input, $state)
      return $state
    else if ($state[$p:lk] = 12320) then                    (: '.' 'this' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(15, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'this' :)
      let $state := p:consume(96, $input, $state)           (: 'this' :)
      return $state
    else if ($state[$p:lk] = 11936) then                    (: '.' 'super' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(14, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'super' :)
      let $state := p:consume(93, $input, $state)           (: 'super' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-arguments($input, $state)
      return $state
    else if ($state[$p:lk] = 10656) then                    (: '.' 'new' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(13, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'new' :)
      let $state := p:consume(83, $input, $state)           (: 'new' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-innerCreator($input, $state)
      return $state
    else
      let $state := p:parse-identifierSuffix-2($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "identifierSuffix", $count, $begin, $end)
};

(:~
 : Try parsing identifierSuffix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-identifierSuffix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 32) then                           (: '.' :)
      let $state := p:lookahead2W(66, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '<' | 'class' | 'new' |
                                                               'super' | 'this' :)
      return $state
    else if ($state[$p:l1] eq 52) then                      (: '[' :)
      let $state := p:lookahead2W(93, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 6836) then                     (: '[' ']' :)
      let $state := p:try-identifierSuffix-1($input, $state)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(11, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'class' :)
      let $state := p:consumeT(63, $input, $state)          (: 'class' :)
      return $state
    else if ($state[$p:lk] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-arguments($input, $state)
      return $state
    else if ($state[$p:lk] = 8096) then                     (: '.' 'class' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(11, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'class' :)
      let $state := p:consumeT(63, $input, $state)          (: 'class' :)
      return $state
    else if ($state[$p:lk] = 4896) then                     (: '.' '<' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(7, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-explicitGenericInvocation($input, $state)
      return $state
    else if ($state[$p:lk] = 12320) then                    (: '.' 'this' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(15, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'this' :)
      let $state := p:consumeT(96, $input, $state)          (: 'this' :)
      return $state
    else if ($state[$p:lk] = 11936) then                    (: '.' 'super' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(14, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'super' :)
      let $state := p:consumeT(93, $input, $state)          (: 'super' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-arguments($input, $state)
      return $state
    else if ($state[$p:lk] = 10656) then                    (: '.' 'new' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(13, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'new' :)
      let $state := p:consumeT(83, $input, $state)          (: 'new' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-innerCreator($input, $state)
      return $state
    else
      let $state := p:try-identifierSuffix-2($input, $state)
      return $state
  return $state
};

(:~
 : Parse parExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-parExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(89, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-expression($input, $state)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "parExpression", $count, $begin, $end)
};

(:~
 : Try parsing parExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-parExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(89, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-expression($input, $state)
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse the 1st loop of production primary (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-primary-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(114, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 32) then                         (: '.' :)
        let $state := p:lookahead2W(67, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'class' | 'new' | 'super' | 'this' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 1184) then                   (: '.' Identifier :)
        let $state := p:memoized($state, 15)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(32, $input, $state)    (: '.' :)
            let $state := p:lookahead1W(0, $input, $state)  (: Identifier | WS | COMMENT | LINE_COMMENT :)
            let $state := p:consumeT(9, $input, $state)     (: Identifier :)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(32, $input, $state)         (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consume(9, $input, $state)          (: Identifier :)
        return p:parse-primary-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production primary (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-primary-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(114, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 32) then                         (: '.' :)
        let $state := p:lookahead2W(67, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'class' | 'new' | 'super' | 'this' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 1184) then                   (: '.' Identifier :)
        let $state := p:memoized($state, 15)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(32, $input, $state)    (: '.' :)
            let $state := p:lookahead1W(0, $input, $state)  (: Identifier | WS | COMMENT | LINE_COMMENT :)
            let $state := p:consumeT(9, $input, $state)     (: Identifier :)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 15, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-primary-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consumeT(32, $input, $state)        (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consumeT(9, $input, $state)         (: Identifier :)
        return p:try-primary-1($input, $state)
};

(:~
 : Parse the 2nd loop of production primary (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-primary-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(114, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 32) then                         (: '.' :)
        let $state := p:lookahead2W(67, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'class' | 'new' | 'super' | 'this' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 1184) then                   (: '.' Identifier :)
        let $state := p:memoized($state, 17)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(32, $input, $state)    (: '.' :)
            let $state := p:lookahead1W(0, $input, $state)  (: Identifier | WS | COMMENT | LINE_COMMENT :)
            let $state := p:consumeT(9, $input, $state)     (: Identifier :)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(32, $input, $state)         (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consume(9, $input, $state)          (: Identifier :)
        return p:parse-primary-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production primary (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-primary-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(114, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 32) then                         (: '.' :)
        let $state := p:lookahead2W(67, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'class' | 'new' | 'super' | 'this' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 1184) then                   (: '.' Identifier :)
        let $state := p:memoized($state, 17)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(32, $input, $state)    (: '.' :)
            let $state := p:lookahead1W(0, $input, $state)  (: Identifier | WS | COMMENT | LINE_COMMENT :)
            let $state := p:consumeT(9, $input, $state)     (: Identifier :)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 17, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-primary-2($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consumeT(32, $input, $state)        (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consumeT(9, $input, $state)         (: Identifier :)
        return p:try-primary-2($input, $state)
};

(:~
 : Parse the 3rd loop of production primary (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-primary-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: WS | COMMENT | LINE_COMMENT | '.' | '[' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-primary-3($input, $state)
};

(:~
 : Try parsing the 3rd loop of production primary (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-primary-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: WS | COMMENT | LINE_COMMENT | '.' | '[' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-primary-3($input, $state)
};

(:~
 : Parse primary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-primary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-parExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'this' :)
      let $state := p:consume(96, $input, $state)           (: 'this' :)
      let $state := p:parse-primary-1($input, $state)
      let $state :=
        if ($state[$p:l1] eq 32) then                       (: '.' :)
          let $state := p:lookahead2W(67, $input, $state)   (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'class' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:l1] eq 52) then                  (: '[' :)
          let $state := p:lookahead2W(93, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 180                        (: '[' HexLiteral :)
              or $state[$p:lk] = 308                        (: '[' DecimalLiteral :)
              or $state[$p:lk] = 436                        (: '[' OctalLiteral :)
              or $state[$p:lk] = 564                        (: '[' FloatingPointLiteral :)
              or $state[$p:lk] = 692                        (: '[' CharacterLiteral :)
              or $state[$p:lk] = 820                        (: '[' StringLiteral :)
              or $state[$p:lk] = 1204                       (: '[' Identifier :)
              or $state[$p:lk] = 1844                       (: '[' '!' :)
              or $state[$p:lk] = 2740                       (: '[' '(' :)
              or $state[$p:lk] = 3252                       (: '[' '+' :)
              or $state[$p:lk] = 3380                       (: '[' '++' :)
              or $state[$p:lk] = 3764                       (: '[' '-' :)
              or $state[$p:lk] = 3892                       (: '[' '--' :)
              or $state[$p:lk] = 4896                       (: '.' '<' :)
              or $state[$p:lk] = 7348                       (: '[' 'boolean' :)
              or $state[$p:lk] = 7604                       (: '[' 'byte' :)
              or $state[$p:lk] = 7988                       (: '[' 'char' :)
              or $state[$p:lk] = 8628                       (: '[' 'double' :)
              or $state[$p:lk] = 9012                       (: '[' 'false' :)
              or $state[$p:lk] = 9396                       (: '[' 'float' :)
              or $state[$p:lk] = 10164                      (: '[' 'int' :)
              or $state[$p:lk] = 10420                      (: '[' 'long' :)
              or $state[$p:lk] = 10656                      (: '.' 'new' :)
              or $state[$p:lk] = 10676                      (: '[' 'new' :)
              or $state[$p:lk] = 10804                      (: '[' 'null' :)
              or $state[$p:lk] = 11572                      (: '[' 'short' :)
              or $state[$p:lk] = 11936                      (: '.' 'super' :)
              or $state[$p:lk] = 11956                      (: '[' 'super' :)
              or $state[$p:lk] = 12320                      (: '.' 'this' :)
              or $state[$p:lk] = 12340                      (: '[' 'this' :)
              or $state[$p:lk] = 12852                      (: '[' 'true' :)
              or $state[$p:lk] = 13108                      (: '[' 'void' :)
              or $state[$p:lk] = 14132) then                (: '[' '~' :)
          let $state := p:memoized($state, 16)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-identifierSuffix($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 21                         (: '(' :)
              or $state[$p:lk] = 6836                       (: '[' ']' :)
              or $state[$p:lk] = 8096) then                 (: '.' 'class' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-identifierSuffix($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'super' :)
      let $state := p:consume(93, $input, $state)           (: 'super' :)
      let $state := p:lookahead1W(25, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-superSuffix($input, $state)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'new' :)
      let $state := p:consume(83, $input, $state)           (: 'new' :)
      let $state := p:lookahead1W(70, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-creator($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: Identifier :)
      let $state := p:consume(9, $input, $state)            (: Identifier :)
      let $state := p:parse-primary-2($input, $state)
      let $state :=
        if ($state[$p:l1] eq 32) then                       (: '.' :)
          let $state := p:lookahead2W(67, $input, $state)   (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'class' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:l1] eq 52) then                  (: '[' :)
          let $state := p:lookahead2W(93, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 180                        (: '[' HexLiteral :)
              or $state[$p:lk] = 308                        (: '[' DecimalLiteral :)
              or $state[$p:lk] = 436                        (: '[' OctalLiteral :)
              or $state[$p:lk] = 564                        (: '[' FloatingPointLiteral :)
              or $state[$p:lk] = 692                        (: '[' CharacterLiteral :)
              or $state[$p:lk] = 820                        (: '[' StringLiteral :)
              or $state[$p:lk] = 1204                       (: '[' Identifier :)
              or $state[$p:lk] = 1844                       (: '[' '!' :)
              or $state[$p:lk] = 2740                       (: '[' '(' :)
              or $state[$p:lk] = 3252                       (: '[' '+' :)
              or $state[$p:lk] = 3380                       (: '[' '++' :)
              or $state[$p:lk] = 3764                       (: '[' '-' :)
              or $state[$p:lk] = 3892                       (: '[' '--' :)
              or $state[$p:lk] = 4896                       (: '.' '<' :)
              or $state[$p:lk] = 7348                       (: '[' 'boolean' :)
              or $state[$p:lk] = 7604                       (: '[' 'byte' :)
              or $state[$p:lk] = 7988                       (: '[' 'char' :)
              or $state[$p:lk] = 8628                       (: '[' 'double' :)
              or $state[$p:lk] = 9012                       (: '[' 'false' :)
              or $state[$p:lk] = 9396                       (: '[' 'float' :)
              or $state[$p:lk] = 10164                      (: '[' 'int' :)
              or $state[$p:lk] = 10420                      (: '[' 'long' :)
              or $state[$p:lk] = 10656                      (: '.' 'new' :)
              or $state[$p:lk] = 10676                      (: '[' 'new' :)
              or $state[$p:lk] = 10804                      (: '[' 'null' :)
              or $state[$p:lk] = 11572                      (: '[' 'short' :)
              or $state[$p:lk] = 11936                      (: '.' 'super' :)
              or $state[$p:lk] = 11956                      (: '[' 'super' :)
              or $state[$p:lk] = 12320                      (: '.' 'this' :)
              or $state[$p:lk] = 12340                      (: '[' 'this' :)
              or $state[$p:lk] = 12852                      (: '[' 'true' :)
              or $state[$p:lk] = 13108                      (: '[' 'void' :)
              or $state[$p:lk] = 14132) then                (: '[' '~' :)
          let $state := p:memoized($state, 18)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-identifierSuffix($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 21                         (: '(' :)
              or $state[$p:lk] = 6836                       (: '[' ']' :)
              or $state[$p:lk] = 8096) then                 (: '.' 'class' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-identifierSuffix($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 57                             (: 'boolean' :)
          or $state[$p:l1] = 59                             (: 'byte' :)
          or $state[$p:l1] = 62                             (: 'char' :)
          or $state[$p:l1] = 67                             (: 'double' :)
          or $state[$p:l1] = 73                             (: 'float' :)
          or $state[$p:l1] = 79                             (: 'int' :)
          or $state[$p:l1] = 81                             (: 'long' :)
          or $state[$p:l1] = 90) then                       (: 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-primitiveType($input, $state)
      let $state := p:parse-primary-3($input, $state)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(11, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'class' :)
      let $state := p:consume(63, $input, $state)           (: 'class' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'void' :)
      let $state := p:consume(102, $input, $state)          (: 'void' :)
      let $state := p:lookahead1W(4, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '.' :)
      let $state := p:consume(32, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(11, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'class' :)
      let $state := p:consume(63, $input, $state)           (: 'class' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-literal($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "primary", $count, $begin, $end)
};

(:~
 : Try parsing primary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-primary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-parExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'this' :)
      let $state := p:consumeT(96, $input, $state)          (: 'this' :)
      let $state := p:try-primary-1($input, $state)
      let $state :=
        if ($state[$p:l1] eq 32) then                       (: '.' :)
          let $state := p:lookahead2W(67, $input, $state)   (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'class' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:l1] eq 52) then                  (: '[' :)
          let $state := p:lookahead2W(93, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 180                        (: '[' HexLiteral :)
              or $state[$p:lk] = 308                        (: '[' DecimalLiteral :)
              or $state[$p:lk] = 436                        (: '[' OctalLiteral :)
              or $state[$p:lk] = 564                        (: '[' FloatingPointLiteral :)
              or $state[$p:lk] = 692                        (: '[' CharacterLiteral :)
              or $state[$p:lk] = 820                        (: '[' StringLiteral :)
              or $state[$p:lk] = 1204                       (: '[' Identifier :)
              or $state[$p:lk] = 1844                       (: '[' '!' :)
              or $state[$p:lk] = 2740                       (: '[' '(' :)
              or $state[$p:lk] = 3252                       (: '[' '+' :)
              or $state[$p:lk] = 3380                       (: '[' '++' :)
              or $state[$p:lk] = 3764                       (: '[' '-' :)
              or $state[$p:lk] = 3892                       (: '[' '--' :)
              or $state[$p:lk] = 4896                       (: '.' '<' :)
              or $state[$p:lk] = 7348                       (: '[' 'boolean' :)
              or $state[$p:lk] = 7604                       (: '[' 'byte' :)
              or $state[$p:lk] = 7988                       (: '[' 'char' :)
              or $state[$p:lk] = 8628                       (: '[' 'double' :)
              or $state[$p:lk] = 9012                       (: '[' 'false' :)
              or $state[$p:lk] = 9396                       (: '[' 'float' :)
              or $state[$p:lk] = 10164                      (: '[' 'int' :)
              or $state[$p:lk] = 10420                      (: '[' 'long' :)
              or $state[$p:lk] = 10656                      (: '.' 'new' :)
              or $state[$p:lk] = 10676                      (: '[' 'new' :)
              or $state[$p:lk] = 10804                      (: '[' 'null' :)
              or $state[$p:lk] = 11572                      (: '[' 'short' :)
              or $state[$p:lk] = 11936                      (: '.' 'super' :)
              or $state[$p:lk] = 11956                      (: '[' 'super' :)
              or $state[$p:lk] = 12320                      (: '.' 'this' :)
              or $state[$p:lk] = 12340                      (: '[' 'this' :)
              or $state[$p:lk] = 12852                      (: '[' 'true' :)
              or $state[$p:lk] = 13108                      (: '[' 'void' :)
              or $state[$p:lk] = 14132) then                (: '[' '~' :)
          let $state := p:memoized($state, 16)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-identifierSuffix($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 21                         (: '(' :)
              or $state[$p:lk] = 6836                       (: '[' ']' :)
              or $state[$p:lk] = 8096) then                 (: '.' 'class' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-identifierSuffix($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'super' :)
      let $state := p:consumeT(93, $input, $state)          (: 'super' :)
      let $state := p:lookahead1W(25, $input, $state)       (: WS | COMMENT | LINE_COMMENT | '(' | '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-superSuffix($input, $state)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'new' :)
      let $state := p:consumeT(83, $input, $state)          (: 'new' :)
      let $state := p:lookahead1W(70, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-creator($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: Identifier :)
      let $state := p:consumeT(9, $input, $state)           (: Identifier :)
      let $state := p:try-primary-2($input, $state)
      let $state :=
        if ($state[$p:l1] eq 32) then                       (: '.' :)
          let $state := p:lookahead2W(67, $input, $state)   (: Identifier | WS | COMMENT | LINE_COMMENT | '<' |
                                                               'class' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:l1] eq 52) then                  (: '[' :)
          let $state := p:lookahead2W(93, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ']' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '~' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 180                        (: '[' HexLiteral :)
              or $state[$p:lk] = 308                        (: '[' DecimalLiteral :)
              or $state[$p:lk] = 436                        (: '[' OctalLiteral :)
              or $state[$p:lk] = 564                        (: '[' FloatingPointLiteral :)
              or $state[$p:lk] = 692                        (: '[' CharacterLiteral :)
              or $state[$p:lk] = 820                        (: '[' StringLiteral :)
              or $state[$p:lk] = 1204                       (: '[' Identifier :)
              or $state[$p:lk] = 1844                       (: '[' '!' :)
              or $state[$p:lk] = 2740                       (: '[' '(' :)
              or $state[$p:lk] = 3252                       (: '[' '+' :)
              or $state[$p:lk] = 3380                       (: '[' '++' :)
              or $state[$p:lk] = 3764                       (: '[' '-' :)
              or $state[$p:lk] = 3892                       (: '[' '--' :)
              or $state[$p:lk] = 4896                       (: '.' '<' :)
              or $state[$p:lk] = 7348                       (: '[' 'boolean' :)
              or $state[$p:lk] = 7604                       (: '[' 'byte' :)
              or $state[$p:lk] = 7988                       (: '[' 'char' :)
              or $state[$p:lk] = 8628                       (: '[' 'double' :)
              or $state[$p:lk] = 9012                       (: '[' 'false' :)
              or $state[$p:lk] = 9396                       (: '[' 'float' :)
              or $state[$p:lk] = 10164                      (: '[' 'int' :)
              or $state[$p:lk] = 10420                      (: '[' 'long' :)
              or $state[$p:lk] = 10656                      (: '.' 'new' :)
              or $state[$p:lk] = 10676                      (: '[' 'new' :)
              or $state[$p:lk] = 10804                      (: '[' 'null' :)
              or $state[$p:lk] = 11572                      (: '[' 'short' :)
              or $state[$p:lk] = 11936                      (: '.' 'super' :)
              or $state[$p:lk] = 11956                      (: '[' 'super' :)
              or $state[$p:lk] = 12320                      (: '.' 'this' :)
              or $state[$p:lk] = 12340                      (: '[' 'this' :)
              or $state[$p:lk] = 12852                      (: '[' 'true' :)
              or $state[$p:lk] = 13108                      (: '[' 'void' :)
              or $state[$p:lk] = 14132) then                (: '[' '~' :)
          let $state := p:memoized($state, 18)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-identifierSuffix($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 21                         (: '(' :)
              or $state[$p:lk] = 6836                       (: '[' ']' :)
              or $state[$p:lk] = 8096) then                 (: '.' 'class' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-identifierSuffix($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 57                             (: 'boolean' :)
          or $state[$p:l1] = 59                             (: 'byte' :)
          or $state[$p:l1] = 62                             (: 'char' :)
          or $state[$p:l1] = 67                             (: 'double' :)
          or $state[$p:l1] = 73                             (: 'float' :)
          or $state[$p:l1] = 79                             (: 'int' :)
          or $state[$p:l1] = 81                             (: 'long' :)
          or $state[$p:l1] = 90) then                       (: 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-primitiveType($input, $state)
      let $state := p:try-primary-3($input, $state)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(11, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'class' :)
      let $state := p:consumeT(63, $input, $state)          (: 'class' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'void' :)
      let $state := p:consumeT(102, $input, $state)         (: 'void' :)
      let $state := p:lookahead1W(4, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '.' :)
      let $state := p:consumeT(32, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(11, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'class' :)
      let $state := p:consumeT(63, $input, $state)          (: 'class' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-literal($input, $state)
      return $state
  return $state
};

(:~
 : Parse assignmentOperator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-assignmentOperator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 42) then                       (: '=' :)
      let $state := p:consume(42, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '+=' :)
      let $state := p:consume(27, $input, $state)           (: '+=' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: '-=' :)
      let $state := p:consume(31, $input, $state)           (: '-=' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: '*=' :)
      let $state := p:consume(24, $input, $state)           (: '*=' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '/=' :)
      let $state := p:consume(35, $input, $state)           (: '/=' :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: '&=' :)
      let $state := p:consume(20, $input, $state)           (: '&=' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: '|=' :)
      let $state := p:consume(107, $input, $state)          (: '|=' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '^=' :)
      let $state := p:consume(55, $input, $state)           (: '^=' :)
      return $state
    else if ($state[$p:l1] = 17) then                       (: '%=' :)
      let $state := p:consume(17, $input, $state)           (: '%=' :)
      return $state
    else if ($state[$p:l1] = 40) then                       (: '<<=' :)
      let $state := p:consume(40, $input, $state)           (: '<<=' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: '>>>=' :)
      let $state := p:consume(49, $input, $state)           (: '>>>=' :)
      return $state
    else
      let $state := p:consume(47, $input, $state)           (: '>>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "assignmentOperator", $count, $begin, $end)
};

(:~
 : Try parsing assignmentOperator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-assignmentOperator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 42) then                       (: '=' :)
      let $state := p:consumeT(42, $input, $state)          (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '+=' :)
      let $state := p:consumeT(27, $input, $state)          (: '+=' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: '-=' :)
      let $state := p:consumeT(31, $input, $state)          (: '-=' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: '*=' :)
      let $state := p:consumeT(24, $input, $state)          (: '*=' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '/=' :)
      let $state := p:consumeT(35, $input, $state)          (: '/=' :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: '&=' :)
      let $state := p:consumeT(20, $input, $state)          (: '&=' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: '|=' :)
      let $state := p:consumeT(107, $input, $state)         (: '|=' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '^=' :)
      let $state := p:consumeT(55, $input, $state)          (: '^=' :)
      return $state
    else if ($state[$p:l1] = 17) then                       (: '%=' :)
      let $state := p:consumeT(17, $input, $state)          (: '%=' :)
      return $state
    else if ($state[$p:l1] = 40) then                       (: '<<=' :)
      let $state := p:consumeT(40, $input, $state)          (: '<<=' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: '>>>=' :)
      let $state := p:consumeT(49, $input, $state)          (: '>>>=' :)
      return $state
    else
      let $state := p:consumeT(47, $input, $state)          (: '>>=' :)
      return $state
  return $state
};

(:~
 : Parse expression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-conditionalExpression($input, $state)
  let $state :=
    if ($state[$p:l1] = (17,                                (: '%=' :)
                         20,                                (: '&=' :)
                         24,                                (: '*=' :)
                         27,                                (: '+=' :)
                         31,                                (: '-=' :)
                         35,                                (: '/=' :)
                         40,                                (: '<<=' :)
                         42,                                (: '=' :)
                         47,                                (: '>>=' :)
                         49,                                (: '>>>=' :)
                         55,                                (: '^=' :)
                         107)) then                         (: '|=' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 22                            (: ')' :)
         and $state[$p:lk] != 28                            (: ',' :)
         and $state[$p:lk] != 36                            (: ':' :)
         and $state[$p:lk] != 37                            (: ';' :)
         and $state[$p:lk] != 53                            (: ']' :)
         and $state[$p:lk] != 109) then                     (: '}' :)
      let $state := p:memoized($state, 11)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-assignmentOperator($input, $state)
          let $state := p:lookahead1W(89, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-expression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-assignmentOperator($input, $state)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "expression", $count, $begin, $end)
};

(:~
 : Try parsing expression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-conditionalExpression($input, $state)
  let $state :=
    if ($state[$p:l1] = (17,                                (: '%=' :)
                         20,                                (: '&=' :)
                         24,                                (: '*=' :)
                         27,                                (: '+=' :)
                         31,                                (: '-=' :)
                         35,                                (: '/=' :)
                         40,                                (: '<<=' :)
                         42,                                (: '=' :)
                         47,                                (: '>>=' :)
                         49,                                (: '>>>=' :)
                         55,                                (: '^=' :)
                         107)) then                         (: '|=' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 22                            (: ')' :)
         and $state[$p:lk] != 28                            (: ',' :)
         and $state[$p:lk] != 36                            (: ':' :)
         and $state[$p:lk] != 37                            (: ';' :)
         and $state[$p:lk] != 53                            (: ']' :)
         and $state[$p:lk] != 109) then                     (: '}' :)
      let $state := p:memoized($state, 11)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-assignmentOperator($input, $state)
          let $state := p:lookahead1W(89, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-expression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-assignmentOperator($input, $state)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse typeArgument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeArgument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50) then                       (: '?' :)
      let $state := p:consume(50, $input, $state)           (: '?' :)
      let $state := p:lookahead1W(58, $input, $state)       (: WS | COMMENT | LINE_COMMENT | ',' | '>' | 'extends' |
                                                               'super' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 69                         (: 'extends' :)
              or $state[$p:l1] = 93) then                   (: 'super' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 69) then               (: 'extends' :)
              let $state := p:consume(69, $input, $state)   (: 'extends' :)
              return $state
            else
              let $state := p:consume(93, $input, $state)   (: 'super' :)
              return $state
          let $state := p:lookahead1W(69, $input, $state)   (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-type($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-type($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "typeArgument", $count, $begin, $end)
};

(:~
 : Try parsing typeArgument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeArgument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50) then                       (: '?' :)
      let $state := p:consumeT(50, $input, $state)          (: '?' :)
      let $state := p:lookahead1W(58, $input, $state)       (: WS | COMMENT | LINE_COMMENT | ',' | '>' | 'extends' |
                                                               'super' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 69                         (: 'extends' :)
              or $state[$p:l1] = 93) then                   (: 'super' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 69) then               (: 'extends' :)
              let $state := p:consumeT(69, $input, $state)  (: 'extends' :)
              return $state
            else
              let $state := p:consumeT(93, $input, $state)  (: 'super' :)
              return $state
          let $state := p:lookahead1W(69, $input, $state)   (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-type($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-type($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production typeArguments (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeArguments-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consume(28, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(72, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '?' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeArgument($input, $state)
      return p:parse-typeArguments-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production typeArguments (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeArguments-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 28) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(28, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(72, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | '?' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeArgument($input, $state)
      return p:try-typeArguments-1($input, $state)
};

(:~
 : Parse typeArguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-typeArguments($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(38, $input, $state)               (: '<' :)
  let $state := p:lookahead1W(72, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | '?' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-typeArgument($input, $state)
  let $state := p:parse-typeArguments-1($input, $state)
  let $state := p:consume(44, $input, $state)               (: '>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "typeArguments", $count, $begin, $end)
};

(:~
 : Try parsing typeArguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-typeArguments($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(38, $input, $state)              (: '<' :)
  let $state := p:lookahead1W(72, $input, $state)           (: Identifier | WS | COMMENT | LINE_COMMENT | '?' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-typeArgument($input, $state)
  let $state := p:try-typeArguments-1($input, $state)
  let $state := p:consumeT(44, $input, $state)              (: '>' :)
  return $state
};

(:~
 : Parse the 1st loop of production classOrInterfaceType (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classOrInterfaceType-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(103, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | '(' | ')' | '*=' | '+=' | ',' |
                                                               '-=' | '.' | '...' | '/=' | ':' | ';' | '<<=' | '=' |
                                                               '==' | '>' | '>>=' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'implements' | '{' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 32) then                         (: '.' :)
        $state
      else
        let $state := p:consume(32, $input, $state)         (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consume(9, $input, $state)          (: Identifier :)
        let $state := p:lookahead1W(104, $input, $state)    (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | '(' | ')' | '*=' | '+=' | ',' |
                                                               '-=' | '.' | '...' | '/=' | ':' | ';' | '<' | '<<=' |
                                                               '=' | '==' | '>' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'implements' | '{' | '|' | '|=' | '||' | '}' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 38) then                 (: '<' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-typeArguments($input, $state)
            return $state
          else
            $state
        return p:parse-classOrInterfaceType-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production classOrInterfaceType (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classOrInterfaceType-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(103, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | '(' | ')' | '*=' | '+=' | ',' |
                                                               '-=' | '.' | '...' | '/=' | ':' | ';' | '<<=' | '=' |
                                                               '==' | '>' | '>>=' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'implements' | '{' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 32) then                         (: '.' :)
        $state
      else
        let $state := p:consumeT(32, $input, $state)        (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consumeT(9, $input, $state)         (: Identifier :)
        let $state := p:lookahead1W(104, $input, $state)    (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | '(' | ')' | '*=' | '+=' | ',' |
                                                               '-=' | '.' | '...' | '/=' | ':' | ';' | '<' | '<<=' |
                                                               '=' | '==' | '>' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'implements' | '{' | '|' | '|=' | '||' | '}' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 38) then                 (: '<' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-typeArguments($input, $state)
            return $state
          else
            $state
        return p:try-classOrInterfaceType-1($input, $state)
};

(:~
 : Parse classOrInterfaceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-classOrInterfaceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(104, $input, $state)          (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | '(' | ')' | '*=' | '+=' | ',' |
                                                               '-=' | '.' | '...' | '/=' | ':' | ';' | '<' | '<<=' |
                                                               '=' | '==' | '>' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'implements' | '{' | '|' | '|=' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-typeArguments($input, $state)
      return $state
    else
      $state
  let $state := p:parse-classOrInterfaceType-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "classOrInterfaceType", $count, $begin, $end)
};

(:~
 : Try parsing classOrInterfaceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-classOrInterfaceType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(104, $input, $state)          (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | '(' | ')' | '*=' | '+=' | ',' |
                                                               '-=' | '.' | '...' | '/=' | ':' | ';' | '<' | '<<=' |
                                                               '=' | '==' | '>' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'implements' | '{' | '|' | '|=' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-typeArguments($input, $state)
      return $state
    else
      $state
  let $state := p:try-classOrInterfaceType-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production type (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-type-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(100, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | ')' | '*=' | '+=' | ',' | '-=' |
                                                               '...' | '/=' | ':' | ';' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-type-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production type (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-type-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(100, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | ')' | '*=' | '+=' | ',' | '-=' |
                                                               '...' | '/=' | ':' | ';' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-type-1($input, $state)
};

(:~
 : Parse the 2nd loop of production type (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-type-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(100, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | ')' | '*=' | '+=' | ',' | '-=' |
                                                               '...' | '/=' | ':' | ';' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consume(53, $input, $state)         (: ']' :)
        return p:parse-type-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production type (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-type-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(100, $input, $state)        (: Identifier | WS | COMMENT | LINE_COMMENT | '!=' | '%=' |
                                                               '&' | '&&' | '&=' | ')' | '*=' | '+=' | ',' | '-=' |
                                                               '...' | '/=' | ':' | ';' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(10, $input, $state)     (: WS | COMMENT | LINE_COMMENT | ']' :)
        let $state := p:consumeT(53, $input, $state)        (: ']' :)
        return p:try-type-2($input, $state)
};

(:~
 : Parse type.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-type($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9) then                        (: Identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-classOrInterfaceType($input, $state)
      let $state := p:parse-type-1($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-primitiveType($input, $state)
      let $state := p:parse-type-2($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "type", $count, $begin, $end)
};

(:~
 : Try parsing type.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-type($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9) then                        (: Identifier :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-classOrInterfaceType($input, $state)
      let $state := p:try-type-1($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-primitiveType($input, $state)
      let $state := p:try-type-2($input, $state)
      return $state
  return $state
};

(:~
 : Parse primitiveType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-primitiveType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 57) then                       (: 'boolean' :)
      let $state := p:consume(57, $input, $state)           (: 'boolean' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: 'char' :)
      let $state := p:consume(62, $input, $state)           (: 'char' :)
      return $state
    else if ($state[$p:l1] = 59) then                       (: 'byte' :)
      let $state := p:consume(59, $input, $state)           (: 'byte' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'short' :)
      let $state := p:consume(90, $input, $state)           (: 'short' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'int' :)
      let $state := p:consume(79, $input, $state)           (: 'int' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'long' :)
      let $state := p:consume(81, $input, $state)           (: 'long' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'float' :)
      let $state := p:consume(73, $input, $state)           (: 'float' :)
      return $state
    else
      let $state := p:consume(67, $input, $state)           (: 'double' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "primitiveType", $count, $begin, $end)
};

(:~
 : Try parsing primitiveType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-primitiveType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 57) then                       (: 'boolean' :)
      let $state := p:consumeT(57, $input, $state)          (: 'boolean' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: 'char' :)
      let $state := p:consumeT(62, $input, $state)          (: 'char' :)
      return $state
    else if ($state[$p:l1] = 59) then                       (: 'byte' :)
      let $state := p:consumeT(59, $input, $state)          (: 'byte' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'short' :)
      let $state := p:consumeT(90, $input, $state)          (: 'short' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'int' :)
      let $state := p:consumeT(79, $input, $state)          (: 'int' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'long' :)
      let $state := p:consumeT(81, $input, $state)          (: 'long' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'float' :)
      let $state := p:consumeT(73, $input, $state)          (: 'float' :)
      return $state
    else
      let $state := p:consumeT(67, $input, $state)          (: 'double' :)
      return $state
  return $state
};

(:~
 : Parse castExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-castExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 21) then                           (: '(' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7317                           (: '(' 'boolean' :)
          or $state[$p:lk] = 7573                           (: '(' 'byte' :)
          or $state[$p:lk] = 7957                           (: '(' 'char' :)
          or $state[$p:lk] = 8597                           (: '(' 'double' :)
          or $state[$p:lk] = 9365                           (: '(' 'float' :)
          or $state[$p:lk] = 10133                          (: '(' 'int' :)
          or $state[$p:lk] = 10389                          (: '(' 'long' :)
          or $state[$p:lk] = 11541) then                    (: '(' 'short' :)
      let $state := p:memoized($state, 13)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(21, $input, $state)      (: '(' :)
          let $state := p:lookahead1W(68, $input, $state)   (: WS | COMMENT | LINE_COMMENT | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'float' | 'int' | 'long' | 'short' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-primitiveType($input, $state)
          let $state := p:lookahead1W(2, $input, $state)    (: WS | COMMENT | LINE_COMMENT | ')' :)
          let $state := p:consumeT(22, $input, $state)      (: ')' :)
          let $state := p:lookahead1W(89, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-unaryExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(21, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(68, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-primitiveType($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ')' :)
      let $state := p:consume(22, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpression($input, $state)
      return $state
    else
      let $state := p:consume(21, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:l1] eq 9) then                        (: Identifier :)
          let $state := p:lookahead2W(106, $input, $state)  (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | '-' | '--' | '-=' | '.' | '/' | '/=' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' |
                                                               '>>=' | '>>>' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
          return $state
        else if ($state[$p:l1] = (57,                       (: 'boolean' :)
                                  59,                       (: 'byte' :)
                                  62,                       (: 'char' :)
                                  67,                       (: 'double' :)
                                  73,                       (: 'float' :)
                                  79,                       (: 'int' :)
                                  81,                       (: 'long' :)
                                  90)) then                 (: 'short' :)
          let $state := p:lookahead2W(46, $input, $state)   (: WS | COMMENT | LINE_COMMENT | ')' | '.' | '[' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 2825                       (: Identifier ')' :)
              or $state[$p:lk] = 4105                       (: Identifier '.' :)
              or $state[$p:lk] = 4873                       (: Identifier '<' :)
              or $state[$p:lk] = 6665                       (: Identifier '[' :)
              or $state[$p:lk] = 6713                       (: 'boolean' '[' :)
              or $state[$p:lk] = 6715                       (: 'byte' '[' :)
              or $state[$p:lk] = 6718                       (: 'char' '[' :)
              or $state[$p:lk] = 6723                       (: 'double' '[' :)
              or $state[$p:lk] = 6729                       (: 'float' '[' :)
              or $state[$p:lk] = 6735                       (: 'int' '[' :)
              or $state[$p:lk] = 6737                       (: 'long' '[' :)
              or $state[$p:lk] = 6746) then                 (: 'short' '[' :)
          let $state := p:memoized($state, 14)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-type($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
         or $state[$p:lk] = 2873                            (: 'boolean' ')' :)
         or $state[$p:lk] = 2875                            (: 'byte' ')' :)
         or $state[$p:lk] = 2878                            (: 'char' ')' :)
         or $state[$p:lk] = 2883                            (: 'double' ')' :)
         or $state[$p:lk] = 2889                            (: 'float' ')' :)
         or $state[$p:lk] = 2895                            (: 'int' ')' :)
         or $state[$p:lk] = 2897                            (: 'long' ')' :)
         or $state[$p:lk] = 2906) then                      (: 'short' ')' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-type($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-expression($input, $state)
          return $state
      let $state := p:consume(22, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(82, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpressionNotPlusMinus($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "castExpression", $count, $begin, $end)
};

(:~
 : Try parsing castExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-castExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 21) then                           (: '(' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7317                           (: '(' 'boolean' :)
          or $state[$p:lk] = 7573                           (: '(' 'byte' :)
          or $state[$p:lk] = 7957                           (: '(' 'char' :)
          or $state[$p:lk] = 8597                           (: '(' 'double' :)
          or $state[$p:lk] = 9365                           (: '(' 'float' :)
          or $state[$p:lk] = 10133                          (: '(' 'int' :)
          or $state[$p:lk] = 10389                          (: '(' 'long' :)
          or $state[$p:lk] = 11541) then                    (: '(' 'short' :)
      let $state := p:memoized($state, 13)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(21, $input, $state)      (: '(' :)
          let $state := p:lookahead1W(68, $input, $state)   (: WS | COMMENT | LINE_COMMENT | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'float' | 'int' | 'long' | 'short' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-primitiveType($input, $state)
          let $state := p:lookahead1W(2, $input, $state)    (: WS | COMMENT | LINE_COMMENT | ')' :)
          let $state := p:consumeT(22, $input, $state)      (: ')' :)
          let $state := p:lookahead1W(89, $input, $state)   (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-unaryExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consumeT(21, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(68, $input, $state)       (: WS | COMMENT | LINE_COMMENT | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-primitiveType($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ')' :)
      let $state := p:consumeT(22, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpression($input, $state)
      return $state
    else
      let $state := p:consumeT(21, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:l1] eq 9) then                        (: Identifier :)
          let $state := p:lookahead2W(106, $input, $state)  (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' |
                                                               '+=' | '-' | '--' | '-=' | '.' | '/' | '/=' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' |
                                                               '>>=' | '>>>' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
          return $state
        else if ($state[$p:l1] = (57,                       (: 'boolean' :)
                                  59,                       (: 'byte' :)
                                  62,                       (: 'char' :)
                                  67,                       (: 'double' :)
                                  73,                       (: 'float' :)
                                  79,                       (: 'int' :)
                                  81,                       (: 'long' :)
                                  90)) then                 (: 'short' :)
          let $state := p:lookahead2W(46, $input, $state)   (: WS | COMMENT | LINE_COMMENT | ')' | '.' | '[' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 2825                       (: Identifier ')' :)
              or $state[$p:lk] = 4105                       (: Identifier '.' :)
              or $state[$p:lk] = 4873                       (: Identifier '<' :)
              or $state[$p:lk] = 6665                       (: Identifier '[' :)
              or $state[$p:lk] = 6713                       (: 'boolean' '[' :)
              or $state[$p:lk] = 6715                       (: 'byte' '[' :)
              or $state[$p:lk] = 6718                       (: 'char' '[' :)
              or $state[$p:lk] = 6723                       (: 'double' '[' :)
              or $state[$p:lk] = 6729                       (: 'float' '[' :)
              or $state[$p:lk] = 6735                       (: 'int' '[' :)
              or $state[$p:lk] = 6737                       (: 'long' '[' :)
              or $state[$p:lk] = 6746) then                 (: 'short' '[' :)
          let $state := p:memoized($state, 14)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-type($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
         or $state[$p:lk] = 2873                            (: 'boolean' ')' :)
         or $state[$p:lk] = 2875                            (: 'byte' ')' :)
         or $state[$p:lk] = 2878                            (: 'char' ')' :)
         or $state[$p:lk] = 2883                            (: 'double' ')' :)
         or $state[$p:lk] = 2889                            (: 'float' ')' :)
         or $state[$p:lk] = 2895                            (: 'int' ')' :)
         or $state[$p:lk] = 2897                            (: 'long' ')' :)
         or $state[$p:lk] = 2906) then                      (: 'short' ')' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-type($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-expression($input, $state)
          return $state
      let $state := p:consumeT(22, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(82, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpressionNotPlusMinus($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production unaryExpressionNotPlusMinus (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-unaryExpressionNotPlusMinus-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 32                               (: '.' :)
      and $state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-selector($input, $state)
        return p:parse-unaryExpressionNotPlusMinus-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production unaryExpressionNotPlusMinus (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-unaryExpressionNotPlusMinus-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                               ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                               '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 32                               (: '.' :)
      and $state[$p:l1] != 52) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-selector($input, $state)
        return p:try-unaryExpressionNotPlusMinus-1($input, $state)
};

(:~
 : Parse unaryExpressionNotPlusMinus.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-unaryExpressionNotPlusMinus($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 21) then                           (: '(' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 1                             (: HexLiteral :)
         and $state[$p:lk] != 2                             (: DecimalLiteral :)
         and $state[$p:lk] != 3                             (: OctalLiteral :)
         and $state[$p:lk] != 4                             (: FloatingPointLiteral :)
         and $state[$p:lk] != 5                             (: CharacterLiteral :)
         and $state[$p:lk] != 6                             (: StringLiteral :)
         and $state[$p:lk] != 9                             (: Identifier :)
         and $state[$p:lk] != 14                            (: '!' :)
         and $state[$p:lk] != 57                            (: 'boolean' :)
         and $state[$p:lk] != 59                            (: 'byte' :)
         and $state[$p:lk] != 62                            (: 'char' :)
         and $state[$p:lk] != 67                            (: 'double' :)
         and $state[$p:lk] != 70                            (: 'false' :)
         and $state[$p:lk] != 73                            (: 'float' :)
         and $state[$p:lk] != 79                            (: 'int' :)
         and $state[$p:lk] != 81                            (: 'long' :)
         and $state[$p:lk] != 83                            (: 'new' :)
         and $state[$p:lk] != 84                            (: 'null' :)
         and $state[$p:lk] != 90                            (: 'short' :)
         and $state[$p:lk] != 93                            (: 'super' :)
         and $state[$p:lk] != 96                            (: 'this' :)
         and $state[$p:lk] != 100                           (: 'true' :)
         and $state[$p:lk] != 102                           (: 'void' :)
         and $state[$p:lk] != 110) then                     (: '~' :)
      let $state := p:memoized($state, 12)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-castExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -3, -3)
            else
              p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -4, -4)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 110) then                      (: '~' :)
      let $state := p:consume(110, $input, $state)          (: '~' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpression($input, $state)
      return $state
    else if ($state[$p:lk] = 14) then                       (: '!' :)
      let $state := p:consume(14, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpression($input, $state)
      return $state
    else if ($state[$p:lk] = -3) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-castExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-primary($input, $state)
      let $state := p:parse-unaryExpressionNotPlusMinus-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 26                         (: '++' :)
              or $state[$p:l1] = 30) then                   (: '--' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 26) then               (: '++' :)
              let $state := p:consume(26, $input, $state)   (: '++' :)
              return $state
            else
              let $state := p:consume(30, $input, $state)   (: '--' :)
              return $state
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "unaryExpressionNotPlusMinus", $count, $begin, $end)
};

(:~
 : Try parsing unaryExpressionNotPlusMinus.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-unaryExpressionNotPlusMinus($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 21) then                           (: '(' :)
      let $state := p:lookahead2W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 1                             (: HexLiteral :)
         and $state[$p:lk] != 2                             (: DecimalLiteral :)
         and $state[$p:lk] != 3                             (: OctalLiteral :)
         and $state[$p:lk] != 4                             (: FloatingPointLiteral :)
         and $state[$p:lk] != 5                             (: CharacterLiteral :)
         and $state[$p:lk] != 6                             (: StringLiteral :)
         and $state[$p:lk] != 9                             (: Identifier :)
         and $state[$p:lk] != 14                            (: '!' :)
         and $state[$p:lk] != 57                            (: 'boolean' :)
         and $state[$p:lk] != 59                            (: 'byte' :)
         and $state[$p:lk] != 62                            (: 'char' :)
         and $state[$p:lk] != 67                            (: 'double' :)
         and $state[$p:lk] != 70                            (: 'false' :)
         and $state[$p:lk] != 73                            (: 'float' :)
         and $state[$p:lk] != 79                            (: 'int' :)
         and $state[$p:lk] != 81                            (: 'long' :)
         and $state[$p:lk] != 83                            (: 'new' :)
         and $state[$p:lk] != 84                            (: 'null' :)
         and $state[$p:lk] != 90                            (: 'short' :)
         and $state[$p:lk] != 93                            (: 'super' :)
         and $state[$p:lk] != 96                            (: 'this' :)
         and $state[$p:lk] != 100                           (: 'true' :)
         and $state[$p:lk] != 102                           (: 'void' :)
         and $state[$p:lk] != 110) then                     (: '~' :)
      let $state := p:memoized($state, 12)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-castExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -3, -3)
            else
              p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -4, -4)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 110) then                      (: '~' :)
      let $state := p:consumeT(110, $input, $state)         (: '~' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpression($input, $state)
      return $state
    else if ($state[$p:lk] = 14) then                       (: '!' :)
      let $state := p:consumeT(14, $input, $state)          (: '!' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpression($input, $state)
      return $state
    else if ($state[$p:lk] = -3) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-castExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-primary($input, $state)
      let $state := p:try-unaryExpressionNotPlusMinus-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 26                         (: '++' :)
              or $state[$p:l1] = 30) then                   (: '--' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 26) then               (: '++' :)
              let $state := p:consumeT(26, $input, $state)  (: '++' :)
              return $state
            else
              let $state := p:consumeT(30, $input, $state)  (: '--' :)
              return $state
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse unaryExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-unaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: '+' :)
      let $state := p:consume(25, $input, $state)           (: '+' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: '-' :)
      let $state := p:consume(29, $input, $state)           (: '-' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '++' :)
      let $state := p:consume(26, $input, $state)           (: '++' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '--' :)
      let $state := p:consume(30, $input, $state)           (: '--' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-unaryExpressionNotPlusMinus($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "unaryExpression", $count, $begin, $end)
};

(:~
 : Try parsing unaryExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-unaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: '+' :)
      let $state := p:consumeT(25, $input, $state)          (: '+' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: '-' :)
      let $state := p:consumeT(29, $input, $state)          (: '-' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '++' :)
      let $state := p:consumeT(26, $input, $state)          (: '++' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '--' :)
      let $state := p:consumeT(30, $input, $state)          (: '--' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-unaryExpressionNotPlusMinus($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production multiplicativeExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-multiplicativeExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(108, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '+=' | ',' | '-' |
                                                               '-=' | '/' | '/=' | ':' | ';' | '<' | '<<' | '<<=' |
                                                               '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '>>>' |
                                                               '>>>=' | '?' | ']' | '^' | '^=' | 'instanceof' | '|' |
                                                               '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 16                               (: '%' :)
      and $state[$p:l1] != 23                               (: '*' :)
      and $state[$p:l1] != 34) then                         (: '/' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 23) then                 (: '*' :)
            let $state := p:consume(23, $input, $state)     (: '*' :)
            return $state
          else if ($state[$p:l1] = 34) then                 (: '/' :)
            let $state := p:consume(34, $input, $state)     (: '/' :)
            return $state
          else
            let $state := p:consume(16, $input, $state)     (: '%' :)
            return $state
        let $state := p:lookahead1W(89, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-unaryExpression($input, $state)
        return p:parse-multiplicativeExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production multiplicativeExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-multiplicativeExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(108, $input, $state)        (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '%=' | '&' |
                                                               '&&' | '&=' | ')' | '*' | '*=' | '+' | '+=' | ',' | '-' |
                                                               '-=' | '/' | '/=' | ':' | ';' | '<' | '<<' | '<<=' |
                                                               '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '>>>' |
                                                               '>>>=' | '?' | ']' | '^' | '^=' | 'instanceof' | '|' |
                                                               '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 16                               (: '%' :)
      and $state[$p:l1] != 23                               (: '*' :)
      and $state[$p:l1] != 34) then                         (: '/' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 23) then                 (: '*' :)
            let $state := p:consumeT(23, $input, $state)    (: '*' :)
            return $state
          else if ($state[$p:l1] = 34) then                 (: '/' :)
            let $state := p:consumeT(34, $input, $state)    (: '/' :)
            return $state
          else
            let $state := p:consumeT(16, $input, $state)    (: '%' :)
            return $state
        let $state := p:lookahead1W(89, $input, $state)     (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-unaryExpression($input, $state)
        return p:try-multiplicativeExpression-1($input, $state)
};

(:~
 : Parse multiplicativeExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-multiplicativeExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-unaryExpression($input, $state)
  let $state := p:parse-multiplicativeExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "multiplicativeExpression", $count, $begin, $end)
};

(:~
 : Try parsing multiplicativeExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-multiplicativeExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-unaryExpression($input, $state)
  let $state := p:try-multiplicativeExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production additiveExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-additiveExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25                                 (: '+' :)
    and $state[$p:l1] != 29) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 25) then                   (: '+' :)
          let $state := p:consume(25, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(29, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-multiplicativeExpression($input, $state)
      return p:parse-additiveExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production additiveExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-additiveExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25                                 (: '+' :)
    and $state[$p:l1] != 29) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 25) then                   (: '+' :)
          let $state := p:consumeT(25, $input, $state)      (: '+' :)
          return $state
        else
          let $state := p:consumeT(29, $input, $state)      (: '-' :)
          return $state
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-multiplicativeExpression($input, $state)
      return p:try-additiveExpression-1($input, $state)
};

(:~
 : Parse additiveExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-additiveExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-multiplicativeExpression($input, $state)
  let $state := p:parse-additiveExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "additiveExpression", $count, $begin, $end)
};

(:~
 : Try parsing additiveExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-additiveExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-multiplicativeExpression($input, $state)
  let $state := p:try-additiveExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production shiftExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-shiftExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39                                 (: '<<' :)
    and $state[$p:l1] != 46                                 (: '>>' :)
    and $state[$p:l1] != 48) then                           (: '>>>' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-shiftOp($input, $state)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-additiveExpression($input, $state)
      return p:parse-shiftExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production shiftExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-shiftExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39                                 (: '<<' :)
    and $state[$p:l1] != 46                                 (: '>>' :)
    and $state[$p:l1] != 48) then                           (: '>>>' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-shiftOp($input, $state)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-additiveExpression($input, $state)
      return p:try-shiftExpression-1($input, $state)
};

(:~
 : Parse shiftExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-shiftExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-additiveExpression($input, $state)
  let $state := p:parse-shiftExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "shiftExpression", $count, $begin, $end)
};

(:~
 : Try parsing shiftExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-shiftExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-additiveExpression($input, $state)
  let $state := p:try-shiftExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production relationalExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-relationalExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '<' :)
    and $state[$p:l1] != 41                                 (: '<=' :)
    and $state[$p:l1] != 44                                 (: '>' :)
    and $state[$p:l1] != 45) then                           (: '>=' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-relationalOp($input, $state)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-shiftExpression($input, $state)
      return p:parse-relationalExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production relationalExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-relationalExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '<' :)
    and $state[$p:l1] != 41                                 (: '<=' :)
    and $state[$p:l1] != 44                                 (: '>' :)
    and $state[$p:l1] != 45) then                           (: '>=' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-relationalOp($input, $state)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-shiftExpression($input, $state)
      return p:try-relationalExpression-1($input, $state)
};

(:~
 : Parse relationalExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-relationalExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-shiftExpression($input, $state)
  let $state := p:parse-relationalExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "relationalExpression", $count, $begin, $end)
};

(:~
 : Try parsing relationalExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-relationalExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-shiftExpression($input, $state)
  let $state := p:try-relationalExpression-1($input, $state)
  return $state
};

(:~
 : Parse instanceOfExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-instanceOfExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-relationalExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'instanceof' :)
      let $state := p:consume(78, $input, $state)           (: 'instanceof' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-type($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "instanceOfExpression", $count, $begin, $end)
};

(:~
 : Try parsing instanceOfExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-instanceOfExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-relationalExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'instanceof' :)
      let $state := p:consumeT(78, $input, $state)          (: 'instanceof' :)
      let $state := p:lookahead1W(69, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'float' | 'int' | 'long' |
                                                               'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-type($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production equalityExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-equalityExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 15                                 (: '!=' :)
    and $state[$p:l1] != 43) then                           (: '==' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 43) then                   (: '==' :)
          let $state := p:consume(43, $input, $state)       (: '==' :)
          return $state
        else
          let $state := p:consume(15, $input, $state)       (: '!=' :)
          return $state
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-instanceOfExpression($input, $state)
      return p:parse-equalityExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production equalityExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-equalityExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 15                                 (: '!=' :)
    and $state[$p:l1] != 43) then                           (: '==' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 43) then                   (: '==' :)
          let $state := p:consumeT(43, $input, $state)      (: '==' :)
          return $state
        else
          let $state := p:consumeT(15, $input, $state)      (: '!=' :)
          return $state
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-instanceOfExpression($input, $state)
      return p:try-equalityExpression-1($input, $state)
};

(:~
 : Parse equalityExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-equalityExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-instanceOfExpression($input, $state)
  let $state := p:parse-equalityExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "equalityExpression", $count, $begin, $end)
};

(:~
 : Try parsing equalityExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-equalityExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-instanceOfExpression($input, $state)
  let $state := p:try-equalityExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production andExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-andExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 18) then                           (: '&' :)
      $state
    else
      let $state := p:consume(18, $input, $state)           (: '&' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-equalityExpression($input, $state)
      return p:parse-andExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production andExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-andExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 18) then                           (: '&' :)
      $state
    else
      let $state := p:consumeT(18, $input, $state)          (: '&' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-equalityExpression($input, $state)
      return p:try-andExpression-1($input, $state)
};

(:~
 : Parse andExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-andExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-equalityExpression($input, $state)
  let $state := p:parse-andExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "andExpression", $count, $begin, $end)
};

(:~
 : Try parsing andExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-andExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-equalityExpression($input, $state)
  let $state := p:try-andExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production exclusiveOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-exclusiveOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 54) then                           (: '^' :)
      $state
    else
      let $state := p:consume(54, $input, $state)           (: '^' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-andExpression($input, $state)
      return p:parse-exclusiveOrExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production exclusiveOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-exclusiveOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 54) then                           (: '^' :)
      $state
    else
      let $state := p:consumeT(54, $input, $state)          (: '^' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-andExpression($input, $state)
      return p:try-exclusiveOrExpression-1($input, $state)
};

(:~
 : Parse exclusiveOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-exclusiveOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-andExpression($input, $state)
  let $state := p:parse-exclusiveOrExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "exclusiveOrExpression", $count, $begin, $end)
};

(:~
 : Try parsing exclusiveOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-exclusiveOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-andExpression($input, $state)
  let $state := p:try-exclusiveOrExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production inclusiveOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-inclusiveOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 106) then                          (: '|' :)
      $state
    else
      let $state := p:consume(106, $input, $state)          (: '|' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-exclusiveOrExpression($input, $state)
      return p:parse-inclusiveOrExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production inclusiveOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-inclusiveOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 106) then                          (: '|' :)
      $state
    else
      let $state := p:consumeT(106, $input, $state)         (: '|' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-exclusiveOrExpression($input, $state)
      return p:try-inclusiveOrExpression-1($input, $state)
};

(:~
 : Parse inclusiveOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-inclusiveOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-exclusiveOrExpression($input, $state)
  let $state := p:parse-inclusiveOrExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "inclusiveOrExpression", $count, $begin, $end)
};

(:~
 : Try parsing inclusiveOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-inclusiveOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-exclusiveOrExpression($input, $state)
  let $state := p:try-inclusiveOrExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production conditionalAndExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-conditionalAndExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 19) then                           (: '&&' :)
      $state
    else
      let $state := p:consume(19, $input, $state)           (: '&&' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-inclusiveOrExpression($input, $state)
      return p:parse-conditionalAndExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production conditionalAndExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-conditionalAndExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 19) then                           (: '&&' :)
      $state
    else
      let $state := p:consumeT(19, $input, $state)          (: '&&' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-inclusiveOrExpression($input, $state)
      return p:try-conditionalAndExpression-1($input, $state)
};

(:~
 : Parse conditionalAndExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-conditionalAndExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-inclusiveOrExpression($input, $state)
  let $state := p:parse-conditionalAndExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "conditionalAndExpression", $count, $begin, $end)
};

(:~
 : Try parsing conditionalAndExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-conditionalAndExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-inclusiveOrExpression($input, $state)
  let $state := p:try-conditionalAndExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production conditionalOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-conditionalOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 108) then                          (: '||' :)
      $state
    else
      let $state := p:consume(108, $input, $state)          (: '||' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-conditionalAndExpression($input, $state)
      return p:parse-conditionalOrExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production conditionalOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-conditionalOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 108) then                          (: '||' :)
      $state
    else
      let $state := p:consumeT(108, $input, $state)         (: '||' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-conditionalAndExpression($input, $state)
      return p:try-conditionalOrExpression-1($input, $state)
};

(:~
 : Parse conditionalOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-conditionalOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-conditionalAndExpression($input, $state)
  let $state := p:parse-conditionalOrExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "conditionalOrExpression", $count, $begin, $end)
};

(:~
 : Try parsing conditionalOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-conditionalOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-conditionalAndExpression($input, $state)
  let $state := p:try-conditionalOrExpression-1($input, $state)
  return $state
};

(:~
 : Parse conditionalExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-conditionalExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-conditionalOrExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50) then                       (: '?' :)
      let $state := p:consume(50, $input, $state)           (: '?' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      let $state := p:consume(36, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expression($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "conditionalExpression", $count, $begin, $end)
};

(:~
 : Try parsing conditionalExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-conditionalExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-conditionalOrExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50) then                       (: '?' :)
      let $state := p:consumeT(50, $input, $state)          (: '?' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      let $state := p:consumeT(36, $input, $state)          (: ':' :)
      let $state := p:lookahead1W(89, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expression($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse elementValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotation($input, $state)
      return $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-elementValueArrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-conditionalExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "elementValue", $count, $begin, $end)
};

(:~
 : Try parsing elementValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-annotation($input, $state)
      return $state
    else if ($state[$p:l1] = 105) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-elementValueArrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-conditionalExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse elementValuePair.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementValuePair($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(8, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '=' :)
  let $state := p:consume(42, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(95, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '@' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-elementValue($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "elementValuePair", $count, $begin, $end)
};

(:~
 : Try parsing elementValuePair.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementValuePair($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(8, $input, $state)            (: WS | COMMENT | LINE_COMMENT | '=' :)
  let $state := p:consumeT(42, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(95, $input, $state)           (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '@' | 'boolean' | 'byte' |
                                                               'char' | 'double' | 'false' | 'float' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-elementValue($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production elementValuePairs (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementValuePairs-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ')' | ',' :)
    return
      if ($state[$p:l1] != 28) then                         (: ',' :)
        $state
      else
        let $state := p:consume(28, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-elementValuePair($input, $state)
        return p:parse-elementValuePairs-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production elementValuePairs (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementValuePairs-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: WS | COMMENT | LINE_COMMENT | ')' | ',' :)
    return
      if ($state[$p:l1] != 28) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(28, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-elementValuePair($input, $state)
        return p:try-elementValuePairs-1($input, $state)
};

(:~
 : Parse elementValuePairs.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-elementValuePair($input, $state)
  let $state := p:parse-elementValuePairs-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "elementValuePairs", $count, $begin, $end)
};

(:~
 : Try parsing elementValuePairs.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-elementValuePair($input, $state)
  let $state := p:try-elementValuePairs-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production annotationName (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationName-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(102, $input, $state)        (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '(' |
                                                               ')' | ',' | '.' | ';' | '<' | '@' | 'abstract' |
                                                               'boolean' | 'byte' | 'char' | 'class' | 'double' |
                                                               'final' | 'float' | 'int' | 'interface' | 'long' |
                                                               'native' | 'package' | 'private' | 'protected' |
                                                               'public' | 'short' | 'static' | 'strictfp' |
                                                               'synchronized' | 'transient' | 'void' | 'volatile' | '}' :)
    return
      if ($state[$p:l1] != 32) then                         (: '.' :)
        $state
      else
        let $state := p:consume(32, $input, $state)         (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consume(9, $input, $state)          (: Identifier :)
        return p:parse-annotationName-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production annotationName (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationName-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(102, $input, $state)        (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '(' |
                                                               ')' | ',' | '.' | ';' | '<' | '@' | 'abstract' |
                                                               'boolean' | 'byte' | 'char' | 'class' | 'double' |
                                                               'final' | 'float' | 'int' | 'interface' | 'long' |
                                                               'native' | 'package' | 'private' | 'protected' |
                                                               'public' | 'short' | 'static' | 'strictfp' |
                                                               'synchronized' | 'transient' | 'void' | 'volatile' | '}' :)
    return
      if ($state[$p:l1] != 32) then                         (: '.' :)
        $state
      else
        let $state := p:consumeT(32, $input, $state)        (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WS | COMMENT | LINE_COMMENT :)
        let $state := p:consumeT(9, $input, $state)         (: Identifier :)
        return p:try-annotationName-1($input, $state)
};

(:~
 : Parse annotationName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotationName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(9, $input, $state)                (: Identifier :)
  let $state := p:parse-annotationName-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotationName", $count, $begin, $end)
};

(:~
 : Try parsing annotationName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotationName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(9, $input, $state)               (: Identifier :)
  let $state := p:try-annotationName-1($input, $state)
  return $state
};

(:~
 : Parse annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(51, $input, $state)               (: '@' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-annotationName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state := p:consume(21, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(97, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '@' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'false' | 'float' | 'int' |
                                                               'long' | 'new' | 'null' | 'short' | 'super' | 'this' |
                                                               'true' | 'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 22) then                  (: ')' :)
          let $state :=
            if ($state[$p:l1] eq 9) then                    (: Identifier :)
              let $state := p:lookahead2W(88, $input, $state) (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '&' | '&&' |
                                                                 '(' | ')' | '*' | '+' | '++' | '-' | '--' | '.' | '/' |
                                                                 '<' | '<<' | '<=' | '=' | '==' | '>' | '>=' | '>>' |
                                                                 '>>>' | '?' | '[' | '^' | 'instanceof' | '|' | '||' :)
              return $state
            else
              ($state[$p:l1], subsequence($state, $p:lk + 1))
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:lk] = 5385) then             (: Identifier '=' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-elementValuePairs($input, $state)
              return $state
            else
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-elementValue($input, $state)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(2, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ')' :)
      let $state := p:consume(22, $input, $state)           (: ')' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "annotation", $count, $begin, $end)
};

(:~
 : Try parsing annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(51, $input, $state)              (: '@' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WS | COMMENT | LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-annotationName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state := p:consumeT(21, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(97, $input, $state)       (: HexLiteral | DecimalLiteral | OctalLiteral |
                                                               FloatingPointLiteral | CharacterLiteral | StringLiteral |
                                                               Identifier | WS | COMMENT | LINE_COMMENT | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '@' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'false' | 'float' | 'int' |
                                                               'long' | 'new' | 'null' | 'short' | 'super' | 'this' |
                                                               'true' | 'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 22) then                  (: ')' :)
          let $state :=
            if ($state[$p:l1] eq 9) then                    (: Identifier :)
              let $state := p:lookahead2W(88, $input, $state) (: WS | COMMENT | LINE_COMMENT | '!=' | '%' | '&' | '&&' |
                                                                 '(' | ')' | '*' | '+' | '++' | '-' | '--' | '.' | '/' |
                                                                 '<' | '<<' | '<=' | '=' | '==' | '>' | '>=' | '>>' |
                                                                 '>>>' | '?' | '[' | '^' | 'instanceof' | '|' | '||' :)
              return $state
            else
              ($state[$p:l1], subsequence($state, $p:lk + 1))
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:lk] = 5385) then             (: Identifier '=' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-elementValuePairs($input, $state)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-elementValue($input, $state)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(2, $input, $state)        (: WS | COMMENT | LINE_COMMENT | ')' :)
      let $state := p:consumeT(22, $input, $state)          (: ')' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production annotations (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotations-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-annotation($input, $state)
    let $state := p:lookahead1W(77, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'abstract' | 'class' | 'final' | 'interface' |
                                                               'package' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' :)
    let $state :=
      if ($state[$p:l1] eq 51) then                         (: '@' :)
        let $state := p:lookahead2W(23, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 1203) then                   (: '@' Identifier :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-annotation($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        p:parse-annotations-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production annotations (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotations-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-annotation($input, $state)
    let $state := p:lookahead1W(77, $input, $state)         (: ENUM | Identifier | WS | COMMENT | LINE_COMMENT | '@' |
                                                               'abstract' | 'class' | 'final' | 'interface' |
                                                               'package' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' :)
    let $state :=
      if ($state[$p:l1] eq 51) then                         (: '@' :)
        let $state := p:lookahead2W(23, $input, $state)     (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 1203) then                   (: '@' Identifier :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-annotation($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 3, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-annotations-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        p:try-annotations-1($input, $state)
};

(:~
 : Parse annotations.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-annotations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-annotations-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "annotations", $count, $begin, $end)
};

(:~
 : Try parsing annotations.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-annotations($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-annotations-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production compilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-compilationUnit-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(79, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'import' | 'interface' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' :)
    return
      if ($state[$p:l1] != 77) then                         (: 'import' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-importDeclaration($input, $state)
        return p:parse-compilationUnit-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production compilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-compilationUnit-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(79, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'import' | 'interface' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' :)
    return
      if ($state[$p:l1] != 77) then                         (: 'import' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-importDeclaration($input, $state)
        return p:try-compilationUnit-1($input, $state)
};

(:~
 : Parse the 2nd loop of production compilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-compilationUnit-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(78, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'interface' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' :)
    return
      if ($state[$p:l1] = 13) then                          (: EOF :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-typeDeclaration($input, $state)
        return p:parse-compilationUnit-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production compilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-compilationUnit-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(78, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'interface' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' :)
    return
      if ($state[$p:l1] = 13) then                          (: EOF :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-typeDeclaration($input, $state)
        return p:try-compilationUnit-2($input, $state)
};

(:~
 : Parse the 3rd loop of production compilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-compilationUnit-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(78, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'interface' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' :)
    return
      if ($state[$p:l1] = 13) then                          (: EOF :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-typeDeclaration($input, $state)
        return p:parse-compilationUnit-3($input, $state)
};

(:~
 : Try parsing the 3rd loop of production compilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-compilationUnit-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(78, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'interface' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' :)
    return
      if ($state[$p:l1] = 13) then                          (: EOF :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-typeDeclaration($input, $state)
        return p:try-compilationUnit-3($input, $state)
};

(:~
 : Parse the 4th loop of production compilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-compilationUnit-4($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(79, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'import' | 'interface' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' :)
    return
      if ($state[$p:l1] != 77) then                         (: 'import' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-importDeclaration($input, $state)
        return p:parse-compilationUnit-4($input, $state)
};

(:~
 : Parse the 5th loop of production compilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-compilationUnit-5($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(78, $input, $state)         (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'interface' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' :)
    return
      if ($state[$p:l1] = 13) then                          (: EOF :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-typeDeclaration($input, $state)
        return p:parse-compilationUnit-5($input, $state)
};

(:~
 : Parse compilationUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-compilationUnit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(80, $input, $state)           (: ENUM | WS | COMMENT | LINE_COMMENT | EOF | ';' | '@' |
                                                               'abstract' | 'class' | 'final' | 'import' | 'interface' |
                                                               'package' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' :)
  let $state :=
    if ($state[$p:l1] eq 51) then                           (: '@' :)
      let $state := p:lookahead2W(23, $input, $state)       (: Identifier | WS | COMMENT | LINE_COMMENT | 'interface' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1203) then                     (: '@' Identifier :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-annotations($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 85) then               (: 'package' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-packageDeclaration($input, $state)
              let $state := p:try-compilationUnit-1($input, $state)
              let $state := p:try-compilationUnit-2($input, $state)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-classOrInterfaceDeclaration($input, $state)
              let $state := p:try-compilationUnit-3($input, $state)
              return $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-annotations($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 85) then                   (: 'package' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-packageDeclaration($input, $state)
          let $state := p:parse-compilationUnit-1($input, $state)
          let $state := p:parse-compilationUnit-2($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-classOrInterfaceDeclaration($input, $state)
          let $state := p:parse-compilationUnit-3($input, $state)
          return $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 85) then                   (: 'package' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-packageDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:parse-compilationUnit-4($input, $state)
      let $state := p:parse-compilationUnit-5($input, $state)
      return $state
  let $state := p:consume(13, $input, $state)               (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "compilationUnit", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 6),
    0, 0, 0,
    subsequence($state, 10),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 6),
    0, 0, 0,
    subsequence($state, 10)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 10                                      (: WS :)
     or $match[1] = 11                                      (: COMMENT :)
     or $match[1] = 12) then                                (: LINE_COMMENT :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 3)
    else
      p:matchW($input, $state[$p:e1], $set)
  return
  (
    $match[1] * 128 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 10)
  )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from lexer state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore lexer state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the lexer state before backtracking started.
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value
  }
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $dpi for input position $e0. Reconstruct state from the parameters.
 :
 : @param $state the lexer state to be restored.
 : @param $update the lexer state containing updates.
 : @param $dpi the decision point id.
 : @param $e0 the input position.
 : @param $v the id of the successful alternative.
 : @param $lk the new lookahead code.
 : @return the reconstructed state.
 :)
declare function p:memoize($state as item()+,
                           $update as item()+,
                           $dpi as xs:integer,
                           $e0 as xs:integer,
                           $v as xs:integer,
                           $lk as xs:integer) as item()+
{
  $lk,
  subsequence($state, $p:b0, $p:memo - $p:b0),
  let $memo := $update[$p:memo]
  let $errors := ($memo, $update[$p:error])[.]
  return
    element memo
    {
      $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
      $memo/value,
      <value key='{$e0 * 32 + $dpi}'>{$v}</value>
    },
  subsequence($state, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $dpi
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $dpi the decision point id.
 : @return the updated state.
 :)
declare function p:memoized($state as item()+, $dpi as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 32 + $dpi])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol compilationUnit from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-compilationUnit($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, false(), <memo/>)
  let $state := p:parse-compilationUnit($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : The input filename, or string, if surrounded by curly braces.
 :)
declare variable $input as xs:string external;

let $result :=
  if (matches($input, "^\{.*\}$")) then
    p:parse-compilationUnit(substring($input, 2, string-length($input) - 2))
  else
    p:parse-compilationUnit(unparsed-text($input, "utf-8"))
return
  if (empty($result/self::ERROR)) then
    $result
  else
    error(xs:QName("p:parse-compilationUnit"), concat("&#10;    ", replace($result, "&#10;", "&#10;    ")))

(: End :)
