xquery version "1.0" encoding "UTF-8";

(: This file was generated on Wed Sep 22, 2021 20:16 (UTC+02) by REx v5.54 which is Copyright (c) 1979-2021 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q XQueryV10withFullText-20100128.ebnf -xquery -main -tree :)

declare namespace p="XQueryV10withFullText-20100128";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 32, 6, 33, 6, 30, 6, 34, 35,
  36, 37, 38, 39, 40, 41, 42, 30, 30, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 30, 57, 58, 59, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1267, 1010, 1027, 1046,
  1054, 1062, 1070, 1275, 1275, 1275, 1275, 1275, 1275, 1424, 1275, 1267, 1267, 1268, 1267, 1267, 1267, 1268, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1269, 1275, 1275, 1275, 1275, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1267, 1267, 1267, 1267, 1267, 1267, 1355, 1268, 1266, 1265, 1267, 1267, 1267, 1267,
  1267, 1268, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1271, 1035, 1267, 1267, 1267, 1267, 1196, 1038, 1267,
  1267, 1267, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1274, 1275, 1037, 1273, 1275, 1401, 1275, 1275, 1275, 1275, 1275, 1266, 1267, 1267, 1272, 1133, 1321, 1400,
  1275, 1395, 1401, 1133, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1357, 1267, 1268, 1144, 1395, 1310, 1209,
  1395, 1401, 1395, 1395, 1395, 1395, 1395, 1395, 1395, 1395, 1397, 1275, 1275, 1275, 1401, 1275, 1275, 1275, 1380,
  1244, 1267, 1267, 1264, 1267, 1267, 1267, 1267, 1268, 1268, 1411, 1265, 1267, 1271, 1275, 1266, 1091, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1266, 1091, 1267, 1267, 1267, 1267, 1100, 1275, 1267, 1267, 1267, 1267, 1267,
  1267, 1113, 1122, 1267, 1267, 1267, 1114, 1269, 1273, 1437, 1267, 1267, 1267, 1267, 1267, 1267, 1162, 1395, 1397,
  1210, 1267, 1180, 1395, 1275, 1275, 1437, 1113, 1356, 1267, 1267, 1265, 1194, 1205, 1171, 1183, 1424, 1220, 1180,
  1395, 1273, 1275, 1231, 1254, 1356, 1267, 1267, 1265, 1083, 1205, 1186, 1183, 1275, 1242, 1425, 1395, 1252, 1275,
  1437, 1243, 1264, 1267, 1267, 1265, 1262, 1162, 1285, 1105, 1275, 1275, 994, 1395, 1275, 1275, 1437, 1113, 1356, 1267,
  1267, 1265, 1353, 1162, 1211, 1183, 1425, 1220, 1125, 1395, 1275, 1275, 1002, 1015, 1298, 1294, 1197, 1015, 1135,
  1125, 1212, 1209, 1424, 1275, 1424, 1395, 1275, 1275, 1437, 1091, 1265, 1267, 1267, 1265, 1092, 1125, 1286, 1209,
  1426, 1275, 1125, 1395, 1275, 1275, 1002, 1091, 1265, 1267, 1267, 1265, 1092, 1125, 1286, 1209, 1426, 1277, 1125,
  1395, 1275, 1275, 1002, 1091, 1265, 1267, 1267, 1265, 1267, 1125, 1172, 1209, 1424, 1275, 1125, 1395, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1267,
  1267, 1267, 1267, 1269, 1275, 1267, 1267, 1267, 1267, 1268, 1275, 1266, 1267, 1267, 1267, 1267, 1268, 1306, 1400,
  1318, 1396, 1395, 1401, 1275, 1275, 1275, 1275, 1223, 1330, 1036, 1266, 1340, 1350, 1306, 1154, 1365, 1397, 1395,
  1401, 1275, 1275, 1275, 1275, 1277, 1019, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1272, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1262, 1082, 1272, 1275, 1275,
  1275, 1275, 1409, 1274, 1409, 1196, 1033, 1342, 1195, 1222, 1275, 1275, 1275, 1275, 1277, 1275, 1332, 1276, 1296,
  1272, 1275, 1275, 1275, 1275, 1420, 1274, 1422, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1271, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1273, 1267, 1267, 1269, 1269, 1267, 1267, 1267, 1267, 1269, 1269, 1267, 1412, 1267, 1267, 1267, 1269, 1267,
  1267, 1267, 1267, 1267, 1267, 1091, 1136, 1234, 1270, 1114, 1271, 1267, 1270, 1234, 1270, 1076, 1275, 1275, 1275,
  1266, 1322, 1170, 1275, 1266, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1270, 999, 1266, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1434, 1035, 1267, 1267, 1267, 1267, 1270, 1275, 1275, 1275, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1395, 1398, 1378, 1275, 1275, 1275, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1271, 1275, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1401, 1395, 1401, 1388, 1370, 1267, 1266, 1267, 1267, 1267, 1273,
  1394, 1395, 1286, 1399, 1285, 1394, 1395, 1397, 1394, 1378, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1266,
  1267, 1267, 1267, 1268, 1422, 1266, 1267, 1267, 1267, 1268, 1275, 1394, 1395, 1168, 1395, 1395, 1150, 1375, 1275,
  1267, 1267, 1267, 1272, 1272, 1275, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 6, 6,
  6, 6, 6, 60, 60, 6, 6, 60, 60, 6, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 6, 6, 6, 30, 30, 6, 6, 30, 6, 30, 30,
  30, 32, 6, 33, 6, 30, 6, 6, 6, 6, 6, 30, 30, 30, 30, 30, 30, 6, 34, 35, 36, 37, 38, 39, 40, 41, 42, 30, 30, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 30, 57, 58, 59, 6, 6, 6, 6, 6, 60, 6, 30, 6, 30, 30, 6, 30, 30, 6, 30,
  30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 60, 60, 60, 60, 6, 60, 60, 60, 6, 6, 30, 30, 30, 30, 30, 6, 6, 30, 30, 30,
  6, 6, 30, 30, 6, 6, 6, 6, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 30, 60, 60, 6, 60, 60,
  60, 6, 60, 60, 30, 6, 6, 30, 30, 6, 6, 60, 30, 60, 60, 6, 60, 60, 60, 60, 60, 6, 6, 60, 60, 30, 30, 60, 60, 6, 6, 60,
  60, 60, 6, 6, 6, 6, 60, 30, 6, 30, 6, 6, 6, 30, 30, 6, 6, 6, 30, 30, 6, 6, 60, 6, 60, 60, 60, 60, 6, 6, 6, 60, 60, 6,
  6, 6, 6, 30, 30, 6, 30, 6, 6, 30, 6, 6, 60, 6, 6, 30, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 6, 30, 6, 30, 30, 60, 60,
  30, 30, 30, 6, 6, 6, 6, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 60, 60,
  60, 60, 60, 60, 6, 60, 60, 6, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 6, 30, 60, 30, 30, 60, 60, 60, 60, 60, 30, 30, 60,
  30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 30, 6, 30, 6, 6, 30, 6, 6, 30, 30, 6, 30, 30, 30, 6, 30, 6, 30, 6, 30,
  6, 6, 30, 30, 6, 30, 30, 6, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 60, 6, 6, 6, 6, 60, 60, 6, 60, 6, 6, 6,
  6, 6, 6, 30, 60, 6, 6, 6, 6, 6, 60, 6, 60, 60, 60, 60, 60, 60, 60, 60, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 30, 6, 30,
  6, 30, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6, 6, 60, 60, 6, 30, 30, 30, 6, 60, 60, 60, 6, 30, 30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 30723, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 4111, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
  31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
  89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 7936, 7970, 7953, 7953, 8001,
  7953, 7953, 7954, 7988, 7953, 7972, 7950, 8017, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 8105, 8120,
  8122, 10629, 8138, 8219, 8219, 8347, 8219, 23439, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8166, 8219, 16237,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8184, 8218, 8219, 8219, 8236, 8219, 16079, 13705, 8258, 8219, 8219, 20336, 8289, 8219, 8219,
  8347, 8219, 8317, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8269, 8219, 16237, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8337,
  8219, 8219, 8219, 8085, 8219, 8219, 19253, 8373, 8219, 8219, 8219, 8396, 8219, 8219, 20757, 8219, 8431, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 16073, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219,
  14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8492, 8219, 8219, 8450, 8219,
  21968, 19253, 8373, 8219, 8490, 8476, 8138, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 8373, 8219, 8219,
  8219, 8138, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 16237, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 11927, 8508, 8219, 8219, 8219, 8531, 8219, 8219, 8347,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8559, 8575,
  8219, 8219, 8592, 8219, 8598, 19253, 8618, 8219, 8219, 21309, 8653, 8219, 8219, 8347, 8219, 13375, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8602, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987,
  8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8683, 8713, 8717, 8717, 8747, 8717, 8760,
  8718, 8734, 8772, 8788, 8697, 8138, 8219, 8219, 21336, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 16017, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8832, 8219, 8219, 8852, 8219, 8168, 8836, 8884, 8865, 8868, 23187,
  8900, 8219, 8219, 22836, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 16683, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 8946, 8975, 8988, 9004, 8138, 8219, 8219, 8347, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 18602, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219,
  8219, 8085, 8219, 8219, 19253, 9020, 9057, 17789, 17781, 8138, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 16237, 8219, 8922, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219,
  12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 20366, 8219, 8219, 9073, 20371, 8319, 9087,
  9103, 9118, 9120, 8321, 8138, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 9136, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 9158, 9194, 18582, 18574, 9210,
  8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 14602, 8219, 9247, 16237, 9266, 20747,
  16099, 19218, 15594, 8219, 13793, 12401, 12837, 14601, 14601, 22322, 8219, 8219, 8219, 10729, 16100, 19218, 8219,
  23264, 12401, 12401, 14359, 14601, 14601, 12779, 20491, 8219, 8219, 8219, 10437, 22914, 19270, 12401, 12401, 15319,
  14601, 14601, 11926, 8219, 8219, 10436, 17236, 13792, 9285, 15320, 9303, 12781, 8219, 9797, 22911, 13790, 21112,
  17833, 22208, 8219, 16836, 15031, 12401, 17830, 14638, 16836, 19409, 9323, 9378, 19362, 16540, 9399, 9474, 22700,
  9505, 20562, 13109, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 9532,
  8219, 8219, 19116, 9555, 8219, 8219, 8347, 8219, 12093, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 17015, 8219,
  8219, 16237, 8219, 8219, 16099, 19218, 15594, 8219, 13793, 12401, 12837, 14601, 14601, 11923, 8219, 8219, 8219, 8219,
  16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 8219, 8219, 8219, 10437, 22914, 19270,
  12401, 12401, 15319, 14601, 14601, 11926, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219,
  22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362, 19467,
  11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 9590, 8219, 8219, 8085,
  8219, 8219, 19253, 9608, 9655, 9644, 9671, 8138, 8219, 8219, 8347, 8219, 23460, 9723, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 9741, 8219,
  8219, 14865, 9555, 8219, 8219, 8347, 8219, 9231, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 17834, 8219, 8219,
  16237, 8219, 9764, 16099, 19218, 15594, 8219, 13793, 12401, 12837, 14601, 14601, 18269, 8219, 8219, 8219, 9788, 16100,
  19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 16627, 9849, 8219, 8219, 13342, 10437, 22914, 19270, 12401,
  12401, 15319, 14601, 14601, 9868, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219, 22911,
  13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362, 19467, 11902,
  15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8041, 8219, 8219, 9888, 9908,
  8219, 9927, 8373, 8219, 21851, 10475, 9943, 8219, 8219, 8029, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 15223, 9980,
  10080, 8219, 8219, 8242, 8219, 8219, 8219, 8219, 8219, 8219, 15225, 10007, 10130, 10079, 10079, 10037, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 10609, 10007, 10007, 10025, 10079, 10079, 10057, 8219, 8219, 8219, 8219, 8219, 8219,
  15292, 10007, 10007, 10147, 10079, 10079, 10040, 8219, 8219, 8219, 8219, 15224, 10007, 10148, 10079, 10059, 8219,
  8219, 8219, 15222, 10007, 10078, 10057, 8219, 8219, 15292, 10007, 10075, 10059, 8219, 10610, 10009, 10079, 10197,
  10096, 9991, 10147, 10123, 10107, 10102, 10146, 10164, 10168, 10184, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 10220, 8219, 8219,
  10213, 10248, 8219, 19253, 10236, 10269, 10272, 19381, 8138, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 10288, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 22327, 8631, 8219, 8219, 11440, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8198, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219,
  12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 8219,
  8959, 10311, 10313, 22748, 8138, 8219, 8219, 8347, 8219, 8219, 10329, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10330,
  8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 10346, 19491, 8219, 8219, 8085, 8219, 8219, 19253, 10381, 10396, 10398, 17512,
  10414, 8219, 8219, 8347, 8219, 8219, 10453, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10473, 8219, 16237, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 10491, 10516, 8219, 8219, 8085, 8219, 8219, 19253, 10534, 10549, 10551, 10500, 10567, 8219, 8219, 8347,
  8219, 8219, 10605, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10626, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 12918, 8219, 14987, 8219, 18129, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10645, 8219,
  8219, 8219, 10682, 8219, 8219, 19253, 8373, 8219, 10694, 8219, 10710, 8219, 8219, 8347, 8219, 23573, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 10745, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987,
  8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219,
  19253, 8373, 8219, 8219, 17126, 8138, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 10783, 8219, 10295, 10812,
  9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 14602, 8219, 8219, 16237, 8219, 8219,
  16099, 19218, 15594, 8219, 12880, 12401, 20874, 14601, 14601, 11923, 8219, 8219, 8219, 13345, 16100, 19218, 8219,
  23264, 12401, 12401, 14359, 14601, 14601, 9383, 10839, 8219, 8219, 13342, 10437, 22914, 19270, 12401, 12401, 15319,
  14601, 14601, 9868, 8219, 13582, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219, 22911, 13790, 12401,
  17833, 12779, 8219, 10858, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362, 19467, 11902, 15319, 11372,
  17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085, 8219, 8219, 19253,
  10783, 8219, 10295, 10812, 9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 14602,
  8219, 8219, 16237, 8219, 8219, 16099, 19218, 15594, 8219, 12880, 12401, 20874, 14601, 14601, 11923, 8219, 8219, 8219,
  13345, 16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 9383, 10839, 8219, 8219, 13342, 10437, 22914,
  19270, 12401, 12401, 15319, 14601, 14601, 9868, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219,
  8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362,
  19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219,
  8085, 8219, 8219, 19253, 10783, 8219, 10295, 10812, 9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219,
  13791, 20240, 14602, 8219, 8219, 16237, 8219, 8219, 16099, 19218, 15594, 8219, 12880, 12401, 20874, 14601, 14601,
  11923, 8219, 8219, 8219, 10879, 16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 9383, 10839, 8219, 8219,
  13342, 10437, 22914, 19270, 12401, 12401, 15319, 14601, 14601, 9868, 8219, 8219, 10436, 17236, 13792, 12401, 15320,
  14601, 12781, 8219, 8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786,
  17997, 14601, 19362, 19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  10763, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 10783, 8219, 10295, 10812, 9555, 8219, 8219, 8347, 8219, 8219, 8219,
  9705, 17237, 8219, 8219, 13791, 20240, 14602, 8219, 8219, 16237, 8219, 8219, 16099, 19218, 15594, 8219, 12880, 12401,
  20874, 14601, 14601, 11923, 8219, 8219, 8219, 13345, 16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601,
  9383, 10839, 8219, 8219, 22826, 10437, 22914, 19270, 12401, 12401, 15319, 14601, 14601, 9868, 8219, 8219, 10436,
  17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401,
  17830, 12781, 16836, 13786, 17997, 14601, 19362, 19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 10783, 8219, 10295, 10812, 9555, 8219, 8219,
  8347, 8219, 11840, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 14602, 8219, 8219, 16237, 8219, 11843, 16099, 19218,
  15594, 8219, 12880, 12401, 20874, 14601, 14601, 11923, 8219, 8219, 8219, 13345, 16100, 19218, 8219, 23264, 12401,
  12401, 14359, 14601, 14601, 9383, 10839, 8219, 8219, 13342, 10437, 22914, 19270, 12401, 12401, 15319, 14601, 14601,
  9868, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219, 22911, 13790, 12401, 17833, 12779,
  8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362, 19467, 11902, 15319, 11372, 17906, 20562,
  15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 10783, 8219, 10295,
  10812, 9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 14602, 8219, 8219, 16237,
  8219, 8219, 16099, 19218, 15594, 8219, 12880, 12401, 20874, 14601, 14601, 11923, 8219, 8219, 8219, 8219, 16100, 19218,
  8219, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 8219, 8219, 8219, 10437, 22914, 19270, 12401, 12401,
  15319, 14601, 14601, 11926, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219, 22911, 13790,
  12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362, 19467, 11902, 15319,
  11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085, 8219, 8219,
  19253, 10783, 8219, 10295, 10812, 9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 13791, 20240,
  14602, 8219, 8219, 16237, 8219, 8219, 16099, 19218, 15594, 8219, 12880, 12401, 20874, 14601, 14601, 11923, 8219, 8219,
  8219, 8219, 16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 8219, 8219, 8219, 10437, 22914,
  19270, 12401, 12401, 15319, 14601, 14601, 11926, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219,
  9748, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362,
  19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219,
  8085, 8219, 8219, 19253, 10919, 10959, 10948, 20893, 8138, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 16237, 8219, 12816, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 10975,
  10990, 10993, 22593, 8138, 8219, 8219, 8347, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12909, 8219, 16646, 8219, 12551, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 10763, 13381, 8219, 8219, 11009, 11047, 10518, 11071, 11087, 11102, 11115, 11131, 9555,
  11147, 13201, 11168, 12467, 11194, 13193, 11230, 11266, 11304, 13923, 11320, 11345, 19021, 16677, 16301, 16237, 10767,
  21826, 16099, 15437, 11979, 8219, 11395, 12401, 11415, 14601, 12999, 11923, 11463, 8219, 11484, 13345, 15059, 12710,
  8219, 11529, 20234, 18306, 22310, 18093, 12376, 11557, 11586, 15773, 11612, 11629, 11645, 14584, 19270, 11704, 11728,
  16797, 11746, 14601, 11773, 9686, 11055, 10436, 17236, 13792, 12401, 11796, 14601, 11818, 11859, 8816, 21495, 9957,
  21668, 17833, 11898, 8219, 16836, 15031, 16436, 20311, 11918, 16836, 13786, 17997, 14601, 19362, 19467, 11902, 15319,
  11943, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8089, 8219, 8219, 8085, 21228, 8219,
  19253, 11966, 11995, 10295, 10812, 9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 13791, 20240,
  14602, 8219, 8219, 16237, 8219, 8219, 16099, 19218, 15594, 8219, 12880, 12401, 20874, 14601, 14601, 11923, 8219, 8219,
  8219, 13345, 16100, 16761, 8415, 23264, 12401, 12401, 12014, 14601, 14601, 12052, 10839, 8219, 8219, 13342, 10437,
  22914, 19270, 12401, 12401, 15319, 14601, 14601, 9868, 8049, 8219, 12109, 17236, 18829, 12401, 17538, 14601, 12781,
  8219, 8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601,
  19362, 19467, 11902, 15319, 11372, 17906, 12133, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8220, 12168,
  8219, 8085, 13404, 8219, 12188, 12204, 12219, 12235, 12250, 9555, 8219, 19635, 18279, 19813, 8219, 8219, 9705, 17237,
  10722, 8219, 12266, 14001, 13129, 8219, 8219, 23403, 9628, 8219, 12288, 12315, 14435, 12333, 12352, 12400, 12580,
  12418, 14601, 11923, 9806, 8219, 18974, 12454, 10863, 19218, 12483, 23264, 13157, 16952, 14359, 18025, 22392, 9383,
  10839, 8219, 12501, 22567, 10437, 22914, 19270, 12401, 12401, 15319, 14601, 14601, 9868, 8219, 19164, 12520, 17236,
  13792, 12401, 15320, 14601, 12781, 8219, 16010, 12537, 12573, 18407, 11802, 14666, 12596, 18489, 12616, 11712, 18469,
  12781, 14295, 13786, 19833, 16910, 19362, 19467, 11902, 15319, 11372, 21036, 18160, 15318, 14530, 14534, 11359, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 10763, 8219, 18199, 8219, 8085, 18196, 9142, 19253, 12640, 12655, 12668, 12684, 9555, 8219, 8219,
  8347, 8219, 8219, 18861, 12700, 17237, 8219, 18868, 12726, 20240, 12775, 8219, 12797, 16237, 23434, 18050, 23349,
  23359, 11659, 18051, 12832, 21658, 19201, 14601, 12853, 11923, 8219, 14438, 8219, 13345, 16100, 19219, 15473, 12872,
  12401, 12401, 11329, 14601, 14601, 20853, 12900, 8219, 15551, 13342, 10437, 22914, 9033, 12937, 12401, 12957, 14601,
  22109, 9868, 8219, 8219, 15514, 16231, 19194, 18994, 19964, 14819, 12781, 8219, 13015, 13035, 13790, 13051, 23076,
  13075, 13817, 16836, 15031, 12401, 17830, 12781, 10429, 13786, 11399, 14601, 13095, 19467, 11902, 15319, 15176, 13145,
  20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 10658, 8219, 8085, 13180, 8219, 13222, 13238,
  13253, 13266, 13282, 9555, 15885, 13298, 14132, 9222, 11840, 19074, 13314, 13330, 13361, 13397, 13420, 13485, 13516,
  16406, 8219, 13562, 13578, 13598, 9698, 9707, 13621, 8219, 22617, 20017, 18245, 17678, 13449, 13650, 17726, 13666,
  13685, 13721, 13737, 13774, 13809, 13833, 18838, 13849, 13865, 22402, 13881, 13897, 13939, 8219, 13970, 13342, 13546,
  19299, 13986, 12740, 9458, 20633, 14037, 14058, 9868, 14117, 14168, 10436, 22814, 14189, 15186, 14205, 14227, 14263,
  8219, 14287, 14311, 14339, 15944, 14375, 14400, 20150, 14420, 14454, 14499, 14515, 14550, 14566, 18648, 17997, 14600,
  18443, 21677, 15105, 14618, 9489, 16370, 19049, 14654, 15982, 14682, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 20812,
  8219, 8085, 8637, 8219, 13954, 14708, 14723, 14736, 14752, 9555, 8219, 23397, 8347, 8219, 8219, 8219, 9705, 17237,
  8219, 8219, 16042, 20240, 14768, 15630, 8219, 16237, 8219, 8219, 19338, 19218, 11245, 8219, 14788, 12401, 20874,
  14815, 14601, 11923, 8219, 8219, 8219, 13345, 16100, 19218, 14835, 23264, 12401, 12884, 14359, 14601, 16583, 9383,
  10839, 8219, 8219, 13342, 10437, 22914, 19270, 12401, 12401, 15319, 14601, 14601, 9868, 8219, 8219, 10436, 14854,
  13792, 11730, 15320, 14601, 14881, 8219, 8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830,
  12781, 16836, 13786, 17997, 14601, 19362, 19467, 11902, 15319, 11372, 17906, 20562, 15318, 18230, 17820, 14902, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085, 9911, 8219, 11178, 14931, 14946, 14952, 14968, 9555, 8219, 8219,
  8347, 8219, 14984, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 14602, 17400, 8219, 16237, 8219, 8219, 16099, 19218,
  15594, 8219, 12880, 12401, 20874, 14601, 14601, 11923, 8219, 8219, 8219, 12336, 16100, 19218, 8219, 15003, 12401,
  12401, 14359, 14601, 14601, 12779, 8219, 9725, 16146, 8219, 10437, 15027, 22517, 12401, 12752, 15319, 12856, 14601,
  11926, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 17035, 22911, 13790, 12401, 17833, 12779,
  15047, 16836, 15031, 12401, 17830, 12781, 22952, 20004, 15075, 12970, 12438, 15091, 15121, 15319, 11372, 17906, 20562,
  15318, 14530, 14692, 15163, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 10783, 8219, 10295,
  10812, 9555, 8219, 8219, 15212, 8219, 8219, 8219, 9705, 15241, 13910, 15247, 20972, 15655, 19888, 8219, 11998, 16237,
  15263, 8219, 16099, 19218, 15594, 8219, 12880, 15674, 20874, 14601, 21720, 11923, 8219, 8219, 8219, 8219, 16100,
  19218, 13019, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 8219, 8219, 8219, 10437, 22914, 21465, 12401,
  12401, 15319, 14601, 14601, 11926, 8219, 15291, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219, 22911,
  13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 9171, 15308, 16791, 14012, 22218, 19868, 16891,
  15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 18135, 8219, 8085, 10932,
  15336, 11570, 15371, 15386, 15399, 15415, 9555, 8219, 8219, 12065, 8219, 10457, 9567, 15431, 15453, 15489, 15539,
  20070, 22874, 21161, 8219, 8219, 17707, 8219, 8219, 15567, 15612, 15594, 15628, 15646, 15671, 19421, 15690, 18957,
  11923, 15755, 17099, 15718, 15753, 16100, 12117, 21547, 23264, 12401, 17078, 19448, 14601, 14247, 12026, 8219, 23125,
  15771, 8219, 10437, 22914, 19270, 15789, 12401, 20981, 14601, 14601, 16389, 15807, 13669, 15823, 17236, 15850, 12401,
  16862, 14601, 12384, 15878, 8219, 15901, 15932, 16525, 15967, 15998, 8219, 11280, 16033, 18393, 21077, 16058, 16095,
  13786, 17997, 14601, 14073, 19467, 14404, 15319, 14915, 16116, 20562, 15318, 18711, 14534, 21189, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 10763, 8219, 8069, 8219, 8085, 8068, 16144, 8357, 16162, 16177, 16188, 16204, 9555, 19600, 8219, 8347, 8219,
  14984, 8219, 16220, 20519, 14142, 20526, 16253, 12272, 14602, 19105, 8219, 17476, 8219, 8219, 21001, 19218, 15594,
  16288, 16317, 16343, 14799, 16359, 12990, 16386, 16405, 8219, 12600, 8219, 17262, 19218, 8219, 23264, 16422, 12401,
  14359, 16452, 14601, 12779, 8219, 16489, 8219, 8219, 12521, 17230, 16510, 12401, 16563, 15319, 18099, 14630, 14271,
  8219, 9539, 9178, 17236, 18379, 12401, 21889, 14601, 12781, 10666, 19236, 16599, 9041, 12401, 16622, 12779, 22574,
  16836, 15031, 12401, 17830, 12781, 13538, 13786, 13059, 22655, 19362, 19467, 11902, 15319, 11372, 17906, 20562, 9413,
  21759, 14483, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8434, 8219, 8085, 8219, 16643, 8273, 16662, 16699, 16712,
  16728, 9555, 13206, 8219, 8347, 15737, 8219, 8219, 16744, 19743, 11494, 19750, 16777, 11379, 16813, 8219, 10365,
  16237, 8219, 16833, 16099, 22933, 22737, 11250, 16852, 12401, 16878, 16907, 9362, 17332, 19594, 19629, 8219, 16926,
  16100, 19218, 8219, 23264, 16943, 16968, 14359, 16987, 17012, 12779, 8219, 8380, 8219, 17031, 10437, 22914, 19270,
  22708, 12941, 15319, 17051, 22103, 11926, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219,
  22911, 13790, 12401, 17833, 14772, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362, 19467,
  21791, 21028, 17071, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8576, 8219, 17094,
  20372, 17115, 19253, 17142, 17157, 17170, 17186, 9555, 9892, 17202, 21346, 15468, 8219, 15916, 17219, 17253, 14152,
  17278, 17308, 15147, 17348, 14173, 17385, 16237, 12085, 15502, 17422, 17598, 10796, 17492, 17528, 12402, 20874, 17554,
  17641, 14886, 8219, 19660, 8219, 8219, 16100, 19218, 12504, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219,
  17573, 8930, 8219, 17592, 23367, 19270, 17614, 19860, 17631, 14601, 17666, 17954, 17694, 15730, 17742, 17772, 17805,
  17850, 17886, 17922, 17946, 8802, 8219, 17970, 12624, 17995, 18013, 12779, 18048, 19318, 15523, 18067, 13435, 18115,
  18915, 21600, 18151, 18176, 19362, 18215, 11902, 15319, 18295, 18330, 18365, 15318, 14530, 18459, 18723, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 10763, 8219, 8219, 18485, 8085, 13605, 11833, 8150, 18505, 18520, 18533, 18549, 9555, 18565, 18598, 8912,
  18618, 8543, 13634, 18636, 18664, 18680, 20947, 19688, 18696, 18739, 8219, 8219, 18769, 18782, 18798, 16099, 19218,
  14323, 8219, 12880, 15951, 11541, 14601, 20663, 11923, 20700, 8219, 18815, 20737, 11882, 21872, 8219, 23264, 17615,
  12401, 18421, 22635, 14601, 14101, 18854, 15348, 8219, 8219, 10437, 22914, 18887, 9287, 12401, 15319, 13120, 14601,
  11926, 8515, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 18912, 8219, 22911, 18931, 12401, 18955, 20587,
  18973, 17576, 15031, 18990, 9353, 12781, 16836, 13786, 17997, 14601, 23243, 22180, 19973, 19010, 9440, 19037, 20562,
  15318, 14530, 14534, 21771, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085, 8219, 19065, 19253, 19090, 11152,
  19132, 19147, 9555, 8219, 8665, 8347, 8219, 11613, 8219, 9705, 23120, 8667, 8219, 13791, 20240, 14602, 10842, 19163,
  16237, 13758, 19180, 16099, 19217, 15594, 19235, 15011, 21108, 18080, 19715, 9307, 13527, 8219, 9621, 22151, 17291,
  16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 16817, 21964, 19252, 8219, 19269, 19286, 22914, 19270,
  16971, 12401, 15319, 14239, 14601, 11926, 19315, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 8219,
  22911, 13790, 12401, 17833, 12779, 8219, 19334, 21918, 21518, 17830, 19354, 16836, 13786, 17997, 14601, 19362, 19467,
  14384, 15319, 17362, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 8085,
  8219, 8219, 19253, 10783, 8219, 10295, 10812, 9555, 8219, 8219, 8347, 8219, 19378, 17503, 19397, 21374, 17458, 17509,
  19437, 18939, 17557, 19807, 8219, 16237, 8219, 8219, 16099, 19218, 15594, 8219, 12880, 12401, 20874, 14601, 14601,
  11923, 8219, 8219, 8219, 8219, 16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 8219, 8219,
  8219, 10437, 22914, 19270, 12401, 12401, 15319, 14601, 14601, 11926, 8219, 8219, 10436, 17236, 13792, 12401, 15320,
  14601, 12781, 8219, 8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786,
  19464, 13463, 19362, 19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  10763, 8219, 8219, 13700, 19483, 13704, 9872, 19507, 19523, 19538, 19549, 19565, 9555, 8219, 11504, 8460, 19581, 8219,
  11688, 11031, 19616, 19651, 19676, 13791, 19704, 18258, 8219, 8219, 10891, 10903, 8219, 16099, 19731, 19768, 19792,
  19829, 19849, 16272, 17650, 19884, 19904, 8219, 19924, 9815, 8219, 16100, 12317, 11214, 23285, 12759, 12401, 20029,
  17930, 14601, 18433, 8219, 20690, 22138, 19940, 19989, 20045, 20061, 12401, 20086, 20097, 22352, 20121, 20141, 8219,
  20166, 10436, 20197, 20221, 18314, 16327, 13469, 21728, 9833, 20256, 22911, 13790, 15791, 17833, 12428, 14838, 16836,
  16606, 12401, 16578, 12781, 20277, 13786, 17997, 14601, 19362, 19467, 13079, 16128, 11372, 16473, 21946, 15318, 14530,
  20301, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 11872, 20327, 10253, 20352, 20388, 20404, 20419, 20433, 20449,
  20465, 8219, 8219, 20481, 15596, 8219, 20174, 20507, 17447, 22157, 20181, 20542, 13164, 20583, 12075, 21220, 16237,
  8219, 16927, 20603, 14579, 13752, 17203, 20619, 14354, 20874, 20649, 14601, 11923, 20679, 20724, 12809, 8219, 16100,
  19218, 18799, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 21820, 20773, 17288, 10437, 20793, 20828, 12401,
  17369, 20844, 14601, 21998, 13500, 8219, 8219, 23489, 17979, 20869, 15862, 15320, 11757, 12781, 19752, 20890, 22911,
  13790, 20909, 14211, 20936, 8219, 11020, 20963, 17865, 22382, 12781, 20997, 21017, 15196, 20105, 21052, 20556, 21093,
  21128, 11372, 18349, 17322, 9516, 21177, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 12557, 8085, 8219,
  9574, 9250, 21205, 21244, 21258, 21274, 9555, 21290, 8202, 8347, 11596, 21325, 21383, 21362, 21399, 21300, 21415,
  21428, 14088, 21444, 8219, 15355, 17406, 8219, 17292, 21489, 17435, 17756, 22433, 21511, 14469, 17870, 20125, 17899,
  21956, 21534, 20804, 12152, 8219, 21572, 21588, 21616, 15275, 21647, 21632, 21693, 21709, 21744, 21787, 23319, 21807,
  22443, 21842, 21867, 15585, 9772, 12401, 12401, 21888, 14601, 12980, 12036, 17719, 11513, 21905, 22039, 19954, 21934,
  20920, 21984, 20567, 22014, 22538, 22030, 22055, 22071, 22090, 16996, 22125, 16836, 15031, 22173, 22196, 11428, 19908,
  22234, 21067, 15702, 18753, 22260, 22295, 15319, 11372, 17906, 20562, 22343, 22368, 14534, 9427, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 10763, 8219, 8219, 9269, 8085, 8219, 8408, 19253, 22418, 22467, 22480, 22496, 9555, 12485, 8219, 8347, 8219,
  8219, 8219, 9705, 17237, 22512, 8219, 13791, 20240, 14602, 22451, 8219, 16237, 8219, 22533, 16099, 19218, 15594, 8219,
  12880, 12401, 23159, 14601, 14601, 22554, 16494, 22590, 8219, 8219, 16100, 15576, 8219, 22609, 16264, 15136, 14359,
  21153, 21142, 12779, 18871, 8219, 8219, 20261, 20285, 22914, 19270, 9449, 12401, 15319, 22633, 14601, 12146, 9824,
  8219, 10436, 12299, 13792, 12401, 15320, 14601, 18032, 8219, 8219, 22911, 21473, 12401, 22651, 12779, 10357, 16836,
  15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362, 22671, 11902, 15319, 11372, 17906, 20562, 22244, 14530,
  16547, 22687, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 10747, 8085, 8219, 8219, 8301, 22724, 22764, 11447, 22783,
  9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 18896, 9964, 14602, 8219, 8219, 16237, 8219, 8219,
  22799, 16755, 15594, 17468, 22862, 23152, 20874, 22890, 14601, 11923, 8219, 8219, 8219, 8219, 22906, 22930, 8219,
  23264, 22074, 12401, 14359, 17055, 14601, 12779, 8219, 8219, 8219, 8219, 10437, 22914, 19270, 12401, 12401, 15319,
  14601, 14601, 11926, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219, 22949, 22911, 13790, 12401,
  17833, 12779, 11208, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 9338, 19467, 11902, 15319, 11372,
  17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219, 22968, 8219, 8219, 9852,
  22989, 23004, 23018, 23034, 9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 14602,
  8219, 8219, 16237, 8219, 12172, 16099, 19218, 15594, 8219, 12880, 12401, 20874, 14601, 14601, 11923, 8219, 8219, 8219,
  8219, 16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 8219, 8219, 8219, 10437, 22914,
  19270, 12401, 12401, 15319, 14601, 14601, 11926, 8219, 8219, 10436, 15834, 13792, 23050, 23070, 22273, 23235, 8219,
  8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362,
  19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 10763, 8219, 8219, 8219,
  8085, 8219, 8219, 19253, 10783, 8219, 11780, 23092, 9555, 8219, 8219, 22846, 11468, 8219, 11679, 23108, 17237, 11669,
  11685, 23141, 11950, 14602, 8219, 8219, 23175, 18620, 23203, 16099, 19218, 15594, 8219, 12880, 12401, 23222, 14601,
  22279, 21455, 8219, 8219, 8219, 8219, 16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 8219,
  8219, 8219, 10437, 22914, 19270, 12401, 12401, 15319, 14601, 14601, 11926, 8219, 8219, 10436, 17236, 13792, 12401,
  15320, 14601, 12781, 8219, 8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836,
  13786, 17997, 14601, 19362, 19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 10763, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 10783, 8219, 10295, 10812, 9555, 23259, 8219, 8347, 8219,
  8219, 8219, 9705, 17237, 8219, 8219, 13791, 12365, 14021, 8219, 8219, 16237, 8219, 8219, 16099, 19218, 15594, 22767,
  12880, 12401, 20874, 14601, 14601, 11923, 23280, 8219, 8219, 8219, 16100, 19218, 8219, 23264, 12401, 12401, 14359,
  14601, 14601, 12779, 9592, 8219, 8219, 8219, 11288, 22914, 19270, 23054, 12401, 15319, 16466, 14601, 11926, 8219,
  8219, 10436, 17236, 13792, 12401, 18342, 14601, 18187, 8219, 19776, 22911, 13790, 12401, 17833, 14042, 8219, 16836,
  15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362, 19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530,
  14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 23301, 10580, 23335, 10589, 23383, 23313, 20205, 23419,
  8138, 8219, 8219, 8347, 8219, 23455, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 16237, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219, 19253, 23476, 23505, 23518, 23206, 8138, 8219, 8219, 8347, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 12918, 8219, 14987, 8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219,
  8219, 8085, 8219, 8219, 10041, 23534, 23549, 23552, 20777, 8138, 8219, 8219, 8347, 8219, 23568, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 16237, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 12918, 8219, 14987,
  8219, 12921, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8065, 8219, 8219, 8219, 8085, 8219, 8219,
  19253, 8373, 8219, 8219, 8219, 9555, 8219, 8219, 8347, 8219, 8219, 8219, 9705, 17237, 8219, 8219, 13791, 20240, 14602,
  8219, 8219, 16237, 8219, 8219, 16099, 19218, 15594, 8219, 13793, 12401, 12837, 14601, 14601, 11923, 8219, 8219, 8219,
  8219, 16100, 19218, 8219, 23264, 12401, 12401, 14359, 14601, 14601, 12779, 8219, 8219, 8219, 8219, 10437, 22914,
  19270, 12401, 12401, 15319, 14601, 14601, 11926, 8219, 8219, 10436, 17236, 13792, 12401, 15320, 14601, 12781, 8219,
  8219, 22911, 13790, 12401, 17833, 12779, 8219, 16836, 15031, 12401, 17830, 12781, 16836, 13786, 17997, 14601, 19362,
  19467, 11902, 15319, 11372, 17906, 20562, 15318, 14530, 14534, 10823, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 22973, 8219, 21556, 23589, 23591, 20708, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219,
  8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 8219, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 45256, 45256, 45256, 45256,
  0, 47305, 47305, 45256, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305,
  47305, 47305, 47305, 22528, 45256, 45256, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305,
  47305, 47305, 47305, 0, 45256, 24576, 47305, 47305, 47305, 47305, 47305, 20480, 47305, 47305, 47305, 47305, 47305,
  47305, 47305, 47305, 47305, 248, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305, 47305,
  1, 2, 30723, 0, 0, 0, 0, 45256, 47305, 0, 203, 204, 0, 0, 0, 0, 0, 0, 0, 575948, 67584, 575948, 0, 67584, 0, 0, 0, 0,
  0, 0, 206, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1242, 0, 0, 0, 0, 0, 0, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  226, 0, 0, 0, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 211, 212, 0, 24576, 0, 0, 0, 0, 0, 20480, 0, 289,
  289, 289, 0, 289, 0, 0, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 1, 2,
  30723, 0, 0, 0, 0, 0, 0, 0, 203, 204, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 232, 0, 0, 0, 22528, 645, 645, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69632, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55296, 0, 203, 0, 204, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 448, 449, 450, 0, 55296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 213, 0, 0, 0, 248, 203,
  203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 575948, 0, 0, 0, 0, 24576, 0, 203, 203, 0, 203, 20480, 0, 0, 0, 0, 0, 0, 0, 203,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 22528, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 0, 12708, 204, 0, 0, 0, 0, 0, 0,
  244, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 79872, 79872,
  551105, 2, 30723, 0, 197, 0, 0, 0, 0, 197, 0, 0, 0, 0, 0, 0, 0, 248, 248, 248, 0, 0, 0, 0, 0, 0, 0, 226, 270, 0, 0, 0,
  226, 0, 0, 22528, 24576, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1094, 0, 0, 1096, 0, 0, 551105, 2, 30723,
  0, 0, 0, 0, 0, 0, 0, 203, 204, 0, 0, 0, 0, 0, 0, 261, 0, 0, 0, 0, 0, 0, 0, 0, 0, 979, 0, 0, 0, 0, 0, 0, 0, 0, 482, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 228, 0, 0, 0, 0, 248, 0, 0, 59392, 59392, 59392, 59392, 0, 0, 0, 0, 0, 0, 0,
  248, 248, 248, 0, 0, 0, 0, 464, 0, 0, 0, 0, 59392, 0, 59392, 0, 59392, 59392, 59392, 59392, 59392, 59392, 0, 0, 59392,
  0, 0, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1243, 0, 0,
  0, 0, 0, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 0, 421, 422, 0, 0, 0, 0, 0, 0, 425, 486, 0, 0, 0, 0, 0, 493, 299008, 0, 1, 2,
  30723, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 204, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 229, 0, 0, 0,
  248, 204, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61718, 0, 204, 204, 0, 204, 20480, 0, 0,
  0, 0, 0, 0, 0, 204, 0, 0, 0, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 0, 0, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 0,
  203, 12711, 0, 0, 0, 0, 0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202,
  202, 0, 202, 202, 202, 202, 63690, 63740, 63740, 63740, 63740, 63740, 63690, 63690, 63690, 0, 0, 202, 63690, 202, 202,
  202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 22528, 24576, 202, 63740, 63740, 202, 63740,
  20480, 202, 63690, 63690, 63690, 202, 63690, 202, 202, 202, 249, 202, 202, 202, 202, 202, 202, 63690, 63690, 252, 202,
  202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 63690, 202, 202, 202, 202, 202, 202, 202, 202, 202,
  202, 202, 202, 63690, 202, 63690, 202, 202, 63690, 202, 63690, 202, 63690, 63690, 63690, 202, 63690, 63690, 0, 0, 0,
  0, 0, 1349, 0, 1351, 0, 0, 405504, 0, 0, 1356, 0, 0, 0, 0, 0, 1362, 0, 0, 0, 0, 0, 0, 0, 1368, 1369, 0, 0, 0, 0, 0,
  69632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 0, 0, 0, 248, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 69632, 69632, 0,
  69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 0, 24576, 0, 0,
  0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 69632, 69632, 0, 2, 30723, 0, 57344, 0, 0, 0, 0, 0, 203, 204, 0, 0, 0, 0, 0, 0,
  458, 248, 248, 248, 0, 0, 0, 0, 0, 0, 0, 713, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1105, 0, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0,
  20480, 0, 71680, 71680, 71680, 0, 71680, 0, 0, 0, 0, 0, 0, 104732, 0, 104739, 104739, 104739, 0, 104739, 0, 0, 104739,
  0, 0, 71680, 0, 0, 0, 0, 0, 0, 0, 0, 71680, 0, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 71680,
  71680, 73728, 73728, 71680, 0, 0, 0, 35211, 0, 0, 0, 0, 71680, 35211, 35211, 35211, 35211, 35211, 35211, 71680, 71680,
  35211, 24576, 0, 0, 0, 0, 0, 20480, 0, 75776, 75776, 75776, 0, 75776, 0, 0, 0, 0, 0, 0, 237568, 0, 0, 0, 0, 0, 0, 0,
  0, 43383, 43383, 43383, 44403, 43383, 43383, 43383, 43383, 43383, 0, 0, 75776, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 0,
  75776, 75776, 75776, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 79872, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 0, 0, 0,
  79872, 22528, 24576, 0, 0, 0, 0, 0, 20480, 0, 79872, 79872, 79872, 0, 79872, 0, 0, 79872, 79872, 79872, 79872, 79872,
  79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 0, 0, 1, 2, 195, 0, 0, 198, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 218, 265, 0, 0, 218, 0, 24576, 0, 0, 0, 0, 0, 20480, 0, 81920, 81920, 81920, 0, 81920, 0, 0, 0, 0,
  0, 0, 323584, 0, 0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 42232, 41267, 41267, 41267, 41267, 41267, 0, 0, 81920, 0,
  0, 0, 0, 0, 0, 0, 0, 81920, 0, 81920, 81920, 81920, 1, 2, 0, 39108, 0, 419, 0, 0, 0, 0, 203, 204, 0, 0, 0, 0, 0, 0,
  472, 0, 474, 0, 0, 0, 0, 0, 0, 0, 0, 8679, 6426, 0, 0, 0, 0, 0, 0, 0, 0, 664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  242, 0, 22528, 0, 693, 694, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243, 0, 0, 43383, 44308, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44180, 43404, 43404, 43404, 44334,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43877, 43404, 43383,
  44531, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44540, 43404, 0, 0, 0,
  1547, 0, 1548, 0, 1513, 0, 41267, 41267, 0, 0, 0, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 44498,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43872, 43404, 43404, 43875, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 44543, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 1074, 0,
  0, 0, 44573, 43404, 44574, 43404, 43404, 43404, 43404, 0, 0, 0, 0, 0, 0, 1513, 0, 43383, 43383, 43383, 44645, 44646,
  43383, 43383, 43383, 43404, 43404, 43404, 44651, 44652, 43404, 43404, 43383, 43383, 43404, 43404, 44681, 44682, 43383,
  43404, 43383, 43404, 43383, 43404, 0, 0, 0, 0, 1513, 0, 43383, 44606, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 44174, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44189, 44190, 43383, 43383, 43383, 44194, 43383,
  43383, 44585, 43383, 43383, 43383, 43383, 44590, 43383, 43383, 43404, 44594, 43404, 43404, 43404, 43404, 44599, 43404,
  0, 0, 0, 1596, 1513, 0, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44613, 44614, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 0, 0, 0, 43383, 43383, 43383, 43383, 43383, 44647, 43383, 43383, 43404, 43404,
  43404, 43404, 43404, 44653, 43404, 24576, 0, 281, 281, 0, 281, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1258, 0, 0, 0, 0,
  0, 1, 2, 30723, 39108, 0, 0, 0, 0, 0, 0, 203, 204, 0, 0, 0, 0, 0, 0, 498, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0,
  0, 0, 0, 205, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206848, 24576, 0, 0, 0, 0, 0, 20480, 0, 90402, 90402,
  90402, 0, 90402, 0, 0, 0, 0, 0, 0, 372736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 701, 0, 0, 0, 0, 0, 0, 0, 90402, 0, 0, 90402,
  90402, 90402, 90402, 90402, 90402, 90402, 0, 0, 90402, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90402, 0, 0, 205, 0, 0, 0,
  0, 0, 90402, 90402, 90402, 90402, 90402, 90402, 90402, 0, 0, 0, 0, 0, 348160, 0, 0, 0, 0, 0, 1244, 0, 0, 0, 0, 0, 0,
  727, 0, 0, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41709,
  41267, 0, 92160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399360, 24576, 0, 6426, 6426, 0, 6426, 20480, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1365, 0, 0, 0, 0, 0, 0, 707, 0, 0, 0, 0, 8679, 10953, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1153, 0, 0, 0,
  0, 0, 43383, 0, 0, 707, 935, 0, 0, 0, 0, 10953, 0, 0, 0, 0, 0, 0, 0, 0, 1364, 0, 0, 0, 0, 0, 0, 0, 0, 898, 0, 0, 0, 0,
  0, 0, 0, 0, 926, 0, 0, 0, 0, 0, 0, 0, 0, 1241, 0, 0, 0, 0, 0, 0, 0, 0, 1352, 0, 0, 1354, 0, 0, 0, 0, 0, 882, 1076, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 0, 22528, 43404, 1074, 0, 1076, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,
  0, 0, 0, 0, 0, 250, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 434, 0, 0, 258048, 0, 207, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 255, 0, 0, 0, 0, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 67584, 203,
  204, 0, 98304, 0, 0, 0, 0, 0, 1390, 0, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 0, 43404,
  43404, 43404, 43404, 43625, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 604, 605, 605, 605, 605, 605, 605, 605,
  0, 0, 0, 0, 0, 0, 1513, 0, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 605,
  605, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 0, 605, 605, 605, 605, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 277, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 0, 0, 0, 0, 0, 0, 0, 564, 564, 564, 564, 605,
  605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 0, 564, 564, 564, 564, 564, 564, 564, 564,
  564, 564, 564, 605, 605, 605, 605, 605, 605, 605, 605, 605, 0, 0, 0, 564, 564, 564, 564, 605, 0, 0, 0, 0, 1513, 0,
  564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 0, 0, 605, 605, 605, 0, 564, 564, 564, 564, 564, 564, 564, 564,
  605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 0, 564, 564, 564, 564, 564, 564, 605, 605, 605, 605, 605, 605, 564,
  564, 564, 564, 605, 605, 605, 605, 564, 564, 605, 605, 564, 605, 564, 605, 564, 605, 564, 605, 0, 0, 0, 0, 0, 0, 0,
  1513, 0, 0, 0, 0, 0, 0, 564, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 0, 0, 0, 24576, 0, 0,
  0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 102400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 251, 0, 102400,
  102400, 0, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400,
  102400, 0, 0, 0, 0, 49152, 0, 0, 0, 14336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 0, 0, 0, 43383, 43383, 104739, 104739,
  104739, 104739, 104739, 104739, 104739, 104739, 104739, 104739, 104739, 104739, 104739, 104739, 104739, 104739, 0, 0,
  0, 0, 110592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 30723, 0, 0, 0, 116736, 0, 0, 0, 116736, 0, 0, 0, 0, 0,
  0, 0, 1442, 0, 0, 0, 0, 0, 0, 0, 0, 670, 0, 0, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 20480, 0, 116736, 116736, 116736,
  0, 116736, 0, 0, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736,
  116736, 116736, 116736, 116736, 0, 0, 1, 2, 30723, 0, 0, 0, 0, 0, 0, 0, 203, 204, 0, 0, 100352, 0, 0, 0, 0, 0, 395264,
  0, 0, 0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 53248, 0, 112640,
  120832, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491, 0, 0, 0, 0, 112640, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206, 0,
  1, 2, 30723, 0, 0, 0, 0, 118784, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119076, 119076, 119076, 0, 118784, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209, 208, 24576, 0, 0, 0, 0, 0, 20480, 0, 119076, 119076, 119076, 0, 119076, 0,
  0, 119076, 119076, 119076, 119076, 119076, 119076, 119076, 119076, 119076, 119076, 119076, 119076, 119076, 119076,
  119076, 119076, 0, 0, 1, 0, 30723, 0, 0, 0, 126976, 0, 0, 0, 203, 204, 94208, 0, 0, 0, 0, 0, 0, 423936, 0, 423936, 0,
  0, 0, 423936, 0, 0, 0, 423936, 423936, 0, 0, 0, 0, 0, 423936, 424212, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 564, 564, 564, 564, 564, 0, 0, 83968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 289, 289, 289, 1, 553154, 30723, 0,
  0, 0, 0, 0, 199, 0, 0, 0, 199, 0, 0, 0, 0, 0, 219, 220, 221, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1353, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 0, 0, 124928, 124928, 0, 0, 0, 1, 553154, 30723, 0, 0,
  0, 0, 0, 0, 0, 203, 204, 0, 0, 0, 0, 0, 0, 547, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106496, 0, 0, 0, 0, 0, 114688, 114688,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 245, 1, 2, 30723, 39108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 704, 0, 0,
  0, 24576, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 41267, 0, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 764, 0, 0, 43383,
  43404, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43383, 43383, 43404, 43404, 43383,
  43404, 43383, 43404, 43383, 43404, 43383, 43404, 0, 0, 0, 0, 1076, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 660, 0, 0,
  0, 0, 0, 0, 1449, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 41915, 41267, 41267, 0, 0, 0, 935, 0, 0,
  0, 0, 0, 0, 0, 938, 0, 0, 0, 0, 0, 0, 684, 685, 0, 687, 248, 248, 0, 0, 0, 0, 0, 0, 698, 0, 700, 0, 0, 0, 0, 0, 0,
  706, 24576, 0, 0, 0, 0, 0, 20480, 0, 131072, 131072, 131072, 0, 131072, 0, 0, 0, 0, 0, 224, 0, 0, 0, 0, 0, 0, 0, 0,
  224, 256, 0, 131072, 0, 0, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 131072, 24576, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 133120, 0, 133120, 133120, 133120,
  133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 0, 0, 0, 0, 0, 248, 0, 0, 0,
  0, 0, 0, 209, 0, 0, 0, 0, 0, 0, 0, 1451, 1452, 0, 174080, 0, 0, 41267, 41267, 41267, 41267, 41267, 41267, 41267,
  41267, 41267, 41267, 41267, 315912, 41267, 41267, 0, 208, 0, 209, 0, 208, 208, 209, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1257,
  0, 0, 0, 0, 1261, 0, 0, 0, 208, 208, 209, 209, 0, 0, 0, 0, 272, 0, 0, 0, 0, 22528, 24576, 0, 0, 0, 0, 0, 20480, 0,
  293, 293, 293, 41268, 293, 41268, 41268, 326, 326, 293, 326, 326, 326, 326, 326, 326, 326, 326, 351, 362, 351, 351,
  351, 351, 351, 351, 351, 351, 351, 351, 41268, 326, 326, 351, 43384, 43384, 43384, 43405, 43384, 43384, 43384, 43384,
  43384, 43405, 43405, 43405, 43405, 43405, 43405, 43384, 43384, 43405, 0, 424, 0, 0, 426, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 358, 363, 358, 358, 0, 0, 0, 0, 455, 0, 0, 0, 248, 248, 248, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 22528,
  0, 0, 483, 0, 0, 0, 424, 0, 0, 0, 0, 0, 0, 492, 0, 0, 0, 0, 0, 1441, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 980, 0, 0, 0,
  241664, 0, 0, 0, 41267, 41267, 41468, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41481, 41267,
  41267, 0, 661, 755, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 776, 0, 0, 0, 0, 41483, 41267, 41267, 41267, 0, 0, 426, 0, 0, 0,
  0, 0, 0, 539, 0, 0, 0, 0, 0, 1450, 0, 0, 0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 41267, 207155, 41267,
  41267, 41267, 41267, 0, 496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 426, 554, 0, 0, 554, 479, 554, 43383, 43383,
  43576, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44039, 43383, 35644, 43404, 43404, 43404, 43404,
  43383, 43383, 43595, 43383, 43598, 43383, 43383, 43608, 43383, 43383, 0, 43404, 43404, 43617, 43404, 43404, 43383,
  44679, 43404, 44680, 43383, 43404, 43383, 43404, 43383, 43404, 43383, 43404, 0, 0, 0, 0, 1513, 0, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 0, 43404, 43404, 43404, 43404, 43624, 0, 0, 762, 43788, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 395639, 43404, 43404, 43383, 43825,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 35644, 43788, 43404, 43404, 43404, 43404, 43404, 43404,
  44512, 43404, 43404, 0, 0, 1507, 0, 0, 0, 0, 0, 0, 49152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 0, 0, 0, 43400, 43400,
  0, 0, 0, 0, 894, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 477, 0, 0, 0, 0, 0, 0, 920, 0, 0, 0, 0, 0, 0, 927, 0, 0, 0, 0, 0, 0,
  0, 433, 0, 433, 0, 0, 0, 0, 0, 0, 0, 443, 444, 0, 0, 0, 0, 0, 0, 0, 0, 256000, 0, 0, 374784, 0, 0, 0, 0, 0, 0, 0, 986,
  0, 988, 0, 0, 991, 0, 0, 43788, 43383, 43383, 43383, 43383, 43383, 43383, 43831, 43383, 43383, 43383, 43383, 35644,
  43788, 43404, 43404, 43404, 43404, 43404, 43404, 44074, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 1074, 0,
  0, 0, 0, 0, 224, 0, 0, 0, 0, 224, 0, 0, 0, 0, 22528, 0, 0, 1076, 0, 0, 0, 0, 0, 0, 1080, 0, 0, 0, 0, 0, 0, 0, 473, 0,
  0, 0, 0, 0, 0, 480, 149504, 1098, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 1112, 0, 0, 0, 0, 935, 0, 0, 0,
  0, 0, 0, 0, 1122, 1123, 0, 1125, 0, 0, 0, 41267, 42088, 42089, 42090, 41267, 41267, 41267, 41267, 42094, 41267, 41267,
  0, 0, 0, 0, 0, 0, 0, 759, 0, 0, 0, 0, 0, 0, 0, 477, 0, 499, 0, 0, 0, 0, 0, 0, 0, 499, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 315392, 503, 0, 43383, 43383, 44169, 43383, 44170, 43383, 44172, 44173, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 44485, 43383, 43383, 43383, 43383, 43383, 43383, 44182, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44316, 44207, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 44216, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44337, 283020,
  43404, 43404, 43404, 43404, 43404, 44341, 43404, 1074, 0, 1076, 0, 0, 1227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 0, 0,
  0, 43402, 43402, 44317, 43383, 43383, 43383, 43383, 44321, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 44431, 43404, 43404, 44343, 43404, 43404, 43404, 43404, 44347, 43404,
  0, 0, 0, 0, 0, 1344, 0, 0, 0, 0, 230, 232, 260, 0, 0, 0, 0, 0, 0, 0, 0, 0, 488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1348, 0, 0, 0, 0, 0, 0, 0, 1355, 0, 0, 0, 0, 0, 235, 236, 237, 238, 239, 0, 0, 0, 0, 0, 0, 0, 949, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 43404, 43404, 44433, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  0, 0, 0, 0, 0, 0, 1513, 0, 43383, 43404, 43404, 43404, 43404, 44509, 43404, 43404, 43404, 43404, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 275, 43404, 1594, 0, 1595, 0, 1513, 0, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 0, 43404, 43404, 43404, 43404, 43626, 24576, 279, 0, 0, 279, 0, 20480, 0, 0, 0, 0, 41267, 0, 41267,
  41267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 762, 0, 0, 766, 0, 0, 0, 279, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 675, 0, 0,
  44031, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 35644, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 44078, 43404, 43404, 43404, 0, 0, 0, 0, 0, 0, 1228, 0, 0, 0, 0, 0, 1234, 0, 0, 44072, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 1074, 0, 0, 0, 0, 0, 457, 0, 248, 248, 248, 0, 0, 0, 0, 0,
  0, 0, 654, 0, 656, 0, 0, 0, 0, 0, 0, 0, 699, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8679, 0, 0, 0, 0, 0, 0, 0, 1264, 0, 0, 0, 0,
  41267, 42229, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41924, 41267, 41267, 41267, 41267, 41267, 41267,
  41267, 44629, 44630, 43383, 44632, 43383, 43404, 43404, 43404, 43404, 44637, 44638, 43404, 44640, 43404, 0, 0, 0, 0,
  1226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 928, 0, 0, 0, 0, 0, 214, 215, 216, 217, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 719,
  0, 0, 0, 0, 214, 0, 0, 0, 0, 0, 0, 0, 214, 0, 214, 0, 0, 214, 22528, 24576, 280, 0, 0, 280, 0, 20480, 213, 294, 294,
  294, 41269, 294, 41269, 41269, 327, 327, 338, 327, 327, 327, 327, 327, 327, 327, 327, 352, 327, 352, 352, 365, 368,
  365, 368, 365, 365, 365, 365, 365, 365, 365, 41269, 352, 352, 365, 43385, 43385, 43406, 43385, 43385, 43385, 43385,
  43385, 43406, 43406, 43406, 43406, 43406, 43406, 43385, 43385, 43406, 461, 0, 0, 461, 0, 0, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 0, 43404, 43404, 43404, 43404, 43623, 0, 0, 723, 0, 0, 0, 0, 0, 0,
  41267, 41689, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 1284, 0, 0, 41267, 41697, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41930, 41267, 0, 0, 770, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 940, 0, 0, 0, 723, 0, 43788, 43789, 43790, 43383, 43383, 43383, 43383, 43797, 43383,
  43800, 43383, 43383, 43383, 43383, 43383, 43606, 43383, 43383, 43383, 43383, 0, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 44064, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 1342, 0, 0, 0, 0, 43805,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43823,
  43404, 43404, 43404, 43845, 43404, 43848, 43404, 43404, 43404, 43853, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 44440, 43404, 0, 0, 0, 0, 0, 0, 0, 1513, 0, 188723, 41267, 188416, 0, 0, 43383, 0, 0, 0, 935, 0, 0, 0,
  0, 0, 0, 0, 0, 939, 0, 0, 0, 0, 0, 471, 0, 0, 0, 0, 0, 0, 0, 479, 0, 0, 0, 973, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 436, 0, 0, 0, 1100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 983, 0, 0, 1263, 0, 0, 0, 0, 0, 41267, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 41267, 42096, 0, 1372, 0, 41267, 41267, 41267, 41267, 41267, 41267, 42339,
  41267, 41267, 41267, 42343, 0, 0, 0, 0, 0, 1574, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 241, 242, 0, 0, 0, 0, 1387, 0, 0,
  0, 0, 1391, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 35644, 43788, 43837, 43838,
  43404, 0, 0, 0, 1440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 930, 0, 0, 0, 41267, 41267, 41267, 42417, 41267, 41267,
  41267, 0, 0, 0, 0, 0, 0, 0, 0, 43383, 43383, 43383, 43383, 43383, 43383, 44405, 43383, 43383, 24576, 218, 0, 0, 218,
  0, 20480, 285, 295, 295, 295, 41270, 295, 41270, 41270, 328, 328, 339, 328, 328, 328, 328, 328, 328, 328, 328, 353,
  328, 353, 353, 353, 353, 353, 353, 353, 353, 353, 353, 41270, 353, 353, 353, 43386, 43386, 43386, 43407, 43386, 43386,
  43386, 43386, 43386, 43407, 43407, 43407, 43407, 43407, 43407, 43386, 43386, 43407, 0, 0, 41267, 41267, 41267, 41267,
  41267, 41267, 41267, 41476, 41267, 41267, 41267, 41267, 41267, 41267, 41922, 41267, 41267, 41267, 41267, 41267, 41928,
  41267, 41267, 41267, 0, 0, 500, 0, 0, 0, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43587, 43383, 43383, 43383,
  43383, 43383, 44171, 43383, 43383, 43383, 44175, 43383, 44177, 43383, 43383, 43383, 43383, 43383, 43383, 44187, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44014, 43383, 43383, 43383, 43383, 43404, 43404,
  43628, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 0, 0, 0, 0, 0,
  212992, 0, 0, 0, 0, 668, 0, 0, 0, 672, 673, 0, 0, 0, 0, 0, 0, 924, 0, 0, 0, 0, 0, 0, 0, 0, 0, 716, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 43788, 141687, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 0, 0, 43404,
  43404, 43404, 289621, 43862, 43863, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 44221, 0, 0, 417792, 0, 0, 0, 0, 0, 0, 0, 0, 43788, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 356727, 43383, 43383, 0, 0, 1076, 0, 0, 0, 0, 0, 1079, 0, 0,
  0, 0, 0, 0, 0, 0, 1550, 0, 0, 0, 0, 0, 0, 0, 0, 1513, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43383, 43383, 43383, 166263,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44193, 43383, 43383, 43383, 43383,
  43383, 43383, 44197, 44198, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 166284, 43404, 43404, 43404, 43404,
  43404, 43404, 228865, 43404, 43404, 333315, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 389516,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43870, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43873, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 319488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 982, 0,
  0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 42338, 41267, 41267, 41267, 41267, 41267, 0, 1385, 44406, 43383,
  43383, 43383, 43383, 43383, 43383, 319863, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  44538, 43383, 43383, 43383, 43404, 43404, 43404, 319884, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 0, 0, 0, 0, 0, 0, 1513, 0, 44584, 395660, 0, 0, 0, 0, 0, 0, 0, 1513, 0, 41267, 41267, 0, 0, 0, 43383, 44644,
  43383, 43383, 43383, 43383, 43383, 43383, 43404, 44650, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44214,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43640, 43404, 43404, 43404, 43404, 43404, 0, 43404,
  43404, 44616, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 43383, 43383, 43383, 43383, 43383, 43383, 44010,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 0, 43404, 43615, 43404, 43404, 43404, 0, 0, 253,
  0, 254, 0, 0, 0, 0, 0, 219, 221, 253, 0, 0, 0, 0, 0, 496, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 433,
  0, 0, 0, 0, 219, 0, 253, 253, 268, 0, 0, 0, 0, 220, 0, 219, 221, 0, 220, 22528, 24576, 0, 0, 0, 0, 0, 20480, 0, 296,
  296, 296, 41271, 296, 41271, 41271, 329, 329, 296, 329, 329, 329, 344, 346, 329, 329, 344, 354, 329, 354, 354, 354,
  354, 354, 354, 354, 354, 354, 354, 41271, 370, 370, 354, 43387, 43387, 43387, 43408, 43387, 43387, 43387, 43387,
  43387, 43408, 43408, 43408, 43408, 43408, 43408, 43387, 43387, 43408, 0, 438, 0, 0, 0, 0, 0, 0, 0, 445, 0, 447, 0, 0,
  0, 451, 296960, 0, 41267, 41267, 41267, 41470, 41267, 41267, 246067, 41267, 276998, 41267, 297267, 41267, 41267,
  41482, 41484, 41267, 41267, 41267, 0, 0, 0, 532, 0, 0, 0, 277017, 0, 0, 0, 0, 0, 0, 935, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 296960, 0, 431, 0, 0, 546, 0, 0, 0, 0, 0, 546, 546, 549, 0, 0, 0, 0, 0, 18432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  208, 209, 0, 0, 0, 0, 532, 0, 0, 277032, 0, 0, 555, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 555,
  277032, 555, 43383, 43383, 43383, 43579, 43383, 43383, 246135, 43383, 277063, 43383, 43383, 43383, 43383, 43404,
  44496, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44503, 43404, 43404, 43404, 43404, 43865, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43876, 43404, 43404, 43404, 43404, 43404, 44544, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 44339, 43404, 43404, 43404, 297335, 43383, 43383, 43597, 43600,
  43603, 43383, 43383, 43383, 43383, 0, 43404, 43404, 43404, 43620, 43404, 0, 880, 0, 886, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1236, 43404, 246156, 43404, 277104, 43404, 297356, 43404, 43404, 43638, 43641, 43644, 43404, 43404, 43404, 43404, 0,
  0, 879, 0, 0, 0, 885, 0, 0, 0, 0, 0, 0, 0, 1512, 0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 42092, 41267,
  41267, 41267, 41267, 41267, 678, 0, 0, 681, 682, 0, 0, 0, 0, 0, 248, 248, 0, 0, 0, 691, 0, 0, 0, 695, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1259, 0, 0, 0, 678, 0, 0, 0, 0, 0, 488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 0, 0, 0, 0, 0, 0, 41711,
  41267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 0, 497, 0, 0, 0, 0, 0, 502, 0, 0, 387072, 0, 43404, 43881,
  43404, 43404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 888, 0, 159744, 905, 0, 907, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1260, 0,
  0, 918, 0, 0, 921, 0, 0, 0, 925, 0, 0, 0, 0, 0, 0, 932, 0, 0, 0, 0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  55570, 0, 0, 0, 935, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 941, 942, 0, 0, 945, 0, 0, 947, 0, 0, 41910, 160051, 41267, 41267,
  41267, 41267, 205107, 41267, 41267, 0, 754, 756, 757, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 702, 0, 0, 0, 0, 0, 41917, 41267,
  41267, 41919, 41920, 41921, 41267, 41267, 41267, 41267, 41267, 41927, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 972, 0, 0, 0, 204800, 0, 977,
  344064, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1443, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 987, 0, 0, 990, 0, 159744, 159744, 43788,
  44000, 44001, 43383, 160119, 43383, 44019, 43383, 44020, 43383, 305527, 44022, 44024, 43383, 43383, 43383, 43383,
  44029, 43383, 43383, 364919, 43383, 43383, 44032, 43383, 44034, 43383, 43383, 43383, 43383, 43383, 44040, 35644,
  44041, 44042, 43404, 160140, 43404, 44060, 43404, 44061, 43404, 305548, 44063, 44065, 43404, 43404, 43404, 43404,
  44070, 43404, 43404, 364940, 43404, 43404, 44073, 43404, 44075, 43404, 43404, 43404, 43404, 43404, 44081, 0, 1074, 0,
  0, 0, 0, 0, 541, 0, 0, 0, 0, 0, 541, 541, 0, 0, 0, 0, 0, 553, 554, 0, 0, 0, 0, 0, 560, 554, 0, 561, 0, 0, 1076, 0, 0,
  0, 0, 0, 0, 0, 0, 1082, 0, 0, 1085, 0, 0, 0, 0, 269, 0, 223, 0, 0, 0, 0, 223, 0, 0, 0, 22528, 0, 0, 0, 0, 354304, 0,
  0, 0, 0, 0, 0, 1107, 0, 0, 0, 1111, 0, 0, 0, 409600, 0, 0, 0, 0, 0, 0, 0, 0, 1156, 0, 0, 43383, 43383, 43383, 43383,
  43599, 43383, 43383, 43383, 43383, 43383, 0, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44546, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43647, 43404, 43404, 43404, 43404, 0, 43404, 43404,
  44209, 43404, 44211, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 1434, 0, 0, 0,
  43404, 44223, 44224, 43404, 43404, 43404, 44228, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 409996, 43404, 0,
  1545, 0, 0, 0, 0, 0, 1513, 0, 41267, 41267, 0, 0, 0, 43383, 43383, 43383, 43383, 43602, 43383, 43383, 43383, 43383,
  43383, 0, 43404, 43616, 43404, 43404, 43404, 43404, 43404, 44076, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 1075, 0,
  290816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1247, 0, 0, 0, 0, 456, 0, 0, 248, 248, 248, 0, 0, 0, 0, 0, 0, 0, 534,
  0, 534, 0, 0, 0, 0, 0, 0, 0, 535, 0, 535, 504, 0, 0, 0, 495, 0, 0, 1250, 0, 1252, 1253, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 658, 659, 0, 0, 0, 0, 0, 0, 0, 329728, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44306,
  43383, 43383, 366967, 43383, 44320, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 44429, 43404, 43404, 43404, 44332, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  291212, 44338, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44213, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 44069, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 366988, 43404,
  44346, 43404, 43404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1232, 0, 0, 0, 0, 1358, 0, 0, 0, 0, 0, 0, 180224, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1514, 0, 0, 0, 41267, 41267, 41267, 0, 0, 1373, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 42340,
  41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 767, 0, 1386, 0, 0, 0, 0, 0, 0, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 180599, 43383, 43383, 43383, 43383, 43809, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 35644, 43404, 43404, 43404, 43404, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  180620, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 1570, 0, 1572, 0, 0, 0, 1513, 0, 43383, 44432, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 0, 0, 0, 1513, 1575, 43383, 1446, 0, 360448, 1448, 0,
  0, 272384, 0, 0, 163840, 0, 264192, 0, 41267, 164147, 41267, 41267, 753, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 915,
  916, 0, 41267, 41267, 264499, 41267, 41267, 42419, 42420, 0, 0, 0, 194560, 1464, 0, 0, 1467, 43383, 43383, 43383,
  43383, 43810, 43383, 280951, 43383, 43383, 43383, 43383, 43383, 43819, 43820, 43383, 43383, 43383, 43383, 43404,
  43404, 43404, 43404, 43404, 43404, 44675, 43383, 43383, 43383, 44677, 43404, 43383, 43383, 164215, 43383, 43383,
  43383, 43383, 44483, 43383, 264567, 43383, 43383, 43383, 43383, 44489, 44491, 44492, 43383, 44494, 401783, 43404,
  43404, 43404, 164236, 43404, 43404, 43404, 43404, 44502, 43404, 264588, 43404, 0, 43383, 43383, 43383, 43383, 43383,
  43383, 43404, 43404, 43404, 43404, 43404, 43404, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 44508,
  44510, 44511, 43404, 44513, 401804, 0, 0, 0, 1508, 0, 0, 294912, 358400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284672, 397312, 0,
  41267, 41267, 41267, 41267, 41699, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 0, 0,
  0, 1145, 0, 151948, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 0, 43383, 43383, 44587, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 44596, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 44229, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 1506, 0, 0,
  0, 0, 0, 0, 0, 44643, 43383, 209271, 43383, 43383, 43383, 43383, 43383, 44649, 43404, 209292, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 44438, 43404, 43404, 43404, 0, 0, 0, 1436, 0, 43383, 43383, 43383, 350583, 43404, 44671,
  43404, 43404, 43404, 350604, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43383, 229751,
  334199, 43383, 43404, 229772, 24576, 0, 0, 283, 222, 283, 20480, 0, 0, 0, 0, 41272, 223, 41272, 41272, 330, 336, 340,
  336, 336, 336, 345, 336, 336, 336, 345, 330, 336, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 41272, 330, 330,
  330, 43388, 43388, 43388, 43409, 43388, 43388, 43388, 43388, 43388, 43409, 43409, 43409, 43409, 43409, 43409, 43388,
  43388, 43409, 43404, 43404, 254348, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 0, 0, 0, 0, 1437, 0, 0, 0, 43788, 43383, 43383, 43383, 43383, 43383, 43383, 43798, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43832, 43383, 43383, 43383, 35644, 43788, 43404, 43404, 43404, 43404, 43404, 43404, 43846, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44340, 43404, 0, 0, 974, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1444, 0, 0, 41267, 41267, 42237, 41267, 41267, 0, 0, 0, 0, 0, 1283, 0, 0, 0, 0, 0,
  0, 0, 6426, 6426, 6426, 6426, 6426, 6426, 0, 0, 6426, 43404, 44342, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 889, 0, 43404, 43404, 186743, 43383, 186764, 43404, 43383, 43404, 43383, 43404, 43383,
  43404, 43383, 43404, 0, 0, 0, 0, 1513, 0, 43383, 43383, 43383, 43383, 44609, 44610, 44611, 44612, 43383, 24576, 0, 0,
  0, 0, 0, 20480, 0, 297, 297, 297, 41273, 297, 41273, 41273, 297, 297, 297, 297, 297, 297, 297, 297, 297, 297, 297,
  297, 297, 297, 297, 297, 41273, 297, 297, 297, 43389, 43389, 43389, 43410, 43389, 43389, 43389, 43389, 43389, 43410,
  43410, 43410, 43410, 43410, 43410, 43389, 43389, 43410, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1513, 0, 0,
  984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43788, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43803,
  43383, 41267, 42097, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 43383, 0,
  0, 0, 0, 321536, 0, 370688, 0, 0, 0, 0, 210944, 0, 0, 0, 0, 0, 0, 948, 0, 41267, 41267, 41267, 41267, 41914, 41267,
  41267, 41267, 43383, 43383, 43383, 228853, 43383, 43383, 333303, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43404, 147852, 43383, 188791, 43383, 43383, 43383, 43383, 43383, 44566, 43383, 43383, 43383, 43404, 43404, 188812,
  43404, 43404, 43404, 43404, 43404, 44577, 43404, 0, 0, 0, 262144, 303104, 0, 1513, 0, 43383, 43404, 43404, 43404,
  44575, 43404, 43404, 43404, 0, 0, 0, 0, 0, 0, 1513, 0, 43383, 43383, 43383, 43383, 44021, 43383, 43383, 43383, 43383,
  43383, 44027, 43383, 43383, 43383, 43383, 43383, 43383, 43607, 43383, 43383, 43383, 0, 43404, 43614, 43404, 43404,
  43404, 334220, 43404, 43383, 43383, 43404, 43404, 43383, 43404, 43383, 43404, 43383, 43404, 43383, 43404, 0, 0, 0, 0,
  1513, 0, 43383, 43383, 44607, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 291191, 44312, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 346487, 43383, 43383, 362871, 43383, 43383, 43404, 43404, 452, 453, 0, 0, 0,
  0, 0, 248, 248, 248, 0, 0, 0, 0, 0, 0, 0, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 41267, 41267,
  41267, 41489, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 541, 0, 559, 0, 0, 0, 541, 0, 692, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 703, 0,
  0, 0, 0, 0, 0, 989, 0, 0, 162735, 943, 43788, 43383, 43383, 43383, 162787, 1249, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 564, 41267, 42476, 41267, 41267, 0, 0, 0, 0, 0, 1519, 0, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 0, 0, 0,
  0, 0, 0, 1091, 0, 0, 0, 0, 0, 0, 0, 0, 0, 671, 0, 0, 674, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 20480, 0, 298, 298, 298,
  41274, 298, 41274, 41274, 331, 331, 298, 331, 331, 331, 331, 331, 331, 331, 331, 355, 331, 298, 298, 298, 298, 298,
  298, 298, 298, 298, 298, 41274, 371, 371, 298, 43390, 43390, 43390, 43411, 43390, 43390, 43390, 43390, 43390, 43411,
  43411, 43411, 43411, 43411, 43411, 43390, 43390, 43411, 0, 0, 41267, 41267, 41267, 41471, 41267, 41267, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41707, 41267, 41267, 41267, 41267, 41486, 41267, 41267, 0, 0,
  0, 533, 0, 0, 0, 0, 0, 0, 542, 0, 0, 0, 0, 470, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 981, 0, 0, 0, 0, 0, 0, 498, 0, 0,
  542, 0, 0, 0, 0, 0, 542, 542, 0, 0, 0, 0, 0, 658, 0, 0, 714, 0, 0, 718, 0, 0, 0, 0, 0, 0, 42228, 41267, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 1461, 0, 1463, 0, 0, 1465, 0, 0, 43383, 498, 0, 0, 0, 0, 0, 0, 556, 0, 0, 0,
  556, 0, 0, 0, 0, 0, 0, 1102, 0, 0, 0, 0, 0, 0, 1109, 0, 0, 0, 0, 0, 724, 0, 0, 0, 728, 0, 41267, 41267, 41267, 41267,
  41267, 41267, 41267, 41923, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 389427, 41267, 41267, 41267, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 145408, 41267, 41267, 41267, 41698, 41267, 41267, 41267, 41267, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41710, 0, 769, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 661, 0, 0, 0, 0, 43788,
  43383, 43383, 43383, 43383, 43793, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43609, 43383, 0, 43404,
  43404, 43618, 43404, 43404, 43383, 43383, 43807, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43821, 43383, 43404, 43841, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43855, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 266636, 43404, 43404, 43404, 43404, 44549, 43404, 43404,
  43404, 0, 0, 0, 0, 922, 0, 0, 0, 0, 0, 0, 929, 0, 0, 0, 0, 0, 0, 1255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 475, 0, 0, 0, 0, 0,
  0, 0, 934, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 903, 0, 0, 1099, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1097,
  0, 43383, 44168, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 44419, 0, 0, 0, 1238, 0, 0, 0, 1240, 0, 0, 0, 0, 0, 1246, 0, 1248, 0, 0, 1265, 0, 0, 0, 41267, 41267, 41267,
  42231, 41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 413696, 0, 0, 0, 1285, 0, 0, 0, 0, 43383, 43383,
  43383, 43383, 43383, 43383, 44302, 43383, 43383, 43383, 43383, 43383, 43383, 44311, 282999, 43383, 43383, 43383,
  43383, 43383, 44315, 43383, 43383, 0, 1345, 0, 1347, 0, 0, 1350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 431, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 42334, 41267, 42336, 41267, 41267, 41267, 41267, 41267, 41267, 42342, 41267, 1384, 0, 0, 0, 0, 495, 0, 0, 0, 0,
  501, 0, 0, 0, 0, 0, 504, 0, 0, 1388, 0, 0, 0, 0, 43383, 44401, 43383, 43383, 44404, 43383, 43383, 43383, 43383, 43383,
  43383, 44411, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43818, 43383, 43383, 43383,
  43383, 43383, 43404, 44422, 43404, 43404, 44425, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44430, 43404,
  0, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43383, 44667, 43404, 43404,
  43404, 44434, 43404, 44436, 43404, 43404, 44439, 43404, 43404, 153600, 0, 0, 0, 0, 0, 0, 1363, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 575947, 575947, 0, 0, 0, 0, 41267, 42416, 41267, 41267, 41267, 41267, 41267, 0, 1462, 0, 0, 0, 0, 0, 0, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 254327, 43383, 43383, 43404, 43404, 44507, 43404, 43404, 43404, 43404,
  43404, 43404, 0, 0, 0, 0, 0, 1509, 0, 0, 0, 0, 646, 650, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 0, 0,
  1510, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 43404, 43404, 43404, 43404,
  44618, 44619, 44620, 44621, 43404, 0, 0, 0, 43383, 43383, 43383, 43383, 43383, 43383, 44591, 43383, 44593, 43404,
  43404, 43404, 43404, 43404, 43404, 44600, 0, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1110, 0, 24576, 0, 0, 0,
  0, 0, 20480, 286, 299, 299, 299, 41275, 299, 41275, 41275, 332, 332, 299, 332, 332, 332, 332, 332, 332, 332, 332, 356,
  332, 356, 356, 332, 356, 356, 356, 356, 356, 41275, 356, 356, 373, 43391, 43391, 43391, 43412, 43391, 43391, 43391,
  43391, 43391, 43412, 43412, 43412, 43412, 43412, 43412, 43391, 43391, 43412, 0, 0, 41267, 41267, 41267, 41267, 41472,
  41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 1279, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 248, 0, 0, 0,
  0, 0, 534, 0, 0, 0, 0, 43383, 43383, 43383, 43383, 43582, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44011,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43834, 43383, 35644, 43788, 43404, 43404, 43404, 0, 0,
  0, 0, 772, 657, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 667, 0, 0, 0, 0, 0, 0, 0, 0, 0, 677, 0, 0, 0, 43788, 43383,
  43383, 43383, 43383, 43383, 43794, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 44329, 43404, 43383, 43806, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43822, 43404, 43404, 43842, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43854, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 44622, 0, 0, 0, 43383, 43383, 201079, 43383, 43880, 43404, 43404, 43404, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1235, 0, 890, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 662, 44004, 44005, 43383,
  43383, 44008, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44016, 43383, 43383, 43383, 43383, 43383, 44480,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44490, 44045, 44046, 43404, 43404, 44049, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 44057, 43404, 43404, 43404, 43404, 43404, 208052, 219532, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 43383, 44627, 43383, 43383, 0, 0, 0, 0, 1089, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 901, 0, 0, 0, 0, 0, 0, 1148, 0, 0, 0, 0, 0, 0, 0, 1154, 0, 0, 0, 0, 43383, 43383, 43383, 43383,
  44409, 43383, 43383, 43383, 43383, 44413, 43383, 44415, 43383, 43383, 44418, 43383, 43383, 43383, 43383, 44564, 43383,
  44565, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43383, 43383, 43383, 44676, 43404, 43404,
  43383, 43383, 43383, 44184, 44185, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44195, 43383, 43383,
  43383, 43383, 138703, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  356748, 43404, 43404, 0, 0, 0, 41267, 42335, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0,
  0, 0, 0, 0, 0, 138684, 43383, 43404, 43404, 43404, 44424, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 876, 1074, 0, 0, 0, 0, 228, 227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1574, 0, 0, 24576, 0, 0,
  0, 0, 0, 20480, 0, 300, 300, 306, 41276, 300, 41276, 41276, 0, 0, 0, 0, 647, 651, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248,
  0, 0, 0, 0, 0, 0, 0, 300, 0, 0, 0, 0, 0, 0, 0, 0, 300, 0, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 41276,
  300, 300, 300, 43392, 43392, 43392, 43413, 43392, 43392, 43392, 43392, 43392, 43413, 43413, 43413, 43413, 43413,
  43413, 43392, 43392, 43413, 0, 0, 41267, 41267, 41267, 41267, 41473, 41267, 41267, 41267, 41267, 41267, 41267, 41267,
  41267, 41267, 41701, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41926, 41267, 41267, 41267,
  41267, 41267, 0, 433, 0, 0, 0, 0, 43383, 43383, 43383, 43383, 43583, 43383, 43383, 43588, 43383, 43383, 43383, 43383,
  43383, 44534, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 44203, 43404, 44204, 43404,
  44206, 43404, 43404, 43629, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0,
  880, 0, 0, 0, 0, 709, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 41267, 41267, 0, 0, 0, 43788, 43383, 43383, 43383,
  43383, 43383, 43795, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 44328,
  43404, 43404, 43824, 43383, 43383, 43827, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 35644, 43788, 43404, 43404,
  43404, 43404, 43404, 43404, 391564, 0, 0, 0, 0, 0, 0, 1513, 0, 43383, 43404, 43404, 43843, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44551, 233472, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 721, 43383, 43383, 44006, 43383, 43383, 43383, 43383, 43383, 44012, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 44025, 44026, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 270711, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44179, 43383, 43404, 43404,
  44047, 43404, 43404, 43404, 43404, 43404, 44053, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  44441, 0, 0, 0, 0, 0, 43404, 43404, 270732, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 88064, 0, 0, 0, 1114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1367, 0, 0, 0, 43404,
  43404, 43404, 44210, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  252300, 43404, 44601, 0, 0, 0, 0, 1513, 0, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 44028, 43383, 43383, 43383, 43383, 0, 0, 0, 248, 229, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 913, 0, 0, 0, 0, 0, 0,
  0, 258, 0, 0, 0, 0, 0, 0, 229, 0, 0, 0, 0, 0, 0, 0, 129024, 129024, 129024, 129024, 129024, 129024, 0, 0, 129024,
  24576, 0, 0, 0, 229, 0, 20480, 287, 301, 305, 305, 41277, 305, 41277, 41277, 305, 337, 301, 337, 337, 337, 337, 337,
  337, 337, 337, 305, 337, 305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 41277, 305, 305, 305, 43393, 43393, 43393,
  43414, 43393, 43393, 43393, 43393, 43393, 43414, 43414, 43414, 43414, 43414, 43414, 43393, 43393, 43414, 437, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 778, 0, 0, 41267, 41466, 41267, 41267, 41267, 41267, 41267, 41477, 41267, 41267,
  41267, 41267, 41267, 41267, 42101, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267,
  41267, 41488, 41267, 0, 495, 0, 0, 535, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 41267, 41912, 41267, 41267, 41267, 41267,
  41267, 0, 0, 551, 0, 0, 0, 0, 0, 0, 558, 0, 0, 0, 0, 0, 0, 0, 711, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258549,
  0, 0, 0, 43383, 43573, 43383, 43383, 43383, 43383, 43383, 43589, 43383, 43383, 43383, 43383, 43383, 44634, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 878, 0, 0, 0, 884, 0, 0, 0, 0, 0, 43404, 43404, 43630, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43648, 43404, 43404, 43404, 0, 0, 0, 0, 1513, 339968, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44192, 43383, 43383, 43383, 385399, 0, 0, 0, 665, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 676, 0, 0, 0, 0, 648, 652, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 248, 0, 689, 0, 0, 722, 0, 0, 0,
  0, 0, 0, 0, 0, 41267, 41267, 41267, 41692, 41267, 41267, 41267, 41267, 41700, 280883, 41267, 41267, 41267, 41704,
  41705, 41267, 41267, 41267, 41267, 41267, 0, 531, 0, 0, 0, 0, 268288, 0, 0, 0, 0, 0, 0, 0, 217088, 0, 217088, 0, 0, 0,
  0, 0, 0, 0, 773, 0, 0, 0, 0, 0, 0, 0, 0, 686, 0, 248, 248, 0, 0, 0, 0, 768, 0, 0, 0, 0, 722, 0, 0, 0, 0, 775, 0, 0, 0,
  0, 0, 0, 0, 217088, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116736, 116736, 116736, 0, 0, 0, 43788, 43383, 43383,
  43383, 43383, 43383, 43796, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 44324, 44325, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43844, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43652, 0, 0, 0, 1088, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 41267, 42415, 0, 0, 0, 0,
  393216, 42087, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41706, 41267, 41267,
  41267, 41267, 44167, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 44017, 43383, 43383, 393591, 43383, 43383, 43383, 43383, 43383, 43404, 44201, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43871, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 231820,
  43404, 43404, 43404, 43404, 43404, 44222, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  393612, 43404, 43404, 43404, 43404, 43404, 43404, 43849, 43404, 43852, 43404, 43404, 43404, 43404, 43404, 43859,
  43404, 0, 0, 313344, 0, 342016, 0, 0, 0, 0, 0, 0, 0, 1245, 0, 0, 0, 0, 0, 683, 0, 0, 0, 0, 248, 248, 0, 0, 0, 0, 0, 0,
  1239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 899, 0, 0, 0, 902, 0, 904, 0, 0, 0, 0, 1266, 0, 41267, 41267, 41267, 41267, 41267,
  42233, 41267, 42234, 41267, 41267, 0, 0, 0, 0, 758, 0, 280576, 0, 761, 0, 0, 765, 0, 307200, 41267, 342323, 41267,
  42238, 41267, 0, 1280, 0, 1282, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776,
  75776, 75776, 77824, 77824, 75776, 0, 0, 0, 0, 0, 1287, 0, 43383, 43383, 43383, 43383, 43383, 44301, 43383, 43383,
  43383, 44305, 43383, 43383, 43383, 43383, 139660, 43404, 43404, 43404, 43404, 43404, 43383, 43383, 43383, 43383,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 8679, 44307,
  43383, 43383, 43383, 43383, 44310, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 342391, 43383, 43383,
  43383, 43383, 174455, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 35644, 43788,
  43404, 43404, 43839, 43383, 44318, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 44327, 43404,
  43404, 43404, 43404, 43404, 43867, 43868, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0,
  43383, 43383, 43383, 43383, 44331, 43404, 44333, 43404, 43404, 43404, 43404, 44336, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 44055, 43404, 43404, 43404, 43404, 342412, 43404, 43404, 44344, 43404,
  43404, 43404, 43404, 43404, 0, 0, 0, 0, 0, 0, 0, 0, 1230, 1231, 0, 1233, 0, 0, 0, 1371, 0, 0, 41267, 41267, 41267,
  42337, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 309248, 43383, 44407, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43383, 43404,
  43404, 43404, 43404, 43404, 43404, 44426, 43404, 43404, 43404, 44428, 43404, 43404, 43404, 43404, 43404, 43404, 44051,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 1343, 0, 0, 0, 0, 243712, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 44477, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44484, 43383, 43383, 43383,
  44487, 43383, 43383, 43383, 43383, 43383, 43829, 43383, 43383, 43383, 43383, 43383, 35644, 43788, 43404, 43404, 43404,
  43404, 43404, 44050, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44218, 44219,
  43404, 43404, 43404, 44506, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 167936, 0, 0, 235520, 0, 0, 0, 0, 0,
  32768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 224, 225, 0, 0, 0, 0, 44530, 43383, 43383, 43383, 43383, 43383, 43383, 44536,
  43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 44636, 43404, 43404, 43404, 43404, 43404, 0, 0, 43404,
  168332, 44541, 44542, 43404, 43404, 43404, 43404, 43404, 43404, 44548, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 422284, 0, 0, 0, 0, 0, 0, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43383, 43383, 44562, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 44571, 43404, 0, 43383, 43383, 43383, 43383, 43383,
  43383, 43404, 43404, 43404, 43404, 43404, 43404, 139639, 43383, 43383, 43383, 43383, 43828, 43383, 43383, 43383,
  43833, 43383, 43383, 35644, 43788, 43404, 43404, 43404, 43404, 43404, 43404, 316019, 43637, 43404, 43404, 43646,
  43404, 43404, 43404, 43404, 0, 876, 0, 0, 0, 882, 0, 0, 0, 0, 0, 0, 0, 248, 248, 248, 461, 0, 0, 0, 0, 0, 43404, 0,
  172032, 0, 0, 1513, 0, 43383, 43383, 43383, 44608, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44023, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44313, 43383, 43383, 43383, 43383, 43383, 43404, 43404,
  43404, 44617, 43404, 43404, 43404, 43404, 43404, 0, 0, 1617, 43383, 43383, 43383, 43383, 43383, 43383, 422263, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 44626, 43383, 43383, 43383, 43383, 43383, 44631,
  43383, 44633, 43404, 43404, 43404, 43404, 43404, 43404, 44639, 43404, 44641, 0, 0, 0, 0, 0, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 44304, 43383, 43383, 43383, 43383, 43383, 44481, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 44488, 43383, 43383, 43383, 43383, 43383, 44410, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44417,
  43383, 43383, 43383, 43383, 43383, 44035, 43383, 43383, 43383, 43383, 43383, 35644, 43404, 43404, 43404, 43404, 43404,
  43404, 44077, 43404, 44079, 43404, 43404, 0, 0, 0, 0, 0, 0, 1549, 1513, 0, 41267, 41267, 0, 0, 0, 43383, 44668, 44669,
  43383, 43383, 43404, 43404, 44672, 44673, 43404, 43404, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 44504, 230, 231, 232, 233, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1453, 41267,
  41267, 41267, 24576, 233, 0, 0, 233, 0, 20480, 231, 302, 302, 302, 41278, 325, 41278, 41278, 333, 333, 341, 333, 343,
  333, 333, 333, 343, 343, 333, 357, 343, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 41278, 357, 357, 357, 43394,
  43394, 43394, 43415, 43394, 43394, 43394, 43394, 43394, 43415, 43415, 43415, 43415, 43415, 43415, 43394, 43394, 43415,
  0, 0, 425, 0, 0, 427, 428, 429, 430, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920,
  81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 0, 0, 439, 440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0,
  466, 467, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274432, 0, 0, 505, 41267, 41267, 41469, 41267, 41267, 41475,
  41267, 41267, 41267, 41479, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 43383, 43383, 151927, 43383, 43383,
  41267, 387379, 41267, 41490, 0, 0, 427, 0, 0, 536, 0, 0, 0, 0, 0, 536, 544, 545, 0, 0, 0, 0, 0, 0, 536, 0, 0, 548,
  458, 0, 0, 550, 43593, 43383, 43383, 43383, 43601, 387447, 43383, 43383, 43610, 43383, 0, 43404, 43404, 43619, 43622,
  43404, 0, 43383, 43383, 44657, 44658, 43383, 43383, 43404, 43404, 44663, 44664, 43404, 43404, 43383, 43383, 43404,
  43404, 43383, 43404, 43383, 43404, 43383, 43404, 338295, 338316, 0, 0, 43627, 43404, 43404, 43404, 43633, 43634,
  43404, 43404, 43404, 43642, 387468, 43404, 43404, 43651, 43404, 0, 0, 0, 0, 301056, 0, 0, 1513, 0, 41267, 41267, 0, 0,
  0, 43383, 0, 679, 0, 0, 0, 0, 0, 0, 0, 0, 248, 248, 688, 0, 0, 0, 0, 0, 697, 0, 0, 0, 0, 0, 0, 0, 705, 0, 0, 679, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 891, 0, 919, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 931, 0, 0, 0, 0, 0, 43383,
  43383, 44298, 44299, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 205175, 43383, 43383, 44015,
  43383, 43383, 43383, 648, 0, 0, 0, 1077, 0, 652, 0, 0, 0, 0, 0, 0, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1084, 0, 0, 0, 0, 0, 0, 1149, 1150, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43383, 43383, 43383, 43383, 43584, 43383, 43383,
  43383, 43383, 43383, 0, 0, 1346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 168243, 42475, 0, 0, 0, 0, 1389, 0, 0,
  44400, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43611, 0, 43404, 43404, 43404, 43404, 217484,
  43383, 44421, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43878, 1438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 933, 43383, 43383, 43383, 44479, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44314, 43383, 43383, 43383, 43383, 44586, 43383, 43383, 43383,
  43383, 43383, 43383, 43404, 43404, 44595, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43636, 43404, 43639, 43404,
  43404, 43649, 43404, 43404, 0, 43404, 44615, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 43383, 43383,
  43383, 43383, 43383, 43404, 43404, 201100, 43404, 43404, 43404, 43404, 43404, 43404, 155648, 1634, 0, 0, 0, 259, 0, 0,
  0, 262, 259, 0, 0, 0, 0, 0, 0, 0, 0, 245760, 0, 276480, 0, 296960, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0,
  41279, 0, 41279, 41279, 0, 0, 0, 0, 648, 652, 0, 0, 0, 0, 657, 0, 0, 0, 0, 0, 0, 0, 86432, 86432, 86432, 86432, 86432,
  86432, 0, 0, 86432, 358, 0, 358, 358, 0, 358, 358, 358, 358, 358, 41279, 358, 358, 358, 43395, 43395, 43416, 43395,
  43395, 43395, 43395, 43395, 43416, 43416, 43416, 43416, 43416, 43416, 43395, 43395, 43416, 663, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1262, 0, 0, 710, 0, 0, 660, 0, 0, 0, 0, 0, 0, 0, 720, 0, 0, 0, 0, 0, 43383, 44297, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 35644, 43788, 141708, 43404, 43404, 41696,
  41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41931,
  660, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1370, 1086, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528,
  376832, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43383, 1124, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267,
  41267, 41267, 42093, 41267, 41267, 41267, 41267, 42100, 41267, 41267, 41267, 41267, 409907, 41267, 0, 1143, 1144, 0,
  0, 0, 1237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42414, 41267, 41267, 0, 1447, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  41267, 41267, 41267, 41267, 41693, 41267, 41267, 44505, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0,
  0, 0, 0, 0, 0, 1513, 0, 41267, 41267, 0, 0, 0, 43383, 0, 0, 485, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400,
  102400, 102400, 0, 0, 41267, 41267, 41267, 41267, 217395, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267,
  41267, 0, 0, 0, 0, 0, 0, 0, 44528, 43383, 43383, 43383, 43383, 43383, 43383, 43830, 43383, 43383, 43383, 43383, 35644,
  43788, 43404, 43404, 43404, 0, 217088, 0, 0, 0, 0, 43383, 43383, 43383, 43383, 217463, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 44037, 43383, 43383, 43383, 35644, 43404, 43404, 43404, 43404, 43383, 43383, 44532, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 248, 0, 0,
  0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 234, 22528,
  24576, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 41280, 0, 41280, 41280, 234, 234, 0, 234, 234, 234, 234, 234, 234, 234, 350,
  234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 41280, 234, 234, 234, 43396, 43396, 43396, 43417, 43396, 43396,
  43396, 43396, 43396, 43417, 43417, 43417, 43417, 43417, 43417, 43396, 43396, 43417, 0, 0, 468, 469, 0, 0, 0, 0, 0, 0,
  0, 0, 478, 0, 0, 0, 0, 0, 895, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 432, 0, 0, 0, 0, 0, 41267, 41487, 41267, 41267, 315392,
  0, 0, 0, 0, 0, 0, 0, 315930, 0, 0, 0, 0, 0, 910, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315836,
  0, 315930, 0, 478, 0, 0, 0, 0, 0, 0, 0, 0, 380928, 0, 912, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315835, 0, 0, 0, 0, 0, 0, 503,
  0, 0, 0, 0, 0, 0, 43383, 43383, 43578, 43581, 43383, 43586, 43383, 43383, 43383, 43592, 43383, 315978, 43596, 43383,
  43383, 43605, 43383, 43383, 43383, 43383, 0, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43851, 43404, 43404,
  43404, 43404, 43856, 43404, 43404, 43404, 41267, 41267, 231731, 41267, 41267, 41267, 41267, 41267, 41703, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 433, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1357, 0, 41267,
  41712, 0, 0, 0, 0, 0, 231424, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 771, 0, 0, 0, 0, 774, 0,
  0, 0, 0, 0, 777, 0, 0, 0, 0, 649, 653, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 476, 0, 0, 0, 0, 0, 0, 0, 706, 43788, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44539, 43383, 43404, 43404, 43383,
  231799, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43816, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 44188, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 391543, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43864, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43650, 43404, 0, 43404, 43404, 43882, 43404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266240, 41267, 41267,
  41267, 0, 0, 0, 0, 909, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 917, 0, 0, 1113, 0, 0, 0, 0, 0, 0, 0, 1118, 0, 1120, 1121, 0, 0,
  0, 0, 0, 44296, 43383, 43383, 43383, 44300, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 44323, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 0, 1571, 0, 0, 0, 0, 1513, 0, 43383, 0, 0, 1126, 0, 0, 41267, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 42095, 41267, 41267, 41267, 41267, 147456, 0, 0, 0, 0, 0, 0, 43383, 147831,
  43383, 43383, 43383, 43383, 43383, 43811, 43383, 43383, 43383, 43383, 43383, 43817, 43383, 43383, 43383, 43383, 43383,
  43383, 44036, 43383, 44038, 43383, 43383, 35644, 43404, 43404, 44043, 43404, 317747, 41267, 42098, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 1146, 318548, 0, 0, 0, 0, 0, 0, 0, 1152, 0, 0, 0, 0, 0, 0,
  43383, 43383, 43383, 43580, 43383, 43383, 43383, 43383, 43383, 43383, 44181, 43383, 44183, 43383, 43383, 318618,
  43383, 43383, 43383, 43383, 44191, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44199, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 346508, 43404, 43404, 362892, 43404, 43404, 43404, 43404, 44225,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43858, 43404, 280972,
  44233, 0, 0, 0, 0, 0, 0, 0, 1229, 0, 0, 0, 0, 0, 0, 0, 0, 403456, 0, 0, 0, 0, 0, 1445, 335872, 0, 0, 1251, 0, 0, 1254,
  0, 1256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 268288, 0, 0, 0, 0, 0, 0, 531, 0, 0, 0, 0, 0, 0, 42236, 41267, 41267, 41267,
  41267, 0, 0, 1281, 0, 0, 0, 0, 0, 0, 0, 0, 0, 423936, 423936, 423936, 423936, 423936, 0, 0, 0, 0, 1286, 0, 0, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 44303, 43383, 43383, 43383, 43383, 43383, 44009, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 0, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 0, 1361, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1119, 0, 0, 0, 0, 0, 0, 0, 0, 1511, 0, 0, 0, 0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 42091, 41267,
  41267, 41267, 41267, 41267, 41267, 43383, 43383, 44670, 43383, 43404, 43404, 43404, 43404, 44674, 43404, 43383, 43383,
  43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 44499, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 248, 0, 0,
  0, 0, 251, 0, 0, 0, 0, 0, 0, 0, 203, 203, 203, 203, 203, 203, 0, 0, 203, 236, 0, 235, 0, 0, 0, 0, 263, 264, 0, 0, 0,
  0, 251, 0, 0, 0, 0, 0, 79872, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 257, 267, 0, 0, 0, 0, 251, 0, 0, 271, 0,
  251, 0, 237, 273, 0, 22528, 24576, 0, 0, 0, 0, 0, 20480, 273, 0, 0, 235, 41281, 0, 41281, 41281, 334, 334, 0, 334,
  334, 334, 334, 334, 334, 334, 334, 359, 334, 359, 359, 366, 359, 359, 369, 359, 359, 359, 359, 359, 41281, 372, 372,
  374, 43397, 43397, 43397, 43418, 43397, 43397, 43397, 43397, 43397, 43418, 43418, 43418, 43418, 43418, 43418, 43397,
  43397, 43418, 1, 2, 30723, 39108, 0, 0, 0, 0, 0, 0, 203, 204, 0, 0, 0, 145408, 0, 0, 454, 0, 0, 0, 0, 248, 248, 248,
  0, 0, 0, 0, 0, 0, 0, 1078, 0, 0, 0, 0, 1083, 0, 0, 0, 0, 0, 41267, 41467, 41267, 41267, 41267, 41267, 41267, 268595,
  41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 534, 0, 0, 0, 0, 0, 0, 0, 557, 0, 0, 0, 0, 0, 0, 0, 0, 268288,
  0, 0, 0, 43383, 43574, 43383, 43383, 43383, 43383, 43383, 268663, 43383, 43383, 43383, 43383, 43383, 326007, 43383,
  43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 0, 176128, 0,
  182272, 43404, 43404, 268684, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0,
  0, 1435, 0, 0, 0, 0, 0, 0, 725, 0, 0, 0, 0, 41267, 41267, 41690, 41267, 41694, 41267, 41695, 779, 0, 0, 43788, 43383,
  43383, 43383, 43792, 43383, 43383, 43799, 43383, 43383, 43802, 43383, 43383, 43383, 43383, 43383, 409975, 43383,
  43383, 43404, 43404, 43404, 43404, 43404, 43404, 44205, 43404, 43840, 43404, 43404, 43847, 43404, 43404, 43850, 43404,
  43404, 43404, 43404, 43404, 43404, 43857, 43404, 43404, 43404, 43404, 43866, 43404, 43404, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43879, 0, 891, 0, 0, 0, 0, 0, 0, 0, 0, 900, 0, 0, 0, 0, 0, 0, 0, 317440, 1092, 1093, 0, 0,
  0, 0, 0, 0, 0, 897, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36864, 0, 0, 0, 36864, 36864, 36864, 0, 0, 0, 908, 0, 0, 0, 0, 0, 911,
  0, 0, 914, 0, 0, 0, 0, 0, 936, 0, 484, 0, 937, 0, 0, 0, 0, 0, 0, 0, 713, 0, 715, 0, 0, 0, 0, 0, 0, 0, 248, 248, 248,
  0, 65536, 0, 0, 0, 0, 0, 0, 0, 419840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 430080, 430080, 430080, 430080, 41267,
  41267, 41267, 42099, 41267, 41267, 385331, 41267, 41267, 41267, 420147, 0, 0, 0, 0, 0, 0, 0, 378880, 0, 0, 0, 0, 0, 0,
  0, 0, 222, 223, 0, 0, 0, 0, 0, 0, 0, 1147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 385024, 1157, 44166, 43383, 44196, 43383,
  43383, 43383, 43383, 420215, 43383, 44200, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44080,
  43404, 0, 1074, 0, 0, 0, 0, 282624, 0, 0, 0, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 35644, 43788, 43404, 43404, 43404, 0, 1359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 131072, 0, 43383,
  43383, 43383, 44408, 43383, 43383, 43383, 43383, 43383, 43383, 44414, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  44322, 43404, 43404, 43404, 44326, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44435, 43404, 43404, 43404,
  43404, 43404, 43404, 0, 0, 0, 0, 0, 0, 0, 387072, 458, 0, 0, 387072, 550, 0, 0, 550, 174387, 41267, 41267, 41267,
  41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 43383, 43383, 43577, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43404, 43404, 44202, 43404, 43404, 43404, 43404, 43404, 0, 382976, 411648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41267,
  41267, 41267, 41691, 41267, 41267, 41267, 41267, 41267, 346419, 362803, 0, 0, 0, 346112, 1518, 0, 362496, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 44592, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 1615,
  1616, 0, 43383, 43383, 43383, 44628, 43404, 1544, 0, 1546, 0, 0, 0, 0, 1513, 190464, 41267, 325939, 0, 0, 325632,
  43383, 43383, 43383, 43383, 266615, 43383, 43383, 43383, 43383, 44537, 43383, 43383, 43383, 43383, 43404, 43404,
  43404, 43404, 43404, 43404, 44500, 43404, 43404, 43404, 43404, 43404, 43404, 326028, 43404, 43404, 43404, 43404,
  43404, 0, 0, 0, 0, 0, 0, 1513, 0, 43383, 43383, 43383, 43808, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 44416, 43383, 43383, 43383, 43383, 43383, 43383, 44588, 44589, 43383, 43383, 43383, 43404,
  43404, 43404, 43404, 44597, 44598, 43404, 43404, 43404, 43404, 44062, 43404, 43404, 43404, 43404, 43404, 44068, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 44052, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  43645, 43404, 43404, 43404, 43404, 0, 43404, 178176, 43383, 44656, 43383, 43383, 43383, 43383, 43404, 44662, 43404,
  43404, 43404, 43404, 43383, 43383, 43404, 43404, 43383, 43404, 44683, 44684, 43383, 43404, 43383, 43404, 0, 0, 24576,
  0, 0, 0, 0, 0, 20480, 242, 303, 303, 303, 41282, 303, 41282, 41282, 0, 0, 0, 0, 666, 0, 0, 669, 0, 0, 0, 0, 0, 0, 0,
  0, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 303, 0, 0, 0, 0, 0, 0, 0, 0, 360, 0, 360, 364, 303, 364, 364, 303, 364, 364, 364,
  364, 364, 41282, 360, 360, 364, 43398, 43398, 43398, 43419, 43398, 43398, 43398, 43398, 43398, 43419, 43419, 43419,
  43419, 43419, 43419, 43398, 43398, 43419, 149504, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 435, 0, 0, 0, 0, 543, 0, 0, 0,
  0, 0, 0, 0, 204, 204, 204, 204, 204, 204, 0, 0, 204, 481, 0, 0, 0, 0, 0, 0, 0, 0, 0, 489, 0, 0, 0, 0, 0, 0, 0, 575947,
  575947, 575947, 0, 0, 0, 0, 0, 0, 0, 248, 248, 248, 0, 0, 0, 463, 0, 465, 0, 0, 41267, 41267, 41267, 41267, 41267,
  41267, 250163, 41267, 287027, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 217088, 0, 0, 0, 0, 0, 0, 0, 0, 249856,
  0, 286720, 0, 0, 0, 0, 0, 41485, 41267, 41267, 41267, 0, 149504, 0, 0, 0, 0, 0, 286720, 0, 540, 0, 543, 0, 0, 0,
  286720, 0, 0, 540, 0, 0, 149504, 0, 0, 0, 540, 0, 0, 540, 286720, 563, 43383, 43575, 43383, 43383, 43383, 43383,
  250231, 43590, 287095, 43383, 43404, 250252, 43631, 287116, 43404, 43404, 43404, 43404, 43404, 43643, 43404, 43404,
  43404, 43404, 43404, 0, 877, 0, 0, 0, 883, 0, 0, 0, 0, 0, 0, 0, 1151, 0, 0, 0, 0, 0, 0, 0, 43383, 43383, 44402, 43383,
  43383, 43383, 43383, 43383, 43383, 0, 0, 0, 0, 726, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 41267, 41267,
  41267, 42341, 41267, 41267, 0, 0, 0, 689, 0, 43788, 43383, 43383, 43791, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 44486, 43383, 43383, 43383, 43383, 0, 0, 892, 0, 0, 0, 896, 0, 0, 0, 0, 0, 292864,
  0, 0, 0, 0, 0, 976, 0, 0, 978, 0, 0, 0, 0, 0, 0, 0, 0, 36864, 36864, 36864, 0, 36864, 0, 0, 36864, 162735, 944, 0, 0,
  946, 0, 0, 0, 41267, 162743, 41267, 41913, 41267, 41267, 41267, 41916, 41267, 41267, 41918, 41267, 41267, 41267,
  41267, 41267, 41267, 41925, 41267, 41267, 41267, 41267, 41267, 41267, 0, 1517, 0, 0, 0, 0, 0, 43383, 43383, 43383,
  168311, 44529, 0, 0, 0, 975, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 944, 44018, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 44030, 43383, 43383, 43383, 44007, 43383, 43383, 43383, 43383, 43383,
  43383, 44013, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 289573, 43814, 43815, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 44412, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44568, 43383, 43404,
  43404, 43404, 43404, 43404, 43383, 379255, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 35644,
  43404, 43404, 43404, 162828, 43404, 43404, 43404, 44048, 43404, 43404, 43404, 43404, 43404, 43404, 44054, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43869, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 1340,
  1341, 0, 0, 0, 0, 0, 44059, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404,
  44071, 43404, 0, 44655, 43383, 43383, 43383, 43383, 43383, 44661, 43404, 43404, 43404, 43404, 43404, 43383, 43383,
  43404, 43404, 43383, 43404, 43383, 43404, 44685, 44686, 43383, 43404, 0, 0, 43404, 379276, 43404, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 0, 0, 0, 0, 0, 1573, 1513, 0, 43383, 0, 1087, 0, 278528, 0, 0, 0, 0, 0, 0, 0, 0,
  368640, 0, 0, 0, 0, 0, 1090, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 717, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1115, 0, 0, 0, 239616, 0,
  0, 0, 0, 0, 0, 0, 206, 206, 0, 0, 207, 207, 0, 0, 0, 0, 0, 0, 389120, 0, 41267, 41267, 41267, 41267, 41267, 41267,
  41267, 41267, 41267, 41267, 41267, 41267, 41267, 41929, 41267, 41267, 389495, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44330, 0, 0, 0, 223232, 0, 0, 41267, 41267,
  42230, 41267, 41267, 41267, 223539, 41267, 41267, 41267, 41267, 42418, 41267, 41267, 0, 0, 0, 0, 0, 0, 1466, 0, 43383,
  43383, 43383, 223607, 43383, 256375, 43383, 43383, 43383, 43383, 43383, 43383, 328055, 43383, 43383, 43383, 43383,
  43383, 43404, 44635, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 0, 0, 0, 880, 0, 0, 0, 886, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 59392, 59392, 0, 0, 43404, 43404, 43404, 43404, 223628, 43404, 256396, 43404, 43404, 43404, 43404,
  43404, 43404, 328076, 43404, 43404, 43404, 43404, 44226, 43404, 43404, 43404, 385420, 43404, 44230, 43404, 43404,
  43404, 43404, 420236, 202752, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260096, 0, 0, 0, 41267, 41267, 41267, 41267,
  182579, 41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 407552, 0, 0, 0, 0, 415744, 0, 0, 0,
  43383, 43383, 43383, 43383, 43383, 170359, 43383, 43383, 182647, 43383, 43383, 203127, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 252279, 43383, 44420, 43404, 43404, 43404,
  43404, 43404, 170380, 43404, 43404, 182668, 43404, 43404, 203148, 43404, 43404, 43404, 43404, 43404, 44227, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44231, 44232, 43404, 43404, 0, 0, 1439,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 247808, 0, 0, 0, 0, 0, 1101, 0, 0, 1104, 0, 1106, 0, 1108, 0, 0, 0, 0, 0, 923, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 454, 0, 0, 0, 531, 0, 43383, 44478, 43383, 43383, 43383, 43383, 200130, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 44569, 43404, 43404, 43404, 43404, 43383, 44493, 43383, 43383, 43404,
  43404, 44497, 43404, 43404, 43404, 43404, 200149, 43404, 43404, 43404, 43404, 43404, 43404, 44437, 43404, 43404,
  43404, 43404, 0, 0, 0, 0, 0, 0, 0, 1513, 0, 41267, 41267, 0, 1551, 0, 43383, 266547, 41267, 41267, 41267, 0, 0,
  192512, 0, 0, 0, 0, 43383, 43383, 43383, 43383, 43383, 43383, 44648, 43383, 43404, 43404, 43404, 43404, 43404, 43404,
  44654, 185873, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44567, 43383, 43383, 43404, 185882, 43404, 43404,
  43404, 43404, 43404, 44335, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43874, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 44576, 43404, 43404, 0, 0, 0, 0, 0, 0, 1513, 0, 43383, 43383, 43383,
  44033, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 35644, 43404, 43404, 43404, 43404, 715, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 203, 0, 0, 0, 203, 352256, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 352631, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 44215, 43404, 44217, 43404, 43404, 318652, 43404, 352652, 0, 43383, 43383,
  43383, 43383, 44659, 44660, 43404, 43404, 43404, 43404, 44665, 44666, 43383, 43383, 43383, 43383, 43404, 43404, 43404,
  43404, 43404, 174476, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44066, 44067, 43404, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 205196, 43404, 43404, 44056, 43404, 43404, 43404, 24576, 0, 0, 0, 0, 0,
  20480, 288, 304, 304, 304, 41283, 304, 41283, 41283, 0, 0, 0, 0, 674, 0, 726, 280576, 0, 761, 0, 0, 0, 0, 0, 0, 0,
  1103, 0, 0, 0, 0, 0, 0, 0, 0, 655, 0, 0, 0, 0, 0, 0, 0, 0, 0, 304, 243, 243, 243, 243, 347, 243, 243, 243, 304, 243,
  304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 41283, 304, 304, 304, 43399, 43399, 43399, 43420, 43399, 43399,
  43399, 43399, 43399, 43420, 43420, 43420, 43420, 43420, 43420, 43399, 43399, 43420, 0, 0, 0, 436, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1155, 0, 0, 0, 43383, 0, 0, 0, 0, 712, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1366, 0, 0, 0, 0, 43404, 43404,
  43404, 43883, 0, 0, 0, 0, 881, 0, 0, 0, 887, 0, 0, 0, 0, 0, 1116, 935, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 225280, 0, 0, 0,
  0, 0, 0, 906, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 133120, 133120, 0, 985, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  43788, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43801, 43383, 43804, 43404, 44208, 43404, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44058, 43383, 43404, 43404,
  44423, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44550, 43404, 43404,
  43383, 43383, 43383, 44563, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43404, 43404, 43404, 43404, 44572, 43404,
  44678, 43383, 43383, 43404, 43404, 43383, 43404, 43383, 43404, 43383, 43404, 43383, 43404, 0, 0, 0, 0, 1513, 0, 44605,
  43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 44176, 43383, 43383, 43383, 43383, 43383, 24576,
  0, 0, 0, 0, 0, 20480, 0, 0, 245, 0, 41267, 244, 41267, 41267, 0, 0, 0, 0, 0, 0, 0, 0, 760, 0, 0, 0, 0, 0, 0, 0,
  104865, 104865, 104865, 104865, 104865, 104865, 104739, 104739, 104866, 0, 0, 244, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 143360, 0, 0, 43400, 43421, 43400, 43400, 43400, 43400, 43400, 43421, 43421, 43421, 43421, 43421, 43421, 43400,
  43400, 43421, 0, 196608, 0, 0, 0, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 196915, 41267, 41267, 41267, 41267,
  366899, 0, 0, 0, 0, 215040, 0, 366592, 0, 0, 0, 0, 0, 0, 935, 0, 0, 1117, 0, 0, 0, 0, 0, 0, 0, 248, 248, 96256, 0, 0,
  0, 0, 0, 0, 0, 248, 248, 248, 0, 0, 462, 0, 0, 0, 0, 0, 0, 43788, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  196983, 43383, 43383, 43383, 43383, 43383, 43604, 43383, 43383, 43383, 43383, 0, 43404, 43404, 43404, 43621, 43404,
  43404, 43404, 43404, 43404, 197004, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 43860, 0, 0,
  0, 251904, 0, 0, 0, 0, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 0, 0, 0, 0, 0,
  41267, 252211, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267,
  41708, 41267, 41267, 0, 0, 1360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147763, 41267, 41267, 246, 247, 0, 248, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36864, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 20480, 246, 0, 0, 0, 41284, 0, 41284, 41284,
  335, 335, 0, 342, 342, 342, 342, 342, 348, 349, 342, 361, 342, 361, 361, 367, 361, 361, 367, 361, 361, 361, 361, 361,
  41284, 361, 361, 361, 43401, 43401, 43401, 43422, 43401, 43401, 43401, 43401, 43401, 43422, 43422, 43422, 43422,
  43422, 43422, 43401, 43401, 43422, 43383, 43383, 43383, 44309, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 208018, 219511, 43383, 43383, 43383, 43383, 43383, 44319, 43383, 43383, 43383, 43404,
  43404, 43404, 43404, 43404, 43404, 43404, 43404, 43404, 44427, 43404, 43404, 43404, 43404, 43404, 43402, 43423, 43402,
  43402, 43402, 43402, 43402, 43423, 43423, 43423, 43423, 43423, 43423, 43402, 43402, 43423, 0, 0, 41267, 41267, 41267,
  41267, 41474, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1095, 0, 0, 0, 0, 0, 562, 0, 0, 0, 0, 43383, 43383, 43383, 43383, 43585, 43383, 43383, 43383, 43383, 43383, 43383,
  43812, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43383, 43835, 35644, 43788, 43404, 43404, 43404,
  0, 0, 680, 0, 0, 0, 0, 0, 0, 0, 248, 248, 0, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 69632, 0, 0, 69632, 69632, 69632, 0, 708,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 428032, 428032, 428032, 43383, 43383, 43826, 43383, 43383, 43383, 43383,
  43383, 43383, 43383, 43383, 35644, 43788, 43404, 43404, 43404, 43404, 43404, 44345, 43404, 43404, 43404, 0, 0, 0, 0,
  0, 0, 0, 1513, 0, 41267, 41267, 0, 0, 0, 44560, 0, 0, 0, 157696, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43788, 43383,
  43383, 43383, 43383, 0, 0, 0, 893, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43788, 43383, 43383, 44002, 43383, 0, 0,
  423936, 248, 0, 423936, 0, 0, 0, 423936, 0, 423936, 423936, 0, 0, 0, 0, 423936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1081, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 423936, 423936, 0, 0, 0, 423936, 0, 0, 423936, 423936, 0, 0, 0, 0, 0, 288768, 0, 0, 289436,
  141619, 41267, 41267, 41267, 41267, 41267, 41267, 289075, 41702, 41267, 41267, 41267, 41267, 41267, 41267, 41267,
  41267, 393523, 41267, 41267, 1142, 0, 0, 0, 0, 424212, 0, 423936, 423936, 0, 423936, 424212, 0, 0, 0, 0, 0, 0, 423936,
  0, 0, 0, 0, 0, 311296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 248, 0, 0, 690, 0, 0, 0, 0, 0, 423936, 423936, 0, 0, 0, 0,
  0, 423936, 0, 423936, 423936, 0, 0, 0, 0, 696, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 490, 0, 0, 0, 0, 0, 0, 0, 425984, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 20480, 0, 428032, 428032, 428032, 0,
  428032, 0, 0, 0, 0, 0, 1267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 41267, 42235, 282931, 0, 0, 428032, 0,
  0, 0, 0, 0, 0, 0, 0, 428032, 0, 428032, 428032, 428032, 428032, 428032, 428032, 428032, 428032, 428032, 428032,
  428032, 428032, 428032, 428032, 0, 0, 277, 0, 0, 0, 0, 430080, 277, 0, 0, 0, 0, 0, 0, 0, 0, 430080, 430080, 0, 430080,
  430080, 430080, 430080, 430080, 430080, 430080, 430080, 430080, 430080, 430080, 430080, 430080, 430080, 0, 0, 0, 0, 0,
  0, 432128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114688, 0, 0, 0, 0, 36864, 36864, 36864, 36864, 36864, 36864, 36864,
  36864, 36864, 36864, 36864, 36864, 36864, 36864, 36864, 36864, 0, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  23, 55, 87, 119, 149, 171, 184, 247, 216, 279, 311, 373, 405, 437, 469, 501, 533, 565, 594, 626, 658, 690, 342, 722,
  726, 727, 727, 732, 727, 736, 728, 740, 744, 748, 752, 756, 1117, 1117, 759, 1117, 768, 777, 833, 782, 1117, 1117,
  762, 773, 888, 789, 1117, 1143, 1117, 798, 1299, 834, 854, 1117, 966, 967, 764, 887, 887, 807, 1117, 1117, 1117, 811,
  791, 834, 1117, 964, 967, 967, 764, 887, 887, 862, 820, 1117, 1117, 1551, 1300, 793, 963, 967, 967, 885, 887, 887,
  826, 1117, 1779, 832, 838, 771, 967, 879, 887, 845, 1117, 1252, 851, 965, 967, 860, 866, 1117, 871, 794, 967, 886,
  845, 1780, 875, 968, 887, 847, 878, 867, 885, 883, 892, 897, 896, 901, 902, 906, 910, 914, 926, 926, 921, 925, 927,
  931, 917, 935, 939, 943, 947, 1117, 1117, 1560, 1117, 1042, 951, 1117, 1117, 1117, 1117, 952, 956, 1117, 1117, 1117,
  961, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 972, 1117, 1117, 1117, 1353, 1117, 1117, 1117, 1117, 1117,
  1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117,
  1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 977, 981, 1117, 1010, 986, 1431, 992, 996, 1000, 1004, 1007, 1544,
  1014, 1032, 1653, 1162, 1116, 1117, 1409, 1116, 1117, 1117, 1071, 1117, 973, 1677, 1083, 1814, 1284, 1089, 1117, 1213,
  1117, 1117, 1488, 1117, 1095, 1101, 1107, 1114, 1117, 1132, 1117, 1487, 1117, 1117, 1817, 1020, 1027, 1031, 1036,
  1189, 1074, 1040, 1179, 1117, 1046, 1117, 1117, 1680, 1053, 1767, 1518, 1057, 1061, 1065, 1117, 1798, 1339, 1117,
  1333, 981, 1117, 1241, 816, 1428, 1122, 1126, 1132, 1340, 1115, 1764, 1117, 1097, 1130, 1136, 1141, 1425, 1709, 1147,
  822, 1235, 1528, 1554, 1151, 1155, 1153, 1159, 1166, 1170, 1174, 1183, 1234, 1117, 1316, 1187, 1117, 1949, 1484, 1743,
  1193, 1197, 1201, 1204, 1206, 1117, 1210, 1117, 1847, 1661, 1177, 1217, 1222, 1227, 1231, 1403, 1239, 1893, 1117,
  1807, 1117, 1712, 1844, 1245, 1724, 1118, 1249, 1593, 1049, 1117, 1503, 1223, 1773, 2021, 1787, 1117, 2027, 1218,
  1824, 1774, 1117, 1117, 1475, 1110, 1820, 1117, 1117, 1562, 1805, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117,
  1117, 1117, 2033, 840, 1258, 1117, 1316, 1265, 1846, 1660, 1270, 1641, 1137, 1274, 1117, 1281, 1117, 1117, 1281, 1117,
  1117, 1858, 982, 1714, 1288, 1591, 1085, 839, 1293, 1117, 1584, 1304, 1117, 1261, 1847, 1309, 1289, 1700, 1789, 1117,
  1091, 1022, 1260, 1847, 1315, 1117, 841, 1117, 1320, 2029, 1796, 1117, 1117, 1326, 1331, 1337, 1117, 856, 778, 1322,
  783, 784, 801, 785, 803, 784, 1344, 1346, 1350, 1368, 1117, 1117, 1117, 1375, 1779, 1117, 1383, 1254, 1387, 1391,
  1395, 1399, 1401, 1117, 1914, 1022, 1445, 1407, 1413, 1419, 1435, 1439, 1732, 1647, 1525, 1757, 1117, 1913, 1443,
  1866, 1449, 1455, 1459, 1108, 1463, 1108, 1666, 1467, 1117, 1472, 1117, 1117, 1481, 1444, 1492, 1497, 1016, 1305,
  1693, 1117, 828, 1117, 1117, 828, 1117, 1117, 1979, 1022, 1501, 1507, 1838, 1682, 1517, 1702, 1117, 1117, 1522, 1117,
  1079, 1445, 1532, 1876, 1841, 1701, 1536, 1109, 1541, 1493, 1445, 1548, 1568, 1023, 1108, 1422, 1632, 1575, 1579,
  1570, 1583, 1557, 1513, 1588, 1571, 855, 1865, 1597, 1569, 962, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117,
  1117, 2001, 2005, 1601, 1607, 1611, 1615, 1619, 1623, 1627, 1630, 1117, 1543, 1730, 1636, 1645, 1117, 1651, 1657,
  1665, 1670, 1674, 2017, 1537, 1686, 1117, 2003, 1749, 1891, 1266, 1543, 1691, 1697, 1706, 1117, 1718, 1117, 1985,
  1722, 1117, 1728, 1311, 1639, 1266, 1468, 1736, 1277, 1117, 1967, 1740, 1117, 1543, 1747, 1751, 1477, 1995, 1356,
  1755, 1967, 1761, 1117, 1884, 1542, 2011, 1564, 1778, 1784, 1793, 1117, 1802, 1117, 1811, 1687, 988, 1117, 1828, 1962,
  1864, 1371, 1603, 1832, 1067, 1851, 1856, 1862, 1870, 2023, 1852, 1882, 1888, 1359, 1878, 1897, 1901, 1899, 1873,
  1362, 1364, 1905, 1909, 1912, 1117, 1117, 1117, 1918, 1925, 1928, 1922, 1932, 1936, 1940, 1944, 1948, 1117, 1117,
  1770, 1773, 1510, 1823, 1117, 814, 1953, 1957, 1961, 1451, 1109, 1966, 1117, 1103, 1973, 1117, 1971, 1117, 1977, 1983,
  1117, 1117, 1415, 1117, 1117, 1379, 1117, 957, 1772, 1117, 1823, 1117, 1989, 1993, 1117, 1117, 1415, 1117, 1117, 1415,
  1117, 1117, 1999, 1562, 1971, 1327, 1835, 1117, 1117, 1378, 1117, 1117, 2009, 1223, 1773, 1077, 1117, 2015, 1117,
  1296, 3346, 2593, 2034, 2043, 2052, 2061, 2061, 2061, 2061, 2070, 2062, 2046, 2056, 2060, 2061, 2061, 2066, 2048,
  2074, 2623, 2078, 2080, 2091, 2089, 2089, 2090, 2087, 2084, 2095, 2099, 2103, 2107, 2111, 2114, 3346, 2643, 2626,
  2594, 2038, 2402, 2594, 2121, 2176, 2176, 2123, 2136, 2118, 2305, 2128, 2594, 2122, 2176, 2176, 2124, 2136, 2922,
  2594, 2594, 2594, 2292, 2150, 2594, 2594, 2594, 2294, 2594, 2594, 3322, 2628, 2594, 2594, 2150, 2150, 3465, 2594,
  2435, 2785, 2431, 3315, 2594, 2158, 2307, 2295, 2594, 2294, 2136, 2627, 2144, 3325, 2657, 2332, 3313, 2594, 2159,
  2594, 2594, 2824, 2533, 2144, 2628, 2594, 2594, 2184, 2616, 2143, 3325, 2594, 2594, 2215, 3024, 2594, 3463, 2150,
  2150, 2150, 2150, 2150, 3467, 2594, 2594, 2594, 2311, 2818, 2136, 2136, 2182, 2594, 2148, 2435, 2997, 2150, 2150,
  3466, 2594, 2594, 2594, 2307, 2819, 2179, 2136, 2136, 2136, 2141, 2144, 2136, 2136, 2180, 2594, 2130, 2594, 3316,
  2594, 3464, 2150, 2594, 2435, 2176, 2176, 2177, 2136, 2136, 2182, 2130, 2176, 2176, 2136, 2136, 2136, 2136, 2137,
  2136, 2136, 2182, 2176, 2122, 2176, 2179, 2136, 2181, 2174, 2176, 2136, 2154, 2178, 2154, 2163, 2171, 2165, 2303,
  2654, 2654, 2194, 2272, 2188, 2199, 2199, 2233, 2236, 2245, 2192, 2198, 2208, 2204, 2212, 2199, 2199, 2199, 2199,
  2223, 2207, 2200, 2199, 2226, 2250, 2246, 2253, 2256, 2266, 2259, 2262, 2596, 2270, 2276, 2280, 2284, 2303, 2636,
  3360, 3160, 2301, 2594, 2594, 2594, 2316, 2306, 2594, 2594, 2594, 2338, 2594, 2997, 2594, 2594, 2594, 2435, 2176,
  2176, 2176, 2176, 2178, 2998, 2594, 2594, 2594, 2455, 2594, 2982, 3474, 2524, 2528, 2594, 2594, 2594, 2495, 2320,
  2324, 2594, 2594, 2219, 2846, 2336, 2343, 3375, 2347, 2348, 2352, 2354, 2358, 2361, 2362, 2366, 2374, 2369, 2370,
  2378, 2380, 2380, 2384, 2594, 2304, 2594, 3163, 2523, 2527, 2594, 2594, 2227, 3019, 3281, 2594, 2824, 2594, 2594,
  2594, 2915, 2388, 2594, 2594, 2416, 2406, 2594, 2594, 2594, 2539, 2421, 2594, 2594, 2425, 2457, 2451, 2594, 2594,
  2290, 2412, 2825, 2522, 2526, 2594, 2312, 2789, 2793, 2461, 2822, 2946, 2157, 2489, 2594, 2594, 2494, 2500, 2594,
  2506, 2510, 2516, 2552, 2594, 2594, 2303, 3160, 2825, 2607, 2527, 2594, 2440, 2446, 2594, 2310, 2594, 2594, 3039,
  2594, 3098, 2591, 2594, 2594, 2305, 2594, 2557, 2661, 2594, 2594, 2311, 3183, 2783, 2594, 2823, 2669, 3098, 2600,
  3097, 2590, 2594, 2594, 2339, 2684, 3127, 3227, 2594, 2594, 2594, 2595, 2219, 2572, 2580, 2660, 2594, 2594, 2594,
  2594, 2183, 2783, 2821, 2667, 2584, 2589, 2593, 3126, 3226, 2838, 3225, 3326, 2578, 2558, 2662, 2472, 2594, 2594,
  2594, 2602, 2573, 2471, 2594, 2594, 2400, 2594, 3128, 2183, 2615, 2593, 2408, 2566, 2183, 2996, 2594, 2995, 2594,
  2620, 2594, 3209, 2995, 2594, 2508, 2548, 2556, 2994, 2594, 3208, 2994, 2594, 2994, 2594, 2647, 2594, 2995, 2993,
  2594, 2534, 2594, 2594, 2450, 2594, 2995, 3270, 3270, 3270, 3296, 2715, 2594, 2594, 2417, 2407, 2677, 2397, 2434,
  2132, 2479, 2482, 2485, 2688, 2692, 2696, 2699, 2699, 2702, 2706, 2706, 2708, 2594, 2594, 3295, 2714, 2594, 2573,
  2556, 2660, 2719, 2594, 2594, 2594, 2638, 2723, 2594, 2594, 2594, 2681, 3169, 2594, 2727, 2733, 2739, 2594, 2490,
  2996, 2594, 2594, 2594, 2620, 2311, 2749, 2594, 2594, 2456, 2594, 2436, 2594, 2594, 2991, 3159, 2594, 2782, 2594,
  2594, 3314, 2594, 2594, 2039, 2797, 2792, 2594, 2594, 2502, 2807, 2594, 2805, 2594, 2594, 2594, 2715, 2435, 2594,
  2594, 2991, 2594, 2997, 2037, 2594, 2594, 3324, 3213, 3115, 2798, 2793, 2594, 2594, 3326, 2574, 2436, 2594, 2413,
  2594, 2594, 2594, 3217, 2800, 2594, 2594, 3455, 2594, 2594, 3464, 2150, 2150, 2799, 2594, 2594, 2594, 2833, 2822,
  2411, 2594, 2414, 2594, 2219, 2408, 2594, 2594, 2594, 2923, 2594, 3181, 2820, 2594, 2594, 2167, 3257, 2594, 2594,
  2594, 2958, 2594, 3256, 2594, 2594, 2520, 2524, 2594, 3228, 2158, 2594, 2594, 2594, 2572, 2293, 2594, 2594, 2844,
  2594, 3314, 2594, 3316, 3314, 2594, 2594, 3467, 2594, 2303, 3195, 3322, 2594, 2594, 3304, 2409, 2923, 3305, 2923,
  3320, 3316, 3315, 3315, 2594, 2594, 3470, 3243, 2594, 3451, 2908, 2594, 2595, 2240, 2594, 2594, 3271, 2840, 2850,
  2394, 3269, 2864, 2823, 2871, 2875, 2884, 2887, 2891, 2895, 2899, 2901, 2902, 2903, 2878, 2880, 2880, 2594, 2594,
  2535, 2743, 2594, 3324, 2594, 2594, 2548, 2556, 2594, 2912, 2594, 2594, 2637, 2241, 3333, 2921, 2928, 2594, 2595,
  2917, 2594, 2606, 2567, 2594, 2469, 2592, 2594, 2391, 2428, 2330, 3343, 2933, 2594, 2938, 2442, 2662, 2944, 2950,
  3015, 2594, 2594, 2594, 2976, 2635, 2594, 3323, 2594, 2594, 2637, 3119, 3317, 3321, 2594, 2980, 2929, 2594, 2594,
  2989, 3003, 2744, 2755, 2326, 3010, 2594, 2594, 2594, 2983, 2594, 3236, 3009, 2594, 2637, 2594, 2594, 3233, 2594,
  3449, 3014, 2824, 2594, 2651, 2541, 2594, 2562, 2525, 2594, 2594, 2635, 2594, 2594, 2594, 3047, 2594, 3319, 2594,
  2229, 2975, 2634, 2594, 2594, 2637, 3120, 3317, 3321, 2228, 2594, 2667, 3195, 2594, 2667, 3228, 2853, 3028, 2594,
  2594, 2594, 3138, 2227, 3034, 2158, 2594, 2778, 2971, 2594, 2632, 2601, 2642, 2594, 3318, 2594, 2229, 2860, 2594,
  2594, 2594, 3150, 2858, 2542, 2594, 2594, 2594, 3161, 3473, 2594, 3320, 2228, 2594, 2784, 3315, 2594, 2183, 2642,
  2594, 2227, 3227, 2594, 2286, 2836, 2594, 2594, 2594, 2219, 2296, 2953, 2594, 2594, 2867, 2594, 2594, 2955, 2594,
  2975, 2635, 3318, 2595, 2310, 2227, 3227, 2953, 2594, 2594, 2594, 3216, 2826, 2310, 2955, 2594, 2811, 2594, 2594,
  2511, 2594, 2865, 2866, 2594, 2867, 2594, 3162, 2594, 2594, 2663, 3249, 2999, 2813, 2218, 3054, 3049, 2297, 2412,
  3287, 3336, 3447, 2594, 3058, 3068, 3075, 3061, 3064, 3079, 3083, 3089, 3087, 3071, 3093, 3093, 3093, 3095, 2594,
  2594, 2667, 2824, 2415, 2594, 2219, 3174, 3286, 2594, 2594, 2771, 2594, 2411, 3112, 2594, 2594, 2729, 2963, 2594,
  3124, 2594, 2594, 2735, 2594, 2594, 3132, 2158, 2594, 2821, 2766, 2594, 2594, 2568, 2594, 2594, 2594, 3237, 2543,
  2594, 2594, 3136, 3142, 3434, 3146, 2594, 2822, 2668, 2594, 2455, 2594, 2594, 2302, 2594, 3155, 2594, 2594, 2594,
  3248, 3187, 2715, 2594, 2594, 2756, 3030, 3194, 2594, 2544, 2303, 2594, 2594, 2594, 2856, 3035, 3426, 2837, 2734,
  2594, 2823, 2611, 2594, 2495, 2760, 2594, 2594, 3042, 2966, 3200, 3224, 2158, 3223, 2542, 2594, 2594, 2770, 2775,
  2594, 3161, 3102, 3107, 2594, 2594, 2710, 2934, 3189, 2594, 2594, 3204, 3263, 3221, 2540, 2594, 2823, 2924, 2673,
  3102, 2996, 2413, 2594, 3167, 3173, 3043, 2594, 3424, 2837, 2594, 2594, 2777, 2970, 3241, 3349, 2158, 2594, 2825,
  2564, 2594, 2467, 2476, 2594, 2338, 2683, 2594, 2594, 2837, 2594, 2310, 2756, 2594, 2594, 2594, 3316, 3464, 2594,
  3161, 2985, 2594, 2825, 2594, 2594, 3181, 2800, 3206, 3323, 3253, 2594, 2830, 2594, 2594, 2515, 2551, 3469, 3241,
  3279, 2594, 2837, 2594, 2594, 3294, 2806, 2594, 3261, 3277, 2594, 2838, 3225, 2594, 2456, 2529, 2594, 2304, 2836,
  2307, 2594, 2594, 2594, 3461, 3157, 2594, 3267, 3160, 2594, 3167, 3285, 2594, 2838, 3438, 2594, 2856, 3020, 2594,
  2754, 3029, 2594, 2765, 2594, 2594, 2496, 2761, 2594, 3291, 3160, 2594, 2594, 3471, 3469, 3242, 2594, 2594, 2804,
  2158, 2594, 3468, 3275, 3227, 2594, 2594, 2975, 2634, 2594, 3418, 2594, 2410, 2923, 3305, 2594, 2856, 3227, 2594,
  3304, 3227, 3300, 2594, 2594, 3468, 3262, 3188, 3472, 3244, 2594, 2410, 3178, 2594, 2594, 2748, 2753, 2409, 3325,
  2338, 3306, 2923, 3305, 2409, 3325, 3303, 2923, 3320, 3303, 2338, 2338, 2679, 3310, 2594, 2594, 2594, 3450, 2907,
  2339, 3330, 2665, 2814, 3358, 2663, 2940, 2666, 2594, 2664, 2666, 2594, 3340, 2665, 3353, 3356, 3366, 3370, 3379,
  3383, 3386, 3390, 3392, 3394, 3395, 3399, 3401, 3403, 3408, 3404, 3412, 2594, 2594, 2594, 3457, 3428, 2594, 3416,
  2463, 3422, 2594, 2594, 3373, 2839, 2594, 2594, 2594, 3468, 3118, 2594, 2594, 2594, 3469, 2309, 2594, 2594, 2594,
  2836, 2594, 2594, 2959, 2594, 2594, 2838, 3362, 3432, 3440, 2594, 2594, 2965, 3199, 2957, 2594, 2594, 2585, 3321,
  3441, 2594, 2594, 2984, 3190, 2923, 2682, 2594, 2594, 3005, 3103, 3108, 2594, 2594, 3050, 2239, 3120, 2594, 2594,
  3005, 3248, 3445, 2594, 2594, 2594, 3151, 2158, 2308, 2594, 2594, 2594, 3159, 3291, 2595, 2219, 2594, 2594, 3229,
  2158, 2167, 0, 136314880, 2097152, 2097152, 0, 0, 0, 16777216, 128, 2097152, 603979776, 4194304, 4194336, 4194336,
  272629760, 272629760, 1077936128, 4194304, 606076928, 2097152, 272629760, 1077936128, 272629760, 272629760,
  1077936128, 1077936128, -2143289344, 4194304, 4194304, 4194304, 4194304, 16777216, 4194304, 4194304, 4194336, 4325376,
  4194304, 4194304, 4194304, 75498688, 545261888, 4194304, -1069547460, -1069547460, 1111621632, 1111621632, 1111621632,
  4718592, 4718624, 37879808, 1380057088, 37879808, 1111621632, 37879808, 1380057088, 37879808, 37879808, 37879808,
  37879808, 1111621632, 37879808, 1111621632, 1111621632, 1112145920, 37879808, 1111621632, 1111621632, 1048576,
  3145728, 5242880, 5308416, 3145728, 273678336, 5242880, 273678336, 5242880, 1347485756, -799997892, -799866820,
  -799997892, -799997892, 1112670208, 1112670208, 1381171260, 0, 128, 8388672, 0, 0, 1048576, 1048576, 1048576, 65536,
  1114112, 24, 28, 0, 32768, 0, 1048576, 262144, 1048576, 1114112, 1114112, 1114112, 1114112, 24, 1114112, 1114112,
  1114112, 32, 32, 32, 32, 32768, 0, 524288, 524288, 524288, 524288, 1114112, 1114112, 1048576, 1048576, -2147483648, 0,
  0, 0, 4224, 1114112, 1114112, 1048576, 1114112, 0, 0, -2147483648, 0, 1048576, 1114112, 1048576, 1114112, 0, 1048576,
  1048576, 1048576, 1048576, 1114112, 1114112, 1114112, 0, 0, 0, 8, 128, 32769, 65537, 131073, 16777217, 1, 16385, 1, 1,
  0, 33562624, 3, 1, 1, 1, 1, 65, 268435459, 131137, 65, 65537, 1, 1, 1, 67, 65537, 131073, 131073, 1, 2, 8, 512, 8, 0,
  0, 0, 1, 67, 3, 65, 0, 0, 1, 2, 0, 0, 10223616, 1, -1889265451, -1889265451, 1, -1889265451, 1, 8, 128, 4096, 8192, 0,
  3, 258342979, 258342979, 258342979, 258342979, -1889265451, 258342979, 258342979, 258342979, 258343127, 258342979,
  258343127, -1889134377, 258343127, -1889134377, -1889101609, -1889101609, -1889134377, 526844139, 526844139,
  -1889134377, 526778583, 258343127, -1889134377, -1889134377, 33562624, 1, 1, 1, 3, 65, 7, 1082918401, 1082924689,
  1082924689, 1082924691, 1082924689, 1082924689, -1889134377, -1889101609, 1340999379, 0, 0, 1, 16384, 0, 9961472, 0,
  0, 2, 32, 32768, 0, 0, 2048, 64, 6291456, 201326592, 0, 0, 0, 256, 0, 0, 0, 2, 0, 0, 0, 3, 12, 0, 1024, 8912896,
  15204352, 0, 64, 64, 16777472, 4096, 131072, 0, 0, 2, 768, 0, 131072, 64, 64, 64, 64, 256, 256, 0, 0, 4, 16, 32, 0,
  131072, 320, 131072, 0, 21498880, 0, 0, 268443648, -2146385904, -2146385904, -2146385904, -1995251568, -1995251568,
  1761747345, 1761747345, 1761747345, -2124887024, 1761747345, 1761747345, 1761747345, 1761747345, -1995300719,
  1761747379, -1995300719, -1995300719, -1995251567, -1995251567, -1995251567, -1995251567, -1995300463, -1995267951,
  -1995251567, -1995267951, -1995251567, -1995300463, -1995251567, -1885871460, -1885871460, -1885871460, -1885871460,
  -1885871460, -1885871459, -1885871459, -1885871459, 16, 1097728, -2147483648, 0, 0, 16777216, 8388608, 67108864,
  134217728, 536870912, 4194308, 128, 0, 0, 16777216, 16777216, 0, -2147483648, 1236992, -1996488704, 0, 0, 0, 2048, 0,
  0, 0, 4096, 0, 0, 0, 144, 1187840, 0, 400, 139264, 1761607680, 0, 5816320, -2130706432, 0, 0, 16777472, 64, 0, 24, 16,
  0, 0, 0, 1048576, 0, 0, 434, 0, 0, 4, 2368, 1236992, 0, 0, 1220608, 668, 1564672, -1887436800, 0, 0, 0, 8388608, 0, 0,
  0, 668, 0, 4718592, 0, 0, 4, 3776, 0, 16, 128, 57344, 131072, 1048576, 234881024, 0, 0, 1179648, 150994944,
  -2147483648, 0, 0, 109056512, 109056512, 109122072, 113250816, 109122072, 42009368, 42009368, 44630808, 1610612736, 0,
  0, 0, 4632, 5767168, 0, 0, 0, 8192, 64, 0, 1179648, 0, 0, 4, 262144, 2, 48, 0, 57344, 40960, 0, 0, 0, 12288, 0, 28,
  128, 512, 57344, 0, 1024, 2048, 8192, 131072, 524288, 2097152, 4194304, 16777216, 0, 0, 0, 320, 49152, 1048576, 0, 0,
  0, 12824, 128, 134217728, 536870912, 1073741824, -2147483648, 0, 0, 96, 0, 12, 128, 512, 57344, 65536, 1441792,
  260046848, -2147483648, 65536, 131072, 262144, 1048576, 8388608, 16777216, 0, 1024, 2048, 131072, 524288, 4194304, 0,
  0, 0, 262528, 0, 12, 128, 512, 32768, 65536, 128, 512, 32768, 131072, 262144, 1048576, 1048576, 0, 0, 128, 512, 32768,
  131072, 1048576, 16777216, 134217728, 0, 0, 0, 0, 1, 1, 1048576, 134217728, 0, 0, 8, 256, 0, 2048, 131072, 524288,
  2097152, 0, 128, 131072, 134217728, 128, 512, 131072, 100663296, 134217728, 0, 2048, 524288, 4194304, -1069547460,
  8421952, 4194304, 0, 32, 32, 32, 0, 0, 268435456, 134217728, 0, 536870912, 0, 0, 1, 8, 0, 100663296, 134217728, 0, 0,
  2097152, 0, 4194304, 8, 67108864, 4194308, 128, 8192, 16777216, 33554432, 536870912, 0, 0, 8388608, 8388608, 16777216,
  234881024, 0, 0, 0, 16384, 0, 0, 0, 32768, 1048576, 0, 8192, 8192, 133120, 536870912, 4194304, 16777216, 0, 16, 0, 16,
  32, 256, 4096, 0, 0, 113512960, 44630808, 44630808, 44630808, 44763928, 44634904, 44630808, 44630808, 44763928,
  109122072, 44630808, 109122072, 109122072, 109122072, 109122072, 646001176, 646001176, 109122072, 511825471,
  511825471, 511825471, 511825471, 0, 0, 6, 2880, 4194304, 536870912, -2147483648, 0, 0, 0, 4608, 41943040, 67108864,
  4632, 65536, 41943040, 67108864, 0, 2686976, 0, 0, 7, 0, 0, 4456448, 0, 0, 0, 1572864, 0, 2840, 2818048, 4888,
  603979776, 0, 0, 0, 2097152, 3, 5692, 114688, 41943040, 469762048, 469762048, 0, 0, 0, 4194304, 0, 0, 64, 16777216,
  1073741824, 0, 0, 268435456, 0, 2048, 131072, 0, 0, 8, 16, 4096, 67108864, 65536, 67108864, 0, 0, 15, 2880, 12288,
  2621440, 0, 0, 0, 8388608, 64, 64, 48, 1024, 4096, 114688, 67108864, 268435456, 0, 0, 12, 48, 1024, 4096, 49152,
  268435456, 0, 4, 16, 262144, 4194304, -2147483648, 0, 0, 0, 16, 4096, 0, 16384, 0, 16384, 4, 32, 49152, 0, 0, 0,
  268435456, 0, 0, 0, 1024, 0, 8192, 64, 16777216, 0, 0, 201326592, 0, 1, 0, 0, 0, 128, 0, 262144, 0, 32, 32768, 0,
  2048, 0, 0, 16512, 8192, 524288, 0, 536870912, 0, 1, 2, 512, 8192, 134217728, 1073741824, -2147483648, 16512, 0, 0, 0,
  1073741824, 0, 0, 268468224, 0, 0, 16909328, 33658951, 33626183, 33634375, 1174477639, 1174477671, -837731505,
  -837731505, -837731505, -837731505, 50403399, 1174477639, 1174477639, 234948932, 237046084, 318871623, 237046084,
  241240388, 237046084, 237046084, 237046084, 241240388, 241240388, 237046084, 1174477638, 241240388, 1174477639,
  1174477639, 100735303, 1174477639, 1174477639, 1174477639, 1174477639, 32768, 8388608, 16777216, 67108864, 268435456,
  0, 1040, 131072, 0, 1, 2, 134217728, 1073741824, 0, 98304, 33554432, 0, 0, 0, 4, 0, 65536, 12288, 0, 0, 0, 65536,
  100663296, 1073741824, 0, 0, 50331648, 0, 0, 0, 16, 16384, 2162688, 0, 0, 0, 16, 49152, 318767104, 0, 239075328, 0, 1,
  2, 1073741824, 0, 0, 128, 4096, 0, 0, 2912, 0, 0, 0, 22, 64, 256, 12288, 1114112, 234881024, -1073741824, 0, 0,
  262144, 524288, 0, 134217728, 3, 4096, 0, 0, 64, 256, 65536, 262144, 0, 3, 768, 4096, 67108864, 0, 0, 8, 67108864, 0,
  0, 0, 524288, 0, 0, 256, 201326592, 0, 0, 64, 512, 12288, 1048576, 201326592, -1073741824, 0, 16384, 32768, 16777216,
  67108864, 268435456, 512, 67108864, 1073741824, 0, 0, 8192, 1048576, 201326592, -1073741824, 4194304, 0, 512,
  1073741824, 0, 0, 512, 8192, 201326592, 1073741824, -2147483648, 8192, 32768, 16777216, 268435456, 0, 2048, 0,
  4194304, 32768, 268435456, 0, 0, 64, 4096, 0, 0, 32768, 8388616, 16777216, 0, 70254592, -1342177280, -1342177280,
  262592, 262592, 262592, -2147221056, 262592, 262592, -1342176768, -1207631552, -1342177280, -1207631552, -1744498368,
  -1744498368, -1203437248, -1207631552, 262592, 262592, 262592, 262624, -1744502464, 262593, -1744502464, -1207631552,
  -1341914816, -1207631552, -1341914816, -1207631552, -1207631552, -1207631552, -1207631552, -1341910720, -1207631552,
  -116970154, -116970154, -116970154, -116970154, 0, 0, 128, 32768, 131072, 512, 16384, 524288, 1048576, 2097152,
  2097152, 16777216, 33554432, 67108864, 0, 4194304, 0, 3145728, 0, 3, 4, 8, 4224, 8192, 0, 0, 0, 805306368,
  -2147483648, 0, 0, 128, 134217728, 536870912, 0, 0, 64, 327936, 939524096, 327936, 402653184, 0, 0, 128, 150994944, 1,
  939524096, 0, 262400, 0, 332032, 0, 4522240, 0, 22, 64, 470272, 2030043136, 2030043136, -2147483648, 0, 0, 256, 65536,
  0, 0, 0, 64, 0, 256, 0, 8, 0, 0, 792, 65536, 0, 32768, 8388608, 0, 0, 0, 4194304, 3145728, 0, 3, 4, 32, 4096, 49152,
  256, 65536, 262144, 134217728, 536870912, -2147483648, 0, 384, 262144, 0, 0, 0, 256, 3072, 73728, 131072, 262144, 0,
  128, 256, 262144, 0, 0, 2048, 4194304, 0, 65536, 134217728, 1, 0, 3, 4, 48, 1024, 65536, 131072, 262144, 16777216,
  134217728, 536870912, 1073741824, 0, 0, 0, 262144, 4194304, 0, 536870912, -2147483648, 0, 3, 8, 768, 12288, 64, 256,
  3072, 65536, 1073741824, 0, 0, 16384, 1048576, 67108864, 0, 0, 0, 65536, 1, 0, 3, 32, 49152, 0, 6, 16, 64, 256, 3072,
  8192, 256, 0, 32, 0, 0, 67108864, 0, 0, 16, 256, 3072, 65536, 262144, 1073741824, 0, 0, 3072, 4718592, 32768, 2048, 0,
  0, 4194304, 64, 0, 256, 32, 0, 4, 16, 128, 262144, 4194304, 2048, 65536, 1073741824, 0, 4, 16, 1024, 2048, 0, 0, 16,
  16, 16, 16, 0, 0, 32768, 0, 0, 0, 16, 1024, 0, 0, 0, 32, 0, 0, 0, 12, 256, 4096, 16384, 0, 7, 2112, 4096, 0, 524288,
  70254592, 16384, 16384, 1, 0, 7, 2880, 4096, 8192, 16384, 262144, 134217728, 536870912, 1073741824, 0, 256, 16384,
  311296, 0, 16384, 16384, 0, 0, 8192, 32768, 16777216, 67108864, 0, 147456, 311296, 258, 65536, 65568, 65536, 4224, 0,
  0, 0, 131072, 0, 65552, 20608, 4224, 132736, 149120, 132736, 65552, 132804, 149188, 132804, 132804, 134852, 136900,
  132804, 200832, 200832, 196736, 200832, 200832, 200832, 200832, 217216, 217216, 217216, 12425, 12425, 12425, 12425,
  28809, 28809, 28809, 12425, 12425, 143497, 225417, 225417, 209033, 0, 1728, 0, 0, 16384, 67108864, 5824, 0, 0, 0,
  65536, 134217728, 0, 0, 1664, 0, 128, 1536, 0, 0, 266496, 0, 512, 1024, 0, 64, 0, 2048, 0, 512, 1024, 64, 0, 0, 0,
  128, 8192, 16384, 32768, 1, 8, 8192, 0, 64, 536870912, 16, 256, 0, 0, 524288, 524288, 524288, 0, 0, 0, 6, 16, 256,
  1024, 2048, 4096, 8192
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "END",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PragmaContents",
  "DirPIContents",
  "DirCommentContents",
  "CDataSection",
  "Wildcard",
  "EOF",
  "PITarget",
  "NCName",
  "QName",
  "S",
  "S",
  "CharRef",
  "CommentContents",
  "'!='",
  "'""'",
  "'#)'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'['",
  "']'",
  "'all'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'any'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'contains'",
  "'content'",
  "'copy-namespaces'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'diacritics'",
  "'different'",
  "'distance'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'entire'",
  "'eq'",
  "'every'",
  "'exactly'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'from'",
  "'ft-option'",
  "'ftand'",
  "'ftnot'",
  "'ftor'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'inherit'",
  "'insensitive'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'language'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'levels'",
  "'lowercase'",
  "'lt'",
  "'mod'",
  "'module'",
  "'most'",
  "'namespace'",
  "'ne'",
  "'no'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'not'",
  "'occurs'",
  "'of'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'paragraph'",
  "'paragraphs'",
  "'parent'",
  "'phrase'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'processing-instruction'",
  "'relationship'",
  "'return'",
  "'same'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'score'",
  "'self'",
  "'sensitive'",
  "'sentence'",
  "'sentences'",
  "'some'",
  "'stable'",
  "'start'",
  "'stemming'",
  "'stop'",
  "'strict'",
  "'strip'",
  "'text'",
  "'then'",
  "'thesaurus'",
  "'times'",
  "'to'",
  "'treat'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'uppercase'",
  "'using'",
  "'validate'",
  "'variable'",
  "'version'",
  "'weight'",
  "'where'",
  "'wildcards'",
  "'window'",
  "'without'",
  "'word'",
  "'words'",
  "'xquery'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 2048
    let $end := $end - $result idiv 256
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 1678 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 32
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 32 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(67, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 46) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 24) then                 (: CommentContents :)
            let $state := p:consumeT(24, $input, $state)    (: CommentContents :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(32, $input, $state)              (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consumeT(46, $input, $state)              (: (':' ')') :)
  return $state
};

(:~
 : Try parsing the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(14, $input, $state)          (: END | S^WS | ('(' ':') :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 22) then                 (: S^WS :)
            let $state := p:consumeT(22, $input, $state)    (: S^WS :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Whitespace-1($input, $state)
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Whitespace-1($input, $state)
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QueryBody", $count, $begin, $end)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QueryBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModule", $count, $begin, $end)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:consume(152, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(5, $input, $state)                (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OptionDecl", $count, $begin, $end)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Param", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(77, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(18, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParamList", $count, $begin, $end)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'function' :)
  let $state := p:consume(118, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(92, $input, $state)           (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 206) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnclosedExpr($input, $state)
      return $state
    else
      let $state := p:consume(109, $input, $state)          (: 'external' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDecl", $count, $begin, $end)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'variable' :)
  let $state := p:consume(196, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(114, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: ':=' :)
      let $state := p:consume(48, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
    else
      let $state := p:consume(109, $input, $state)          (: 'external' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDecl", $count, $begin, $end)
};

(:~
 : Parse FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(152, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(5, $input, $state)                (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTExtensionOption", $count, $begin, $end)
};

(:~
 : Parse FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 191) then                      (: 'union' :)
      let $state := p:consume(191, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'except' :)
      return $state
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTStopWords($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWordsInclExcl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWords-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(77, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(15, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(5, $input, $state)          (: StringLiteral :)
        return p:parse-FTStopWords-1($input, $state)
};

(:~
 : Parse FTStopWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'at' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      let $state := p:parse-FTStopWords-1($input, $state)
      let $state := p:consume(33, $input, $state)           (: ')' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWords", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(151, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'except' | 'for' | 'ftand' |
                                                               'ftor' | 'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' |
                                                               'ne' | 'not' | 'or' | 'order' | 'ordered' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'union' | 'using' |
                                                               'weight' | 'where' | 'window' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 108                              (: 'except' :)
      and $state[$p:l1] != 191) then                        (: 'union' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-1($input, $state)
};

(:~
 : Parse the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(151, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'except' | 'for' | 'ftand' |
                                                               'ftor' | 'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' |
                                                               'ne' | 'not' | 'or' | 'order' | 'ordered' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'union' | 'using' |
                                                               'weight' | 'where' | 'window' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 108                              (: 'except' :)
      and $state[$p:l1] != 191) then                        (: 'union' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-2($input, $state)
};

(:~
 : Parse FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 181) then                          (: 'stop' :)
      let $state := p:lookahead2W(65, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state :=
        if ($state[$p:lk] eq 52405) then                    (: 'stop' 'words' :)
          let $state := p:lookahead3W(110, $input, $state)  (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 5819573) then                  (: 'stop' 'words' 'default' :)
      let $state := p:consume(181, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(65, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(204, $input, $state)          (: 'words' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'default' :)
      let $state := p:consume(88, $input, $state)           (: 'default' :)
      let $state := p:parse-FTStopWordOption-2($input, $state)
      return $state
    else if ($state[$p:lk] = 145) then                      (: 'no' :)
      let $state := p:consume(145, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:consume(181, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(65, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(204, $input, $state)          (: 'words' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(65, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(204, $input, $state)          (: 'words' :)
      let $state := p:lookahead1W(74, $input, $state)       (: S^WS | '(' | ('(' ':') | 'at' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTStopWords($input, $state)
      let $state := p:parse-FTStopWordOption-1($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWordOption", $count, $begin, $end)
};

(:~
 : Parse FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 92) then                           (: 'diacritics' :)
      let $state := p:lookahead2W(96, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 32604) then                    (: 'diacritics' 'insensitive' :)
      let $state := p:consume(92, $input, $state)           (: 'diacritics' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:consume(127, $input, $state)          (: 'insensitive' :)
      return $state
    else
      let $state := p:consume(92, $input, $state)           (: 'diacritics' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:consume(174, $input, $state)          (: 'sensitive' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTDiacriticsOption", $count, $begin, $end)
};

(:~
 : Parse FTCaseOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 77) then                           (: 'case' :)
      let $state := p:lookahead2W(96, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 32589) then                    (: 'case' 'insensitive' :)
      let $state := p:consume(77, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:consume(127, $input, $state)          (: 'insensitive' :)
      return $state
    else if ($state[$p:lk] = 44621) then                    (: 'case' 'sensitive' :)
      let $state := p:consume(77, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:consume(174, $input, $state)          (: 'sensitive' :)
      return $state
    else if ($state[$p:lk] = 138) then                      (: 'lowercase' :)
      let $state := p:consume(138, $input, $state)          (: 'lowercase' :)
      return $state
    else
      let $state := p:consume(193, $input, $state)          (: 'uppercase' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTCaseOption", $count, $begin, $end)
};

(:~
 : Parse FTStemOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 180) then                      (: 'stemming' :)
      let $state := p:consume(180, $input, $state)          (: 'stemming' :)
      return $state
    else
      let $state := p:consume(145, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(56, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:consume(180, $input, $state)          (: 'stemming' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStemOption", $count, $begin, $end)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(162, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               '?' | ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'contains' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'levels' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'treat' |
                                                               'union' | 'where' | 'words' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '?' :)
      let $state := p:consume(60, $input, $state)           (: '?' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleType", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(76, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 31) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(188, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 209) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExtensionExpr", $count, $begin, $end)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: '@' :)
      let $state := p:consume(62, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(177, $input, $state)          (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NodeTest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevForwardStep", $count, $begin, $end)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'child' :)
      let $state := p:consume(80, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'descendant' :)
      let $state := p:consume(89, $input, $state)           (: 'descendant' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'attribute' :)
      let $state := p:consume(73, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:consume(173, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'descendant-or-self' :)
      let $state := p:consume(90, $input, $state)           (: 'descendant-or-self' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'following-sibling' :)
      let $state := p:consume(111, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(110, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardAxis", $count, $begin, $end)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 73) then                           (: 'attribute' :)
      let $state := p:lookahead2W(168, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'levels' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'treat' |
                                                               'union' | 'where' | 'words' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (80,                           (: 'child' :)
                              89,                           (: 'descendant' :)
                              90,                           (: 'descendant-or-self' :)
                              110,                          (: 'following' :)
                              111,                          (: 'following-sibling' :)
                              173)) then                    (: 'self' :)
      let $state := p:lookahead2W(167, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 12105                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12112                          (: 'child' '::' :)
          or $state[$p:lk] = 12121                          (: 'descendant' '::' :)
          or $state[$p:lk] = 12122                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 12142                          (: 'following' '::' :)
          or $state[$p:lk] = 12143                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 12205) then                    (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(177, $input, $state)      (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevForwardStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardStep", $count, $begin, $end)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(42, $input, $state)               (: '..' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevReverseStep", $count, $begin, $end)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: Wildcard :)
      let $state := p:consume(16, $input, $state)           (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameTest", $count, $begin, $end)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (73,                                (: 'attribute' :)
                         82,                                (: 'comment' :)
                         97,                                (: 'document-node' :)
                         98,                                (: 'element' :)
                         148,                               (: 'node' :)
                         164,                               (: 'processing-instruction' :)
                         170,                               (: 'schema-attribute' :)
                         171,                               (: 'schema-element' :)
                         184)) then                         (: 'text' :)
      let $state := p:lookahead2W(166, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7753                           (: 'attribute' '(' :)
          or $state[$p:lk] = 7762                           (: 'comment' '(' :)
          or $state[$p:lk] = 7777                           (: 'document-node' '(' :)
          or $state[$p:lk] = 7778                           (: 'element' '(' :)
          or $state[$p:lk] = 7828                           (: 'node' '(' :)
          or $state[$p:lk] = 7844                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 7850                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 7851                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 7864) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeTest", $count, $begin, $end)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'parent' :)
      let $state := p:consume(159, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ancestor' :)
      let $state := p:consume(66, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'preceding-sibling' :)
      let $state := p:consume(162, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'preceding' :)
      let $state := p:consume(161, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(67, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(47, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseAxis", $count, $begin, $end)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 42) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(177, $input, $state)      (: Wildcard | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseStep", $count, $begin, $end)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (66,                                (: 'ancestor' :)
                         67,                                (: 'ancestor-or-self' :)
                         159,                               (: 'parent' :)
                         161,                               (: 'preceding' :)
                         162)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(167, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42                             (: '..' :)
          or $state[$p:lk] = 12098                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 12099                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 12191                          (: 'parent' '::' :)
          or $state[$p:lk] = 12193                          (: 'preceding' '::' :)
          or $state[$p:lk] = 12194) then                    (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(165, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '|' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AxisStep", $count, $begin, $end)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(63, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(64, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Predicate", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '|' | '}' :)
    return
      if ($state[$p:l1] != 63) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PredicateList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PredicateList", $count, $begin, $end)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(164, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(141, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 206) then                      (: '{' :)
      let $state := p:consume(206, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(209, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(188, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 209) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompPIConstructor", $count, $begin, $end)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(82, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(184, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompTextConstructor", $count, $begin, $end)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(73, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(180, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 206) then                      (: '{' :)
      let $state := p:consume(206, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(209, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(188, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 209) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompAttrConstructor", $count, $begin, $end)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContentExpr", $count, $begin, $end)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(98, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(180, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 206) then                      (: '{' :)
      let $state := p:consume(206, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(209, $input, $state)          (: '}' :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(188, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 209) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompElemConstructor", $count, $begin, $end)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'document' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompDocConstructor", $count, $begin, $end)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 96) then                       (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComputedConstructor", $count, $begin, $end)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(55, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(3, $input, $state)             (: PITarget :)
  let $state := p:consume(18, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(12, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      let $state := p:lookahead1(1, $input, $state)         (: DirPIContents :)
      let $state := p:consume(13, $input, $state)           (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(8, $input, $state)             (: '?>' :)
  let $state := p:consume(61, $input, $state)               (: '?>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirPIConstructor", $count, $begin, $end)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(51, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(2, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(14, $input, $state)               (: DirCommentContents :)
  let $state := p:lookahead1(5, $input, $state)             (: '-->' :)
  let $state := p:consume(40, $input, $state)               (: '-->' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50                             (: '<' :)
          or $state[$p:l1] = 51                             (: '<!--' :)
          or $state[$p:l1] = 55) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 15) then                       (: CDataSection :)
      let $state := p:consume(15, $input, $state)           (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:consume(9, $input, $state)            (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemContent", $count, $begin, $end)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: AposAttrContentChar :)
      let $state := p:consume(11, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AposAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExpr", $count, $begin, $end)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: PredefinedEntityRef :)
      let $state := p:consume(6, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: CharRef :)
      let $state := p:consume(23, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 207) then                      (: '{{' :)
      let $state := p:consume(207, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: '}}' :)
      let $state := p:consume(210, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnclosedExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CommonContent", $count, $begin, $end)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: QuotAttrContentChar :)
      let $state := p:consume(10, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QuotAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(127, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 26) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 7) then                  (: EscapeQuot :)
            let $state := p:consume(7, $input, $state)      (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(128, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 29) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 8) then                  (: EscapeApos :)
            let $state := p:consume(8, $input, $state)      (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(13, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26) then                       (: '"' :)
      let $state := p:consume(26, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(26, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(29, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(29, $input, $state)           (: "'" :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeValue", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(17, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 21) then                         (: S :)
        $state
      else
        let $state := p:consume(21, $input, $state)         (: S :)
        let $state := p:lookahead1(178, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 21                      (: S :)
               and $state[$p:l1] != 45                      (: '/>' :)
               and $state[$p:l1] != 57) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QName($input, $state)
            let $state := p:lookahead1(10, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 21) then             (: S :)
                let $state := p:consume(21, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(6, $input, $state)   (: '=' :)
            let $state := p:consume(56, $input, $state)     (: '=' :)
            let $state := p:lookahead1(16, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 21) then             (: S :)
                let $state := p:consume(21, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-DirAttributeList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(134, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CDataSection |
                                                               CharRef | '<' | '<!--' | '</' | '<?' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 52) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(50, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '/>' :)
      let $state := p:consume(45, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(57, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(52, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1(11, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: S :)
          let $state := p:consume(21, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(7, $input, $state)         (: '>' :)
      let $state := p:consume(57, $input, $state)           (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemConstructor", $count, $begin, $end)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirectConstructor", $count, $begin, $end)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50                             (: '<' :)
          or $state[$p:l1] = 51                             (: '<!--' :)
          or $state[$p:l1] = 55) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComputedConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Constructor", $count, $begin, $end)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(192, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnorderedExpr", $count, $begin, $end)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(155, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderedExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38) then                           (: ',' :)
      $state
    else
      let $state := p:consume(38, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(186, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | ')' | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionCall", $count, $begin, $end)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(41, $input, $state)               (: '.' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemExpr", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(186, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | ')' | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedExpr", $count, $begin, $end)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarRef", $count, $begin, $end)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (96,                                (: 'document' :)
                         155,                               (: 'ordered' :)
                         192)) then                         (: 'unordered' :)
      let $state := p:lookahead2W(75, $input, $state)       (: S^WS | '(' | ('(' ':') | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2                              (: IntegerLiteral :)
          or $state[$p:lk] = 3                              (: DecimalLiteral :)
          or $state[$p:lk] = 4                              (: DoubleLiteral :)
          or $state[$p:lk] = 5) then                        (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 28) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 30) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 41) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 52891) then                    (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 52928) then                    (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 50                             (: '<' :)
          or $state[$p:lk] = 51                             (: '<!--' :)
          or $state[$p:lk] = 55                             (: '<?' :)
          or $state[$p:lk] = 73                             (: 'attribute' :)
          or $state[$p:lk] = 82                             (: 'comment' :)
          or $state[$p:lk] = 98                             (: 'element' :)
          or $state[$p:lk] = 164                            (: 'processing-instruction' :)
          or $state[$p:lk] = 184                            (: 'text' :)
          or $state[$p:lk] = 52832) then                    (: 'document' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Constructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionCall($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpr", $count, $begin, $end)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(165, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '|' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FilterExpr", $count, $begin, $end)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 73) then                           (: 'attribute' :)
      let $state := p:lookahead2W(190, $input, $state)      (: EOF | QName^Token | S^WS | '!=' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'module' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' | '|' |
                                                               '}' :)
      let $state :=
        if ($state[$p:lk] eq 19785) then                    (: 'attribute' 'case' :)
          let $state := p:lookahead3W(181, $input, $state)  (: QName^Token | S^WS | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 20809) then               (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(69, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 21577) then               (: 'attribute' 'contains' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 22601) then               (: 'attribute' 'default' :)
          let $state := p:lookahead3W(108, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 25673) then               (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 28745) then               (: 'attribute' 'for' :)
          let $state := p:lookahead3W(73, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 32841) then               (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(100, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 34889) then               (: 'attribute' 'let' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | '$' | ('(' ':') | 'score' | '{' :)
          return $state
        else if ($state[$p:lk] eq 39497) then               (: 'attribute' 'order' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] eq 45641) then               (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18249,                    (: 'attribute' 'ascending' :)
                                  23369)) then              (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(126, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (35145,                    (: 'attribute' 'levels' :)
                                  47945)) then              (: 'attribute' 'times' :)
          let $state := p:lookahead3W(149, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'using' | 'weight' | 'where' |
                                                               'window' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (20041,                    (: 'attribute' 'cast' :)
                                  20297,                    (: 'attribute' 'castable' :)
                                  48457)) then              (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (40521,                    (: 'attribute' 'paragraphs' :)
                                  45129,                    (: 'attribute' 'sentences' :)
                                  52297)) then              (: 'attribute' 'words' :)
          let $state := p:lookahead3W(144, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ge' | 'gt' | 'is' |
                                                               'le' | 'let' | 'lt' | 'ne' | 'or' | 'order' | 'ordered' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'where' |
                                                               'window' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (17481,                    (: 'attribute' 'and' :)
                                  24393,                    (: 'attribute' 'div' :)
                                  25417,                    (: 'attribute' 'else' :)
                                  26953,                    (: 'attribute' 'eq' :)
                                  27721,                    (: 'attribute' 'except' :)
                                  30537,                    (: 'attribute' 'ge' :)
                                  31049,                    (: 'attribute' 'gt' :)
                                  31305,                    (: 'attribute' 'idiv' :)
                                  33097,                    (: 'attribute' 'intersect' :)
                                  33353,                    (: 'attribute' 'is' :)
                                  34377,                    (: 'attribute' 'le' :)
                                  35657,                    (: 'attribute' 'lt' :)
                                  35913,                    (: 'attribute' 'mod' :)
                                  36937,                    (: 'attribute' 'ne' :)
                                  39241,                    (: 'attribute' 'or' :)
                                  42569,                    (: 'attribute' 'return' :)
                                  43081,                    (: 'attribute' 'satisfies' :)
                                  48201,                    (: 'attribute' 'to' :)
                                  48969,                    (: 'attribute' 'union' :)
                                  51017)) then              (: 'attribute' 'where' :)
          let $state := p:lookahead3W(187, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 98) then                      (: 'element' :)
      let $state := p:lookahead2W(189, $input, $state)      (: EOF | QName^Token | S^WS | '!=' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' | '|' |
                                                               '}' :)
      let $state :=
        if ($state[$p:lk] eq 19810) then                    (: 'element' 'case' :)
          let $state := p:lookahead3W(181, $input, $state)  (: QName^Token | S^WS | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 20834) then               (: 'element' 'collation' :)
          let $state := p:lookahead3W(69, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 21602) then               (: 'element' 'contains' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 22626) then               (: 'element' 'default' :)
          let $state := p:lookahead3W(108, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 25698) then               (: 'element' 'empty' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 28770) then               (: 'element' 'for' :)
          let $state := p:lookahead3W(73, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 32866) then               (: 'element' 'instance' :)
          let $state := p:lookahead3W(100, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 34914) then               (: 'element' 'let' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | '$' | ('(' ':') | 'score' | '{' :)
          return $state
        else if ($state[$p:lk] eq 39522) then               (: 'element' 'order' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] eq 45666) then               (: 'element' 'stable' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18274,                    (: 'element' 'ascending' :)
                                  23394)) then              (: 'element' 'descending' :)
          let $state := p:lookahead3W(126, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (35170,                    (: 'element' 'levels' :)
                                  47970)) then              (: 'element' 'times' :)
          let $state := p:lookahead3W(149, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'using' | 'weight' | 'where' |
                                                               'window' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (20066,                    (: 'element' 'cast' :)
                                  20322,                    (: 'element' 'castable' :)
                                  48482)) then              (: 'element' 'treat' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (40546,                    (: 'element' 'paragraphs' :)
                                  45154,                    (: 'element' 'sentences' :)
                                  52322)) then              (: 'element' 'words' :)
          let $state := p:lookahead3W(144, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ge' | 'gt' | 'is' |
                                                               'le' | 'let' | 'lt' | 'ne' | 'or' | 'order' | 'ordered' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'where' |
                                                               'window' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (17506,                    (: 'element' 'and' :)
                                  24418,                    (: 'element' 'div' :)
                                  25442,                    (: 'element' 'else' :)
                                  26978,                    (: 'element' 'eq' :)
                                  27746,                    (: 'element' 'except' :)
                                  30562,                    (: 'element' 'ge' :)
                                  31074,                    (: 'element' 'gt' :)
                                  31330,                    (: 'element' 'idiv' :)
                                  33122,                    (: 'element' 'intersect' :)
                                  33378,                    (: 'element' 'is' :)
                                  34402,                    (: 'element' 'le' :)
                                  35682,                    (: 'element' 'lt' :)
                                  35938,                    (: 'element' 'mod' :)
                                  36962,                    (: 'element' 'ne' :)
                                  39266,                    (: 'element' 'or' :)
                                  42594,                    (: 'element' 'return' :)
                                  43106,                    (: 'element' 'satisfies' :)
                                  48226,                    (: 'element' 'to' :)
                                  48994,                    (: 'element' 'union' :)
                                  51042)) then              (: 'element' 'where' :)
          let $state := p:lookahead3W(187, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 164) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(170, $input, $state)      (: EOF | NCName^Token | S^WS | '!=' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'levels' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'treat' |
                                                               'union' | 'where' | 'words' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 19876) then                    (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(181, $input, $state)  (: QName^Token | S^WS | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 20900) then               (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(69, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 21668) then               (: 'processing-instruction' 'contains' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 22692) then               (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(108, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 25764) then               (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 28836) then               (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(73, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 32932) then               (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(100, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 34980) then               (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | '$' | ('(' ':') | 'score' | '{' :)
          return $state
        else if ($state[$p:lk] eq 39588) then               (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] eq 45732) then               (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (18340,                    (: 'processing-instruction' 'ascending' :)
                                  23460)) then              (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(126, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (35236,                    (: 'processing-instruction' 'levels' :)
                                  48036)) then              (: 'processing-instruction' 'times' :)
          let $state := p:lookahead3W(149, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'using' | 'weight' | 'where' |
                                                               'window' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (20132,                    (: 'processing-instruction' 'cast' :)
                                  20388,                    (: 'processing-instruction' 'castable' :)
                                  48548)) then              (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (40612,                    (: 'processing-instruction' 'paragraphs' :)
                                  45220,                    (: 'processing-instruction' 'sentences' :)
                                  52388)) then              (: 'processing-instruction' 'words' :)
          let $state := p:lookahead3W(144, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ge' | 'gt' | 'is' |
                                                               'le' | 'let' | 'lt' | 'ne' | 'or' | 'order' | 'ordered' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'where' |
                                                               'window' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (17572,                    (: 'processing-instruction' 'and' :)
                                  24484,                    (: 'processing-instruction' 'div' :)
                                  25508,                    (: 'processing-instruction' 'else' :)
                                  27044,                    (: 'processing-instruction' 'eq' :)
                                  27812,                    (: 'processing-instruction' 'except' :)
                                  30628,                    (: 'processing-instruction' 'ge' :)
                                  31140,                    (: 'processing-instruction' 'gt' :)
                                  31396,                    (: 'processing-instruction' 'idiv' :)
                                  33188,                    (: 'processing-instruction' 'intersect' :)
                                  33444,                    (: 'processing-instruction' 'is' :)
                                  34468,                    (: 'processing-instruction' 'le' :)
                                  35748,                    (: 'processing-instruction' 'lt' :)
                                  36004,                    (: 'processing-instruction' 'mod' :)
                                  37028,                    (: 'processing-instruction' 'ne' :)
                                  39332,                    (: 'processing-instruction' 'or' :)
                                  42660,                    (: 'processing-instruction' 'return' :)
                                  43172,                    (: 'processing-instruction' 'satisfies' :)
                                  48292,                    (: 'processing-instruction' 'to' :)
                                  49060,                    (: 'processing-instruction' 'union' :)
                                  51108)) then              (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(187, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (82,                           (: 'comment' :)
                              96,                           (: 'document' :)
                              155,                          (: 'ordered' :)
                              184,                          (: 'text' :)
                              192)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(169, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (66,                           (: 'ancestor' :)
                              67,                           (: 'ancestor-or-self' :)
                              80,                           (: 'child' :)
                              89,                           (: 'descendant' :)
                              90,                           (: 'descendant-or-self' :)
                              110,                          (: 'following' :)
                              111,                          (: 'following-sibling' :)
                              159,                          (: 'parent' :)
                              161,                          (: 'preceding' :)
                              162,                          (: 'preceding-sibling' :)
                              173)) then                    (: 'self' :)
      let $state := p:lookahead2W(168, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'levels' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'treat' |
                                                               'union' | 'where' | 'words' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (20,                           (: QName^Token :)
                              68,                           (: 'and' :)
                              71,                           (: 'ascending' :)
                              77,                           (: 'case' :)
                              78,                           (: 'cast' :)
                              79,                           (: 'castable' :)
                              81,                           (: 'collation' :)
                              84,                           (: 'contains' :)
                              87,                           (: 'declare' :)
                              88,                           (: 'default' :)
                              91,                           (: 'descending' :)
                              95,                           (: 'div' :)
                              99,                           (: 'else' :)
                              100,                          (: 'empty' :)
                              105,                          (: 'eq' :)
                              106,                          (: 'every' :)
                              108,                          (: 'except' :)
                              112,                          (: 'for' :)
                              119,                          (: 'ge' :)
                              121,                          (: 'gt' :)
                              122,                          (: 'idiv' :)
                              124,                          (: 'import' :)
                              128,                          (: 'instance' :)
                              129,                          (: 'intersect' :)
                              130,                          (: 'is' :)
                              134,                          (: 'le' :)
                              136,                          (: 'let' :)
                              137,                          (: 'levels' :)
                              139,                          (: 'lt' :)
                              140,                          (: 'mod' :)
                              141,                          (: 'module' :)
                              144,                          (: 'ne' :)
                              153,                          (: 'or' :)
                              154,                          (: 'order' :)
                              158,                          (: 'paragraphs' :)
                              166,                          (: 'return' :)
                              168,                          (: 'satisfies' :)
                              176,                          (: 'sentences' :)
                              177,                          (: 'some' :)
                              178,                          (: 'stable' :)
                              187,                          (: 'times' :)
                              188,                          (: 'to' :)
                              189,                          (: 'treat' :)
                              191,                          (: 'union' :)
                              195,                          (: 'validate' :)
                              199,                          (: 'where' :)
                              204,                          (: 'words' :)
                              205)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(166, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2                              (: IntegerLiteral :)
          or $state[$p:lk] = 3                              (: DecimalLiteral :)
          or $state[$p:lk] = 4                              (: DoubleLiteral :)
          or $state[$p:lk] = 5                              (: StringLiteral :)
          or $state[$p:lk] = 28                             (: '$' :)
          or $state[$p:lk] = 30                             (: '(' :)
          or $state[$p:lk] = 41                             (: '.' :)
          or $state[$p:lk] = 50                             (: '<' :)
          or $state[$p:lk] = 51                             (: '<!--' :)
          or $state[$p:lk] = 55                             (: '<?' :)
          or $state[$p:lk] = 5028                           (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 5193                           (: 'attribute' QName^Token :)
          or $state[$p:lk] = 5218                           (: 'element' QName^Token :)
          or $state[$p:lk] = 7700                           (: QName^Token '(' :)
          or $state[$p:lk] = 7746                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 7747                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 7748                           (: 'and' '(' :)
          or $state[$p:lk] = 7751                           (: 'ascending' '(' :)
          or $state[$p:lk] = 7757                           (: 'case' '(' :)
          or $state[$p:lk] = 7758                           (: 'cast' '(' :)
          or $state[$p:lk] = 7759                           (: 'castable' '(' :)
          or $state[$p:lk] = 7760                           (: 'child' '(' :)
          or $state[$p:lk] = 7761                           (: 'collation' '(' :)
          or $state[$p:lk] = 7764                           (: 'contains' '(' :)
          or $state[$p:lk] = 7767                           (: 'declare' '(' :)
          or $state[$p:lk] = 7768                           (: 'default' '(' :)
          or $state[$p:lk] = 7769                           (: 'descendant' '(' :)
          or $state[$p:lk] = 7770                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 7771                           (: 'descending' '(' :)
          or $state[$p:lk] = 7775                           (: 'div' '(' :)
          or $state[$p:lk] = 7776                           (: 'document' '(' :)
          or $state[$p:lk] = 7779                           (: 'else' '(' :)
          or $state[$p:lk] = 7780                           (: 'empty' '(' :)
          or $state[$p:lk] = 7785                           (: 'eq' '(' :)
          or $state[$p:lk] = 7786                           (: 'every' '(' :)
          or $state[$p:lk] = 7788                           (: 'except' '(' :)
          or $state[$p:lk] = 7790                           (: 'following' '(' :)
          or $state[$p:lk] = 7791                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 7792                           (: 'for' '(' :)
          or $state[$p:lk] = 7799                           (: 'ge' '(' :)
          or $state[$p:lk] = 7801                           (: 'gt' '(' :)
          or $state[$p:lk] = 7802                           (: 'idiv' '(' :)
          or $state[$p:lk] = 7804                           (: 'import' '(' :)
          or $state[$p:lk] = 7808                           (: 'instance' '(' :)
          or $state[$p:lk] = 7809                           (: 'intersect' '(' :)
          or $state[$p:lk] = 7810                           (: 'is' '(' :)
          or $state[$p:lk] = 7814                           (: 'le' '(' :)
          or $state[$p:lk] = 7816                           (: 'let' '(' :)
          or $state[$p:lk] = 7817                           (: 'levels' '(' :)
          or $state[$p:lk] = 7819                           (: 'lt' '(' :)
          or $state[$p:lk] = 7820                           (: 'mod' '(' :)
          or $state[$p:lk] = 7821                           (: 'module' '(' :)
          or $state[$p:lk] = 7824                           (: 'ne' '(' :)
          or $state[$p:lk] = 7833                           (: 'or' '(' :)
          or $state[$p:lk] = 7834                           (: 'order' '(' :)
          or $state[$p:lk] = 7835                           (: 'ordered' '(' :)
          or $state[$p:lk] = 7838                           (: 'paragraphs' '(' :)
          or $state[$p:lk] = 7839                           (: 'parent' '(' :)
          or $state[$p:lk] = 7841                           (: 'preceding' '(' :)
          or $state[$p:lk] = 7842                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 7846                           (: 'return' '(' :)
          or $state[$p:lk] = 7848                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 7853                           (: 'self' '(' :)
          or $state[$p:lk] = 7856                           (: 'sentences' '(' :)
          or $state[$p:lk] = 7857                           (: 'some' '(' :)
          or $state[$p:lk] = 7858                           (: 'stable' '(' :)
          or $state[$p:lk] = 7867                           (: 'times' '(' :)
          or $state[$p:lk] = 7868                           (: 'to' '(' :)
          or $state[$p:lk] = 7869                           (: 'treat' '(' :)
          or $state[$p:lk] = 7871                           (: 'union' '(' :)
          or $state[$p:lk] = 7872                           (: 'unordered' '(' :)
          or $state[$p:lk] = 7875                           (: 'validate' '(' :)
          or $state[$p:lk] = 7879                           (: 'where' '(' :)
          or $state[$p:lk] = 7884                           (: 'words' '(' :)
          or $state[$p:lk] = 7885                           (: 'xquery' '(' :)
          or $state[$p:lk] = 16969                          (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 16994                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 17225                          (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 17250                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 18761                          (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 18786                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 20553                          (: 'attribute' 'child' :)
          or $state[$p:lk] = 20578                          (: 'element' 'child' :)
          or $state[$p:lk] = 21065                          (: 'attribute' 'comment' :)
          or $state[$p:lk] = 21090                          (: 'element' 'comment' :)
          or $state[$p:lk] = 22345                          (: 'attribute' 'declare' :)
          or $state[$p:lk] = 22370                          (: 'element' 'declare' :)
          or $state[$p:lk] = 22857                          (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 22882                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 23113                          (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 23138                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 24649                          (: 'attribute' 'document' :)
          or $state[$p:lk] = 24674                          (: 'element' 'document' :)
          or $state[$p:lk] = 24905                          (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 24930                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 25161                          (: 'attribute' 'element' :)
          or $state[$p:lk] = 25186                          (: 'element' 'element' :)
          or $state[$p:lk] = 25929                          (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 25954                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 27209                          (: 'attribute' 'every' :)
          or $state[$p:lk] = 27234                          (: 'element' 'every' :)
          or $state[$p:lk] = 28233                          (: 'attribute' 'following' :)
          or $state[$p:lk] = 28258                          (: 'element' 'following' :)
          or $state[$p:lk] = 28489                          (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 28514                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 31561                          (: 'attribute' 'if' :)
          or $state[$p:lk] = 31586                          (: 'element' 'if' :)
          or $state[$p:lk] = 31817                          (: 'attribute' 'import' :)
          or $state[$p:lk] = 31842                          (: 'element' 'import' :)
          or $state[$p:lk] = 33609                          (: 'attribute' 'item' :)
          or $state[$p:lk] = 33634                          (: 'element' 'item' :)
          or $state[$p:lk] = 36169                          (: 'attribute' 'module' :)
          or $state[$p:lk] = 36194                          (: 'element' 'module' :)
          or $state[$p:lk] = 37961                          (: 'attribute' 'node' :)
          or $state[$p:lk] = 37986                          (: 'element' 'node' :)
          or $state[$p:lk] = 39753                          (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 39778                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 40777                          (: 'attribute' 'parent' :)
          or $state[$p:lk] = 40802                          (: 'element' 'parent' :)
          or $state[$p:lk] = 41289                          (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 41314                          (: 'element' 'preceding' :)
          or $state[$p:lk] = 41545                          (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 41570                          (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 42057                          (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 42082                          (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 43593                          (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 43618                          (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 43849                          (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 43874                          (: 'element' 'schema-element' :)
          or $state[$p:lk] = 44361                          (: 'attribute' 'self' :)
          or $state[$p:lk] = 44386                          (: 'element' 'self' :)
          or $state[$p:lk] = 45385                          (: 'attribute' 'some' :)
          or $state[$p:lk] = 45410                          (: 'element' 'some' :)
          or $state[$p:lk] = 47177                          (: 'attribute' 'text' :)
          or $state[$p:lk] = 47202                          (: 'element' 'text' :)
          or $state[$p:lk] = 48713                          (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 48738                          (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 49225                          (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 49250                          (: 'element' 'unordered' :)
          or $state[$p:lk] = 49993                          (: 'attribute' 'validate' :)
          or $state[$p:lk] = 50018                          (: 'element' 'validate' :)
          or $state[$p:lk] = 52553                          (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 52578                          (: 'element' 'xquery' :)
          or $state[$p:lk] = 52809                          (: 'attribute' '{' :)
          or $state[$p:lk] = 52818                          (: 'comment' '{' :)
          or $state[$p:lk] = 52832                          (: 'document' '{' :)
          or $state[$p:lk] = 52834                          (: 'element' '{' :)
          or $state[$p:lk] = 52891                          (: 'ordered' '{' :)
          or $state[$p:lk] = 52900                          (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 52920                          (: 'text' '{' :)
          or $state[$p:lk] = 52928                          (: 'unordered' '{' :)
          or $state[$p:lk] = 13517897                       (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 13517922                       (: 'element' 'and' '{' :)
          or $state[$p:lk] = 13517988                       (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 13518665                       (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 13518690                       (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 13518756                       (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 13520201                       (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 13520226                       (: 'element' 'case' '{' :)
          or $state[$p:lk] = 13520292                       (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 13520457                       (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 13520482                       (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 13520548                       (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 13520713                       (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 13520738                       (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 13520804                       (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 13521225                       (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 13521250                       (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 13521316                       (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 13521993                       (: 'attribute' 'contains' '{' :)
          or $state[$p:lk] = 13522018                       (: 'element' 'contains' '{' :)
          or $state[$p:lk] = 13522084                       (: 'processing-instruction' 'contains' '{' :)
          or $state[$p:lk] = 13523017                       (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 13523042                       (: 'element' 'default' '{' :)
          or $state[$p:lk] = 13523108                       (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 13523785                       (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 13523810                       (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 13523876                       (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 13524809                       (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 13524834                       (: 'element' 'div' '{' :)
          or $state[$p:lk] = 13524900                       (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 13525833                       (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 13525858                       (: 'element' 'else' '{' :)
          or $state[$p:lk] = 13525924                       (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 13526089                       (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 13526114                       (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 13526180                       (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 13527369                       (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 13527394                       (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 13527460                       (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 13528137                       (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 13528162                       (: 'element' 'except' '{' :)
          or $state[$p:lk] = 13528228                       (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 13529161                       (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 13529186                       (: 'element' 'for' '{' :)
          or $state[$p:lk] = 13529252                       (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 13530953                       (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 13530978                       (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 13531044                       (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 13531465                       (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 13531490                       (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 13531556                       (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 13531721                       (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 13531746                       (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 13531812                       (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 13533257                       (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 13533282                       (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 13533348                       (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 13533513                       (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 13533538                       (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 13533604                       (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 13533769                       (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 13533794                       (: 'element' 'is' '{' :)
          or $state[$p:lk] = 13533860                       (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 13534793                       (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 13534818                       (: 'element' 'le' '{' :)
          or $state[$p:lk] = 13534884                       (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 13535305                       (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 13535330                       (: 'element' 'let' '{' :)
          or $state[$p:lk] = 13535396                       (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 13535561                       (: 'attribute' 'levels' '{' :)
          or $state[$p:lk] = 13535586                       (: 'element' 'levels' '{' :)
          or $state[$p:lk] = 13535652                       (: 'processing-instruction' 'levels' '{' :)
          or $state[$p:lk] = 13536073                       (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 13536098                       (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 13536164                       (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 13536329                       (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 13536354                       (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 13536420                       (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 13537353                       (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 13537378                       (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 13537444                       (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 13539657                       (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 13539682                       (: 'element' 'or' '{' :)
          or $state[$p:lk] = 13539748                       (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 13539913                       (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 13539938                       (: 'element' 'order' '{' :)
          or $state[$p:lk] = 13540004                       (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 13540937                       (: 'attribute' 'paragraphs' '{' :)
          or $state[$p:lk] = 13540962                       (: 'element' 'paragraphs' '{' :)
          or $state[$p:lk] = 13541028                       (: 'processing-instruction' 'paragraphs' '{' :)
          or $state[$p:lk] = 13542985                       (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 13543010                       (: 'element' 'return' '{' :)
          or $state[$p:lk] = 13543076                       (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 13543497                       (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 13543522                       (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 13543588                       (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 13545545                       (: 'attribute' 'sentences' '{' :)
          or $state[$p:lk] = 13545570                       (: 'element' 'sentences' '{' :)
          or $state[$p:lk] = 13545636                       (: 'processing-instruction' 'sentences' '{' :)
          or $state[$p:lk] = 13546057                       (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 13546082                       (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 13546148                       (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 13548361                       (: 'attribute' 'times' '{' :)
          or $state[$p:lk] = 13548386                       (: 'element' 'times' '{' :)
          or $state[$p:lk] = 13548452                       (: 'processing-instruction' 'times' '{' :)
          or $state[$p:lk] = 13548617                       (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 13548642                       (: 'element' 'to' '{' :)
          or $state[$p:lk] = 13548708                       (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 13548873                       (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 13548898                       (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 13548964                       (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 13549385                       (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 13549410                       (: 'element' 'union' '{' :)
          or $state[$p:lk] = 13549476                       (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 13551433                       (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 13551458                       (: 'element' 'where' '{' :)
          or $state[$p:lk] = 13551524                       (: 'processing-instruction' 'where' '{' :)
          or $state[$p:lk] = 13552713                       (: 'attribute' 'words' '{' :)
          or $state[$p:lk] = 13552738                       (: 'element' 'words' '{' :)
          or $state[$p:lk] = 13552804) then                 (: 'processing-instruction' 'words' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FilterExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AxisStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StepExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 43                                 (: '/' :)
    and $state[$p:l1] != 44) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 43) then                   (: '/' :)
          let $state := p:consume(43, $input, $state)       (: '/' :)
          return $state
        else
          let $state := p:consume(44, $input, $state)       (: '//' :)
          return $state
      let $state := p:lookahead1W(183, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | ('(' ':') | '.' | '..' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'levels' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'node' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'text' | 'times' | 'to' | 'treat' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelativePathExpr", $count, $begin, $end)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '/' :)
      let $state := p:consume(43, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(191, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | EOF | QName^Token | S^WS |
                                                               '!=' | '$' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '.' | '..' | ';' | '<' | '<!--' | '<<' | '<=' |
                                                               '<?' | '=' | '>' | '>=' | '>>' | '@' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 17                         (: EOF :)
              or $state[$p:l1] = 25                         (: '!=' :)
              or $state[$p:l1] = 33                         (: ')' :)
              or $state[$p:l1] = 34                         (: '*' :)
              or $state[$p:l1] = 36                         (: '+' :)
              or $state[$p:l1] = 38                         (: ',' :)
              or $state[$p:l1] = 39                         (: '-' :)
              or $state[$p:l1] = 49                         (: ';' :)
              or $state[$p:l1] = 53                         (: '<<' :)
              or $state[$p:l1] = 54                         (: '<=' :)
              or $state[$p:l1] = 56                         (: '=' :)
              or $state[$p:l1] = 57                         (: '>' :)
              or $state[$p:l1] = 58                         (: '>=' :)
              or $state[$p:l1] = 59                         (: '>>' :)
              or $state[$p:l1] = 64                         (: ']' :)
              or $state[$p:l1] = 208                        (: '|' :)
              or $state[$p:l1] = 209) then                  (: '}' :)
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 44) then                       (: '//' :)
      let $state := p:consume(44, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(183, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | ('(' ':') | '.' | '..' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'levels' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'node' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'text' | 'times' | 'to' | 'treat' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PathExpr", $count, $begin, $end)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 130) then                      (: 'is' :)
      let $state := p:consume(130, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<<' :)
      let $state := p:consume(53, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(59, $input, $state)           (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeComp", $count, $begin, $end)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 56) then                       (: '=' :)
      let $state := p:consume(56, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '!=' :)
      let $state := p:consume(25, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: '<' :)
      let $state := p:consume(50, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<=' :)
      let $state := p:consume(54, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '>' :)
      let $state := p:consume(57, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(58, $input, $state)           (: '>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GeneralComp", $count, $begin, $end)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: 'eq' :)
      let $state := p:consume(105, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'ne' :)
      let $state := p:consume(144, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:consume(139, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'le' :)
      let $state := p:consume(134, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'gt' :)
      let $state := p:consume(121, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(119, $input, $state)          (: 'ge' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueComp", $count, $begin, $end)
};

(:~
 : Parse FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(202, $input, $state)              (: 'without' :)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:consume(85, $input, $state)               (: 'content' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTIgnoreOption", $count, $begin, $end)
};

(:~
 : Parse FTContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 72) then                           (: 'at' :)
      let $state := p:lookahead2W(91, $input, $state)       (: S^WS | ('(' ':') | 'end' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 45896) then                    (: 'at' 'start' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'start' :)
      let $state := p:consume(179, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:lk] = 26440) then                    (: 'at' 'end' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | ('(' ':') | 'end' :)
      let $state := p:consume(103, $input, $state)          (: 'end' :)
      return $state
    else
      let $state := p:consume(104, $input, $state)          (: 'entire' :)
      let $state := p:lookahead1W(34, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:consume(85, $input, $state)           (: 'content' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTContent", $count, $begin, $end)
};

(:~
 : Parse FTBigUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 175) then                      (: 'sentence' :)
      let $state := p:consume(175, $input, $state)          (: 'sentence' :)
      return $state
    else
      let $state := p:consume(157, $input, $state)          (: 'paragraph' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTBigUnit", $count, $begin, $end)
};

(:~
 : Parse FTScope.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 167) then                      (: 'same' :)
      let $state := p:consume(167, $input, $state)          (: 'same' :)
      return $state
    else
      let $state := p:consume(93, $input, $state)           (: 'different' :)
      return $state
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTBigUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTScope", $count, $begin, $end)
};

(:~
 : Parse FTDistance.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(94, $input, $state)               (: 'distance' :)
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTRange($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTDistance", $count, $begin, $end)
};

(:~
 : Parse FTUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 204) then                      (: 'words' :)
      let $state := p:consume(204, $input, $state)          (: 'words' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'sentences' :)
      let $state := p:consume(176, $input, $state)          (: 'sentences' :)
      return $state
    else
      let $state := p:consume(158, $input, $state)          (: 'paragraphs' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTUnit", $count, $begin, $end)
};

(:~
 : Parse FTWindow.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(201, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWindow", $count, $begin, $end)
};

(:~
 : Parse FTOrder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(155, $input, $state)              (: 'ordered' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOrder", $count, $begin, $end)
};

(:~
 : Parse FTPosFilter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 155) then                      (: 'ordered' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'window' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'distance' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 93                             (: 'different' :)
          or $state[$p:l1] = 167) then                      (: 'same' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScope($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPosFilter", $count, $begin, $end)
};

(:~
 : Parse FTWeight.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(198, $input, $state)              (: 'weight' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWeight", $count, $begin, $end)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(175, $input, $state)           (: QName^Token | S | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'levels' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'node' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'text' | 'times' | 'to' | 'treat' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state := p:lookahead1(9, $input, $state)             (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: S :)
      let $state := p:consume(21, $input, $state)           (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:consume(12, $input, $state)           (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:consume(27, $input, $state)               (: '#)' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Pragma", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(76, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 31) then                         (: '(#' :)
        $state
      else
        p:parse-FTExtensionSelection-1($input, $state)
};

(:~
 : Parse FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTExtensionSelection-1($input, $state)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(133, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 209) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTExtensionSelection", $count, $begin, $end)
};

(:~
 : Parse FTTimes.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(150, $input, $state)              (: 'occurs' :)
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTRange($input, $state)
  let $state := p:consume(187, $input, $state)              (: 'times' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTTimes", $count, $begin, $end)
};

(:~
 : Parse FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'any' :)
      let $state := p:consume(69, $input, $state)           (: 'any' :)
      let $state := p:lookahead1W(152, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'occurs' | 'or' | 'order' | 'ordered' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'using' | 'weight' |
                                                               'where' | 'window' | 'without' | 'word' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 203) then                  (: 'word' :)
          let $state := p:consume(203, $input, $state)      (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'all' :)
      let $state := p:consume(65, $input, $state)           (: 'all' :)
      let $state := p:lookahead1W(153, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'occurs' | 'or' | 'order' | 'ordered' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'using' | 'weight' |
                                                               'where' | 'window' | 'without' | 'words' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 204) then                  (: 'words' :)
          let $state := p:consume(204, $input, $state)      (: 'words' :)
          return $state
        else
          $state
      return $state
    else
      let $state := p:consume(160, $input, $state)          (: 'phrase' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTAnyallOption", $count, $begin, $end)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: IntegerLiteral :)
      let $state := p:consume(2, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 3) then                        (: DecimalLiteral :)
      let $state := p:consume(3, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(4, $input, $state)            (: DoubleLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: StringLiteral :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Parse FTWordsValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 206) then                      (: '{' :)
      let $state := p:consume(206, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(209, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWordsValue", $count, $begin, $end)
};

(:~
 : Parse FTWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTWordsValue($input, $state)
  let $state := p:lookahead1W(156, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'all' |
                                                               'and' | 'any' | 'ascending' | 'at' | 'case' |
                                                               'collation' | 'default' | 'descending' | 'different' |
                                                               'distance' | 'else' | 'empty' | 'entire' | 'eq' | 'for' |
                                                               'ftand' | 'ftor' | 'ge' | 'gt' | 'is' | 'le' | 'let' |
                                                               'lt' | 'ne' | 'not' | 'occurs' | 'or' | 'order' |
                                                               'ordered' | 'phrase' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'using' | 'weight' | 'where' | 'window' |
                                                               'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65                             (: 'all' :)
          or $state[$p:l1] = 69                             (: 'any' :)
          or $state[$p:l1] = 160) then                      (: 'phrase' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTAnyallOption($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWords", $count, $begin, $end)
};

(:~
 : Parse FTPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '(' :)
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(131, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      let $state := p:consume(33, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTExtensionSelection($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWords($input, $state)
      let $state := p:lookahead1W(148, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'occurs' | 'or' | 'order' | 'ordered' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'using' | 'weight' |
                                                               'where' | 'window' | 'without' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 150) then                  (: 'occurs' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPrimary", $count, $begin, $end)
};

(:~
 : Parse FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTPrimary($input, $state)
  let $state := p:lookahead1W(147, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'using' | 'weight' | 'where' |
                                                               'window' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 194) then                      (: 'using' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 198) then                      (: 'weight' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWeight($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPrimaryWithOptions", $count, $begin, $end)
};

(:~
 : Parse FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 116) then                      (: 'ftnot' :)
      let $state := p:consume(116, $input, $state)          (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(130, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTPrimaryWithOptions($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTUnaryNot", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMildNot-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(145, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'where' | 'window' | 'without' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 149) then                        (: 'not' :)
        $state
      else
        let $state := p:consume(149, $input, $state)        (: 'not' :)
        let $state := p:lookahead1W(42, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:consume(125, $input, $state)        (: 'in' :)
        let $state := p:lookahead1W(131, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTUnaryNot($input, $state)
        return p:parse-FTMildNot-1($input, $state)
};

(:~
 : Parse FTMildNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnaryNot($input, $state)
  let $state := p:parse-FTMildNot-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMildNot", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnd-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 115) then                          (: 'ftand' :)
      $state
    else
      let $state := p:consume(115, $input, $state)          (: 'ftand' :)
      let $state := p:lookahead1W(131, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTMildNot($input, $state)
      return p:parse-FTAnd-1($input, $state)
};

(:~
 : Parse FTAnd.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTMildNot($input, $state)
  let $state := p:parse-FTAnd-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTAnd", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 117) then                          (: 'ftor' :)
      $state
    else
      let $state := p:consume(117, $input, $state)          (: 'ftor' :)
      let $state := p:lookahead1W(131, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTAnd($input, $state)
      return p:parse-FTOr-1($input, $state)
};

(:~
 : Parse FTOr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTAnd($input, $state)
  let $state := p:parse-FTOr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(143, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ge' | 'gt' | 'is' |
                                                               'le' | 'let' | 'lt' | 'ne' | 'or' | 'order' | 'ordered' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'where' |
                                                               'window' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 72                               (: 'at' :)
      and $state[$p:l1] != 93                               (: 'different' :)
      and $state[$p:l1] != 94                               (: 'distance' :)
      and $state[$p:l1] != 104                              (: 'entire' :)
      and $state[$p:l1] != 155                              (: 'ordered' :)
      and $state[$p:l1] != 167                              (: 'same' :)
      and $state[$p:l1] != 201) then                        (: 'window' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTPosFilter($input, $state)
        return p:parse-FTSelection-1($input, $state)
};

(:~
 : Parse FTSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTOr($input, $state)
  let $state := p:parse-FTSelection-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTSelection", $count, $begin, $end)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 188) then                      (: 'to' :)
      let $state := p:consume(188, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RangeExpr", $count, $begin, $end)
};

(:~
 : Parse FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-RangeExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'contains' :)
      let $state := p:consume(84, $input, $state)           (: 'contains' :)
      let $state := p:lookahead1W(58, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:consume(184, $input, $state)          (: 'text' :)
      let $state := p:lookahead1W(131, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 202) then                  (: 'without' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTContainsExpr", $count, $begin, $end)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25                             (: '!=' :)
          or $state[$p:l1] = 50                             (: '<' :)
          or $state[$p:l1] = 53                             (: '<<' :)
          or $state[$p:l1] = 54                             (: '<=' :)
          or $state[$p:l1] = 56                             (: '=' :)
          or $state[$p:l1] = 57                             (: '>' :)
          or $state[$p:l1] = 58                             (: '>=' :)
          or $state[$p:l1] = 59                             (: '>>' :)
          or $state[$p:l1] = 105                            (: 'eq' :)
          or $state[$p:l1] = 119                            (: 'ge' :)
          or $state[$p:l1] = 121                            (: 'gt' :)
          or $state[$p:l1] = 130                            (: 'is' :)
          or $state[$p:l1] = 134                            (: 'le' :)
          or $state[$p:l1] = 139                            (: 'lt' :)
          or $state[$p:l1] = 144) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 105                        (: 'eq' :)
              or $state[$p:l1] = 119                        (: 'ge' :)
              or $state[$p:l1] = 121                        (: 'gt' :)
              or $state[$p:l1] = 134                        (: 'le' :)
              or $state[$p:l1] = 139                        (: 'lt' :)
              or $state[$p:l1] = 144) then                  (: 'ne' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 53                         (: '<<' :)
              or $state[$p:l1] = 59                         (: '>>' :)
              or $state[$p:l1] = 130) then                  (: 'is' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeComp($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTContainsExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComparisonExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 68) then                           (: 'and' :)
      $state
    else
      let $state := p:consume(68, $input, $state)           (: 'and' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 153) then                          (: 'or' :)
      $state
    else
      let $state := p:consume(153, $input, $state)          (: 'or' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrExpr", $count, $begin, $end)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(123, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(185, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:consume(99, $input, $state)               (: 'else' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IfExpr", $count, $begin, $end)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(77, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(179, $input, $state)          (: QName^Token | S^WS | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:consume(28, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(166, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 77) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(190, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(88, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:consume(28, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(166, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeswitchExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38) then                           (: ',' :)
      $state
    else
      let $state := p:consume(38, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(18, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(28, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(85, $input, $state)       (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:consume(125, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 177) then                      (: 'some' :)
      let $state := p:consume(177, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(106, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(125, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(168, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QuantifiedExpr", $count, $begin, $end)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71                             (: 'ascending' :)
          or $state[$p:l1] = 91) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 71) then                   (: 'ascending' :)
          let $state := p:consume(71, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(91, $input, $state)       (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 100) then                      (: 'empty' :)
      let $state := p:consume(100, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(93, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 120) then                  (: 'greatest' :)
          let $state := p:consume(120, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(135, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:consume(81, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderModifier", $count, $begin, $end)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderModifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(80, $input, $state)         (: S^WS | ('(' ':') | ',' | 'return' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(184, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpecList", $count, $begin, $end)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 154) then                      (: 'order' :)
      let $state := p:consume(154, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(76, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(178, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(50, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(154, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(76, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderByClause", $count, $begin, $end)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(199, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhereClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38) then                           (: ',' :)
      $state
    else
      let $state := p:consume(38, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | '$' | ('(' ':') | 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: '$' :)
          let $state := p:consume(28, $input, $state)       (: '$' :)
          let $state := p:lookahead1W(176, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarName($input, $state)
          let $state := p:lookahead1W(81, $input, $state)   (: S^WS | ('(' ':') | ':=' | 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 70) then               (: 'as' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-TypeDeclaration($input, $state)
              return $state
            else
              $state
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTScoreVar($input, $state)
          return $state
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:consume(48, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(136, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | '$' | ('(' ':') | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:consume(28, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(81, $input, $state)       (: S^WS | ('(' ':') | ':=' | 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScoreVar($input, $state)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(48, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetClause", $count, $begin, $end)
};

(:~
 : Parse FTScoreVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTScoreVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(172, $input, $state)              (: 'score' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTScoreVar", $count, $begin, $end)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(72, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PositionalVar", $count, $begin, $end)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '?' :)
      let $state := p:consume(60, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:consume(35, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(37, $input, $state)           (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OccurrenceIndicator", $count, $begin, $end)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AtomicType", $count, $begin, $end)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(148, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyKindTest", $count, $begin, $end)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(184, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TextTest", $count, $begin, $end)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(82, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CommentTest", $count, $begin, $end)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(164, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(142, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'levels' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'treat' |
                                                               'union' | 'where' | 'words' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 5) then                    (: StringLiteral :)
          let $state := p:consume(5, $input, $state)        (: StringLiteral :)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PITest", $count, $begin, $end)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(170, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaAttributeTest", $count, $begin, $end)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeName", $count, $begin, $end)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '*' :)
      let $state := p:consume(34, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AttribNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(73, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(182, $input, $state)          (: QName^Token | S^WS | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(77, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: ',' :)
          let $state := p:consume(38, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(176, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeTest", $count, $begin, $end)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(171, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaElementTest", $count, $begin, $end)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeName", $count, $begin, $end)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementName", $count, $begin, $end)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '*' :)
      let $state := p:consume(34, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(98, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(182, $input, $state)          (: QName^Token | S^WS | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(77, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: ',' :)
          let $state := p:consume(38, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(176, $input, $state)  (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(78, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 60) then               (: '?' :)
              let $state := p:consume(60, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementTest", $count, $begin, $end)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(97, $input, $state)               (: 'document-node' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 98) then                   (: 'element' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(33, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DocumentTest", $count, $begin, $end)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 97) then                       (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TextTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyKindTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KindTest", $count, $begin, $end)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (73,                                (: 'attribute' :)
                         82,                                (: 'comment' :)
                         97,                                (: 'document-node' :)
                         98,                                (: 'element' :)
                         131,                               (: 'item' :)
                         148,                               (: 'node' :)
                         164,                               (: 'processing-instruction' :)
                         170,                               (: 'schema-attribute' :)
                         171,                               (: 'schema-element' :)
                         184)) then                         (: 'text' :)
      let $state := p:lookahead2W(172, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'external' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'union' |
                                                               'where' | 'words' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7753                           (: 'attribute' '(' :)
          or $state[$p:lk] = 7762                           (: 'comment' '(' :)
          or $state[$p:lk] = 7777                           (: 'document-node' '(' :)
          or $state[$p:lk] = 7778                           (: 'element' '(' :)
          or $state[$p:lk] = 7828                           (: 'node' '(' :)
          or $state[$p:lk] = 7844                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 7850                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 7851                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 7864) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 7811) then                     (: 'item' '(' :)
      let $state := p:consume(131, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(19, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(33, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AtomicType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ItemType", $count, $begin, $end)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 101) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(172, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'external' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'union' |
                                                               'where' | 'words' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7781) then                     (: 'empty-sequence' '(' :)
      let $state := p:consume(101, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(19, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(33, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(171, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'contains' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'in' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'union' |
                                                               'where' | 'words' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35                         (: '*' :)
              or $state[$p:l1] = 37                         (: '+' :)
              or $state[$p:l1] = 60) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceType", $count, $begin, $end)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(70, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 20) then                       (: QName^Token :)
      let $state := p:consume(20, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ancestor' :)
      let $state := p:consume(66, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(67, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'and' :)
      let $state := p:consume(68, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ascending' :)
      let $state := p:consume(71, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'case' :)
      let $state := p:consume(77, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'cast' :)
      let $state := p:consume(78, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'castable' :)
      let $state := p:consume(79, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'child' :)
      let $state := p:consume(80, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:consume(81, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'contains' :)
      let $state := p:consume(84, $input, $state)           (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'declare' :)
      let $state := p:consume(87, $input, $state)           (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'default' :)
      let $state := p:consume(88, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'descendant' :)
      let $state := p:consume(89, $input, $state)           (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'descendant-or-self' :)
      let $state := p:consume(90, $input, $state)           (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descending' :)
      let $state := p:consume(91, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'div' :)
      let $state := p:consume(95, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'document' :)
      let $state := p:consume(96, $input, $state)           (: 'document' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'else' :)
      let $state := p:consume(99, $input, $state)           (: 'else' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'empty' :)
      let $state := p:consume(100, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'eq' :)
      let $state := p:consume(105, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'every' :)
      let $state := p:consume(106, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'except' :)
      let $state := p:consume(108, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'following' :)
      let $state := p:consume(110, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'following-sibling' :)
      let $state := p:consume(111, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'for' :)
      let $state := p:consume(112, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'ge' :)
      let $state := p:consume(119, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'gt' :)
      let $state := p:consume(121, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'idiv' :)
      let $state := p:consume(122, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'import' :)
      let $state := p:consume(124, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'instance' :)
      let $state := p:consume(128, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'intersect' :)
      let $state := p:consume(129, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'is' :)
      let $state := p:consume(130, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'le' :)
      let $state := p:consume(134, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'let' :)
      let $state := p:consume(136, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'levels' :)
      let $state := p:consume(137, $input, $state)          (: 'levels' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:consume(139, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'mod' :)
      let $state := p:consume(140, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'module' :)
      let $state := p:consume(141, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'ne' :)
      let $state := p:consume(144, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'or' :)
      let $state := p:consume(153, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'order' :)
      let $state := p:consume(154, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'ordered' :)
      let $state := p:consume(155, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'paragraphs' :)
      let $state := p:consume(158, $input, $state)          (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'parent' :)
      let $state := p:consume(159, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'preceding' :)
      let $state := p:consume(161, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'preceding-sibling' :)
      let $state := p:consume(162, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'return' :)
      let $state := p:consume(166, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'satisfies' :)
      let $state := p:consume(168, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:consume(173, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'sentences' :)
      let $state := p:consume(176, $input, $state)          (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'some' :)
      let $state := p:consume(177, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'stable' :)
      let $state := p:consume(178, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'times' :)
      let $state := p:consume(187, $input, $state)          (: 'times' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'to' :)
      let $state := p:consume(188, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'treat' :)
      let $state := p:consume(189, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'union' :)
      let $state := p:consume(191, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'unordered' :)
      let $state := p:consume(192, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 195) then                      (: 'validate' :)
      let $state := p:consume(195, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: 'where' :)
      let $state := p:consume(199, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:l1] = 204) then                      (: 'words' :)
      let $state := p:consume(204, $input, $state)          (: 'words' :)
      return $state
    else
      let $state := p:consume(205, $input, $state)          (: 'xquery' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionName", $count, $begin, $end)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(174, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'levels' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'node' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'text' | 'times' | 'to' | 'treat' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'attribute' :)
      let $state := p:consume(73, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:consume(82, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'document-node' :)
      let $state := p:consume(97, $input, $state)           (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'element' :)
      let $state := p:consume(98, $input, $state)           (: 'element' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'empty-sequence' :)
      let $state := p:consume(101, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'if' :)
      let $state := p:consume(123, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'item' :)
      let $state := p:consume(131, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'node' :)
      let $state := p:consume(148, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'processing-instruction' :)
      let $state := p:consume(164, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'schema-attribute' :)
      let $state := p:consume(170, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'schema-element' :)
      let $state := p:consume(171, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'text' :)
      let $state := p:consume(184, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'typeswitch' :)
      let $state := p:consume(190, $input, $state)          (: 'typeswitch' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QName", $count, $begin, $end)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarName", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38) then                           (: ',' :)
      $state
    else
      let $state := p:consume(38, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(18, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(28, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(122, $input, $state)      (: S^WS | ('(' ':') | 'as' | 'at' | 'in' | 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(117, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'in' | 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 72) then                   (: 'at' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-PositionalVar($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(94, $input, $state)       (: S^WS | ('(' ':') | 'in' | 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 172) then                  (: 'score' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTScoreVar($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:consume(125, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(112, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(176, $input, $state)          (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(94, $input, $state)           (: S^WS | ('(' ':') | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 172) then                      (: 'score' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScoreVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(125, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FLWORExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 112) then                    (: 'for' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ForClause($input, $state)
        return $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-LetClause($input, $state)
        return $state
    return
      if ($state[$p:l1] != 112                              (: 'for' :)
      and $state[$p:l1] != 136) then                        (: 'let' :)
        $state
      else
        p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 199) then                      (: 'where' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhereClause($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 166) then                     (: 'return' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderByClause($input, $state)
      return $state
    else
      $state
  let $state := p:consume(166, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FLWORExpr", $count, $begin, $end)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'let' :)
      let $state := p:lookahead2W(164, $input, $state)      (: EOF | S^WS | '!=' | '$' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'score' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (123,                          (: 'if' :)
                              190)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(159, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = (106,                          (: 'every' :)
                              112,                          (: 'for' :)
                              177)) then                    (: 'some' :)
      let $state := p:lookahead2W(161, $input, $state)      (: EOF | S^WS | '!=' | '$' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7280                           (: 'for' '$' :)
          or $state[$p:lk] = 7304                           (: 'let' '$' :)
          or $state[$p:lk] = 44168) then                    (: 'let' 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7274                           (: 'every' '$' :)
          or $state[$p:lk] = 7345) then                     (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7870) then                     (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7803) then                     (: 'if' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IfExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExprSingle", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38) then                           (: ',' :)
      $state
    else
      let $state := p:consume(38, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expr", $count, $begin, $end)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 133) then                      (: 'lax' :)
      let $state := p:consume(133, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(182, $input, $state)          (: 'strict' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidationMode", $count, $begin, $end)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(195, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 206) then                     (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidationMode($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(206, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(209, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidateExpr", $count, $begin, $end)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 195) then                          (: 'validate' :)
      let $state := p:lookahead2W(173, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'lax' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'strict' | 'times' | 'to' | 'treat' |
                                                               'union' | 'where' | 'words' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 34243                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 46787                          (: 'validate' 'strict' :)
          or $state[$p:lk] = 52931) then                    (: 'validate' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(184, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
    return
      if ($state[$p:l1] != 36                               (: '+' :)
      and $state[$p:l1] != 39) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 39) then                 (: '-' :)
            let $state := p:consume(39, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(36, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpr", $count, $begin, $end)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(163, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'levels' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'words' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'cast' :)
      let $state := p:consume(78, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpr", $count, $begin, $end)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(160, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'contains' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'levels' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'times' | 'to' | 'treat' |
                                                               'union' | 'where' | 'words' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 79) then                       (: 'castable' :)
      let $state := p:consume(79, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastableExpr", $count, $begin, $end)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(158, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'contains' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: 'treat' :)
      let $state := p:consume(189, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(70, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TreatExpr", $count, $begin, $end)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(157, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'contains' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'union' | 'where' | 'words' |
                                                               '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 128) then                      (: 'instance' :)
      let $state := p:consume(128, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(151, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(176, $input, $state)      (: QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceofExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(155, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'contains' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'intersect' | 'is' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'times' | 'to' | 'union' | 'where' | 'words' | '|' | '}' :)
    return
      if ($state[$p:l1] != 108                              (: 'except' :)
      and $state[$p:l1] != 129) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 129) then                (: 'intersect' :)
            let $state := p:consume(129, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(108, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(184, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntersectExceptExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 191                                (: 'union' :)
    and $state[$p:l1] != 208) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 191) then                  (: 'union' :)
          let $state := p:consume(191, $input, $state)      (: 'union' :)
          return $state
        else
          let $state := p:consume(208, $input, $state)      (: '|' :)
          return $state
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 34                                 (: '*' :)
    and $state[$p:l1] != 95                                 (: 'div' :)
    and $state[$p:l1] != 122                                (: 'idiv' :)
    and $state[$p:l1] != 140) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '*' :)
          let $state := p:consume(34, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 95) then                   (: 'div' :)
          let $state := p:consume(95, $input, $state)       (: 'div' :)
          return $state
        else if ($state[$p:l1] = 122) then                  (: 'idiv' :)
          let $state := p:consume(122, $input, $state)      (: 'idiv' :)
          return $state
        else
          let $state := p:consume(140, $input, $state)      (: 'mod' :)
          return $state
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 36                                 (: '+' :)
    and $state[$p:l1] != 39) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 36) then                   (: '+' :)
          let $state := p:consume(36, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(39, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpr", $count, $begin, $end)
};

(:~
 : Parse FTRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 72) then                           (: 'at' :)
      let $state := p:lookahead2W(97, $input, $state)       (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 107) then                      (: 'exactly' :)
      let $state := p:consume(107, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 34632) then                    (: 'at' 'least' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:consume(135, $input, $state)          (: 'least' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 36424) then                    (: 'at' 'most' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(46, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:consume(142, $input, $state)          (: 'most' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else
      let $state := p:consume(113, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      let $state := p:consume(188, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(184, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTRange", $count, $begin, $end)
};

(:~
 : Parse FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(72, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(154, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'exactly' | 'for' | 'from' |
                                                               'ftand' | 'ftor' | 'ge' | 'gt' | 'is' | 'le' | 'let' |
                                                               'lt' | 'ne' | 'not' | 'or' | 'order' | 'ordered' |
                                                               'relationship' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'using' | 'weight' | 'where' | 'window' |
                                                               'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 165) then                      (: 'relationship' :)
      let $state := p:consume(165, $input, $state)          (: 'relationship' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(150, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'exactly' | 'for' | 'from' |
                                                               'ftand' | 'ftor' | 'ge' | 'gt' | 'is' | 'le' | 'let' |
                                                               'lt' | 'ne' | 'not' | 'or' | 'order' | 'ordered' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'using' |
                                                               'weight' | 'where' | 'window' | 'without' | '}' :)
  let $state :=
    if ($state[$p:l1] eq 72) then                           (: 'at' :)
      let $state := p:lookahead2W(124, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 107                            (: 'exactly' :)
          or $state[$p:lk] = 113                            (: 'from' :)
          or $state[$p:lk] = 34632                          (: 'at' 'least' :)
          or $state[$p:lk] = 36424) then                    (: 'at' 'most' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTRange($input, $state)
      let $state := p:consume(137, $input, $state)          (: 'levels' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTThesaurusID", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(77, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(27, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTThesaurusID($input, $state)
        return p:parse-FTThesaurusOption-1($input, $state)
};

(:~
 : Parse FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 186) then                          (: 'thesaurus' :)
      let $state := p:lookahead2W(110, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7866) then                     (: 'thesaurus' '(' :)
      let $state := p:consume(186, $input, $state)          (: 'thesaurus' :)
      let $state := p:lookahead1W(19, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(87, $input, $state)       (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 72) then                   (: 'at' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTThesaurusID($input, $state)
          return $state
        else
          let $state := p:consume(88, $input, $state)       (: 'default' :)
          return $state
      let $state := p:parse-FTThesaurusOption-1($input, $state)
      let $state := p:consume(33, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 145) then                      (: 'no' :)
      let $state := p:consume(145, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:consume(186, $input, $state)          (: 'thesaurus' :)
      return $state
    else
      let $state := p:consume(186, $input, $state)          (: 'thesaurus' :)
      let $state := p:lookahead1W(87, $input, $state)       (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 72) then                   (: 'at' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTThesaurusID($input, $state)
          return $state
        else
          let $state := p:consume(88, $input, $state)       (: 'default' :)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTThesaurusOption", $count, $begin, $end)
};

(:~
 : Parse FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 200) then                      (: 'wildcards' :)
      let $state := p:consume(200, $input, $state)          (: 'wildcards' :)
      return $state
    else
      let $state := p:consume(145, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(64, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:consume(200, $input, $state)          (: 'wildcards' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWildCardOption", $count, $begin, $end)
};

(:~
 : Parse FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(132, $input, $state)              (: 'language' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(5, $input, $state)                (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTLanguageOption", $count, $begin, $end)
};

(:~
 : Parse FTMatchOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 145) then                          (: 'no' :)
      let $state := p:lookahead2W(125, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 132) then                      (: 'language' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 200                            (: 'wildcards' :)
          or $state[$p:lk] = 51345) then                    (: 'no' 'wildcards' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 186                            (: 'thesaurus' :)
          or $state[$p:lk] = 47761) then                    (: 'no' 'thesaurus' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 180                            (: 'stemming' :)
          or $state[$p:lk] = 46225) then                    (: 'no' 'stemming' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 92) then                       (: 'diacritics' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 181                            (: 'stop' :)
          or $state[$p:lk] = 46481) then                    (: 'no' 'stop' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 152) then                      (: 'option' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTExtensionOption($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTCaseOption($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMatchOption", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOptions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(194, $input, $state)            (: 'using' :)
    let $state := p:lookahead1W(135, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-FTMatchOption($input, $state)
    let $state := p:lookahead1W(147, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'entire' | 'eq' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'not' |
                                                               'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'using' | 'weight' | 'where' |
                                                               'window' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 194) then                        (: 'using' :)
        $state
      else
        p:parse-FTMatchOptions-1($input, $state)
};

(:~
 : Parse FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTMatchOptions-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMatchOptions", $count, $begin, $end)
};

(:~
 : Parse FTOptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'ft-option' :)
  let $state := p:consume(114, $input, $state)              (: 'ft-option' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'using' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTMatchOptions($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOptionDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(79, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(15, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(124, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:consume(141, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(68, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:consume(143, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(139, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(56, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'at' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleImport", $count, $begin, $end)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:consume(143, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(139, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(56, $input, $state)           (: '=' :)
      return $state
    else
      let $state := p:consume(88, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:consume(98, $input, $state)           (: 'element' :)
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:consume(143, $input, $state)          (: 'namespace' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaPrefix", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(79, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:consume(38, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(15, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(124, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:consume(169, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(106, $input, $state)          (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 5) then                       (: StringLiteral :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'at' :)
      let $state := p:consume(72, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaImport", $count, $begin, $end)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 124) then                          (: 'import' :)
      let $state := p:lookahead2W(98, $input, $state)       (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 43388) then                    (: 'import' 'schema' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaImport($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ModuleImport($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Import", $count, $begin, $end)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(143, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(139, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(56, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 126) then                      (: 'inherit' :)
      let $state := p:consume(126, $input, $state)          (: 'inherit' :)
      return $state
    else
      let $state := p:consume(146, $input, $state)          (: 'no-inherit' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InheritMode", $count, $begin, $end)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 163) then                      (: 'preserve' :)
      let $state := p:consume(163, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(147, $input, $state)          (: 'no-preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PreserveMode", $count, $begin, $end)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(86, $input, $state)               (: 'copy-namespaces' :)
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(38, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(95, $input, $state)           (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InheritMode($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CopyNamespacesDecl", $count, $begin, $end)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(88, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(154, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(100, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(93, $input, $state)           (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 120) then                      (: 'greatest' :)
      let $state := p:consume(120, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(135, $input, $state)          (: 'least' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyOrderDecl", $count, $begin, $end)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:consume(156, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 155) then                      (: 'ordered' :)
      let $state := p:consume(155, $input, $state)          (: 'ordered' :)
      return $state
    else
      let $state := p:consume(192, $input, $state)          (: 'unordered' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderingModeDecl", $count, $begin, $end)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:consume(83, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 183) then                      (: 'strip' :)
      let $state := p:consume(183, $input, $state)          (: 'strip' :)
      return $state
    else
      let $state := p:consume(163, $input, $state)          (: 'preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConstructionDecl", $count, $begin, $end)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:consume(74, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BaseURIDecl", $count, $begin, $end)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(88, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(81, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultCollationDecl", $count, $begin, $end)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(75, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 163) then                      (: 'preserve' :)
      let $state := p:consume(163, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(183, $input, $state)          (: 'strip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BoundarySpaceDecl", $count, $begin, $end)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 87) then                           (: 'declare' :)
      let $state := p:lookahead2W(129, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'default' |
                                                               'ordering' :)
      let $state :=
        if ($state[$p:lk] eq 22615) then                    (: 'declare' 'default' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | 'collation' | 'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 19287) then                    (: 'declare' 'boundary-space' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5331031) then                  (: 'declare' 'default' 'collation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 19031) then                    (: 'declare' 'base-uri' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 21335) then                    (: 'declare' 'construction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 40023) then                    (: 'declare' 'ordering' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 10115159) then                 (: 'declare' 'default' 'order' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EmptyOrderDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyNamespacesDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Setter", $count, $begin, $end)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(88, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'element' :)
      let $state := p:consume(98, $input, $state)           (: 'element' :)
      return $state
    else
      let $state := p:consume(118, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(143, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultNamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(185, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | EOF | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 87) then                         (: 'declare' :)
        let $state := p:lookahead2W(146, $input, $state)    (: EOF | S^WS | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'base-uri' | 'boundary-space' |
                                                               'cast' | 'castable' | 'construction' | 'contains' |
                                                               'copy-namespaces' | 'default' | 'div' | 'eq' | 'except' |
                                                               'ft-option' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'namespace' | 'ne' | 'option' | 'or' | 'ordering' |
                                                               'to' | 'treat' | 'union' | 'variable' | '|' :)
        return $state
      else if ($state[$p:l1] eq 124) then                   (: 'import' :)
        let $state := p:lookahead2W(138, $input, $state)    (: EOF | S^WS | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'contains' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'schema' | 'to' | 'treat' |
                                                               'union' | '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 19031                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 19287                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 21335                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 22103                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 22615                            (: 'declare' 'default' :)
      and $state[$p:lk] != 29271                            (: 'declare' 'ft-option' :)
      and $state[$p:lk] != 36220                            (: 'import' 'module' :)
      and $state[$p:lk] != 36695                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 40023                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 43388) then                      (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 87) then                     (: 'declare' :)
            let $state := p:lookahead2W(132, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'default' |
                                                                'ft-option' | 'namespace' | 'ordering' :)
            let $state :=
              if ($state[$p:lk] eq 22615) then              (: 'declare' 'default' :)
                let $state := p:lookahead3W(123, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'element' |
                                                                    'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 6445143                  (: 'declare' 'default' 'element' :)
                or $state[$p:lk] = 7755863) then            (: 'declare' 'default' 'function' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 36695) then              (: 'declare' 'namespace' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 124) then                (: 'import' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Import($input, $state)
            return $state
          else if ($state[$p:lk] = 29271) then              (: 'declare' 'ft-option' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-FTOptionDecl($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(185, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | EOF | QName^Token | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 87) then                         (: 'declare' :)
        let $state := p:lookahead2W(140, $input, $state)    (: EOF | S^WS | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'contains' |
                                                               'div' | 'eq' | 'except' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'ne' | 'option' | 'or' | 'to' | 'treat' |
                                                               'union' | 'variable' | '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 30295                            (: 'declare' 'function' :)
      and $state[$p:lk] != 38999                            (: 'declare' 'option' :)
      and $state[$p:lk] != 50263) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 87) then                     (: 'declare' :)
            let $state := p:lookahead2W(118, $input, $state) (: S^WS | ('(' ':') | 'function' | 'option' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 50263) then              (: 'declare' 'variable' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 30295) then              (: 'declare' 'function' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-FunctionDecl($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-OptionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prolog", $count, $begin, $end)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(5, $input, $state)                (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "URILiteral", $count, $begin, $end)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: NCName^Token :)
      let $state := p:consume(19, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'and' :)
      let $state := p:consume(68, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ascending' :)
      let $state := p:consume(71, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'case' :)
      let $state := p:consume(77, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'cast' :)
      let $state := p:consume(78, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'castable' :)
      let $state := p:consume(79, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:consume(81, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'contains' :)
      let $state := p:consume(84, $input, $state)           (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'default' :)
      let $state := p:consume(88, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descending' :)
      let $state := p:consume(91, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'div' :)
      let $state := p:consume(95, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'else' :)
      let $state := p:consume(99, $input, $state)           (: 'else' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'empty' :)
      let $state := p:consume(100, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'eq' :)
      let $state := p:consume(105, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'except' :)
      let $state := p:consume(108, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'for' :)
      let $state := p:consume(112, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'ge' :)
      let $state := p:consume(119, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'gt' :)
      let $state := p:consume(121, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'idiv' :)
      let $state := p:consume(122, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'instance' :)
      let $state := p:consume(128, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'intersect' :)
      let $state := p:consume(129, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'is' :)
      let $state := p:consume(130, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'le' :)
      let $state := p:consume(134, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'let' :)
      let $state := p:consume(136, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'levels' :)
      let $state := p:consume(137, $input, $state)          (: 'levels' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:consume(139, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'mod' :)
      let $state := p:consume(140, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'ne' :)
      let $state := p:consume(144, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'or' :)
      let $state := p:consume(153, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'order' :)
      let $state := p:consume(154, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'paragraphs' :)
      let $state := p:consume(158, $input, $state)          (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'return' :)
      let $state := p:consume(166, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'satisfies' :)
      let $state := p:consume(168, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'sentences' :)
      let $state := p:consume(176, $input, $state)          (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'stable' :)
      let $state := p:consume(178, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'times' :)
      let $state := p:consume(187, $input, $state)          (: 'times' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'to' :)
      let $state := p:consume(188, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'treat' :)
      let $state := p:consume(189, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'union' :)
      let $state := p:consume(191, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: 'where' :)
      let $state := p:consume(199, $input, $state)          (: 'where' :)
      return $state
    else
      let $state := p:consume(204, $input, $state)          (: 'words' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NCName", $count, $begin, $end)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(141, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(143, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(139, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'levels' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'words' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(56, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleDecl", $count, $begin, $end)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(107, $input, $state)          (: EOF | S^WS | ('(' ':') | 'declare' | 'import' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LibraryModule", $count, $begin, $end)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(49, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Separator", $count, $begin, $end)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(205, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'version' :)
  let $state := p:consume(197, $input, $state)              (: 'version' :)
  let $state := p:lookahead1W(15, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(5, $input, $state)                (: StringLiteral :)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | ('(' ':') | ';' | 'encoding' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 102) then                      (: 'encoding' :)
      let $state := p:consume(102, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(15, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VersionDecl", $count, $begin, $end)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 205) then                          (: 'xquery' :)
      let $state := p:lookahead2W(137, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'contains' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | 'version' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 50637) then                    (: 'xquery' 'version' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 141) then                          (: 'module' :)
      let $state := p:lookahead2W(136, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'contains' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'namespace' | 'ne' | 'or' | 'to' | 'treat' | 'union' |
                                                               '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 36749) then                    (: 'module' 'namespace' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LibraryModule($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MainModule($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Module", $count, $begin, $end)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(184, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | Wildcard | QName^Token | S^WS | '$' |
                                                               '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'levels' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'text' | 'times' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Module($input, $state)
  let $state := p:consume(17, $input, $state)               (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "XQuery", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 22) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 32) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:matchW($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:matchW($input, $state[$p:e2], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-XQuery($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : The input filename, or string, if surrounded by curly braces.
 :)
declare variable $input as xs:string external;

let $result :=
  if (matches($input, "^\{.*\}$")) then
    p:parse-XQuery(substring($input, 2, string-length($input) - 2))
  else
    p:parse-XQuery(unparsed-text($input, "utf-8"))
return
  if (empty($result/self::ERROR)) then
    $result
  else
    error(xs:QName("p:parse-XQuery"), concat("&#10;    ", replace($result, "&#10;", "&#10;    ")))

(: End :)
