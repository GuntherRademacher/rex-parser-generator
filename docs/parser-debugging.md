<link rel="stylesheet" href="markdown.css">

[⇦ Previous page](disambiguation-techniques.md) &nbsp;&nbsp;│&nbsp;&nbsp; [⇧ Back to index](../README.md#-rex-parser-generator) &nbsp;&nbsp;│&nbsp;&nbsp; [Next page ⇨ ](performance-considerations.md)

&nbsp;
# Parser Debugging

This document serves as a guide to understanding and interpreting parser and lexer traces generated by REx. These traces provide insights into the operation of the parser and the lexer, facilitating the debugging process when the parser does not behave as expected. By breaking down trace elements and their attributes, this guide aims to help pinpoint issues and find solutions.

## Trace

When a parser does not act as expected, its operation may be investigated by inspecting a parser trace. REx provides the ability to write a trace of parser and lexer actions. It can be activated by using the `-trace` command line option at generation time. A parser that was generated with trace enabled will write a log of its parser and scanner actions to the secondary output channel (i.e. `stderr`, `System.err`, etc. depending on the platform). Trace output is written in XML.

Trace is best used when also asking REx for generating a simple main program by using the `-main` command line option, because using `-trace` also modifies the generated main program to initialize trace operation. It can be used independent of `-main`, but in that case care must be taken to initialize trace operation in the same way.

Traces may become quite large, so when analyzing them, it is advisable to apply them to the smallest possible reproduction of the problem.

Traces contain information about both lexer and parser operation. Lexer operation is traced in `tokenize` elements, while parser actions show up in `parse` elements. There are different structures of `parse` elements for LL, LR, and GLR parsing.

## Lexer trace

The lexer operates as a deterministic finite automaton (DFA). The trace shows the DFA's transitions and result state marks. The lexer aims at finding the longest valid token out of the set of valid tokens, specific to some parser state.

Sample lexer trace elements might look like this:

```xml
  <tokenize tokenset="1">
    <next state="2" offset="0" char="1" codepoint="49" class="7" result="Number"/>
    <next state="4" offset="1" char="2" codepoint="50" class="7" result="Number"/>
    <next state="4" offset="2" char="3" codepoint="51" class="7" result="Number"/>
    <next state="4" offset="3" char="+" codepoint="43" class="4"/>
    <done result="Number" begin="0" end="3"/>
  </tokenize>
  ...
  <tokenize tokenset="2">
    <next state="3" offset="3" char="+" codepoint="43" class="4" result="'+'"/>
    <done result="'+'" begin="3" end="4"/>
  </tokenize>
  ...  
  <tokenize tokenset="1">
    <next state="2" offset="4" char="!" codepoint="33" class="0"/>
    <fail begin="4" end="4" state="2"/>
  </tokenize>   
 ```

These are the details of a lexer trace:

 - `tokenize`: this element marks a lexer operation in the trace
 - `tokenset`: this attribute provides the internal token set id that the lexer will work on. Each parser state has a set of expected tokens, and REx generates a specific DFA for each such set, identified by this id.
 - `next`: this element shows a transition taken by the lexer.
 - `state`: this attribute provides the internal id of the DFA state being processed.
 - `offset`: this attribute shows the current position in the input string that is being processed.
 - `char`: this attribute is the (printable) character at the current position in the input string.
 - `codepoint`: this attribute is the Unicode code point of the character at the current position in the input string.
 - `class`: this attribute shows the internal character class id of the current character. REx automatically classifies characters, and the DFA operates on these character classes instead of individual characters.
 - `result`: this attribute, when present, shows a token that has been identified.
 - `done`: this element documents the lexer's result, in case of success.
 - `begin`: this attribute shows the position where the result token begins in the input string.
 - `end`: this attribute shows the position where the result token ends in the input string.
 - `fail`: this element indicates tokenization failure. It appears in the trace, when the lexer was unable to identify a valid token. In this case it failed in the given `state`, after successfully processing the substring from `begin` to `end`.

## Parser Trace (LL Parsing)

The methods of a REx-generated LL parser correspond to the nonterminals of the syntax definition, and the parser operates by recursively descending from the method representing the start symbol. The events shown in LL parser trace are entry and completion of those methods, and consumption of terminals. These very much correspond to the events sent to the event processor interface in the generated code.

This is a sample of LL parser trace elements:

```xml
  <parse startnonterminal="Expression"/>
  ...
  <parse startnonterminal="Term" input="Number"/>
  <parse startnonterminal="Factor" input="Number"/>
  <parse startnonterminal="Primary" input="Number"/>
  <parse terminal="Number"/>
  <parse endnonterminal="Primary"/>
  <parse endnonterminal="Factor"/>
```

The details of an LL parser trace are:

 - `parse`: this element shows a parser event in the trace.
 - `startnonterminal`: this attribute shows the name of the nonterminal that is going to be processed. 
 - `input`: this attribute shows the current lookahead tokens.
 - `endnonterminal`: this attribute shows the name of a completed nonterminal.
 - `terminal`: this attribute show the name of a terminal that is being consumed.

## Parser Trace (LR Parsing)

An LR parser is implemented by a state machine that maintains a stack. Its actions are called 

 - `shift`, which is pushing a single symbol onto the stack, and proceeding to a follow-up state,
 - `reduce`, which is popping groups of symbols and the next state off of the stack, and
 - `accept` for successfully completing the parse.

 A REx-generated LR parser also has a combined `shift reduce` action, pushing one symbol onto the stack and immediately reducing from the stack. This eliminates the actual representation of LR(0) reduce states from the automaton, by exploiting the fact that they do not have any lookahead requirements.

 LR here applies to all flavors of LR parsing: to LALR(k), LR(k), and also to the LALR or LR parsers used as a basis for GLR parsing.

 Sample LR parser trace elements look like the following:

 ```xml
  <parse state="0" input="Number" action="shift reduce" nonterminal="Primary" count="1"/>
  <parse state="0" input="Primary" action="shift reduce" nonterminal="Factor" count="1"/>
  <parse state="0" input="Factor" action="shift"/>
  ...
  <parse state="6" input="'+'" action="reduce" nonterminal="Term" count="1"/>
  <parse state="0" input="Term '+'" action="shift"/>
  <parse state="5" input="'+'" action="shift"/>
  ...
  <parse state="6" input="END" action="reduce" nonterminal="Term" count="1"/>
  <parse state="3" input="Term END" action="shift"/>
  <parse state="5" input="END" action="reduce" nonterminal="Expression" count="3"/>
  <parse state="0" input="Expression END" action="accept"/>  
 ```

The details of an LR parser trace are:

 - `parse`: this element shows a parser event in the trace.
 - `state`: the internal id of the state that the parser is in.
 - `input`: this attribute shows the current lookahead symbols.
 - `action`: the action that has been performed by the parser.
 - `nonterminal`: this attribute shows the name of the nonterminal that results from a reduce action.
 - `count`: this attribute shows the number of symbols that are popped off the stack by a reduce action.

## Parser Trace (GLR Parsing)

GLR parsing builds on LR parsing (this covers LALR as well as LR). Where an LR parser would not have been constructed due to conflicts, a GLR parser uses a runtime `fork` action to spawn extra paths, and pursues all conflicting variants at runtime in parallel, expecting only the correct one to survive. This may run into a situation where multiple of them are valid. As soon as this is detected, an ambiguity is reported.

A GLR parser trace may show the `fork` action, and `parse` elements have additional attributes `thread` and `offset`.

This is a sample:

```xml
  <parse thread="0" offset="3" state="7" input="'+'" action="fork"/>
  <parse thread="0" offset="3" state="7" input="'+'" action="reduce" nonterminal="Number" count="1"/>
  <parse thread="0" offset="3" state="0" input="Number '+'" action="shift reduce" nonterminal="Primary" count="1"/>
  <parse thread="0" offset="3" state="0" input="Primary '+'" action="shift reduce" nonterminal="Factor" count="1"/>
  <parse thread="0" offset="3" state="0" input="Factor '+'" action="shift"/>
  <parse thread="0" offset="3" state="6" input="'+'" action="reduce" nonterminal="Term" count="1"/>
  <parse thread="0" offset="3" state="0" input="Term '+'" action="shift"/>
  <parse thread="0" offset="3" state="5" input="'+'" action="shift"/>
  ...
  <parse thread="1" offset="3" state="7" input="'+'" action="reduce" nonterminal="Primary" count="1"/>
  <parse thread="1" offset="3" state="0" input="Primary '+'" action="shift reduce" nonterminal="Factor" count="1"/>
  <parse thread="1" offset="3" state="0" input="Factor '+'" action="shift"/>
  <parse thread="1" offset="3" state="6" input="'+'" action="reduce" nonterminal="Term" count="1"/>
  <parse thread="1" offset="3" state="0" input="Term '+'" action="shift"/>
  <parse thread="1" offset="3" state="5" input="'+'" action="shift"/>
 ```

The additional attributes are:

 - `thread`: the internal id of the path that the action is being performed on. This is used to distinguish multiple paths through the input that are being processed in parallel.
 - `offset`: the current position in the input string.

&nbsp;
---
[⇦ Previous page](disambiguation-techniques.md) &nbsp;&nbsp;│&nbsp;&nbsp; [⇧ Back to index](../README.md#-rex-parser-generator) &nbsp;&nbsp;│&nbsp;&nbsp; [Next page ⇨ ](performance-considerations.md)