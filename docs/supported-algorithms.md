<link rel="stylesheet" href="markdown.css">

[⇦ Previous page](rex-command-line.md) &nbsp;&nbsp;│&nbsp;&nbsp; [⇧ Back to index](../README.md#-rex-parser-generator) &nbsp;&nbsp;│&nbsp;&nbsp; [Next page ⇨ ](ebnf-notation.md)

&nbsp;
# Supported Algorithms

REx supports multiple parsing algorithms, which can be selected using specific command line options, based on LL or LR parsing.

A lexer is always generated as a set of deterministic finite automata (DFA).

Below is an overview of the supported parsing algorithms and their corresponding command line options.

## LL Parsing

The LL parsing approach is implemented in the form of recursive descent. This method maps EBNF productions to functions in the target language and uses "First" and "Follow" sets for decisions. The design goal of the LL implementation is to generate control flow in target language code as much as possible to maximize performance.

- **LL(1)**: When lookahead is restricted to a single token.
- **sLL(k)**: For longer lookaheads, where `k` is the specified number of tokens to look ahead. The lookahead limit is specified via the command line option `-ll`, e.g. `-ll 3`. The generator starts with a single-token lookahead and increases it up to the specified limit, as long as there are conflicts.

If an LL parser cannot be constructed due to conflicts, backtracking can be employed. This approach creates an LL(1) or sLL(k) parser, which attempts to resolve conflicts statically where feasible. For unresolved conflicts, it employs backtracking by sequentially trying alternative paths until one succeeds. However, the first successful path chosen may not always be the correct one. Backtracking can often be effective, especially when conflicting alternatives are properly ordered. Nevertheless, using this form of backtracking makes the parser non-deterministic, so caution is advised when uncertainty arises.

**Command Line Options:**

- `-ll`: Specifies the maximum lookahead limit for LL parsing, e.g. `-ll 3`.
- `backtrack`: Augments the LL parser with PEG style backtracking to resolve conflicts dynamically.

## LR Parsing

The LR approach provides LALR and full LR variants. Either is implemented by generating state tables and using those for driving state transitions at runtime. Although there is no hard limit on lookahead length in the LR construction, practical limits arise from space and time constraints.

 - **LALR (Look-Ahead LR)**: Selected by the `-lalr` option, this method augments the states of an LR(0) parser with lookahead of some length.
 - **Full LR**: Selected by the `-lr` option, this variant may have many more states compared to LALR, resulting in higher memory requirements and longer construction times. Production-quality parsers for smaller languages often use LR(4), but for larger grammars, using smaller lookaheads is typically more feasible.

**Command Line Options:**

- `-lalr`: Generates a Look-Ahead LR parser with maximum lookahead as specified, e.g. `-lalr 2`.
- `-lr`: Generates a full LR parser with maximum lookahead as specified, e.g. `-lr 1`.

## GLR (Generalized LR) Parsing

A GLR parser generated by REx is based on an LALR or LR parser with lookahead of choice. This is triggered by either of the following options:

- **GLALR (Generalized LALR)**: Selected by the `-glalr` option, e.g. `-glalr 1`.
- **GLR**: Selected by the `-glr` option, e.g. `-glr 1`.

Using an LALR or LR parser with lookahead already reduces the number of LR(0) conflicts statically, such that the GLR mechanism is only needed to handle the remaining conflicts. Those are not reported at generation time, so the generation process does not fail with conflicts, rather they are handled dynamically at runtime. A parser is generated that uses the GLR runtime, employing a graph-structured stack. This involves processing conflicting alternatives in parallel until incorrect ones fail, leaving only the correct ones intact.

Note that a GLR parser is non-deterministic because it is unknown at generation time whether the grammar is unambiguous. Ambiguities may arise at runtime if more than one alternative leads to the same state. REx parsers will return an error message, as soon as this is detected. 

**Command Line Options:**

- `-glalr`: Generates a GLR parser based on an LALR parser, e.g. `-glalr 1`.
- `-glr`: Generates a GLR parser based on an LR parser, e.g. `-glr 1`.

## Lexer Generation

The lexer in REx is always generated as a set of deterministic finite automata (DFA). This is done by initially creating a nondeterministic finite automaton (NFA) from the specification rules and expressions, and then grouping the states of the NFA into DFA states, based on their behavior, by applying the classic subset construction algorithm.

### Context dependent tokenization

REx automatically does context dependent lexing. This means that for each state of the parser, a specific lexer is generated that recognizes only the tokens that are valid continuations expected by the parser in this particular state.

This eliminates the need for manually setting up rules for different lexical states, as it is sometimes supported in other parser generators. Rather the approach taken by REx exploits the parser's context information to pre-select the token set allowed in a given situation.

At runtime, lexer operation is driven by the parser. The parser sends a request to the lexer for the next token and passes the information about allowable token set. The lexer then responds with an expected token out out this set, or with an error, if none can be found.

In cases where this is not desirable, it can be explicitly turned off by using command line option `-contextindependentlexer` when generating with REx.

&nbsp;
---
[⇦ Previous page](rex-command-line.md) &nbsp;&nbsp;│&nbsp;&nbsp; [⇧ Back to index](../README.md#-rex-parser-generator) &nbsp;&nbsp;│&nbsp;&nbsp; [Next page ⇨ ](ebnf-notation.md)