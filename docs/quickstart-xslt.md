<link rel="stylesheet" href="markdown.css">

[⇦ Previous page](quickstart-xquery.md) &nbsp;&nbsp;│&nbsp;&nbsp; [⇧ Back to index](../README.md#-rex-parser-generator) &nbsp;&nbsp;│&nbsp;&nbsp; [Next page ⇨ ](rex-command-line.md)

&nbsp;
# Quick Start Guide for Generating and Running a Parser in XSLT with REx

This tutorial will guide you through creating and running a parser in XSLT for a simple arithmetic expression grammar using REx. It will also demonstrate how to visualize parse trees, trace parser operations, and highlight some key properties of the generated code. Finally, it will show you how to annotate the grammar with target language code to process the parser's input at runtime.

## Prerequisites

The XSLT code generated by REx conforms to XSLT 2.0 when generating an LL or LR parsers, and to XSLT 3.0 for a GLR one. REx-generated code has been tested with Saxon 12.5, which will be used with the examples below. This also requires a JRE 11 or higher. Make sure you have these prerequisites available. Earlier or later versions of Saxon might do as well, it is certainly worth trying.

## Step 1: Define the Grammar

Create a text file named `Arithmetic.ebnf` and define the grammar for simple arithmetic expressions as follows:

```
Expression ::= Term (('+' | '-') Term)*
Term       ::= Factor (('*' | '/') Factor)*
Factor     ::= ('+' | '-')? Primary
Primary    ::= Number
             | '(' Expression ')'

<?TOKENS?>

Number     ::= [0-9]+
Whitespace ::= [ #x9#xA]+
               /*ws: definition*/
```

This grammar defines:

  - basic arithmetic operations (`+`, `-`, `*`, `/`)
  - integer numbers
  - ignored whitespace

We will use it to produce parse trees, trace parser and lexer execution, and evaluate actual arithmetic expressions to get their result.

Two remarks on the grammar:

 - Note that `<?TOKENS?>` separates syntax rules from lexical rules. While syntax rules describe the structure of the language, lexical rules define individual tokens. These sections have different allowances: syntax rules allow recursive patterns, whereas lexical rules are restricted to regular expressions.
 - This grammar does not enforce end-of-input processing. As a result, a parser generated from it may accept input as valid once it reaches a stopping point, even if additional characters remain. This behavior could lead to subtle bugs, especially when input is expected to match the grammar entirely. To ensure complete processing, additional checks or rules should be added to handle end-of-input explicitly.

## Step 2: Generate the Parser and Lexer

Open a command prompt or terminal and navigate to the directory containing `Arithmetic.ebnf`. Run the following command to generate the parser and lexer code:

```sh
rex -xslt -main -tree Arithmetic.ebnf
```

This command line asks REx for

  - a parser and lexer in XSLT (`-xslt`),
  - a simple main template for it (`-main`),
  - code generation for parse tree production (`-tree`),
  - using the grammar in file `Arithmetic.ebnf`.

The result will be an XSLT file named `Arithmetic.xslt` in the current directory, containing the generated code.

The command line is used to specify the generator's options. With the above command, we have applied for the default of LL for the parsing algorithm to be used, which would have read `-ll 3`, if it had been specified explicitly (the grammar being LL(1), though). In case an LR parser is preferred, `-lalr 1` could have been used as an alternative here.

## Step 3: Run the Generated Code

The generated code is self-contained, i.e. it has in it everything that is needed and does not need anything to be added. So you are now in a position to run it. At this point it can be used to dump the parse tree in XML while parsing any input - this is the functionality of the main template, that was generated in response to REx option `-main`.

The main template requires the setting of external variable `input`. This can be a filename, but when enclosed in curly braces, it is taken as literal text.

So it can be run, passing command line arguments like this:

```sh
java net.sf.saxon.Transform -xsl:Arithmetic.xslt -it:main "input={1 + 2 * 3}"
```

Option `-it:main` is for selecting the generated main template as the initial template. The actual input that is parsed in this case is `1 + 2 * 3`, the curly braces are stripped as the literal indicator, the double quotes serve for making it a single command line argument, and `input=` binds the string following it to variable `$input`.

This results in the output of a lossless representation of the concrete parse tree, for the given input, in XML:

```xml
<?xml version="1.0" encoding="UTF-8"?><Expression><Term><Factor><Primary><Number>1</Number></Primary></Factor></Term> <TOKEN>+</TOKEN> <Term><Factor><Primary><Number>2</Number></Primary></Factor> <TOKEN>*</TOKEN> <Factor><Primary><Number>3</Number></Primary></Factor></Term></Expression>
```

It is lossless in the sense that it contains every single character of the input as content, where the parse tree structure has been inserted as markup. Taking the string value of the XML document would regain the original input.

For making it more readable, serialization option `indent` could be used to add extra whitespace and indentation:

```sh
java net.sf.saxon.Transform -xsl:Arithmetic.xslt -it:main "input={1 + 2 * 3}"
```

results in

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Expression>
   <Term>
      <Factor>
         <Primary>
            <Number>1</Number>
         </Primary>
      </Factor>
   </Term>
   <TOKEN>+</TOKEN>
   <Term>
      <Factor>
         <Primary>
            <Number>2</Number>
         </Primary>
      </Factor>
      <TOKEN>*</TOKEN>
      <Factor>
         <Primary>
            <Number>3</Number>
         </Primary>
      </Factor>
   </Term>
</Expression>
```

Note that this is the concrete parse tree, containing nodes for each and every derivation step that was taken during parsing. Usually many of those are not needed for further processing, so it often makes sense to condense the parse tree before applying any further transformations to it. In the actual case, a tree like the following could be sufficient:

```xml
<Expression>
  <Number>1</Number>
  <TOKEN>+</TOKEN>
  <Term>
    <Number>2</Number>
    <TOKEN>*</TOKEN>
    <Number>3</Number>
  </Term>
</Expression>
```

However condensing the tree must be performed on behalf of the application, REx does not provide means to support it.

When looking at the generated XSLT code, you will find the main template as an example of how to invoke a the generated parser:

```xml
  <!--~
   ! The input filename, or string, if surrounded by curly braces.
  -->
  <xsl:param name="input" as="xs:string?" select="()"/>

  <!--~
   ! The (simple) main program.
  -->
  <xsl:template name="main" match="/">
    <xsl:param name="input" as="xs:string?" select="$input"/>

    <xsl:choose>
      <xsl:when test="empty($input)">
        <xsl:sequence select="error(xs:QName('main'), '&#xA;    Usage: java net.sf.saxon.Transform -xsl:Arithmetic.xslt -it:main input=INPUT&#xA;&#xA;      parse INPUT, which is either a filename or literal text enclosed in curly braces')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="result" select="
          if (matches($input, '^\{.*\}$')) then
            p:parse-Expression(substring($input, 2, string-length($input) - 2))
          else
            p:parse-Expression(unparsed-text($input, 'utf-8'))
        "/>
        <xsl:choose>
          <xsl:when test="empty($result/self::ERROR)">
            <xsl:sequence select="$result"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="error(xs:QName('p:parse-Expression'), concat('&#10;    ', replace($result, '&#10;', '&#10;    ')))"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
```

For the start symbol of the grammar, `Expression`, REx has generated function `parse-Expression`, which when called with an input string, returns an `Expression` element node that represents the parse tree, or an `ERROR` element in case of parsing errors.

## Step 4: Trace Lexer and Parser Execution

For debugging grammars, it is often useful to see the actions that the lexer and parser are performing during execution. When using the `-trace` command line option, REx will generate additional code that writes a log of actions, in XML.

```sh
rex -xslt -main -trace Arithmetic.ebnf
java net.sf.saxon.Transform -xsl:Arithmetic.xslt -it:main "input={1 + 2 * 3}"
```

The trace is written using XPath function `fn:trace`. It is written in XML, but `fn:trace` output typically contains some extra marking, e.g. Saxon also shows the type of the traced expression. This is likely to look different when using another XSLT processor. The word `trace`, that is prepended to each line is the label that is passed to `fn:trace`.

```xml
trace [1]: xs:string: <trace>
trace [1]: xs:string:   <parse startnonterminal="Expression"/>
trace [1]: xs:string:   <tokenize tokenset="1">
trace [1]: xs:string:     <next state="2" offset="1" char="1" codepoint="49" class="7" result="Number"/>
trace [1]: xs:string:     <next state="4" offset="2" char=" " codepoint="32" class="8"/>
trace [1]: xs:string:     <done result="Number" begin="1" end="2"/>
trace [1]: xs:string:   </tokenize>
trace [1]: xs:string:   <parse startnonterminal="Term" input="Number"/>
trace [1]: xs:string:   <parse startnonterminal="Factor" input="Number"/>
trace [1]: xs:string:   <parse startnonterminal="Primary" input="Number"/>
trace [1]: xs:string:   <parse terminal="Number"/>
trace [1]: xs:string:   <parse endnonterminal="Primary"/>
trace [1]: xs:string:   <parse endnonterminal="Factor"/>
trace [1]: xs:string:   <tokenize tokenset="2">
trace [1]: xs:string:     <next state="3" offset="2" char=" " codepoint="32" class="8" result="Whitespace"/>
trace [1]: xs:string:     <next state="5" offset="3" char="+" codepoint="43" class="4"/>
trace [1]: xs:string:     <done result="Whitespace" begin="2" end="3"/>
trace [1]: xs:string:   </tokenize>
trace [1]: xs:string:   <tokenize tokenset="2">
trace [1]: xs:string:     <next state="3" offset="3" char="+" codepoint="43" class="4" result="'+'"/>
trace [1]: xs:string:     <done result="'+'" begin="3" end="4"/>
trace [1]: xs:string:   </tokenize>
trace [1]: xs:string:   <parse endnonterminal="Term" input="'+'"/>
trace [1]: xs:string:   <parse terminal="'+'"/>
...
```

The `parse` actions show how the parser makes its way through the grammar rules by entering and leaving the code that corresponds to the grammar nonterminals, or consuming terminals.

The `tokenize` actions show how the lexer assembles tokens from input characters.

Some details in this trace may be understandable only by looking at some internals of the parser, but the trace can by useful anyway because it documents the course of action. As trace output may become huge, it is a good idea to isolate a problem to as small as possible a reproduction, before using a trace to analyze it.

## Step 5: Annotate the Grammar with XSLT code

Usually you do not want to just see the parse tree, but rather compile and execute the language that is being parsed. In case of the grammar for arithmetic expressions, this could be evaluating the expressions to their result.

While it is possible to do this evaluation based on a parse tree, it can also be done by omitting parse tree generation, and instead annotating the grammar with actions in Java code, that will be triggered during parser execution. This is what we will be doing in this step.

The parser maintains its state in a variable called $state, which is a sequence of items. There is a constant, declared as a variable named $p:result, that holds the index of the first item in the $state sequence that is not used for internal purposes by the parser. Initially, the sequence ends exactly before this index, allowing us to maintain our own state in the subsequent elements.

In our example we will use the end of `$state` as a stack, appending our items, and removing them from the end when evaluating them.

For achieving evaluation, we will augment the grammar with the following actions, whose implementation details will be shown later:

- `local:number($state)`: push numeric value of most recently consumed token onto the stack,
- `local:push($state, $item)`: push an item onto the stack,
- `local:pop($state)`: pop the top item off of the stack
- `local:evaluate($state)`: pop an operand, and operator, and maybe a second operand off of the stack and evaluate the operator on the operands, then pushing the result back onto the stack.

Each of these actions will return an updated state, to be stored in variable `$state`.

For inserting an action in XSLT into the EBNF grammar, it must be wrapped in a **processing instruction**, which

- begins with `<?` and a name,
- continues with some whitespace, and the actual Java code,
- terminates with `?>`.

The inserted XSLT code of course must not contain the character sequence `?>`.

A grammar may contain multiple action sets using different names, and an action is only included into the generated code, if its name is selected using the `-a` command line option to specify the name. We will use `aee` as the name of our set of actions, as an acronym for *A*rithmetic *E*xpression *E*valuator. Thus command line option `-a aee` must be used, and actions inserted into the grammar will look like this: `<?aee <xsl:variable name="state" select="p:number($state)"/>?>`.

The actions are positioned in the grammar as follows:

```
Expression ::= Term (('+'                   <?aee <xsl:variable name="state"
                                                                select="p:push($state, '+')"/>?>
                          | '-'             <?aee <xsl:variable name="state"
                                                                select="p:push($state, '-')"/>?>
                               ) Term       <?aee <xsl:variable name="state"
                                                                select="p:evaluate($state)"/>?>
                                     )*
Term       ::= Factor (('*'                 <?aee <xsl:variable name="state"
                                                                select="p:push($state, '*')"/>?>
                            | '/'           <?aee <xsl:variable name="state"
                                                                select="p:push($state, '/')"/>?>
                                 ) Factor   <?aee <xsl:variable name="state"
                                                                select="p:evaluate($state)"/>?>
                                         )*
Factor     ::=                              <?aee <xsl:variable name="state"
                                                                select="p:push($state, ' ')"/>?>
               ('+' | '-'                   <?aee
                                              <xsl:variable name="state"
                                                            select="p:pop($state)"/>
                                              <xsl:variable name="state"
                                                            select="p:push($state, '_')"/>
                                            ?>
                         )? Primary         <?aee <xsl:variable name="state"
                                                                select="p:evaluate($state)"/>?>
Primary    ::= Number                       <?aee <xsl:variable name="state"
                                                                select="p:number($state)"/>?>
             | '(' Expression ')'
```

Actions may be placed anywhere on the right hand side of the syntax rules, and they will be executed when the parser's control flow passes by the respective position. Note that actions can only be placed in the syntax definition, but not in the lexical definition.

You are free in formatting the grammar as you like, but in the example above, actions have been aligned on the right hand side, in order to visually separate them from the pure grammar rules on the left hand side.

Now for actually implementing the functions used in our actions, we need to add some more XSLT code:

```xml
  <xsl:function name="p:evaluate">
    <xsl:param name="state"/>
    <xsl:variable name="length" select="count($state)"/>
    <xsl:variable name="rhs" select="$state[$length]"/>
    <xsl:variable name="op" select="$state[$length - 1]"/>
    <xsl:variable name="lhs" select="$state[$length - 2]"/>
    <xsl:variable name="pop" select="if ($op = (' ', '_')) then 2 else 3"/>
    <xsl:variable name="result">
      <xsl:choose>
        <xsl:when test="$op eq '+'">
          <xsl:sequence select="$lhs + $rhs"/>
        </xsl:when>
        <xsl:when test="$op eq '-'">
          <xsl:sequence select="$lhs - $rhs"/>
        </xsl:when>
        <xsl:when test="$op eq '*'">
          <xsl:sequence select="$lhs * $rhs"/>
        </xsl:when>
        <xsl:when test="$op eq '/'">
          <xsl:sequence select="$lhs idiv $rhs"/>
        </xsl:when>
        <xsl:when test="$op eq '_'">
          <xsl:sequence select="- $rhs"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$rhs"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="subsequence($state, 1, $length - $pop), $result"/>
  </xsl:function>

  <xsl:function name="p:number">
    <xsl:param name="state"/>
    <xsl:variable name="begin" select="$state[$p:b0]"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:variable name="length" select="$end - $begin"/>
    <xsl:variable name="token" select="substring($input, $begin, $length)"/>
    <xsl:sequence select="$state, xs:integer($token)"/>
  </xsl:function>

  <xsl:function name="p:push">
    <xsl:param name="state"/>
    <xsl:param name="item"/>
    <xsl:sequence select="$state, $item"/>
  </xsl:function>

  <xsl:function name="p:pop">
    <xsl:param name="state"/>
    <xsl:sequence select="subsequence($state, 1, count($state) - 1)"/>
  </xsl:function>
```

Also we will no longer use the standard main template, that is generated when using the `-main` REx command line option, but supply our own main template, taking input from external variable `$input`, passing it to the parser, and returning the result:

```xml
  <xsl:param name="input" as="xs:string"/>

  <xsl:template name="main" match="/">
    <xsl:variable name="result" select="p:parse-Expression($input)"/>
    <xsl:choose>
      <xsl:when test="$result instance of element(ERROR)">
        <xsl:sequence select="error(xs:QName('p:parse-Expression'), $result)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$result"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
```

Both of this, the code implementing the actions and the main template can be added to the grammar file, for having REx include it into the generated code. Such extra code can be added

- at the very beginning of the grammar. In this case it must also contain the opening tag of the stylesheet, `<xsl:stylesheet>` with namespace declarations for prefixes `xs`, `xsl`, and `p`, the latter being used in the names of the parser's own templates.
- at the end of the grammar, following an `<?ENCORE?>` indicator. In that case, the code is appended to the end of the generated `.xslt` file, and it must also contain the closing tag of the stylesheet, `</xsl:stylesheet>`.

We will add our code at the end, such that the complete file `Arithmetic.ebnf` now looks as follows:

```
Expression ::= Term (('+'                   <?aee <xsl:variable name="state"
                                                                select="p:push($state, '+')"/>?>
                          | '-'             <?aee <xsl:variable name="state"
                                                                select="p:push($state, '-')"/>?>
                               ) Term       <?aee <xsl:variable name="state"
                                                                select="p:evaluate($state)"/>?>
                                     )*
Term       ::= Factor (('*'                 <?aee <xsl:variable name="state"
                                                                select="p:push($state, '*')"/>?>
                            | '/'           <?aee <xsl:variable name="state"
                                                                select="p:push($state, '/')"/>?>
                                 ) Factor   <?aee <xsl:variable name="state"
                                                                select="p:evaluate($state)"/>?>
                                         )*
Factor     ::=                              <?aee <xsl:variable name="state"
                                                                select="p:push($state, ' ')"/>?>
               ('+' | '-'                   <?aee
                                              <xsl:variable name="state"
                                                            select="p:pop($state)"/>
                                              <xsl:variable name="state"
                                                            select="p:push($state, '_')"/>
                                            ?>
                         )? Primary         <?aee <xsl:variable name="state"
                                                                select="p:evaluate($state)"/>?>
Primary    ::= Number                       <?aee <xsl:variable name="state"
                                                                select="p:number($state)"/>?>
             | '(' Expression ')'

<?TOKENS?>

Number     ::= [0-9]+
Whitespace ::= [ #x9#xA]+
               /*ws: definition*/

<?ENCORE?>

<?aee
  <xsl:function name="p:evaluate">
    <xsl:param name="state"/>
    <xsl:variable name="length" select="count($state)"/>
    <xsl:variable name="rhs" select="$state[$length]"/>
    <xsl:variable name="op" select="$state[$length - 1]"/>
    <xsl:variable name="lhs" select="$state[$length - 2]"/>
    <xsl:variable name="pop" select="if ($op = (' ', '_')) then 2 else 3"/>
    <xsl:variable name="result">
      <xsl:choose>
        <xsl:when test="$op eq '+'">
          <xsl:sequence select="$lhs + $rhs"/>
        </xsl:when>
        <xsl:when test="$op eq '-'">
          <xsl:sequence select="$lhs - $rhs"/>
        </xsl:when>
        <xsl:when test="$op eq '*'">
          <xsl:sequence select="$lhs * $rhs"/>
        </xsl:when>
        <xsl:when test="$op eq '/'">
          <xsl:sequence select="$lhs idiv $rhs"/>
        </xsl:when>
        <xsl:when test="$op eq '_'">
          <xsl:sequence select="- $rhs"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$rhs"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="subsequence($state, 1, $length - $pop), $result"/>
  </xsl:function>

  <xsl:function name="p:number">
    <xsl:param name="state"/>
    <xsl:variable name="begin" select="$state[$p:b0]"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:variable name="length" select="$end - $begin"/>
    <xsl:variable name="token" select="substring($input, $begin, $length)"/>
    <xsl:sequence select="$state, xs:integer($token)"/>
  </xsl:function>

  <xsl:function name="p:push">
    <xsl:param name="state"/>
    <xsl:param name="item"/>
    <xsl:sequence select="$state, $item"/>
  </xsl:function>

  <xsl:function name="p:pop">
    <xsl:param name="state"/>
    <xsl:sequence select="subsequence($state, 1, count($state) - 1)"/>
  </xsl:function>

  <xsl:param name="input" as="xs:string"/>

  <xsl:template name="main" match="/">
    <xsl:variable name="result" select="p:parse-Expression($input)"/>
    <xsl:choose>
      <xsl:when test="$result instance of element(ERROR)">
        <xsl:sequence select="error(xs:QName('p:parse-Expression'), $result)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$result"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>
?>
```

For having REx insert our newly added actions into the generated code, option `-a aee` must be added to the REx command line. Without that, there would be no difference in behavior, compared to the plain grammar that was used before.

Generate a parser including the actions, using this command:

```sh
rex -xslt -a aee Arithmetic.ebnf
```

Now it can be run to actually evaluate arithmetic expressions specified in variable `$input`, e.g.

```sh
java net.sf.saxon.Transform -xsl:Arithmetic.xslt -it:main "input=( 42 * 17 + 6 ) / 8 - -9"
```

&nbsp;
---
[⇦ Previous page](quickstart-xquery.md) &nbsp;&nbsp;│&nbsp;&nbsp; [⇧ Back to index](../README.md#-rex-parser-generator) &nbsp;&nbsp;│&nbsp;&nbsp; [Next page ⇨ ](rex-command-line.md)